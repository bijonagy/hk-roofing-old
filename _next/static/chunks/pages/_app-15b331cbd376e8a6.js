(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
  [2888],
  {
    41004: function (t, e, n) {
      "use strict";
      t = n.nmd(t);
      const r =
          (t, e) =>
          (...n) =>
            `\x1b[${t(...n) + e}m`,
        i =
          (t, e) =>
          (...n) => {
            const r = t(...n);
            return `\x1b[${38 + e};5;${r}m`;
          },
        o =
          (t, e) =>
          (...n) => {
            const r = t(...n);
            return `\x1b[${38 + e};2;${r[0]};${r[1]};${r[2]}m`;
          },
        s = (t) => t,
        a = (t, e, n) => [t, e, n],
        l = (t, e, n) => {
          Object.defineProperty(t, e, {
            get: () => {
              const r = n();
              return (
                Object.defineProperty(t, e, {
                  value: r,
                  enumerable: !0,
                  configurable: !0,
                }),
                r
              );
            },
            enumerable: !0,
            configurable: !0,
          });
        };
      let c;
      const u = (t, e, r, i) => {
        void 0 === c && (c = n(78553));
        const o = i ? 10 : 0,
          s = {};
        for (const [n, a] of Object.entries(c)) {
          const i = "ansi16" === n ? "ansi" : n;
          n === e
            ? (s[i] = t(r, o))
            : "object" === typeof a && (s[i] = t(a[e], o));
        }
        return s;
      };
      Object.defineProperty(t, "exports", {
        enumerable: !0,
        get: function () {
          const t = new Map(),
            e = {
              modifier: {
                reset: [0, 0],
                bold: [1, 22],
                dim: [2, 22],
                italic: [3, 23],
                underline: [4, 24],
                inverse: [7, 27],
                hidden: [8, 28],
                strikethrough: [9, 29],
              },
              color: {
                black: [30, 39],
                red: [31, 39],
                green: [32, 39],
                yellow: [33, 39],
                blue: [34, 39],
                magenta: [35, 39],
                cyan: [36, 39],
                white: [37, 39],
                blackBright: [90, 39],
                redBright: [91, 39],
                greenBright: [92, 39],
                yellowBright: [93, 39],
                blueBright: [94, 39],
                magentaBright: [95, 39],
                cyanBright: [96, 39],
                whiteBright: [97, 39],
              },
              bgColor: {
                bgBlack: [40, 49],
                bgRed: [41, 49],
                bgGreen: [42, 49],
                bgYellow: [43, 49],
                bgBlue: [44, 49],
                bgMagenta: [45, 49],
                bgCyan: [46, 49],
                bgWhite: [47, 49],
                bgBlackBright: [100, 49],
                bgRedBright: [101, 49],
                bgGreenBright: [102, 49],
                bgYellowBright: [103, 49],
                bgBlueBright: [104, 49],
                bgMagentaBright: [105, 49],
                bgCyanBright: [106, 49],
                bgWhiteBright: [107, 49],
              },
            };
          (e.color.gray = e.color.blackBright),
            (e.bgColor.bgGray = e.bgColor.bgBlackBright),
            (e.color.grey = e.color.blackBright),
            (e.bgColor.bgGrey = e.bgColor.bgBlackBright);
          for (const [n, r] of Object.entries(e)) {
            for (const [n, i] of Object.entries(r))
              (e[n] = { open: `\x1b[${i[0]}m`, close: `\x1b[${i[1]}m` }),
                (r[n] = e[n]),
                t.set(i[0], i[1]);
            Object.defineProperty(e, n, { value: r, enumerable: !1 });
          }
          return (
            Object.defineProperty(e, "codes", { value: t, enumerable: !1 }),
            (e.color.close = "\x1b[39m"),
            (e.bgColor.close = "\x1b[49m"),
            l(e.color, "ansi", () => u(r, "ansi16", s, !1)),
            l(e.color, "ansi256", () => u(i, "ansi256", s, !1)),
            l(e.color, "ansi16m", () => u(o, "rgb", a, !1)),
            l(e.bgColor, "ansi", () => u(r, "ansi16", s, !0)),
            l(e.bgColor, "ansi256", () => u(i, "ansi256", s, !0)),
            l(e.bgColor, "ansi16m", () => u(o, "rgb", a, !0)),
            e
          );
        },
      });
    },
    56334: function (t, e, n) {
      const r = n(35701),
        i = {};
      for (const s of Object.keys(r)) i[r[s]] = s;
      const o = {
        rgb: { channels: 3, labels: "rgb" },
        hsl: { channels: 3, labels: "hsl" },
        hsv: { channels: 3, labels: "hsv" },
        hwb: { channels: 3, labels: "hwb" },
        cmyk: { channels: 4, labels: "cmyk" },
        xyz: { channels: 3, labels: "xyz" },
        lab: { channels: 3, labels: "lab" },
        lch: { channels: 3, labels: "lch" },
        hex: { channels: 1, labels: ["hex"] },
        keyword: { channels: 1, labels: ["keyword"] },
        ansi16: { channels: 1, labels: ["ansi16"] },
        ansi256: { channels: 1, labels: ["ansi256"] },
        hcg: { channels: 3, labels: ["h", "c", "g"] },
        apple: { channels: 3, labels: ["r16", "g16", "b16"] },
        gray: { channels: 1, labels: ["gray"] },
      };
      t.exports = o;
      for (const s of Object.keys(o)) {
        if (!("channels" in o[s]))
          throw new Error("missing channels property: " + s);
        if (!("labels" in o[s]))
          throw new Error("missing channel labels property: " + s);
        if (o[s].labels.length !== o[s].channels)
          throw new Error("channel and label counts mismatch: " + s);
        const { channels: t, labels: e } = o[s];
        delete o[s].channels,
          delete o[s].labels,
          Object.defineProperty(o[s], "channels", { value: t }),
          Object.defineProperty(o[s], "labels", { value: e });
      }
      (o.rgb.hsl = function (t) {
        const e = t[0] / 255,
          n = t[1] / 255,
          r = t[2] / 255,
          i = Math.min(e, n, r),
          o = Math.max(e, n, r),
          s = o - i;
        let a, l;
        o === i
          ? (a = 0)
          : e === o
          ? (a = (n - r) / s)
          : n === o
          ? (a = 2 + (r - e) / s)
          : r === o && (a = 4 + (e - n) / s),
          (a = Math.min(60 * a, 360)),
          a < 0 && (a += 360);
        const c = (i + o) / 2;
        return (
          (l = o === i ? 0 : c <= 0.5 ? s / (o + i) : s / (2 - o - i)),
          [a, 100 * l, 100 * c]
        );
      }),
        (o.rgb.hsv = function (t) {
          let e, n, r, i, o;
          const s = t[0] / 255,
            a = t[1] / 255,
            l = t[2] / 255,
            c = Math.max(s, a, l),
            u = c - Math.min(s, a, l),
            h = function (t) {
              return (c - t) / 6 / u + 0.5;
            };
          return (
            0 === u
              ? ((i = 0), (o = 0))
              : ((o = u / c),
                (e = h(s)),
                (n = h(a)),
                (r = h(l)),
                s === c
                  ? (i = r - n)
                  : a === c
                  ? (i = 1 / 3 + e - r)
                  : l === c && (i = 2 / 3 + n - e),
                i < 0 ? (i += 1) : i > 1 && (i -= 1)),
            [360 * i, 100 * o, 100 * c]
          );
        }),
        (o.rgb.hwb = function (t) {
          const e = t[0],
            n = t[1];
          let r = t[2];
          const i = o.rgb.hsl(t)[0],
            s = (1 / 255) * Math.min(e, Math.min(n, r));
          return (
            (r = 1 - (1 / 255) * Math.max(e, Math.max(n, r))),
            [i, 100 * s, 100 * r]
          );
        }),
        (o.rgb.cmyk = function (t) {
          const e = t[0] / 255,
            n = t[1] / 255,
            r = t[2] / 255,
            i = Math.min(1 - e, 1 - n, 1 - r);
          return [
            100 * ((1 - e - i) / (1 - i) || 0),
            100 * ((1 - n - i) / (1 - i) || 0),
            100 * ((1 - r - i) / (1 - i) || 0),
            100 * i,
          ];
        }),
        (o.rgb.keyword = function (t) {
          const e = i[t];
          if (e) return e;
          let n,
            o = 1 / 0;
          for (const i of Object.keys(r)) {
            const e = r[i],
              l =
                ((a = e),
                ((s = t)[0] - a[0]) ** 2 +
                  (s[1] - a[1]) ** 2 +
                  (s[2] - a[2]) ** 2);
            l < o && ((o = l), (n = i));
          }
          var s, a;
          return n;
        }),
        (o.keyword.rgb = function (t) {
          return r[t];
        }),
        (o.rgb.xyz = function (t) {
          let e = t[0] / 255,
            n = t[1] / 255,
            r = t[2] / 255;
          (e = e > 0.04045 ? ((e + 0.055) / 1.055) ** 2.4 : e / 12.92),
            (n = n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92),
            (r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92);
          return [
            100 * (0.4124 * e + 0.3576 * n + 0.1805 * r),
            100 * (0.2126 * e + 0.7152 * n + 0.0722 * r),
            100 * (0.0193 * e + 0.1192 * n + 0.9505 * r),
          ];
        }),
        (o.rgb.lab = function (t) {
          const e = o.rgb.xyz(t);
          let n = e[0],
            r = e[1],
            i = e[2];
          (n /= 95.047),
            (r /= 100),
            (i /= 108.883),
            (n = n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116),
            (r = r > 0.008856 ? r ** (1 / 3) : 7.787 * r + 16 / 116),
            (i = i > 0.008856 ? i ** (1 / 3) : 7.787 * i + 16 / 116);
          return [116 * r - 16, 500 * (n - r), 200 * (r - i)];
        }),
        (o.hsl.rgb = function (t) {
          const e = t[0] / 360,
            n = t[1] / 100,
            r = t[2] / 100;
          let i, o, s;
          if (0 === n) return (s = 255 * r), [s, s, s];
          i = r < 0.5 ? r * (1 + n) : r + n - r * n;
          const a = 2 * r - i,
            l = [0, 0, 0];
          for (let c = 0; c < 3; c++)
            (o = e + (1 / 3) * -(c - 1)),
              o < 0 && o++,
              o > 1 && o--,
              (s =
                6 * o < 1
                  ? a + 6 * (i - a) * o
                  : 2 * o < 1
                  ? i
                  : 3 * o < 2
                  ? a + (i - a) * (2 / 3 - o) * 6
                  : a),
              (l[c] = 255 * s);
          return l;
        }),
        (o.hsl.hsv = function (t) {
          const e = t[0];
          let n = t[1] / 100,
            r = t[2] / 100,
            i = n;
          const o = Math.max(r, 0.01);
          (r *= 2), (n *= r <= 1 ? r : 2 - r), (i *= o <= 1 ? o : 2 - o);
          return [
            e,
            100 * (0 === r ? (2 * i) / (o + i) : (2 * n) / (r + n)),
            100 * ((r + n) / 2),
          ];
        }),
        (o.hsv.rgb = function (t) {
          const e = t[0] / 60,
            n = t[1] / 100;
          let r = t[2] / 100;
          const i = Math.floor(e) % 6,
            o = e - Math.floor(e),
            s = 255 * r * (1 - n),
            a = 255 * r * (1 - n * o),
            l = 255 * r * (1 - n * (1 - o));
          switch (((r *= 255), i)) {
            case 0:
              return [r, l, s];
            case 1:
              return [a, r, s];
            case 2:
              return [s, r, l];
            case 3:
              return [s, a, r];
            case 4:
              return [l, s, r];
            case 5:
              return [r, s, a];
          }
        }),
        (o.hsv.hsl = function (t) {
          const e = t[0],
            n = t[1] / 100,
            r = t[2] / 100,
            i = Math.max(r, 0.01);
          let o, s;
          s = (2 - n) * r;
          const a = (2 - n) * i;
          return (
            (o = n * i),
            (o /= a <= 1 ? a : 2 - a),
            (o = o || 0),
            (s /= 2),
            [e, 100 * o, 100 * s]
          );
        }),
        (o.hwb.rgb = function (t) {
          const e = t[0] / 360;
          let n = t[1] / 100,
            r = t[2] / 100;
          const i = n + r;
          let o;
          i > 1 && ((n /= i), (r /= i));
          const s = Math.floor(6 * e),
            a = 1 - r;
          (o = 6 * e - s), 0 !== (1 & s) && (o = 1 - o);
          const l = n + o * (a - n);
          let c, u, h;
          switch (s) {
            default:
            case 6:
            case 0:
              (c = a), (u = l), (h = n);
              break;
            case 1:
              (c = l), (u = a), (h = n);
              break;
            case 2:
              (c = n), (u = a), (h = l);
              break;
            case 3:
              (c = n), (u = l), (h = a);
              break;
            case 4:
              (c = l), (u = n), (h = a);
              break;
            case 5:
              (c = a), (u = n), (h = l);
          }
          return [255 * c, 255 * u, 255 * h];
        }),
        (o.cmyk.rgb = function (t) {
          const e = t[0] / 100,
            n = t[1] / 100,
            r = t[2] / 100,
            i = t[3] / 100;
          return [
            255 * (1 - Math.min(1, e * (1 - i) + i)),
            255 * (1 - Math.min(1, n * (1 - i) + i)),
            255 * (1 - Math.min(1, r * (1 - i) + i)),
          ];
        }),
        (o.xyz.rgb = function (t) {
          const e = t[0] / 100,
            n = t[1] / 100,
            r = t[2] / 100;
          let i, o, s;
          return (
            (i = 3.2406 * e + -1.5372 * n + -0.4986 * r),
            (o = -0.9689 * e + 1.8758 * n + 0.0415 * r),
            (s = 0.0557 * e + -0.204 * n + 1.057 * r),
            (i = i > 0.0031308 ? 1.055 * i ** (1 / 2.4) - 0.055 : 12.92 * i),
            (o = o > 0.0031308 ? 1.055 * o ** (1 / 2.4) - 0.055 : 12.92 * o),
            (s = s > 0.0031308 ? 1.055 * s ** (1 / 2.4) - 0.055 : 12.92 * s),
            (i = Math.min(Math.max(0, i), 1)),
            (o = Math.min(Math.max(0, o), 1)),
            (s = Math.min(Math.max(0, s), 1)),
            [255 * i, 255 * o, 255 * s]
          );
        }),
        (o.xyz.lab = function (t) {
          let e = t[0],
            n = t[1],
            r = t[2];
          (e /= 95.047),
            (n /= 100),
            (r /= 108.883),
            (e = e > 0.008856 ? e ** (1 / 3) : 7.787 * e + 16 / 116),
            (n = n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116),
            (r = r > 0.008856 ? r ** (1 / 3) : 7.787 * r + 16 / 116);
          return [116 * n - 16, 500 * (e - n), 200 * (n - r)];
        }),
        (o.lab.xyz = function (t) {
          let e, n, r;
          (n = (t[0] + 16) / 116), (e = t[1] / 500 + n), (r = n - t[2] / 200);
          const i = n ** 3,
            o = e ** 3,
            s = r ** 3;
          return (
            (n = i > 0.008856 ? i : (n - 16 / 116) / 7.787),
            (e = o > 0.008856 ? o : (e - 16 / 116) / 7.787),
            (r = s > 0.008856 ? s : (r - 16 / 116) / 7.787),
            (e *= 95.047),
            (n *= 100),
            (r *= 108.883),
            [e, n, r]
          );
        }),
        (o.lab.lch = function (t) {
          const e = t[0],
            n = t[1],
            r = t[2];
          let i;
          (i = (360 * Math.atan2(r, n)) / 2 / Math.PI), i < 0 && (i += 360);
          return [e, Math.sqrt(n * n + r * r), i];
        }),
        (o.lch.lab = function (t) {
          const e = t[0],
            n = t[1],
            r = (t[2] / 360) * 2 * Math.PI;
          return [e, n * Math.cos(r), n * Math.sin(r)];
        }),
        (o.rgb.ansi16 = function (t, e = null) {
          const [n, r, i] = t;
          let s = null === e ? o.rgb.hsv(t)[2] : e;
          if (((s = Math.round(s / 50)), 0 === s)) return 30;
          let a =
            30 +
            ((Math.round(i / 255) << 2) |
              (Math.round(r / 255) << 1) |
              Math.round(n / 255));
          return 2 === s && (a += 60), a;
        }),
        (o.hsv.ansi16 = function (t) {
          return o.rgb.ansi16(o.hsv.rgb(t), t[2]);
        }),
        (o.rgb.ansi256 = function (t) {
          const e = t[0],
            n = t[1],
            r = t[2];
          if (e === n && n === r)
            return e < 8
              ? 16
              : e > 248
              ? 231
              : Math.round(((e - 8) / 247) * 24) + 232;
          return (
            16 +
            36 * Math.round((e / 255) * 5) +
            6 * Math.round((n / 255) * 5) +
            Math.round((r / 255) * 5)
          );
        }),
        (o.ansi16.rgb = function (t) {
          let e = t % 10;
          if (0 === e || 7 === e)
            return t > 50 && (e += 3.5), (e = (e / 10.5) * 255), [e, e, e];
          const n = 0.5 * (1 + ~~(t > 50));
          return [
            (1 & e) * n * 255,
            ((e >> 1) & 1) * n * 255,
            ((e >> 2) & 1) * n * 255,
          ];
        }),
        (o.ansi256.rgb = function (t) {
          if (t >= 232) {
            const e = 10 * (t - 232) + 8;
            return [e, e, e];
          }
          let e;
          t -= 16;
          return [
            (Math.floor(t / 36) / 5) * 255,
            (Math.floor((e = t % 36) / 6) / 5) * 255,
            ((e % 6) / 5) * 255,
          ];
        }),
        (o.rgb.hex = function (t) {
          const e = (
            ((255 & Math.round(t[0])) << 16) +
            ((255 & Math.round(t[1])) << 8) +
            (255 & Math.round(t[2]))
          )
            .toString(16)
            .toUpperCase();
          return "000000".substring(e.length) + e;
        }),
        (o.hex.rgb = function (t) {
          const e = t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
          if (!e) return [0, 0, 0];
          let n = e[0];
          3 === e[0].length &&
            (n = n
              .split("")
              .map((t) => t + t)
              .join(""));
          const r = parseInt(n, 16);
          return [(r >> 16) & 255, (r >> 8) & 255, 255 & r];
        }),
        (o.rgb.hcg = function (t) {
          const e = t[0] / 255,
            n = t[1] / 255,
            r = t[2] / 255,
            i = Math.max(Math.max(e, n), r),
            o = Math.min(Math.min(e, n), r),
            s = i - o;
          let a, l;
          return (
            (a = s < 1 ? o / (1 - s) : 0),
            (l =
              s <= 0
                ? 0
                : i === e
                ? ((n - r) / s) % 6
                : i === n
                ? 2 + (r - e) / s
                : 4 + (e - n) / s),
            (l /= 6),
            (l %= 1),
            [360 * l, 100 * s, 100 * a]
          );
        }),
        (o.hsl.hcg = function (t) {
          const e = t[1] / 100,
            n = t[2] / 100,
            r = n < 0.5 ? 2 * e * n : 2 * e * (1 - n);
          let i = 0;
          return (
            r < 1 && (i = (n - 0.5 * r) / (1 - r)), [t[0], 100 * r, 100 * i]
          );
        }),
        (o.hsv.hcg = function (t) {
          const e = t[1] / 100,
            n = t[2] / 100,
            r = e * n;
          let i = 0;
          return r < 1 && (i = (n - r) / (1 - r)), [t[0], 100 * r, 100 * i];
        }),
        (o.hcg.rgb = function (t) {
          const e = t[0] / 360,
            n = t[1] / 100,
            r = t[2] / 100;
          if (0 === n) return [255 * r, 255 * r, 255 * r];
          const i = [0, 0, 0],
            o = (e % 1) * 6,
            s = o % 1,
            a = 1 - s;
          let l = 0;
          switch (Math.floor(o)) {
            case 0:
              (i[0] = 1), (i[1] = s), (i[2] = 0);
              break;
            case 1:
              (i[0] = a), (i[1] = 1), (i[2] = 0);
              break;
            case 2:
              (i[0] = 0), (i[1] = 1), (i[2] = s);
              break;
            case 3:
              (i[0] = 0), (i[1] = a), (i[2] = 1);
              break;
            case 4:
              (i[0] = s), (i[1] = 0), (i[2] = 1);
              break;
            default:
              (i[0] = 1), (i[1] = 0), (i[2] = a);
          }
          return (
            (l = (1 - n) * r),
            [255 * (n * i[0] + l), 255 * (n * i[1] + l), 255 * (n * i[2] + l)]
          );
        }),
        (o.hcg.hsv = function (t) {
          const e = t[1] / 100,
            n = e + (t[2] / 100) * (1 - e);
          let r = 0;
          return n > 0 && (r = e / n), [t[0], 100 * r, 100 * n];
        }),
        (o.hcg.hsl = function (t) {
          const e = t[1] / 100,
            n = (t[2] / 100) * (1 - e) + 0.5 * e;
          let r = 0;
          return (
            n > 0 && n < 0.5
              ? (r = e / (2 * n))
              : n >= 0.5 && n < 1 && (r = e / (2 * (1 - n))),
            [t[0], 100 * r, 100 * n]
          );
        }),
        (o.hcg.hwb = function (t) {
          const e = t[1] / 100,
            n = e + (t[2] / 100) * (1 - e);
          return [t[0], 100 * (n - e), 100 * (1 - n)];
        }),
        (o.hwb.hcg = function (t) {
          const e = t[1] / 100,
            n = 1 - t[2] / 100,
            r = n - e;
          let i = 0;
          return r < 1 && (i = (n - r) / (1 - r)), [t[0], 100 * r, 100 * i];
        }),
        (o.apple.rgb = function (t) {
          return [
            (t[0] / 65535) * 255,
            (t[1] / 65535) * 255,
            (t[2] / 65535) * 255,
          ];
        }),
        (o.rgb.apple = function (t) {
          return [
            (t[0] / 255) * 65535,
            (t[1] / 255) * 65535,
            (t[2] / 255) * 65535,
          ];
        }),
        (o.gray.rgb = function (t) {
          return [(t[0] / 100) * 255, (t[0] / 100) * 255, (t[0] / 100) * 255];
        }),
        (o.gray.hsl = function (t) {
          return [0, 0, t[0]];
        }),
        (o.gray.hsv = o.gray.hsl),
        (o.gray.hwb = function (t) {
          return [0, 100, t[0]];
        }),
        (o.gray.cmyk = function (t) {
          return [0, 0, 0, t[0]];
        }),
        (o.gray.lab = function (t) {
          return [t[0], 0, 0];
        }),
        (o.gray.hex = function (t) {
          const e = 255 & Math.round((t[0] / 100) * 255),
            n = ((e << 16) + (e << 8) + e).toString(16).toUpperCase();
          return "000000".substring(n.length) + n;
        }),
        (o.rgb.gray = function (t) {
          return [((t[0] + t[1] + t[2]) / 3 / 255) * 100];
        });
    },
    78553: function (t, e, n) {
      const r = n(56334),
        i = n(25602),
        o = {};
      Object.keys(r).forEach((t) => {
        (o[t] = {}),
          Object.defineProperty(o[t], "channels", { value: r[t].channels }),
          Object.defineProperty(o[t], "labels", { value: r[t].labels });
        const e = i(t);
        Object.keys(e).forEach((n) => {
          const r = e[n];
          (o[t][n] = (function (t) {
            const e = function (...e) {
              const n = e[0];
              if (void 0 === n || null === n) return n;
              n.length > 1 && (e = n);
              const r = t(e);
              if ("object" === typeof r)
                for (let t = r.length, i = 0; i < t; i++)
                  r[i] = Math.round(r[i]);
              return r;
            };
            return "conversion" in t && (e.conversion = t.conversion), e;
          })(r)),
            (o[t][n].raw = (function (t) {
              const e = function (...e) {
                const n = e[0];
                return void 0 === n || null === n
                  ? n
                  : (n.length > 1 && (e = n), t(e));
              };
              return "conversion" in t && (e.conversion = t.conversion), e;
            })(r));
        });
      }),
        (t.exports = o);
    },
    25602: function (t, e, n) {
      const r = n(56334);
      function i(t) {
        const e = (function () {
            const t = {},
              e = Object.keys(r);
            for (let n = e.length, r = 0; r < n; r++)
              t[e[r]] = { distance: -1, parent: null };
            return t;
          })(),
          n = [t];
        for (e[t].distance = 0; n.length; ) {
          const t = n.pop(),
            i = Object.keys(r[t]);
          for (let r = i.length, o = 0; o < r; o++) {
            const r = i[o],
              s = e[r];
            -1 === s.distance &&
              ((s.distance = e[t].distance + 1), (s.parent = t), n.unshift(r));
          }
        }
        return e;
      }
      function o(t, e) {
        return function (n) {
          return e(t(n));
        };
      }
      function s(t, e) {
        const n = [e[t].parent, t];
        let i = r[e[t].parent][t],
          s = e[t].parent;
        for (; e[s].parent; )
          n.unshift(e[s].parent),
            (i = o(r[e[s].parent][s], i)),
            (s = e[s].parent);
        return (i.conversion = n), i;
      }
      t.exports = function (t) {
        const e = i(t),
          n = {},
          r = Object.keys(e);
        for (let i = r.length, o = 0; o < i; o++) {
          const t = r[o];
          null !== e[t].parent && (n[t] = s(t, e));
        }
        return n;
      };
    },
    35701: function (t) {
      "use strict";
      t.exports = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50],
      };
    },
    9669: function (t, e, n) {
      t.exports = n(51609);
    },
    55448: function (t, e, n) {
      "use strict";
      var r = n(64867),
        i = n(36026),
        o = n(4372),
        s = n(15327),
        a = n(94097),
        l = n(84109),
        c = n(67985),
        u = n(85061);
      t.exports = function (t) {
        return new Promise(function (e, n) {
          var h = t.data,
            p = t.headers,
            d = t.responseType;
          r.isFormData(h) && delete p["Content-Type"];
          var f = new XMLHttpRequest();
          if (t.auth) {
            var m = t.auth.username || "",
              g = t.auth.password
                ? unescape(encodeURIComponent(t.auth.password))
                : "";
            p.Authorization = "Basic " + btoa(m + ":" + g);
          }
          var y = a(t.baseURL, t.url);
          function _() {
            if (f) {
              var r =
                  "getAllResponseHeaders" in f
                    ? l(f.getAllResponseHeaders())
                    : null,
                o = {
                  data:
                    d && "text" !== d && "json" !== d
                      ? f.response
                      : f.responseText,
                  status: f.status,
                  statusText: f.statusText,
                  headers: r,
                  config: t,
                  request: f,
                };
              i(e, n, o), (f = null);
            }
          }
          if (
            (f.open(
              t.method.toUpperCase(),
              s(y, t.params, t.paramsSerializer),
              !0
            ),
            (f.timeout = t.timeout),
            "onloadend" in f
              ? (f.onloadend = _)
              : (f.onreadystatechange = function () {
                  f &&
                    4 === f.readyState &&
                    (0 !== f.status ||
                      (f.responseURL &&
                        0 === f.responseURL.indexOf("file:"))) &&
                    setTimeout(_);
                }),
            (f.onabort = function () {
              f && (n(u("Request aborted", t, "ECONNABORTED", f)), (f = null));
            }),
            (f.onerror = function () {
              n(u("Network Error", t, null, f)), (f = null);
            }),
            (f.ontimeout = function () {
              var e = "timeout of " + t.timeout + "ms exceeded";
              t.timeoutErrorMessage && (e = t.timeoutErrorMessage),
                n(
                  u(
                    e,
                    t,
                    t.transitional && t.transitional.clarifyTimeoutError
                      ? "ETIMEDOUT"
                      : "ECONNABORTED",
                    f
                  )
                ),
                (f = null);
            }),
            r.isStandardBrowserEnv())
          ) {
            var v =
              (t.withCredentials || c(y)) && t.xsrfCookieName
                ? o.read(t.xsrfCookieName)
                : void 0;
            v && (p[t.xsrfHeaderName] = v);
          }
          "setRequestHeader" in f &&
            r.forEach(p, function (t, e) {
              "undefined" === typeof h && "content-type" === e.toLowerCase()
                ? delete p[e]
                : f.setRequestHeader(e, t);
            }),
            r.isUndefined(t.withCredentials) ||
              (f.withCredentials = !!t.withCredentials),
            d && "json" !== d && (f.responseType = t.responseType),
            "function" === typeof t.onDownloadProgress &&
              f.addEventListener("progress", t.onDownloadProgress),
            "function" === typeof t.onUploadProgress &&
              f.upload &&
              f.upload.addEventListener("progress", t.onUploadProgress),
            t.cancelToken &&
              t.cancelToken.promise.then(function (t) {
                f && (f.abort(), n(t), (f = null));
              }),
            h || (h = null),
            f.send(h);
        });
      };
    },
    51609: function (t, e, n) {
      "use strict";
      var r = n(64867),
        i = n(91849),
        o = n(30321),
        s = n(47185);
      function a(t) {
        var e = new o(t),
          n = i(o.prototype.request, e);
        return r.extend(n, o.prototype, e), r.extend(n, e), n;
      }
      var l = a(n(45655));
      (l.Axios = o),
        (l.create = function (t) {
          return a(s(l.defaults, t));
        }),
        (l.Cancel = n(65263)),
        (l.CancelToken = n(14972)),
        (l.isCancel = n(26502)),
        (l.all = function (t) {
          return Promise.all(t);
        }),
        (l.spread = n(8713)),
        (l.isAxiosError = n(16268)),
        (t.exports = l),
        (t.exports.default = l);
    },
    65263: function (t) {
      "use strict";
      function e(t) {
        this.message = t;
      }
      (e.prototype.toString = function () {
        return "Cancel" + (this.message ? ": " + this.message : "");
      }),
        (e.prototype.__CANCEL__ = !0),
        (t.exports = e);
    },
    14972: function (t, e, n) {
      "use strict";
      var r = n(65263);
      function i(t) {
        if ("function" !== typeof t)
          throw new TypeError("executor must be a function.");
        var e;
        this.promise = new Promise(function (t) {
          e = t;
        });
        var n = this;
        t(function (t) {
          n.reason || ((n.reason = new r(t)), e(n.reason));
        });
      }
      (i.prototype.throwIfRequested = function () {
        if (this.reason) throw this.reason;
      }),
        (i.source = function () {
          var t;
          return {
            token: new i(function (e) {
              t = e;
            }),
            cancel: t,
          };
        }),
        (t.exports = i);
    },
    26502: function (t) {
      "use strict";
      t.exports = function (t) {
        return !(!t || !t.__CANCEL__);
      };
    },
    30321: function (t, e, n) {
      "use strict";
      var r = n(64867),
        i = n(15327),
        o = n(80782),
        s = n(13572),
        a = n(47185),
        l = n(54875),
        c = l.validators;
      function u(t) {
        (this.defaults = t),
          (this.interceptors = { request: new o(), response: new o() });
      }
      (u.prototype.request = function (t) {
        "string" === typeof t
          ? ((t = arguments[1] || {}).url = arguments[0])
          : (t = t || {}),
          (t = a(this.defaults, t)).method
            ? (t.method = t.method.toLowerCase())
            : this.defaults.method
            ? (t.method = this.defaults.method.toLowerCase())
            : (t.method = "get");
        var e = t.transitional;
        void 0 !== e &&
          l.assertOptions(
            e,
            {
              silentJSONParsing: c.transitional(c.boolean, "1.0.0"),
              forcedJSONParsing: c.transitional(c.boolean, "1.0.0"),
              clarifyTimeoutError: c.transitional(c.boolean, "1.0.0"),
            },
            !1
          );
        var n = [],
          r = !0;
        this.interceptors.request.forEach(function (e) {
          ("function" === typeof e.runWhen && !1 === e.runWhen(t)) ||
            ((r = r && e.synchronous), n.unshift(e.fulfilled, e.rejected));
        });
        var i,
          o = [];
        if (
          (this.interceptors.response.forEach(function (t) {
            o.push(t.fulfilled, t.rejected);
          }),
          !r)
        ) {
          var u = [s, void 0];
          for (
            Array.prototype.unshift.apply(u, n),
              u = u.concat(o),
              i = Promise.resolve(t);
            u.length;

          )
            i = i.then(u.shift(), u.shift());
          return i;
        }
        for (var h = t; n.length; ) {
          var p = n.shift(),
            d = n.shift();
          try {
            h = p(h);
          } catch (f) {
            d(f);
            break;
          }
        }
        try {
          i = s(h);
        } catch (f) {
          return Promise.reject(f);
        }
        for (; o.length; ) i = i.then(o.shift(), o.shift());
        return i;
      }),
        (u.prototype.getUri = function (t) {
          return (
            (t = a(this.defaults, t)),
            i(t.url, t.params, t.paramsSerializer).replace(/^\?/, "")
          );
        }),
        r.forEach(["delete", "get", "head", "options"], function (t) {
          u.prototype[t] = function (e, n) {
            return this.request(
              a(n || {}, { method: t, url: e, data: (n || {}).data })
            );
          };
        }),
        r.forEach(["post", "put", "patch"], function (t) {
          u.prototype[t] = function (e, n, r) {
            return this.request(a(r || {}, { method: t, url: e, data: n }));
          };
        }),
        (t.exports = u);
    },
    80782: function (t, e, n) {
      "use strict";
      var r = n(64867);
      function i() {
        this.handlers = [];
      }
      (i.prototype.use = function (t, e, n) {
        return (
          this.handlers.push({
            fulfilled: t,
            rejected: e,
            synchronous: !!n && n.synchronous,
            runWhen: n ? n.runWhen : null,
          }),
          this.handlers.length - 1
        );
      }),
        (i.prototype.eject = function (t) {
          this.handlers[t] && (this.handlers[t] = null);
        }),
        (i.prototype.forEach = function (t) {
          r.forEach(this.handlers, function (e) {
            null !== e && t(e);
          });
        }),
        (t.exports = i);
    },
    94097: function (t, e, n) {
      "use strict";
      var r = n(91793),
        i = n(7303);
      t.exports = function (t, e) {
        return t && !r(e) ? i(t, e) : e;
      };
    },
    85061: function (t, e, n) {
      "use strict";
      var r = n(80481);
      t.exports = function (t, e, n, i, o) {
        var s = new Error(t);
        return r(s, e, n, i, o);
      };
    },
    13572: function (t, e, n) {
      "use strict";
      var r = n(64867),
        i = n(18527),
        o = n(26502),
        s = n(45655);
      function a(t) {
        t.cancelToken && t.cancelToken.throwIfRequested();
      }
      t.exports = function (t) {
        return (
          a(t),
          (t.headers = t.headers || {}),
          (t.data = i.call(t, t.data, t.headers, t.transformRequest)),
          (t.headers = r.merge(
            t.headers.common || {},
            t.headers[t.method] || {},
            t.headers
          )),
          r.forEach(
            ["delete", "get", "head", "post", "put", "patch", "common"],
            function (e) {
              delete t.headers[e];
            }
          ),
          (t.adapter || s.adapter)(t).then(
            function (e) {
              return (
                a(t),
                (e.data = i.call(t, e.data, e.headers, t.transformResponse)),
                e
              );
            },
            function (e) {
              return (
                o(e) ||
                  (a(t),
                  e &&
                    e.response &&
                    (e.response.data = i.call(
                      t,
                      e.response.data,
                      e.response.headers,
                      t.transformResponse
                    ))),
                Promise.reject(e)
              );
            }
          )
        );
      };
    },
    80481: function (t) {
      "use strict";
      t.exports = function (t, e, n, r, i) {
        return (
          (t.config = e),
          n && (t.code = n),
          (t.request = r),
          (t.response = i),
          (t.isAxiosError = !0),
          (t.toJSON = function () {
            return {
              message: this.message,
              name: this.name,
              description: this.description,
              number: this.number,
              fileName: this.fileName,
              lineNumber: this.lineNumber,
              columnNumber: this.columnNumber,
              stack: this.stack,
              config: this.config,
              code: this.code,
            };
          }),
          t
        );
      };
    },
    47185: function (t, e, n) {
      "use strict";
      var r = n(64867);
      t.exports = function (t, e) {
        e = e || {};
        var n = {},
          i = ["url", "method", "data"],
          o = ["headers", "auth", "proxy", "params"],
          s = [
            "baseURL",
            "transformRequest",
            "transformResponse",
            "paramsSerializer",
            "timeout",
            "timeoutMessage",
            "withCredentials",
            "adapter",
            "responseType",
            "xsrfCookieName",
            "xsrfHeaderName",
            "onUploadProgress",
            "onDownloadProgress",
            "decompress",
            "maxContentLength",
            "maxBodyLength",
            "maxRedirects",
            "transport",
            "httpAgent",
            "httpsAgent",
            "cancelToken",
            "socketPath",
            "responseEncoding",
          ],
          a = ["validateStatus"];
        function l(t, e) {
          return r.isPlainObject(t) && r.isPlainObject(e)
            ? r.merge(t, e)
            : r.isPlainObject(e)
            ? r.merge({}, e)
            : r.isArray(e)
            ? e.slice()
            : e;
        }
        function c(i) {
          r.isUndefined(e[i])
            ? r.isUndefined(t[i]) || (n[i] = l(void 0, t[i]))
            : (n[i] = l(t[i], e[i]));
        }
        r.forEach(i, function (t) {
          r.isUndefined(e[t]) || (n[t] = l(void 0, e[t]));
        }),
          r.forEach(o, c),
          r.forEach(s, function (i) {
            r.isUndefined(e[i])
              ? r.isUndefined(t[i]) || (n[i] = l(void 0, t[i]))
              : (n[i] = l(void 0, e[i]));
          }),
          r.forEach(a, function (r) {
            r in e
              ? (n[r] = l(t[r], e[r]))
              : r in t && (n[r] = l(void 0, t[r]));
          });
        var u = i.concat(o).concat(s).concat(a),
          h = Object.keys(t)
            .concat(Object.keys(e))
            .filter(function (t) {
              return -1 === u.indexOf(t);
            });
        return r.forEach(h, c), n;
      };
    },
    36026: function (t, e, n) {
      "use strict";
      var r = n(85061);
      t.exports = function (t, e, n) {
        var i = n.config.validateStatus;
        n.status && i && !i(n.status)
          ? e(
              r(
                "Request failed with status code " + n.status,
                n.config,
                null,
                n.request,
                n
              )
            )
          : t(n);
      };
    },
    18527: function (t, e, n) {
      "use strict";
      var r = n(64867),
        i = n(45655);
      t.exports = function (t, e, n) {
        var o = this || i;
        return (
          r.forEach(n, function (n) {
            t = n.call(o, t, e);
          }),
          t
        );
      };
    },
    45655: function (t, e, n) {
      "use strict";
      var r = n(34155),
        i = n(64867),
        o = n(16016),
        s = n(80481),
        a = { "Content-Type": "application/x-www-form-urlencoded" };
      function l(t, e) {
        !i.isUndefined(t) &&
          i.isUndefined(t["Content-Type"]) &&
          (t["Content-Type"] = e);
      }
      var c = {
        transitional: {
          silentJSONParsing: !0,
          forcedJSONParsing: !0,
          clarifyTimeoutError: !1,
        },
        adapter: (function () {
          var t;
          return (
            ("undefined" !== typeof XMLHttpRequest ||
              ("undefined" !== typeof r &&
                "[object process]" === Object.prototype.toString.call(r))) &&
              (t = n(55448)),
            t
          );
        })(),
        transformRequest: [
          function (t, e) {
            return (
              o(e, "Accept"),
              o(e, "Content-Type"),
              i.isFormData(t) ||
              i.isArrayBuffer(t) ||
              i.isBuffer(t) ||
              i.isStream(t) ||
              i.isFile(t) ||
              i.isBlob(t)
                ? t
                : i.isArrayBufferView(t)
                ? t.buffer
                : i.isURLSearchParams(t)
                ? (l(e, "application/x-www-form-urlencoded;charset=utf-8"),
                  t.toString())
                : i.isObject(t) ||
                  (e && "application/json" === e["Content-Type"])
                ? (l(e, "application/json"),
                  (function (t, e, n) {
                    if (i.isString(t))
                      try {
                        return (e || JSON.parse)(t), i.trim(t);
                      } catch (r) {
                        if ("SyntaxError" !== r.name) throw r;
                      }
                    return (n || JSON.stringify)(t);
                  })(t))
                : t
            );
          },
        ],
        transformResponse: [
          function (t) {
            var e = this.transitional,
              n = e && e.silentJSONParsing,
              r = e && e.forcedJSONParsing,
              o = !n && "json" === this.responseType;
            if (o || (r && i.isString(t) && t.length))
              try {
                return JSON.parse(t);
              } catch (a) {
                if (o) {
                  if ("SyntaxError" === a.name)
                    throw s(a, this, "E_JSON_PARSE");
                  throw a;
                }
              }
            return t;
          },
        ],
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        validateStatus: function (t) {
          return t >= 200 && t < 300;
        },
        headers: { common: { Accept: "application/json, text/plain, */*" } },
      };
      i.forEach(["delete", "get", "head"], function (t) {
        c.headers[t] = {};
      }),
        i.forEach(["post", "put", "patch"], function (t) {
          c.headers[t] = i.merge(a);
        }),
        (t.exports = c);
    },
    91849: function (t) {
      "use strict";
      t.exports = function (t, e) {
        return function () {
          for (var n = new Array(arguments.length), r = 0; r < n.length; r++)
            n[r] = arguments[r];
          return t.apply(e, n);
        };
      };
    },
    15327: function (t, e, n) {
      "use strict";
      var r = n(64867);
      function i(t) {
        return encodeURIComponent(t)
          .replace(/%3A/gi, ":")
          .replace(/%24/g, "$")
          .replace(/%2C/gi, ",")
          .replace(/%20/g, "+")
          .replace(/%5B/gi, "[")
          .replace(/%5D/gi, "]");
      }
      t.exports = function (t, e, n) {
        if (!e) return t;
        var o;
        if (n) o = n(e);
        else if (r.isURLSearchParams(e)) o = e.toString();
        else {
          var s = [];
          r.forEach(e, function (t, e) {
            null !== t &&
              "undefined" !== typeof t &&
              (r.isArray(t) ? (e += "[]") : (t = [t]),
              r.forEach(t, function (t) {
                r.isDate(t)
                  ? (t = t.toISOString())
                  : r.isObject(t) && (t = JSON.stringify(t)),
                  s.push(i(e) + "=" + i(t));
              }));
          }),
            (o = s.join("&"));
        }
        if (o) {
          var a = t.indexOf("#");
          -1 !== a && (t = t.slice(0, a)),
            (t += (-1 === t.indexOf("?") ? "?" : "&") + o);
        }
        return t;
      };
    },
    7303: function (t) {
      "use strict";
      t.exports = function (t, e) {
        return e ? t.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : t;
      };
    },
    4372: function (t, e, n) {
      "use strict";
      var r = n(64867);
      t.exports = r.isStandardBrowserEnv()
        ? {
            write: function (t, e, n, i, o, s) {
              var a = [];
              a.push(t + "=" + encodeURIComponent(e)),
                r.isNumber(n) && a.push("expires=" + new Date(n).toGMTString()),
                r.isString(i) && a.push("path=" + i),
                r.isString(o) && a.push("domain=" + o),
                !0 === s && a.push("secure"),
                (document.cookie = a.join("; "));
            },
            read: function (t) {
              var e = document.cookie.match(
                new RegExp("(^|;\\s*)(" + t + ")=([^;]*)")
              );
              return e ? decodeURIComponent(e[3]) : null;
            },
            remove: function (t) {
              this.write(t, "", Date.now() - 864e5);
            },
          }
        : {
            write: function () {},
            read: function () {
              return null;
            },
            remove: function () {},
          };
    },
    91793: function (t) {
      "use strict";
      t.exports = function (t) {
        return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(t);
      };
    },
    16268: function (t) {
      "use strict";
      t.exports = function (t) {
        return "object" === typeof t && !0 === t.isAxiosError;
      };
    },
    67985: function (t, e, n) {
      "use strict";
      var r = n(64867);
      t.exports = r.isStandardBrowserEnv()
        ? (function () {
            var t,
              e = /(msie|trident)/i.test(navigator.userAgent),
              n = document.createElement("a");
            function i(t) {
              var r = t;
              return (
                e && (n.setAttribute("href", r), (r = n.href)),
                n.setAttribute("href", r),
                {
                  href: n.href,
                  protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
                  host: n.host,
                  search: n.search ? n.search.replace(/^\?/, "") : "",
                  hash: n.hash ? n.hash.replace(/^#/, "") : "",
                  hostname: n.hostname,
                  port: n.port,
                  pathname:
                    "/" === n.pathname.charAt(0)
                      ? n.pathname
                      : "/" + n.pathname,
                }
              );
            }
            return (
              (t = i(window.location.href)),
              function (e) {
                var n = r.isString(e) ? i(e) : e;
                return n.protocol === t.protocol && n.host === t.host;
              }
            );
          })()
        : function () {
            return !0;
          };
    },
    16016: function (t, e, n) {
      "use strict";
      var r = n(64867);
      t.exports = function (t, e) {
        r.forEach(t, function (n, r) {
          r !== e &&
            r.toUpperCase() === e.toUpperCase() &&
            ((t[e] = n), delete t[r]);
        });
      };
    },
    84109: function (t, e, n) {
      "use strict";
      var r = n(64867),
        i = [
          "age",
          "authorization",
          "content-length",
          "content-type",
          "etag",
          "expires",
          "from",
          "host",
          "if-modified-since",
          "if-unmodified-since",
          "last-modified",
          "location",
          "max-forwards",
          "proxy-authorization",
          "referer",
          "retry-after",
          "user-agent",
        ];
      t.exports = function (t) {
        var e,
          n,
          o,
          s = {};
        return t
          ? (r.forEach(t.split("\n"), function (t) {
              if (
                ((o = t.indexOf(":")),
                (e = r.trim(t.substr(0, o)).toLowerCase()),
                (n = r.trim(t.substr(o + 1))),
                e)
              ) {
                if (s[e] && i.indexOf(e) >= 0) return;
                s[e] =
                  "set-cookie" === e
                    ? (s[e] ? s[e] : []).concat([n])
                    : s[e]
                    ? s[e] + ", " + n
                    : n;
              }
            }),
            s)
          : s;
      };
    },
    8713: function (t) {
      "use strict";
      t.exports = function (t) {
        return function (e) {
          return t.apply(null, e);
        };
      };
    },
    54875: function (t, e, n) {
      "use strict";
      var r = n(88593),
        i = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach(
        function (t, e) {
          i[t] = function (n) {
            return typeof n === t || "a" + (e < 1 ? "n " : " ") + t;
          };
        }
      );
      var o = {},
        s = r.version.split(".");
      function a(t, e) {
        for (
          var n = e ? e.split(".") : s, r = t.split("."), i = 0;
          i < 3;
          i++
        ) {
          if (n[i] > r[i]) return !0;
          if (n[i] < r[i]) return !1;
        }
        return !1;
      }
      (i.transitional = function (t, e, n) {
        var i = e && a(e);
        function s(t, e) {
          return (
            "[Axios v" +
            r.version +
            "] Transitional option '" +
            t +
            "'" +
            e +
            (n ? ". " + n : "")
          );
        }
        return function (n, r, a) {
          if (!1 === t) throw new Error(s(r, " has been removed in " + e));
          return (
            i &&
              !o[r] &&
              ((o[r] = !0),
              console.warn(
                s(
                  r,
                  " has been deprecated since v" +
                    e +
                    " and will be removed in the near future"
                )
              )),
            !t || t(n, r, a)
          );
        };
      }),
        (t.exports = {
          isOlderVersion: a,
          assertOptions: function (t, e, n) {
            if ("object" !== typeof t)
              throw new TypeError("options must be an object");
            for (var r = Object.keys(t), i = r.length; i-- > 0; ) {
              var o = r[i],
                s = e[o];
              if (s) {
                var a = t[o],
                  l = void 0 === a || s(a, o, t);
                if (!0 !== l)
                  throw new TypeError("option " + o + " must be " + l);
              } else if (!0 !== n) throw Error("Unknown option " + o);
            }
          },
          validators: i,
        });
    },
    64867: function (t, e, n) {
      "use strict";
      var r = n(91849),
        i = Object.prototype.toString;
      function o(t) {
        return "[object Array]" === i.call(t);
      }
      function s(t) {
        return "undefined" === typeof t;
      }
      function a(t) {
        return null !== t && "object" === typeof t;
      }
      function l(t) {
        if ("[object Object]" !== i.call(t)) return !1;
        var e = Object.getPrototypeOf(t);
        return null === e || e === Object.prototype;
      }
      function c(t) {
        return "[object Function]" === i.call(t);
      }
      function u(t, e) {
        if (null !== t && "undefined" !== typeof t)
          if (("object" !== typeof t && (t = [t]), o(t)))
            for (var n = 0, r = t.length; n < r; n++) e.call(null, t[n], n, t);
          else
            for (var i in t)
              Object.prototype.hasOwnProperty.call(t, i) &&
                e.call(null, t[i], i, t);
      }
      t.exports = {
        isArray: o,
        isArrayBuffer: function (t) {
          return "[object ArrayBuffer]" === i.call(t);
        },
        isBuffer: function (t) {
          return (
            null !== t &&
            !s(t) &&
            null !== t.constructor &&
            !s(t.constructor) &&
            "function" === typeof t.constructor.isBuffer &&
            t.constructor.isBuffer(t)
          );
        },
        isFormData: function (t) {
          return "undefined" !== typeof FormData && t instanceof FormData;
        },
        isArrayBufferView: function (t) {
          return "undefined" !== typeof ArrayBuffer && ArrayBuffer.isView
            ? ArrayBuffer.isView(t)
            : t && t.buffer && t.buffer instanceof ArrayBuffer;
        },
        isString: function (t) {
          return "string" === typeof t;
        },
        isNumber: function (t) {
          return "number" === typeof t;
        },
        isObject: a,
        isPlainObject: l,
        isUndefined: s,
        isDate: function (t) {
          return "[object Date]" === i.call(t);
        },
        isFile: function (t) {
          return "[object File]" === i.call(t);
        },
        isBlob: function (t) {
          return "[object Blob]" === i.call(t);
        },
        isFunction: c,
        isStream: function (t) {
          return a(t) && c(t.pipe);
        },
        isURLSearchParams: function (t) {
          return (
            "undefined" !== typeof URLSearchParams &&
            t instanceof URLSearchParams
          );
        },
        isStandardBrowserEnv: function () {
          return (
            ("undefined" === typeof navigator ||
              ("ReactNative" !== navigator.product &&
                "NativeScript" !== navigator.product &&
                "NS" !== navigator.product)) &&
            "undefined" !== typeof window &&
            "undefined" !== typeof document
          );
        },
        forEach: u,
        merge: function t() {
          var e = {};
          function n(n, r) {
            l(e[r]) && l(n)
              ? (e[r] = t(e[r], n))
              : l(n)
              ? (e[r] = t({}, n))
              : o(n)
              ? (e[r] = n.slice())
              : (e[r] = n);
          }
          for (var r = 0, i = arguments.length; r < i; r++) u(arguments[r], n);
          return e;
        },
        extend: function (t, e, n) {
          return (
            u(e, function (e, i) {
              t[i] = n && "function" === typeof e ? r(e, n) : e;
            }),
            t
          );
        },
        trim: function (t) {
          return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "");
        },
        stripBOM: function (t) {
          return 65279 === t.charCodeAt(0) && (t = t.slice(1)), t;
        },
      };
    },
    21924: function (t, e, n) {
      "use strict";
      var r = n(40210),
        i = n(55559),
        o = i(r("String.prototype.indexOf"));
      t.exports = function (t, e) {
        var n = r(t, !!e);
        return "function" === typeof n && o(t, ".prototype.") > -1 ? i(n) : n;
      };
    },
    55559: function (t, e, n) {
      "use strict";
      var r = n(58612),
        i = n(40210),
        o = i("%Function.prototype.apply%"),
        s = i("%Function.prototype.call%"),
        a = i("%Reflect.apply%", !0) || r.call(s, o),
        l = i("%Object.getOwnPropertyDescriptor%", !0),
        c = i("%Object.defineProperty%", !0),
        u = i("%Math.max%");
      if (c)
        try {
          c({}, "a", { value: 1 });
        } catch (p) {
          c = null;
        }
      t.exports = function (t) {
        var e = a(r, s, arguments);
        if (l && c) {
          var n = l(e, "length");
          n.configurable &&
            c(e, "length", {
              value: 1 + u(0, t.length - (arguments.length - 1)),
            });
        }
        return e;
      };
      var h = function () {
        return a(r, o, arguments);
      };
      c ? c(t.exports, "apply", { value: h }) : (t.exports.apply = h);
    },
    40487: function (t) {
      var e = {
        utf8: {
          stringToBytes: function (t) {
            return e.bin.stringToBytes(unescape(encodeURIComponent(t)));
          },
          bytesToString: function (t) {
            return decodeURIComponent(escape(e.bin.bytesToString(t)));
          },
        },
        bin: {
          stringToBytes: function (t) {
            for (var e = [], n = 0; n < t.length; n++)
              e.push(255 & t.charCodeAt(n));
            return e;
          },
          bytesToString: function (t) {
            for (var e = [], n = 0; n < t.length; n++)
              e.push(String.fromCharCode(t[n]));
            return e.join("");
          },
        },
      };
      t.exports = e;
    },
    76489: function (t, e) {
      "use strict";
      (e.Q = function (t, e) {
        if ("string" !== typeof t)
          throw new TypeError("argument str must be a string");
        for (
          var r = {}, o = e || {}, a = t.split(i), l = o.decode || n, c = 0;
          c < a.length;
          c++
        ) {
          var u = a[c],
            h = u.indexOf("=");
          if (!(h < 0)) {
            var p = u.substr(0, h).trim(),
              d = u.substr(++h, u.length).trim();
            '"' == d[0] && (d = d.slice(1, -1)),
              void 0 == r[p] && (r[p] = s(d, l));
          }
        }
        return r;
      }),
        (e.q = function (t, e, n) {
          var i = n || {},
            s = i.encode || r;
          if ("function" !== typeof s)
            throw new TypeError("option encode is invalid");
          if (!o.test(t)) throw new TypeError("argument name is invalid");
          var a = s(e);
          if (a && !o.test(a)) throw new TypeError("argument val is invalid");
          var l = t + "=" + a;
          if (null != i.maxAge) {
            var c = i.maxAge - 0;
            if (isNaN(c) || !isFinite(c))
              throw new TypeError("option maxAge is invalid");
            l += "; Max-Age=" + Math.floor(c);
          }
          if (i.domain) {
            if (!o.test(i.domain))
              throw new TypeError("option domain is invalid");
            l += "; Domain=" + i.domain;
          }
          if (i.path) {
            if (!o.test(i.path)) throw new TypeError("option path is invalid");
            l += "; Path=" + i.path;
          }
          if (i.expires) {
            if ("function" !== typeof i.expires.toUTCString)
              throw new TypeError("option expires is invalid");
            l += "; Expires=" + i.expires.toUTCString();
          }
          i.httpOnly && (l += "; HttpOnly");
          i.secure && (l += "; Secure");
          if (i.sameSite) {
            switch (
              "string" === typeof i.sameSite
                ? i.sameSite.toLowerCase()
                : i.sameSite
            ) {
              case !0:
                l += "; SameSite=Strict";
                break;
              case "lax":
                l += "; SameSite=Lax";
                break;
              case "strict":
                l += "; SameSite=Strict";
                break;
              case "none":
                l += "; SameSite=None";
                break;
              default:
                throw new TypeError("option sameSite is invalid");
            }
          }
          return l;
        });
      var n = decodeURIComponent,
        r = encodeURIComponent,
        i = /; */,
        o = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
      function s(t, e) {
        try {
          return e(t);
        } catch (n) {
          return t;
        }
      }
    },
    71012: function (t) {
      !(function () {
        var e =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          n = {
            rotl: function (t, e) {
              return (t << e) | (t >>> (32 - e));
            },
            rotr: function (t, e) {
              return (t << (32 - e)) | (t >>> e);
            },
            endian: function (t) {
              if (t.constructor == Number)
                return (16711935 & n.rotl(t, 8)) | (4278255360 & n.rotl(t, 24));
              for (var e = 0; e < t.length; e++) t[e] = n.endian(t[e]);
              return t;
            },
            randomBytes: function (t) {
              for (var e = []; t > 0; t--)
                e.push(Math.floor(256 * Math.random()));
              return e;
            },
            bytesToWords: function (t) {
              for (var e = [], n = 0, r = 0; n < t.length; n++, r += 8)
                e[r >>> 5] |= t[n] << (24 - (r % 32));
              return e;
            },
            wordsToBytes: function (t) {
              for (var e = [], n = 0; n < 32 * t.length; n += 8)
                e.push((t[n >>> 5] >>> (24 - (n % 32))) & 255);
              return e;
            },
            bytesToHex: function (t) {
              for (var e = [], n = 0; n < t.length; n++)
                e.push((t[n] >>> 4).toString(16)),
                  e.push((15 & t[n]).toString(16));
              return e.join("");
            },
            hexToBytes: function (t) {
              for (var e = [], n = 0; n < t.length; n += 2)
                e.push(parseInt(t.substr(n, 2), 16));
              return e;
            },
            bytesToBase64: function (t) {
              for (var n = [], r = 0; r < t.length; r += 3)
                for (
                  var i = (t[r] << 16) | (t[r + 1] << 8) | t[r + 2], o = 0;
                  o < 4;
                  o++
                )
                  8 * r + 6 * o <= 8 * t.length
                    ? n.push(e.charAt((i >>> (6 * (3 - o))) & 63))
                    : n.push("=");
              return n.join("");
            },
            base64ToBytes: function (t) {
              t = t.replace(/[^A-Z0-9+\/]/gi, "");
              for (var n = [], r = 0, i = 0; r < t.length; i = ++r % 4)
                0 != i &&
                  n.push(
                    ((e.indexOf(t.charAt(r - 1)) &
                      (Math.pow(2, -2 * i + 8) - 1)) <<
                      (2 * i)) |
                      (e.indexOf(t.charAt(r)) >>> (6 - 2 * i))
                  );
              return n;
            },
          };
        t.exports = n;
      })();
    },
    27484: function (t) {
      t.exports = (function () {
        "use strict";
        var t = 1e3,
          e = 6e4,
          n = 36e5,
          r = "millisecond",
          i = "second",
          o = "minute",
          s = "hour",
          a = "day",
          l = "week",
          c = "month",
          u = "quarter",
          h = "year",
          p = "date",
          d = "Invalid Date",
          f =
            /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
          m =
            /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
          g = {
            name: "en",
            weekdays:
              "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
                "_"
              ),
            months:
              "January_February_March_April_May_June_July_August_September_October_November_December".split(
                "_"
              ),
            ordinal: function (t) {
              var e = ["th", "st", "nd", "rd"],
                n = t % 100;
              return "[" + t + (e[(n - 20) % 10] || e[n] || e[0]) + "]";
            },
          },
          y = function (t, e, n) {
            var r = String(t);
            return !r || r.length >= e
              ? t
              : "" + Array(e + 1 - r.length).join(n) + t;
          },
          _ = {
            s: y,
            z: function (t) {
              var e = -t.utcOffset(),
                n = Math.abs(e),
                r = Math.floor(n / 60),
                i = n % 60;
              return (e <= 0 ? "+" : "-") + y(r, 2, "0") + ":" + y(i, 2, "0");
            },
            m: function t(e, n) {
              if (e.date() < n.date()) return -t(n, e);
              var r = 12 * (n.year() - e.year()) + (n.month() - e.month()),
                i = e.clone().add(r, c),
                o = n - i < 0,
                s = e.clone().add(r + (o ? -1 : 1), c);
              return +(-(r + (n - i) / (o ? i - s : s - i)) || 0);
            },
            a: function (t) {
              return t < 0 ? Math.ceil(t) || 0 : Math.floor(t);
            },
            p: function (t) {
              return (
                { M: c, y: h, w: l, d: a, D: p, h: s, m: o, s: i, ms: r, Q: u }[
                  t
                ] ||
                String(t || "")
                  .toLowerCase()
                  .replace(/s$/, "")
              );
            },
            u: function (t) {
              return void 0 === t;
            },
          },
          v = "en",
          b = {};
        b[v] = g;
        var x = function (t) {
            return t instanceof T;
          },
          w = function t(e, n, r) {
            var i;
            if (!e) return v;
            if ("string" == typeof e) {
              var o = e.toLowerCase();
              b[o] && (i = o), n && ((b[o] = n), (i = o));
              var s = e.split("-");
              if (!i && s.length > 1) return t(s[0]);
            } else {
              var a = e.name;
              (b[a] = e), (i = a);
            }
            return !r && i && (v = i), i || (!r && v);
          },
          S = function (t, e) {
            if (x(t)) return t.clone();
            var n = "object" == typeof e ? e : {};
            return (n.date = t), (n.args = arguments), new T(n);
          },
          E = _;
        (E.l = w),
          (E.i = x),
          (E.w = function (t, e) {
            return S(t, {
              locale: e.$L,
              utc: e.$u,
              x: e.$x,
              $offset: e.$offset,
            });
          });
        var T = (function () {
            function g(t) {
              (this.$L = w(t.locale, null, !0)), this.parse(t);
            }
            var y = g.prototype;
            return (
              (y.parse = function (t) {
                (this.$d = (function (t) {
                  var e = t.date,
                    n = t.utc;
                  if (null === e) return new Date(NaN);
                  if (E.u(e)) return new Date();
                  if (e instanceof Date) return new Date(e);
                  if ("string" == typeof e && !/Z$/i.test(e)) {
                    var r = e.match(f);
                    if (r) {
                      var i = r[2] - 1 || 0,
                        o = (r[7] || "0").substring(0, 3);
                      return n
                        ? new Date(
                            Date.UTC(
                              r[1],
                              i,
                              r[3] || 1,
                              r[4] || 0,
                              r[5] || 0,
                              r[6] || 0,
                              o
                            )
                          )
                        : new Date(
                            r[1],
                            i,
                            r[3] || 1,
                            r[4] || 0,
                            r[5] || 0,
                            r[6] || 0,
                            o
                          );
                    }
                  }
                  return new Date(e);
                })(t)),
                  (this.$x = t.x || {}),
                  this.init();
              }),
              (y.init = function () {
                var t = this.$d;
                (this.$y = t.getFullYear()),
                  (this.$M = t.getMonth()),
                  (this.$D = t.getDate()),
                  (this.$W = t.getDay()),
                  (this.$H = t.getHours()),
                  (this.$m = t.getMinutes()),
                  (this.$s = t.getSeconds()),
                  (this.$ms = t.getMilliseconds());
              }),
              (y.$utils = function () {
                return E;
              }),
              (y.isValid = function () {
                return !(this.$d.toString() === d);
              }),
              (y.isSame = function (t, e) {
                var n = S(t);
                return this.startOf(e) <= n && n <= this.endOf(e);
              }),
              (y.isAfter = function (t, e) {
                return S(t) < this.startOf(e);
              }),
              (y.isBefore = function (t, e) {
                return this.endOf(e) < S(t);
              }),
              (y.$g = function (t, e, n) {
                return E.u(t) ? this[e] : this.set(n, t);
              }),
              (y.unix = function () {
                return Math.floor(this.valueOf() / 1e3);
              }),
              (y.valueOf = function () {
                return this.$d.getTime();
              }),
              (y.startOf = function (t, e) {
                var n = this,
                  r = !!E.u(e) || e,
                  u = E.p(t),
                  d = function (t, e) {
                    var i = E.w(
                      n.$u ? Date.UTC(n.$y, e, t) : new Date(n.$y, e, t),
                      n
                    );
                    return r ? i : i.endOf(a);
                  },
                  f = function (t, e) {
                    return E.w(
                      n
                        .toDate()
                        [t].apply(
                          n.toDate("s"),
                          (r ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e)
                        ),
                      n
                    );
                  },
                  m = this.$W,
                  g = this.$M,
                  y = this.$D,
                  _ = "set" + (this.$u ? "UTC" : "");
                switch (u) {
                  case h:
                    return r ? d(1, 0) : d(31, 11);
                  case c:
                    return r ? d(1, g) : d(0, g + 1);
                  case l:
                    var v = this.$locale().weekStart || 0,
                      b = (m < v ? m + 7 : m) - v;
                    return d(r ? y - b : y + (6 - b), g);
                  case a:
                  case p:
                    return f(_ + "Hours", 0);
                  case s:
                    return f(_ + "Minutes", 1);
                  case o:
                    return f(_ + "Seconds", 2);
                  case i:
                    return f(_ + "Milliseconds", 3);
                  default:
                    return this.clone();
                }
              }),
              (y.endOf = function (t) {
                return this.startOf(t, !1);
              }),
              (y.$set = function (t, e) {
                var n,
                  l = E.p(t),
                  u = "set" + (this.$u ? "UTC" : ""),
                  d = ((n = {}),
                  (n[a] = u + "Date"),
                  (n[p] = u + "Date"),
                  (n[c] = u + "Month"),
                  (n[h] = u + "FullYear"),
                  (n[s] = u + "Hours"),
                  (n[o] = u + "Minutes"),
                  (n[i] = u + "Seconds"),
                  (n[r] = u + "Milliseconds"),
                  n)[l],
                  f = l === a ? this.$D + (e - this.$W) : e;
                if (l === c || l === h) {
                  var m = this.clone().set(p, 1);
                  m.$d[d](f),
                    m.init(),
                    (this.$d = m.set(p, Math.min(this.$D, m.daysInMonth())).$d);
                } else d && this.$d[d](f);
                return this.init(), this;
              }),
              (y.set = function (t, e) {
                return this.clone().$set(t, e);
              }),
              (y.get = function (t) {
                return this[E.p(t)]();
              }),
              (y.add = function (r, u) {
                var p,
                  d = this;
                r = Number(r);
                var f = E.p(u),
                  m = function (t) {
                    var e = S(d);
                    return E.w(e.date(e.date() + Math.round(t * r)), d);
                  };
                if (f === c) return this.set(c, this.$M + r);
                if (f === h) return this.set(h, this.$y + r);
                if (f === a) return m(1);
                if (f === l) return m(7);
                var g =
                    ((p = {}), (p[o] = e), (p[s] = n), (p[i] = t), p)[f] || 1,
                  y = this.$d.getTime() + r * g;
                return E.w(y, this);
              }),
              (y.subtract = function (t, e) {
                return this.add(-1 * t, e);
              }),
              (y.format = function (t) {
                var e = this,
                  n = this.$locale();
                if (!this.isValid()) return n.invalidDate || d;
                var r = t || "YYYY-MM-DDTHH:mm:ssZ",
                  i = E.z(this),
                  o = this.$H,
                  s = this.$m,
                  a = this.$M,
                  l = n.weekdays,
                  c = n.months,
                  u = function (t, n, i, o) {
                    return (t && (t[n] || t(e, r))) || i[n].slice(0, o);
                  },
                  h = function (t) {
                    return E.s(o % 12 || 12, t, "0");
                  },
                  p =
                    n.meridiem ||
                    function (t, e, n) {
                      var r = t < 12 ? "AM" : "PM";
                      return n ? r.toLowerCase() : r;
                    },
                  f = {
                    YY: String(this.$y).slice(-2),
                    YYYY: this.$y,
                    M: a + 1,
                    MM: E.s(a + 1, 2, "0"),
                    MMM: u(n.monthsShort, a, c, 3),
                    MMMM: u(c, a),
                    D: this.$D,
                    DD: E.s(this.$D, 2, "0"),
                    d: String(this.$W),
                    dd: u(n.weekdaysMin, this.$W, l, 2),
                    ddd: u(n.weekdaysShort, this.$W, l, 3),
                    dddd: l[this.$W],
                    H: String(o),
                    HH: E.s(o, 2, "0"),
                    h: h(1),
                    hh: h(2),
                    a: p(o, s, !0),
                    A: p(o, s, !1),
                    m: String(s),
                    mm: E.s(s, 2, "0"),
                    s: String(this.$s),
                    ss: E.s(this.$s, 2, "0"),
                    SSS: E.s(this.$ms, 3, "0"),
                    Z: i,
                  };
                return r.replace(m, function (t, e) {
                  return e || f[t] || i.replace(":", "");
                });
              }),
              (y.utcOffset = function () {
                return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
              }),
              (y.diff = function (r, p, d) {
                var f,
                  m = E.p(p),
                  g = S(r),
                  y = (g.utcOffset() - this.utcOffset()) * e,
                  _ = this - g,
                  v = E.m(this, g);
                return (
                  (v =
                    ((f = {}),
                    (f[h] = v / 12),
                    (f[c] = v),
                    (f[u] = v / 3),
                    (f[l] = (_ - y) / 6048e5),
                    (f[a] = (_ - y) / 864e5),
                    (f[s] = _ / n),
                    (f[o] = _ / e),
                    (f[i] = _ / t),
                    f)[m] || _),
                  d ? v : E.a(v)
                );
              }),
              (y.daysInMonth = function () {
                return this.endOf(c).$D;
              }),
              (y.$locale = function () {
                return b[this.$L];
              }),
              (y.locale = function (t, e) {
                if (!t) return this.$L;
                var n = this.clone(),
                  r = w(t, e, !0);
                return r && (n.$L = r), n;
              }),
              (y.clone = function () {
                return E.w(this.$d, this);
              }),
              (y.toDate = function () {
                return new Date(this.valueOf());
              }),
              (y.toJSON = function () {
                return this.isValid() ? this.toISOString() : null;
              }),
              (y.toISOString = function () {
                return this.$d.toISOString();
              }),
              (y.toString = function () {
                return this.$d.toUTCString();
              }),
              g
            );
          })(),
          A = T.prototype;
        return (
          (S.prototype = A),
          [
            ["$ms", r],
            ["$s", i],
            ["$m", o],
            ["$H", s],
            ["$W", a],
            ["$M", c],
            ["$y", h],
            ["$D", p],
          ].forEach(function (t) {
            A[t[1]] = function (e) {
              return this.$g(e, t[0], t[1]);
            };
          }),
          (S.extend = function (t, e) {
            return t.$i || (t(e, T, S), (t.$i = !0)), S;
          }),
          (S.locale = w),
          (S.isDayjs = x),
          (S.unix = function (t) {
            return S(1e3 * t);
          }),
          (S.en = b[v]),
          (S.Ls = b),
          (S.p = {}),
          S
        );
      })();
    },
    27856: function (t) {
      t.exports = (function () {
        "use strict";
        function t(t) {
          if (Array.isArray(t)) {
            for (var e = 0, n = Array(t.length); e < t.length; e++) n[e] = t[e];
            return n;
          }
          return Array.from(t);
        }
        var e = Object.hasOwnProperty,
          n = Object.setPrototypeOf,
          r = Object.isFrozen,
          i = Object.getPrototypeOf,
          o = Object.getOwnPropertyDescriptor,
          s = Object.freeze,
          a = Object.seal,
          l = Object.create,
          c = "undefined" !== typeof Reflect && Reflect,
          u = c.apply,
          h = c.construct;
        u ||
          (u = function (t, e, n) {
            return t.apply(e, n);
          }),
          s ||
            (s = function (t) {
              return t;
            }),
          a ||
            (a = function (t) {
              return t;
            }),
          h ||
            (h = function (e, n) {
              return new (Function.prototype.bind.apply(
                e,
                [null].concat(t(n))
              ))();
            });
        var p = w(Array.prototype.forEach),
          d = w(Array.prototype.pop),
          f = w(Array.prototype.push),
          m = w(String.prototype.toLowerCase),
          g = w(String.prototype.match),
          y = w(String.prototype.replace),
          _ = w(String.prototype.indexOf),
          v = w(String.prototype.trim),
          b = w(RegExp.prototype.test),
          x = S(TypeError);
        function w(t) {
          return function (e) {
            for (
              var n = arguments.length, r = Array(n > 1 ? n - 1 : 0), i = 1;
              i < n;
              i++
            )
              r[i - 1] = arguments[i];
            return u(t, e, r);
          };
        }
        function S(t) {
          return function () {
            for (var e = arguments.length, n = Array(e), r = 0; r < e; r++)
              n[r] = arguments[r];
            return h(t, n);
          };
        }
        function E(t, e) {
          n && n(t, null);
          for (var i = e.length; i--; ) {
            var o = e[i];
            if ("string" === typeof o) {
              var s = m(o);
              s !== o && (r(e) || (e[i] = s), (o = s));
            }
            t[o] = !0;
          }
          return t;
        }
        function T(t) {
          var n = l(null),
            r = void 0;
          for (r in t) u(e, t, [r]) && (n[r] = t[r]);
          return n;
        }
        function A(t, e) {
          for (; null !== t; ) {
            var n = o(t, e);
            if (n) {
              if (n.get) return w(n.get);
              if ("function" === typeof n.value) return w(n.value);
            }
            t = i(t);
          }
          function r(t) {
            return console.warn("fallback value for", t), null;
          }
          return r;
        }
        var C = s([
            "a",
            "abbr",
            "acronym",
            "address",
            "area",
            "article",
            "aside",
            "audio",
            "b",
            "bdi",
            "bdo",
            "big",
            "blink",
            "blockquote",
            "body",
            "br",
            "button",
            "canvas",
            "caption",
            "center",
            "cite",
            "code",
            "col",
            "colgroup",
            "content",
            "data",
            "datalist",
            "dd",
            "decorator",
            "del",
            "details",
            "dfn",
            "dialog",
            "dir",
            "div",
            "dl",
            "dt",
            "element",
            "em",
            "fieldset",
            "figcaption",
            "figure",
            "font",
            "footer",
            "form",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "head",
            "header",
            "hgroup",
            "hr",
            "html",
            "i",
            "img",
            "input",
            "ins",
            "kbd",
            "label",
            "legend",
            "li",
            "main",
            "map",
            "mark",
            "marquee",
            "menu",
            "menuitem",
            "meter",
            "nav",
            "nobr",
            "ol",
            "optgroup",
            "option",
            "output",
            "p",
            "picture",
            "pre",
            "progress",
            "q",
            "rp",
            "rt",
            "ruby",
            "s",
            "samp",
            "section",
            "select",
            "shadow",
            "small",
            "source",
            "spacer",
            "span",
            "strike",
            "strong",
            "style",
            "sub",
            "summary",
            "sup",
            "table",
            "tbody",
            "td",
            "template",
            "textarea",
            "tfoot",
            "th",
            "thead",
            "time",
            "tr",
            "track",
            "tt",
            "u",
            "ul",
            "var",
            "video",
            "wbr",
          ]),
          P = s([
            "svg",
            "a",
            "altglyph",
            "altglyphdef",
            "altglyphitem",
            "animatecolor",
            "animatemotion",
            "animatetransform",
            "circle",
            "clippath",
            "defs",
            "desc",
            "ellipse",
            "filter",
            "font",
            "g",
            "glyph",
            "glyphref",
            "hkern",
            "image",
            "line",
            "lineargradient",
            "marker",
            "mask",
            "metadata",
            "mpath",
            "path",
            "pattern",
            "polygon",
            "polyline",
            "radialgradient",
            "rect",
            "stop",
            "style",
            "switch",
            "symbol",
            "text",
            "textpath",
            "title",
            "tref",
            "tspan",
            "view",
            "vkern",
          ]),
          M = s([
            "feBlend",
            "feColorMatrix",
            "feComponentTransfer",
            "feComposite",
            "feConvolveMatrix",
            "feDiffuseLighting",
            "feDisplacementMap",
            "feDistantLight",
            "feFlood",
            "feFuncA",
            "feFuncB",
            "feFuncG",
            "feFuncR",
            "feGaussianBlur",
            "feMerge",
            "feMergeNode",
            "feMorphology",
            "feOffset",
            "fePointLight",
            "feSpecularLighting",
            "feSpotLight",
            "feTile",
            "feTurbulence",
          ]),
          O = s([
            "animate",
            "color-profile",
            "cursor",
            "discard",
            "fedropshadow",
            "feimage",
            "font-face",
            "font-face-format",
            "font-face-name",
            "font-face-src",
            "font-face-uri",
            "foreignobject",
            "hatch",
            "hatchpath",
            "mesh",
            "meshgradient",
            "meshpatch",
            "meshrow",
            "missing-glyph",
            "script",
            "set",
            "solidcolor",
            "unknown",
            "use",
          ]),
          k = s([
            "math",
            "menclose",
            "merror",
            "mfenced",
            "mfrac",
            "mglyph",
            "mi",
            "mlabeledtr",
            "mmultiscripts",
            "mn",
            "mo",
            "mover",
            "mpadded",
            "mphantom",
            "mroot",
            "mrow",
            "ms",
            "mspace",
            "msqrt",
            "mstyle",
            "msub",
            "msup",
            "msubsup",
            "mtable",
            "mtd",
            "mtext",
            "mtr",
            "munder",
            "munderover",
          ]),
          I = s([
            "maction",
            "maligngroup",
            "malignmark",
            "mlongdiv",
            "mscarries",
            "mscarry",
            "msgroup",
            "mstack",
            "msline",
            "msrow",
            "semantics",
            "annotation",
            "annotation-xml",
            "mprescripts",
            "none",
          ]),
          D = s(["#text"]),
          z = s([
            "accept",
            "action",
            "align",
            "alt",
            "autocapitalize",
            "autocomplete",
            "autopictureinpicture",
            "autoplay",
            "background",
            "bgcolor",
            "border",
            "capture",
            "cellpadding",
            "cellspacing",
            "checked",
            "cite",
            "class",
            "clear",
            "color",
            "cols",
            "colspan",
            "controls",
            "controlslist",
            "coords",
            "crossorigin",
            "datetime",
            "decoding",
            "default",
            "dir",
            "disabled",
            "disablepictureinpicture",
            "disableremoteplayback",
            "download",
            "draggable",
            "enctype",
            "enterkeyhint",
            "face",
            "for",
            "headers",
            "height",
            "hidden",
            "high",
            "href",
            "hreflang",
            "id",
            "inputmode",
            "integrity",
            "ismap",
            "kind",
            "label",
            "lang",
            "list",
            "loading",
            "loop",
            "low",
            "max",
            "maxlength",
            "media",
            "method",
            "min",
            "minlength",
            "multiple",
            "muted",
            "name",
            "noshade",
            "novalidate",
            "nowrap",
            "open",
            "optimum",
            "pattern",
            "placeholder",
            "playsinline",
            "poster",
            "preload",
            "pubdate",
            "radiogroup",
            "readonly",
            "rel",
            "required",
            "rev",
            "reversed",
            "role",
            "rows",
            "rowspan",
            "spellcheck",
            "scope",
            "selected",
            "shape",
            "size",
            "sizes",
            "span",
            "srclang",
            "start",
            "src",
            "srcset",
            "step",
            "style",
            "summary",
            "tabindex",
            "title",
            "translate",
            "type",
            "usemap",
            "valign",
            "value",
            "width",
            "xmlns",
            "slot",
          ]),
          R = s([
            "accent-height",
            "accumulate",
            "additive",
            "alignment-baseline",
            "ascent",
            "attributename",
            "attributetype",
            "azimuth",
            "basefrequency",
            "baseline-shift",
            "begin",
            "bias",
            "by",
            "class",
            "clip",
            "clippathunits",
            "clip-path",
            "clip-rule",
            "color",
            "color-interpolation",
            "color-interpolation-filters",
            "color-profile",
            "color-rendering",
            "cx",
            "cy",
            "d",
            "dx",
            "dy",
            "diffuseconstant",
            "direction",
            "display",
            "divisor",
            "dur",
            "edgemode",
            "elevation",
            "end",
            "fill",
            "fill-opacity",
            "fill-rule",
            "filter",
            "filterunits",
            "flood-color",
            "flood-opacity",
            "font-family",
            "font-size",
            "font-size-adjust",
            "font-stretch",
            "font-style",
            "font-variant",
            "font-weight",
            "fx",
            "fy",
            "g1",
            "g2",
            "glyph-name",
            "glyphref",
            "gradientunits",
            "gradienttransform",
            "height",
            "href",
            "id",
            "image-rendering",
            "in",
            "in2",
            "k",
            "k1",
            "k2",
            "k3",
            "k4",
            "kerning",
            "keypoints",
            "keysplines",
            "keytimes",
            "lang",
            "lengthadjust",
            "letter-spacing",
            "kernelmatrix",
            "kernelunitlength",
            "lighting-color",
            "local",
            "marker-end",
            "marker-mid",
            "marker-start",
            "markerheight",
            "markerunits",
            "markerwidth",
            "maskcontentunits",
            "maskunits",
            "max",
            "mask",
            "media",
            "method",
            "mode",
            "min",
            "name",
            "numoctaves",
            "offset",
            "operator",
            "opacity",
            "order",
            "orient",
            "orientation",
            "origin",
            "overflow",
            "paint-order",
            "path",
            "pathlength",
            "patterncontentunits",
            "patterntransform",
            "patternunits",
            "points",
            "preservealpha",
            "preserveaspectratio",
            "primitiveunits",
            "r",
            "rx",
            "ry",
            "radius",
            "refx",
            "refy",
            "repeatcount",
            "repeatdur",
            "restart",
            "result",
            "rotate",
            "scale",
            "seed",
            "shape-rendering",
            "specularconstant",
            "specularexponent",
            "spreadmethod",
            "startoffset",
            "stddeviation",
            "stitchtiles",
            "stop-color",
            "stop-opacity",
            "stroke-dasharray",
            "stroke-dashoffset",
            "stroke-linecap",
            "stroke-linejoin",
            "stroke-miterlimit",
            "stroke-opacity",
            "stroke",
            "stroke-width",
            "style",
            "surfacescale",
            "systemlanguage",
            "tabindex",
            "targetx",
            "targety",
            "transform",
            "text-anchor",
            "text-decoration",
            "text-rendering",
            "textlength",
            "type",
            "u1",
            "u2",
            "unicode",
            "values",
            "viewbox",
            "visibility",
            "version",
            "vert-adv-y",
            "vert-origin-x",
            "vert-origin-y",
            "width",
            "word-spacing",
            "wrap",
            "writing-mode",
            "xchannelselector",
            "ychannelselector",
            "x",
            "x1",
            "x2",
            "xmlns",
            "y",
            "y1",
            "y2",
            "z",
            "zoomandpan",
          ]),
          L = s([
            "accent",
            "accentunder",
            "align",
            "bevelled",
            "close",
            "columnsalign",
            "columnlines",
            "columnspan",
            "denomalign",
            "depth",
            "dir",
            "display",
            "displaystyle",
            "encoding",
            "fence",
            "frame",
            "height",
            "href",
            "id",
            "largeop",
            "length",
            "linethickness",
            "lspace",
            "lquote",
            "mathbackground",
            "mathcolor",
            "mathsize",
            "mathvariant",
            "maxsize",
            "minsize",
            "movablelimits",
            "notation",
            "numalign",
            "open",
            "rowalign",
            "rowlines",
            "rowspacing",
            "rowspan",
            "rspace",
            "rquote",
            "scriptlevel",
            "scriptminsize",
            "scriptsizemultiplier",
            "selection",
            "separator",
            "separators",
            "stretchy",
            "subscriptshift",
            "supscriptshift",
            "symmetric",
            "voffset",
            "width",
            "xmlns",
          ]),
          F = s([
            "xlink:href",
            "xml:id",
            "xlink:title",
            "xml:space",
            "xmlns:xlink",
          ]),
          B = a(/\{\{[\s\S]*|[\s\S]*\}\}/gm),
          N = a(/<%[\s\S]*|[\s\S]*%>/gm),
          j = a(/^data-[\-\w.\u00B7-\uFFFF]/),
          U = a(/^aria-[\-\w]+$/),
          Z = a(
            /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
          ),
          V = a(/^(?:\w+script|data):/i),
          q = a(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g),
          $ =
            "function" === typeof Symbol && "symbol" === typeof Symbol.iterator
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t &&
                    "function" === typeof Symbol &&
                    t.constructor === Symbol &&
                    t !== Symbol.prototype
                    ? "symbol"
                    : typeof t;
                };
        function G(t) {
          if (Array.isArray(t)) {
            for (var e = 0, n = Array(t.length); e < t.length; e++) n[e] = t[e];
            return n;
          }
          return Array.from(t);
        }
        var W = function () {
            return "undefined" === typeof window ? null : window;
          },
          H = function (t, e) {
            if (
              "object" !== ("undefined" === typeof t ? "undefined" : $(t)) ||
              "function" !== typeof t.createPolicy
            )
              return null;
            var n = null,
              r = "data-tt-policy-suffix";
            e.currentScript &&
              e.currentScript.hasAttribute(r) &&
              (n = e.currentScript.getAttribute(r));
            var i = "dompurify" + (n ? "#" + n : "");
            try {
              return t.createPolicy(i, {
                createHTML: function (t) {
                  return t;
                },
              });
            } catch (o) {
              return (
                console.warn(
                  "TrustedTypes policy " + i + " could not be created."
                ),
                null
              );
            }
          };
        function X() {
          var t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : W(),
            e = function (t) {
              return X(t);
            };
          if (
            ((e.version = "2.3.3"),
            (e.removed = []),
            !t || !t.document || 9 !== t.document.nodeType)
          )
            return (e.isSupported = !1), e;
          var n = t.document,
            r = t.document,
            i = t.DocumentFragment,
            o = t.HTMLTemplateElement,
            a = t.Node,
            l = t.Element,
            c = t.NodeFilter,
            u = t.NamedNodeMap,
            h = void 0 === u ? t.NamedNodeMap || t.MozNamedAttrMap : u,
            w = t.Text,
            S = t.Comment,
            K = t.DOMParser,
            Y = t.trustedTypes,
            Q = l.prototype,
            J = A(Q, "cloneNode"),
            tt = A(Q, "nextSibling"),
            et = A(Q, "childNodes"),
            nt = A(Q, "parentNode");
          if ("function" === typeof o) {
            var rt = r.createElement("template");
            rt.content &&
              rt.content.ownerDocument &&
              (r = rt.content.ownerDocument);
          }
          var it = H(Y, n),
            ot = it && Ft ? it.createHTML("") : "",
            st = r,
            at = st.implementation,
            lt = st.createNodeIterator,
            ct = st.createDocumentFragment,
            ut = st.getElementsByTagName,
            ht = n.importNode,
            pt = {};
          try {
            pt = T(r).documentMode ? r.documentMode : {};
          } catch (we) {}
          var dt = {};
          e.isSupported =
            "function" === typeof nt &&
            at &&
            "undefined" !== typeof at.createHTMLDocument &&
            9 !== pt;
          var ft = B,
            mt = N,
            gt = j,
            yt = U,
            _t = V,
            vt = q,
            bt = Z,
            xt = null,
            wt = E({}, [].concat(G(C), G(P), G(M), G(k), G(D))),
            St = null,
            Et = E({}, [].concat(G(z), G(R), G(L), G(F))),
            Tt = null,
            At = null,
            Ct = !0,
            Pt = !0,
            Mt = !1,
            Ot = !1,
            kt = !1,
            It = !1,
            Dt = !1,
            zt = !1,
            Rt = !1,
            Lt = !0,
            Ft = !1,
            Bt = !0,
            Nt = !0,
            jt = !1,
            Ut = {},
            Zt = null,
            Vt = E({}, [
              "annotation-xml",
              "audio",
              "colgroup",
              "desc",
              "foreignobject",
              "head",
              "iframe",
              "math",
              "mi",
              "mn",
              "mo",
              "ms",
              "mtext",
              "noembed",
              "noframes",
              "noscript",
              "plaintext",
              "script",
              "style",
              "svg",
              "template",
              "thead",
              "title",
              "video",
              "xmp",
            ]),
            qt = null,
            $t = E({}, ["audio", "video", "img", "source", "image", "track"]),
            Gt = null,
            Wt = E({}, [
              "alt",
              "class",
              "for",
              "id",
              "label",
              "name",
              "pattern",
              "placeholder",
              "role",
              "summary",
              "title",
              "value",
              "style",
              "xmlns",
            ]),
            Ht = "http://www.w3.org/1998/Math/MathML",
            Xt = "http://www.w3.org/2000/svg",
            Kt = "http://www.w3.org/1999/xhtml",
            Yt = Kt,
            Qt = !1,
            Jt = void 0,
            te = ["application/xhtml+xml", "text/html"],
            ee = "text/html",
            ne = void 0,
            re = null,
            ie = r.createElement("form"),
            oe = function (t) {
              (re && re === t) ||
                ((t &&
                  "object" ===
                    ("undefined" === typeof t ? "undefined" : $(t))) ||
                  (t = {}),
                (t = T(t)),
                (xt = "ALLOWED_TAGS" in t ? E({}, t.ALLOWED_TAGS) : wt),
                (St = "ALLOWED_ATTR" in t ? E({}, t.ALLOWED_ATTR) : Et),
                (Gt =
                  "ADD_URI_SAFE_ATTR" in t
                    ? E(T(Wt), t.ADD_URI_SAFE_ATTR)
                    : Wt),
                (qt =
                  "ADD_DATA_URI_TAGS" in t
                    ? E(T($t), t.ADD_DATA_URI_TAGS)
                    : $t),
                (Zt = "FORBID_CONTENTS" in t ? E({}, t.FORBID_CONTENTS) : Vt),
                (Tt = "FORBID_TAGS" in t ? E({}, t.FORBID_TAGS) : {}),
                (At = "FORBID_ATTR" in t ? E({}, t.FORBID_ATTR) : {}),
                (Ut = "USE_PROFILES" in t && t.USE_PROFILES),
                (Ct = !1 !== t.ALLOW_ARIA_ATTR),
                (Pt = !1 !== t.ALLOW_DATA_ATTR),
                (Mt = t.ALLOW_UNKNOWN_PROTOCOLS || !1),
                (Ot = t.SAFE_FOR_TEMPLATES || !1),
                (kt = t.WHOLE_DOCUMENT || !1),
                (zt = t.RETURN_DOM || !1),
                (Rt = t.RETURN_DOM_FRAGMENT || !1),
                (Lt = !1 !== t.RETURN_DOM_IMPORT),
                (Ft = t.RETURN_TRUSTED_TYPE || !1),
                (Dt = t.FORCE_BODY || !1),
                (Bt = !1 !== t.SANITIZE_DOM),
                (Nt = !1 !== t.KEEP_CONTENT),
                (jt = t.IN_PLACE || !1),
                (bt = t.ALLOWED_URI_REGEXP || bt),
                (Yt = t.NAMESPACE || Kt),
                (Jt = Jt =
                  -1 === te.indexOf(t.PARSER_MEDIA_TYPE)
                    ? ee
                    : t.PARSER_MEDIA_TYPE),
                (ne =
                  "application/xhtml+xml" === Jt
                    ? function (t) {
                        return t;
                      }
                    : m),
                Ot && (Pt = !1),
                Rt && (zt = !0),
                Ut &&
                  ((xt = E({}, [].concat(G(D)))),
                  (St = []),
                  !0 === Ut.html && (E(xt, C), E(St, z)),
                  !0 === Ut.svg && (E(xt, P), E(St, R), E(St, F)),
                  !0 === Ut.svgFilters && (E(xt, M), E(St, R), E(St, F)),
                  !0 === Ut.mathMl && (E(xt, k), E(St, L), E(St, F))),
                t.ADD_TAGS && (xt === wt && (xt = T(xt)), E(xt, t.ADD_TAGS)),
                t.ADD_ATTR && (St === Et && (St = T(St)), E(St, t.ADD_ATTR)),
                t.ADD_URI_SAFE_ATTR && E(Gt, t.ADD_URI_SAFE_ATTR),
                t.FORBID_CONTENTS &&
                  (Zt === Vt && (Zt = T(Zt)), E(Zt, t.FORBID_CONTENTS)),
                Nt && (xt["#text"] = !0),
                kt && E(xt, ["html", "head", "body"]),
                xt.table && (E(xt, ["tbody"]), delete Tt.tbody),
                s && s(t),
                (re = t));
            },
            se = E({}, ["mi", "mo", "mn", "ms", "mtext"]),
            ae = E({}, ["foreignobject", "desc", "title", "annotation-xml"]),
            le = E({}, P);
          E(le, M), E(le, O);
          var ce = E({}, k);
          E(ce, I);
          var ue = function (t) {
              var e = nt(t);
              (e && e.tagName) ||
                (e = { namespaceURI: Kt, tagName: "template" });
              var n = m(t.tagName),
                r = m(e.tagName);
              if (t.namespaceURI === Xt)
                return e.namespaceURI === Kt
                  ? "svg" === n
                  : e.namespaceURI === Ht
                  ? "svg" === n && ("annotation-xml" === r || se[r])
                  : Boolean(le[n]);
              if (t.namespaceURI === Ht)
                return e.namespaceURI === Kt
                  ? "math" === n
                  : e.namespaceURI === Xt
                  ? "math" === n && ae[r]
                  : Boolean(ce[n]);
              if (t.namespaceURI === Kt) {
                if (e.namespaceURI === Xt && !ae[r]) return !1;
                if (e.namespaceURI === Ht && !se[r]) return !1;
                var i = E({}, ["title", "style", "font", "a", "script"]);
                return !ce[n] && (i[n] || !le[n]);
              }
              return !1;
            },
            he = function (t) {
              f(e.removed, { element: t });
              try {
                t.parentNode.removeChild(t);
              } catch (we) {
                try {
                  t.outerHTML = ot;
                } catch (we) {
                  t.remove();
                }
              }
            },
            pe = function (t, n) {
              try {
                f(e.removed, { attribute: n.getAttributeNode(t), from: n });
              } catch (we) {
                f(e.removed, { attribute: null, from: n });
              }
              if ((n.removeAttribute(t), "is" === t && !St[t]))
                if (zt || Rt)
                  try {
                    he(n);
                  } catch (we) {}
                else
                  try {
                    n.setAttribute(t, "");
                  } catch (we) {}
            },
            de = function (t) {
              var e = void 0,
                n = void 0;
              if (Dt) t = "<remove></remove>" + t;
              else {
                var i = g(t, /^[\r\n\t ]+/);
                n = i && i[0];
              }
              "application/xhtml+xml" === Jt &&
                (t =
                  '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' +
                  t +
                  "</body></html>");
              var o = it ? it.createHTML(t) : t;
              if (Yt === Kt)
                try {
                  e = new K().parseFromString(o, Jt);
                } catch (we) {}
              if (!e || !e.documentElement) {
                e = at.createDocument(Yt, "template", null);
                try {
                  e.documentElement.innerHTML = Qt ? "" : o;
                } catch (we) {}
              }
              var s = e.body || e.documentElement;
              return (
                t &&
                  n &&
                  s.insertBefore(r.createTextNode(n), s.childNodes[0] || null),
                Yt === Kt
                  ? ut.call(e, kt ? "html" : "body")[0]
                  : kt
                  ? e.documentElement
                  : s
              );
            },
            fe = function (t) {
              return lt.call(
                t.ownerDocument || t,
                t,
                c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT,
                null,
                !1
              );
            },
            me = function (t) {
              return (
                !(t instanceof w || t instanceof S) &&
                !(
                  "string" === typeof t.nodeName &&
                  "string" === typeof t.textContent &&
                  "function" === typeof t.removeChild &&
                  t.attributes instanceof h &&
                  "function" === typeof t.removeAttribute &&
                  "function" === typeof t.setAttribute &&
                  "string" === typeof t.namespaceURI &&
                  "function" === typeof t.insertBefore
                )
              );
            },
            ge = function (t) {
              return "object" ===
                ("undefined" === typeof a ? "undefined" : $(a))
                ? t instanceof a
                : t &&
                    "object" ===
                      ("undefined" === typeof t ? "undefined" : $(t)) &&
                    "number" === typeof t.nodeType &&
                    "string" === typeof t.nodeName;
            },
            ye = function (t, n, r) {
              dt[t] &&
                p(dt[t], function (t) {
                  t.call(e, n, r, re);
                });
            },
            _e = function (t) {
              var n = void 0;
              if ((ye("beforeSanitizeElements", t, null), me(t)))
                return he(t), !0;
              if (g(t.nodeName, /[\u0080-\uFFFF]/)) return he(t), !0;
              var r = ne(t.nodeName);
              if (
                (ye("uponSanitizeElement", t, { tagName: r, allowedTags: xt }),
                !ge(t.firstElementChild) &&
                  (!ge(t.content) || !ge(t.content.firstElementChild)) &&
                  b(/<[/\w]/g, t.innerHTML) &&
                  b(/<[/\w]/g, t.textContent))
              )
                return he(t), !0;
              if ("select" === r && b(/<template/i, t.innerHTML))
                return he(t), !0;
              if (!xt[r] || Tt[r]) {
                if (Nt && !Zt[r]) {
                  var i = nt(t) || t.parentNode,
                    o = et(t) || t.childNodes;
                  if (o && i)
                    for (var s = o.length - 1; s >= 0; --s)
                      i.insertBefore(J(o[s], !0), tt(t));
                }
                return he(t), !0;
              }
              return t instanceof l && !ue(t)
                ? (he(t), !0)
                : ("noscript" !== r && "noembed" !== r) ||
                  !b(/<\/no(script|embed)/i, t.innerHTML)
                ? (Ot &&
                    3 === t.nodeType &&
                    ((n = t.textContent),
                    (n = y(n, ft, " ")),
                    (n = y(n, mt, " ")),
                    t.textContent !== n &&
                      (f(e.removed, { element: t.cloneNode() }),
                      (t.textContent = n))),
                  ye("afterSanitizeElements", t, null),
                  !1)
                : (he(t), !0);
            },
            ve = function (t, e, n) {
              if (Bt && ("id" === e || "name" === e) && (n in r || n in ie))
                return !1;
              if (Pt && !At[e] && b(gt, e));
              else if (Ct && b(yt, e));
              else {
                if (!St[e] || At[e]) return !1;
                if (Gt[e]);
                else if (b(bt, y(n, vt, "")));
                else if (
                  ("src" !== e && "xlink:href" !== e && "href" !== e) ||
                  "script" === t ||
                  0 !== _(n, "data:") ||
                  !qt[t]
                )
                  if (Mt && !b(_t, y(n, vt, "")));
                  else if (n) return !1;
              }
              return !0;
            },
            be = function (t) {
              var n = void 0,
                r = void 0,
                i = void 0,
                o = void 0;
              ye("beforeSanitizeAttributes", t, null);
              var s = t.attributes;
              if (s) {
                var a = {
                  attrName: "",
                  attrValue: "",
                  keepAttr: !0,
                  allowedAttributes: St,
                };
                for (o = s.length; o--; ) {
                  var l = (n = s[o]),
                    c = l.name,
                    u = l.namespaceURI;
                  if (
                    ((r = v(n.value)),
                    (i = ne(c)),
                    (a.attrName = i),
                    (a.attrValue = r),
                    (a.keepAttr = !0),
                    (a.forceKeepAttr = void 0),
                    ye("uponSanitizeAttribute", t, a),
                    (r = a.attrValue),
                    !a.forceKeepAttr && (pe(c, t), a.keepAttr))
                  )
                    if (b(/\/>/i, r)) pe(c, t);
                    else {
                      Ot && ((r = y(r, ft, " ")), (r = y(r, mt, " ")));
                      var h = ne(t.nodeName);
                      if (ve(h, i, r))
                        try {
                          u ? t.setAttributeNS(u, c, r) : t.setAttribute(c, r),
                            d(e.removed);
                        } catch (we) {}
                    }
                }
                ye("afterSanitizeAttributes", t, null);
              }
            },
            xe = function t(e) {
              var n = void 0,
                r = fe(e);
              for (ye("beforeSanitizeShadowDOM", e, null); (n = r.nextNode()); )
                ye("uponSanitizeShadowNode", n, null),
                  _e(n) || (n.content instanceof i && t(n.content), be(n));
              ye("afterSanitizeShadowDOM", e, null);
            };
          return (
            (e.sanitize = function (r, o) {
              var s = void 0,
                l = void 0,
                c = void 0,
                u = void 0,
                h = void 0;
              if (
                ((Qt = !r) && (r = "\x3c!--\x3e"),
                "string" !== typeof r && !ge(r))
              ) {
                if ("function" !== typeof r.toString)
                  throw x("toString is not a function");
                if ("string" !== typeof (r = r.toString()))
                  throw x("dirty is not a string, aborting");
              }
              if (!e.isSupported) {
                if (
                  "object" === $(t.toStaticHTML) ||
                  "function" === typeof t.toStaticHTML
                ) {
                  if ("string" === typeof r) return t.toStaticHTML(r);
                  if (ge(r)) return t.toStaticHTML(r.outerHTML);
                }
                return r;
              }
              if (
                (It || oe(o),
                (e.removed = []),
                "string" === typeof r && (jt = !1),
                jt)
              );
              else if (r instanceof a)
                (1 ===
                  (l = (s = de("\x3c!----\x3e")).ownerDocument.importNode(
                    r,
                    !0
                  )).nodeType &&
                  "BODY" === l.nodeName) ||
                "HTML" === l.nodeName
                  ? (s = l)
                  : s.appendChild(l);
              else {
                if (!zt && !Ot && !kt && -1 === r.indexOf("<"))
                  return it && Ft ? it.createHTML(r) : r;
                if (!(s = de(r))) return zt ? null : ot;
              }
              s && Dt && he(s.firstChild);
              for (var p = fe(jt ? r : s); (c = p.nextNode()); )
                (3 === c.nodeType && c === u) ||
                  _e(c) ||
                  (c.content instanceof i && xe(c.content), be(c), (u = c));
              if (((u = null), jt)) return r;
              if (zt) {
                if (Rt)
                  for (h = ct.call(s.ownerDocument); s.firstChild; )
                    h.appendChild(s.firstChild);
                else h = s;
                return Lt && (h = ht.call(n, h, !0)), h;
              }
              var d = kt ? s.outerHTML : s.innerHTML;
              return (
                Ot && ((d = y(d, ft, " ")), (d = y(d, mt, " "))),
                it && Ft ? it.createHTML(d) : d
              );
            }),
            (e.setConfig = function (t) {
              oe(t), (It = !0);
            }),
            (e.clearConfig = function () {
              (re = null), (It = !1);
            }),
            (e.isValidAttribute = function (t, e, n) {
              re || oe({});
              var r = ne(t),
                i = ne(e);
              return ve(r, i, n);
            }),
            (e.addHook = function (t, e) {
              "function" === typeof e && ((dt[t] = dt[t] || []), f(dt[t], e));
            }),
            (e.removeHook = function (t) {
              dt[t] && d(dt[t]);
            }),
            (e.removeHooks = function (t) {
              dt[t] && (dt[t] = []);
            }),
            (e.removeAllHooks = function () {
              dt = {};
            }),
            e
          );
        }
        return X();
      })();
    },
    79180: function (t, e, n) {
      var r, i, o;
      !(function (s, a) {
        "use strict";
        (i = [n(59829)]),
          void 0 ===
            (o =
              "function" ===
              typeof (r = function (t) {
                var e = /(^|@)\S+\:\d+/,
                  n = /^\s*at .*(\S+\:\d+|\(native\))/m,
                  r = /^(eval@)?(\[native code\])?$/;
                function i(t, e, n) {
                  if ("function" === typeof Array.prototype.map)
                    return t.map(e, n);
                  for (var r = new Array(t.length), i = 0; i < t.length; i++)
                    r[i] = e.call(n, t[i]);
                  return r;
                }
                function o(t, e, n) {
                  if ("function" === typeof Array.prototype.filter)
                    return t.filter(e, n);
                  for (var r = [], i = 0; i < t.length; i++)
                    e.call(n, t[i]) && r.push(t[i]);
                  return r;
                }
                function s(t, e) {
                  if ("function" === typeof Array.prototype.indexOf)
                    return t.indexOf(e);
                  for (var n = 0; n < t.length; n++) if (t[n] === e) return n;
                  return -1;
                }
                return {
                  parse: function (t) {
                    if (
                      "undefined" !== typeof t.stacktrace ||
                      "undefined" !== typeof t["opera#sourceloc"]
                    )
                      return this.parseOpera(t);
                    if (t.stack && t.stack.match(n)) return this.parseV8OrIE(t);
                    if (t.stack) return this.parseFFOrSafari(t);
                    throw new Error("Cannot parse given Error object");
                  },
                  extractLocation: function (t) {
                    if (-1 === t.indexOf(":")) return [t];
                    var e = /(.+?)(?:\:(\d+))?(?:\:(\d+))?$/.exec(
                      t.replace(/[\(\)]/g, "")
                    );
                    return [e[1], e[2] || void 0, e[3] || void 0];
                  },
                  parseV8OrIE: function (e) {
                    return i(
                      o(
                        e.stack.split("\n"),
                        function (t) {
                          return !!t.match(n);
                        },
                        this
                      ),
                      function (e) {
                        e.indexOf("(eval ") > -1 &&
                          (e = e
                            .replace(/eval code/g, "eval")
                            .replace(/(\(eval at [^\()]*)|(\)\,.*$)/g, ""));
                        var n = e
                            .replace(/^\s+/, "")
                            .replace(/\(eval code/g, "(")
                            .split(/\s+/)
                            .slice(1),
                          r = this.extractLocation(n.pop()),
                          i = n.join(" ") || void 0,
                          o =
                            s(["eval", "<anonymous>"], r[0]) > -1
                              ? void 0
                              : r[0];
                        return new t(i, void 0, o, r[1], r[2], e);
                      },
                      this
                    );
                  },
                  parseFFOrSafari: function (e) {
                    return i(
                      o(
                        e.stack.split("\n"),
                        function (t) {
                          return !t.match(r);
                        },
                        this
                      ),
                      function (e) {
                        if (
                          (e.indexOf(" > eval") > -1 &&
                            (e = e.replace(
                              / line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g,
                              ":$1"
                            )),
                          -1 === e.indexOf("@") && -1 === e.indexOf(":"))
                        )
                          return new t(e);
                        var n = e.split("@"),
                          r = this.extractLocation(n.pop()),
                          i = n.join("@") || void 0;
                        return new t(i, void 0, r[0], r[1], r[2], e);
                      },
                      this
                    );
                  },
                  parseOpera: function (t) {
                    return !t.stacktrace ||
                      (t.message.indexOf("\n") > -1 &&
                        t.message.split("\n").length >
                          t.stacktrace.split("\n").length)
                      ? this.parseOpera9(t)
                      : t.stack
                      ? this.parseOpera11(t)
                      : this.parseOpera10(t);
                  },
                  parseOpera9: function (e) {
                    for (
                      var n = /Line (\d+).*script (?:in )?(\S+)/i,
                        r = e.message.split("\n"),
                        i = [],
                        o = 2,
                        s = r.length;
                      o < s;
                      o += 2
                    ) {
                      var a = n.exec(r[o]);
                      a &&
                        i.push(new t(void 0, void 0, a[2], a[1], void 0, r[o]));
                    }
                    return i;
                  },
                  parseOpera10: function (e) {
                    for (
                      var n =
                          /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i,
                        r = e.stacktrace.split("\n"),
                        i = [],
                        o = 0,
                        s = r.length;
                      o < s;
                      o += 2
                    ) {
                      var a = n.exec(r[o]);
                      a &&
                        i.push(
                          new t(
                            a[3] || void 0,
                            void 0,
                            a[2],
                            a[1],
                            void 0,
                            r[o]
                          )
                        );
                    }
                    return i;
                  },
                  parseOpera11: function (n) {
                    return i(
                      o(
                        n.stack.split("\n"),
                        function (t) {
                          return !!t.match(e) && !t.match(/^Error created at/);
                        },
                        this
                      ),
                      function (e) {
                        var n,
                          r = e.split("@"),
                          i = this.extractLocation(r.pop()),
                          o = r.shift() || "",
                          s =
                            o
                              .replace(/<anonymous function(: (\w+))?>/, "$2")
                              .replace(/\([^\)]*\)/g, "") || void 0;
                        o.match(/\(([^\)]*)\)/) &&
                          (n = o.replace(/^[^\(]+\(([^\)]*)\)$/, "$1"));
                        var a =
                          void 0 === n || "[arguments not available]" === n
                            ? void 0
                            : n.split(",");
                        return new t(s, a, i[0], i[1], i[2], e);
                      },
                      this
                    );
                  },
                };
              })
                ? r.apply(e, i)
                : r) || (t.exports = o);
      })();
    },
    17648: function (t) {
      "use strict";
      var e = "Function.prototype.bind called on incompatible ",
        n = Array.prototype.slice,
        r = Object.prototype.toString,
        i = "[object Function]";
      t.exports = function (t) {
        var o = this;
        if ("function" !== typeof o || r.call(o) !== i)
          throw new TypeError(e + o);
        for (
          var s,
            a = n.call(arguments, 1),
            l = function () {
              if (this instanceof s) {
                var e = o.apply(this, a.concat(n.call(arguments)));
                return Object(e) === e ? e : this;
              }
              return o.apply(t, a.concat(n.call(arguments)));
            },
            c = Math.max(0, o.length - a.length),
            u = [],
            h = 0;
          h < c;
          h++
        )
          u.push("$" + h);
        if (
          ((s = Function(
            "binder",
            "return function (" +
              u.join(",") +
              "){ return binder.apply(this,arguments); }"
          )(l)),
          o.prototype)
        ) {
          var p = function () {};
          (p.prototype = o.prototype),
            (s.prototype = new p()),
            (p.prototype = null);
        }
        return s;
      };
    },
    58612: function (t, e, n) {
      "use strict";
      var r = n(17648);
      t.exports = Function.prototype.bind || r;
    },
    40210: function (t, e, n) {
      "use strict";
      var r,
        i = SyntaxError,
        o = Function,
        s = TypeError,
        a = function (t) {
          try {
            return o('"use strict"; return (' + t + ").constructor;")();
          } catch (e) {}
        },
        l = Object.getOwnPropertyDescriptor;
      if (l)
        try {
          l({}, "");
        } catch (P) {
          l = null;
        }
      var c = function () {
          throw new s();
        },
        u = l
          ? (function () {
              try {
                return c;
              } catch (t) {
                try {
                  return l(arguments, "callee").get;
                } catch (e) {
                  return c;
                }
              }
            })()
          : c,
        h = n(41405)(),
        p =
          Object.getPrototypeOf ||
          function (t) {
            return t.__proto__;
          },
        d = {},
        f = "undefined" === typeof Uint8Array ? r : p(Uint8Array),
        m = {
          "%AggregateError%":
            "undefined" === typeof AggregateError ? r : AggregateError,
          "%Array%": Array,
          "%ArrayBuffer%": "undefined" === typeof ArrayBuffer ? r : ArrayBuffer,
          "%ArrayIteratorPrototype%": h ? p([][Symbol.iterator]()) : r,
          "%AsyncFromSyncIteratorPrototype%": r,
          "%AsyncFunction%": d,
          "%AsyncGenerator%": d,
          "%AsyncGeneratorFunction%": d,
          "%AsyncIteratorPrototype%": d,
          "%Atomics%": "undefined" === typeof Atomics ? r : Atomics,
          "%BigInt%": "undefined" === typeof BigInt ? r : BigInt,
          "%Boolean%": Boolean,
          "%DataView%": "undefined" === typeof DataView ? r : DataView,
          "%Date%": Date,
          "%decodeURI%": decodeURI,
          "%decodeURIComponent%": decodeURIComponent,
          "%encodeURI%": encodeURI,
          "%encodeURIComponent%": encodeURIComponent,
          "%Error%": Error,
          "%eval%": eval,
          "%EvalError%": EvalError,
          "%Float32Array%":
            "undefined" === typeof Float32Array ? r : Float32Array,
          "%Float64Array%":
            "undefined" === typeof Float64Array ? r : Float64Array,
          "%FinalizationRegistry%":
            "undefined" === typeof FinalizationRegistry
              ? r
              : FinalizationRegistry,
          "%Function%": o,
          "%GeneratorFunction%": d,
          "%Int8Array%": "undefined" === typeof Int8Array ? r : Int8Array,
          "%Int16Array%": "undefined" === typeof Int16Array ? r : Int16Array,
          "%Int32Array%": "undefined" === typeof Int32Array ? r : Int32Array,
          "%isFinite%": isFinite,
          "%isNaN%": isNaN,
          "%IteratorPrototype%": h ? p(p([][Symbol.iterator]())) : r,
          "%JSON%": "object" === typeof JSON ? JSON : r,
          "%Map%": "undefined" === typeof Map ? r : Map,
          "%MapIteratorPrototype%":
            "undefined" !== typeof Map && h
              ? p(new Map()[Symbol.iterator]())
              : r,
          "%Math%": Math,
          "%Number%": Number,
          "%Object%": Object,
          "%parseFloat%": parseFloat,
          "%parseInt%": parseInt,
          "%Promise%": "undefined" === typeof Promise ? r : Promise,
          "%Proxy%": "undefined" === typeof Proxy ? r : Proxy,
          "%RangeError%": RangeError,
          "%ReferenceError%": ReferenceError,
          "%Reflect%": "undefined" === typeof Reflect ? r : Reflect,
          "%RegExp%": RegExp,
          "%Set%": "undefined" === typeof Set ? r : Set,
          "%SetIteratorPrototype%":
            "undefined" !== typeof Set && h
              ? p(new Set()[Symbol.iterator]())
              : r,
          "%SharedArrayBuffer%":
            "undefined" === typeof SharedArrayBuffer ? r : SharedArrayBuffer,
          "%String%": String,
          "%StringIteratorPrototype%": h ? p(""[Symbol.iterator]()) : r,
          "%Symbol%": h ? Symbol : r,
          "%SyntaxError%": i,
          "%ThrowTypeError%": u,
          "%TypedArray%": f,
          "%TypeError%": s,
          "%Uint8Array%": "undefined" === typeof Uint8Array ? r : Uint8Array,
          "%Uint8ClampedArray%":
            "undefined" === typeof Uint8ClampedArray ? r : Uint8ClampedArray,
          "%Uint16Array%": "undefined" === typeof Uint16Array ? r : Uint16Array,
          "%Uint32Array%": "undefined" === typeof Uint32Array ? r : Uint32Array,
          "%URIError%": URIError,
          "%WeakMap%": "undefined" === typeof WeakMap ? r : WeakMap,
          "%WeakRef%": "undefined" === typeof WeakRef ? r : WeakRef,
          "%WeakSet%": "undefined" === typeof WeakSet ? r : WeakSet,
        },
        g = function t(e) {
          var n;
          if ("%AsyncFunction%" === e) n = a("async function () {}");
          else if ("%GeneratorFunction%" === e) n = a("function* () {}");
          else if ("%AsyncGeneratorFunction%" === e)
            n = a("async function* () {}");
          else if ("%AsyncGenerator%" === e) {
            var r = t("%AsyncGeneratorFunction%");
            r && (n = r.prototype);
          } else if ("%AsyncIteratorPrototype%" === e) {
            var i = t("%AsyncGenerator%");
            i && (n = p(i.prototype));
          }
          return (m[e] = n), n;
        },
        y = {
          "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
          "%ArrayPrototype%": ["Array", "prototype"],
          "%ArrayProto_entries%": ["Array", "prototype", "entries"],
          "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
          "%ArrayProto_keys%": ["Array", "prototype", "keys"],
          "%ArrayProto_values%": ["Array", "prototype", "values"],
          "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
          "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
          "%AsyncGeneratorPrototype%": [
            "AsyncGeneratorFunction",
            "prototype",
            "prototype",
          ],
          "%BooleanPrototype%": ["Boolean", "prototype"],
          "%DataViewPrototype%": ["DataView", "prototype"],
          "%DatePrototype%": ["Date", "prototype"],
          "%ErrorPrototype%": ["Error", "prototype"],
          "%EvalErrorPrototype%": ["EvalError", "prototype"],
          "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
          "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
          "%FunctionPrototype%": ["Function", "prototype"],
          "%Generator%": ["GeneratorFunction", "prototype"],
          "%GeneratorPrototype%": [
            "GeneratorFunction",
            "prototype",
            "prototype",
          ],
          "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
          "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
          "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
          "%JSONParse%": ["JSON", "parse"],
          "%JSONStringify%": ["JSON", "stringify"],
          "%MapPrototype%": ["Map", "prototype"],
          "%NumberPrototype%": ["Number", "prototype"],
          "%ObjectPrototype%": ["Object", "prototype"],
          "%ObjProto_toString%": ["Object", "prototype", "toString"],
          "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
          "%PromisePrototype%": ["Promise", "prototype"],
          "%PromiseProto_then%": ["Promise", "prototype", "then"],
          "%Promise_all%": ["Promise", "all"],
          "%Promise_reject%": ["Promise", "reject"],
          "%Promise_resolve%": ["Promise", "resolve"],
          "%RangeErrorPrototype%": ["RangeError", "prototype"],
          "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
          "%RegExpPrototype%": ["RegExp", "prototype"],
          "%SetPrototype%": ["Set", "prototype"],
          "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
          "%StringPrototype%": ["String", "prototype"],
          "%SymbolPrototype%": ["Symbol", "prototype"],
          "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
          "%TypedArrayPrototype%": ["TypedArray", "prototype"],
          "%TypeErrorPrototype%": ["TypeError", "prototype"],
          "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
          "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
          "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
          "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
          "%URIErrorPrototype%": ["URIError", "prototype"],
          "%WeakMapPrototype%": ["WeakMap", "prototype"],
          "%WeakSetPrototype%": ["WeakSet", "prototype"],
        },
        _ = n(58612),
        v = n(17642),
        b = _.call(Function.call, Array.prototype.concat),
        x = _.call(Function.apply, Array.prototype.splice),
        w = _.call(Function.call, String.prototype.replace),
        S = _.call(Function.call, String.prototype.slice),
        E =
          /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
        T = /\\(\\)?/g,
        A = function (t) {
          var e = S(t, 0, 1),
            n = S(t, -1);
          if ("%" === e && "%" !== n)
            throw new i("invalid intrinsic syntax, expected closing `%`");
          if ("%" === n && "%" !== e)
            throw new i("invalid intrinsic syntax, expected opening `%`");
          var r = [];
          return (
            w(t, E, function (t, e, n, i) {
              r[r.length] = n ? w(i, T, "$1") : e || t;
            }),
            r
          );
        },
        C = function (t, e) {
          var n,
            r = t;
          if ((v(y, r) && (r = "%" + (n = y[r])[0] + "%"), v(m, r))) {
            var o = m[r];
            if ((o === d && (o = g(r)), "undefined" === typeof o && !e))
              throw new s(
                "intrinsic " +
                  t +
                  " exists, but is not available. Please file an issue!"
              );
            return { alias: n, name: r, value: o };
          }
          throw new i("intrinsic " + t + " does not exist!");
        };
      t.exports = function (t, e) {
        if ("string" !== typeof t || 0 === t.length)
          throw new s("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && "boolean" !== typeof e)
          throw new s('"allowMissing" argument must be a boolean');
        var n = A(t),
          r = n.length > 0 ? n[0] : "",
          o = C("%" + r + "%", e),
          a = o.name,
          c = o.value,
          u = !1,
          h = o.alias;
        h && ((r = h[0]), x(n, b([0, 1], h)));
        for (var p = 1, d = !0; p < n.length; p += 1) {
          var f = n[p],
            g = S(f, 0, 1),
            y = S(f, -1);
          if (
            ('"' === g ||
              "'" === g ||
              "`" === g ||
              '"' === y ||
              "'" === y ||
              "`" === y) &&
            g !== y
          )
            throw new i("property names with quotes must have matching quotes");
          if (
            (("constructor" !== f && d) || (u = !0),
            v(m, (a = "%" + (r += "." + f) + "%")))
          )
            c = m[a];
          else if (null != c) {
            if (!(f in c)) {
              if (!e)
                throw new s(
                  "base intrinsic for " +
                    t +
                    " exists, but the property is not available."
                );
              return;
            }
            if (l && p + 1 >= n.length) {
              var _ = l(c, f);
              c =
                (d = !!_) && "get" in _ && !("originalValue" in _.get)
                  ? _.get
                  : c[f];
            } else (d = v(c, f)), (c = c[f]);
            d && !u && (m[a] = c);
          }
        }
        return c;
      };
    },
    50840: function (t, e, n) {
      var r;
      !(function (i, o, s, a) {
        "use strict";
        var l,
          c = ["", "webkit", "Moz", "MS", "ms", "o"],
          u = o.createElement("div"),
          h = Math.round,
          p = Math.abs,
          d = Date.now;
        function f(t, e, n) {
          return setTimeout(x(t, n), e);
        }
        function m(t, e, n) {
          return !!Array.isArray(t) && (g(t, n[e], n), !0);
        }
        function g(t, e, n) {
          var r;
          if (t)
            if (t.forEach) t.forEach(e, n);
            else if (t.length !== a)
              for (r = 0; r < t.length; ) e.call(n, t[r], r, t), r++;
            else for (r in t) t.hasOwnProperty(r) && e.call(n, t[r], r, t);
        }
        function y(t, e, n) {
          var r = "DEPRECATED METHOD: " + e + "\n" + n + " AT \n";
          return function () {
            var e = new Error("get-stack-trace"),
              n =
                e && e.stack
                  ? e.stack
                      .replace(/^[^\(]+?[\n$]/gm, "")
                      .replace(/^\s+at\s+/gm, "")
                      .replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@")
                  : "Unknown Stack Trace",
              o = i.console && (i.console.warn || i.console.log);
            return o && o.call(i.console, r, n), t.apply(this, arguments);
          };
        }
        l =
          "function" !== typeof Object.assign
            ? function (t) {
                if (t === a || null === t)
                  throw new TypeError(
                    "Cannot convert undefined or null to object"
                  );
                for (var e = Object(t), n = 1; n < arguments.length; n++) {
                  var r = arguments[n];
                  if (r !== a && null !== r)
                    for (var i in r) r.hasOwnProperty(i) && (e[i] = r[i]);
                }
                return e;
              }
            : Object.assign;
        var _ = y(
            function (t, e, n) {
              for (var r = Object.keys(e), i = 0; i < r.length; )
                (!n || (n && t[r[i]] === a)) && (t[r[i]] = e[r[i]]), i++;
              return t;
            },
            "extend",
            "Use `assign`."
          ),
          v = y(
            function (t, e) {
              return _(t, e, !0);
            },
            "merge",
            "Use `assign`."
          );
        function b(t, e, n) {
          var r,
            i = e.prototype;
          ((r = t.prototype = Object.create(i)).constructor = t),
            (r._super = i),
            n && l(r, n);
        }
        function x(t, e) {
          return function () {
            return t.apply(e, arguments);
          };
        }
        function w(t, e) {
          return "function" == typeof t ? t.apply((e && e[0]) || a, e) : t;
        }
        function S(t, e) {
          return t === a ? e : t;
        }
        function E(t, e, n) {
          g(P(e), function (e) {
            t.addEventListener(e, n, !1);
          });
        }
        function T(t, e, n) {
          g(P(e), function (e) {
            t.removeEventListener(e, n, !1);
          });
        }
        function A(t, e) {
          for (; t; ) {
            if (t == e) return !0;
            t = t.parentNode;
          }
          return !1;
        }
        function C(t, e) {
          return t.indexOf(e) > -1;
        }
        function P(t) {
          return t.trim().split(/\s+/g);
        }
        function M(t, e, n) {
          if (t.indexOf && !n) return t.indexOf(e);
          for (var r = 0; r < t.length; ) {
            if ((n && t[r][n] == e) || (!n && t[r] === e)) return r;
            r++;
          }
          return -1;
        }
        function O(t) {
          return Array.prototype.slice.call(t, 0);
        }
        function k(t, e, n) {
          for (var r = [], i = [], o = 0; o < t.length; ) {
            var s = e ? t[o][e] : t[o];
            M(i, s) < 0 && r.push(t[o]), (i[o] = s), o++;
          }
          return (
            n &&
              (r = e
                ? r.sort(function (t, n) {
                    return t[e] > n[e];
                  })
                : r.sort()),
            r
          );
        }
        function I(t, e) {
          for (
            var n, r, i = e[0].toUpperCase() + e.slice(1), o = 0;
            o < c.length;

          ) {
            if ((r = (n = c[o]) ? n + i : e) in t) return r;
            o++;
          }
          return a;
        }
        var D = 1;
        function z(t) {
          var e = t.ownerDocument || t;
          return e.defaultView || e.parentWindow || i;
        }
        var R = "ontouchstart" in i,
          L = I(i, "PointerEvent") !== a,
          F =
            R &&
            /mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent),
          B = "touch",
          N = "mouse",
          j = 24,
          U = ["x", "y"],
          Z = ["clientX", "clientY"];
        function V(t, e) {
          var n = this;
          (this.manager = t),
            (this.callback = e),
            (this.element = t.element),
            (this.target = t.options.inputTarget),
            (this.domHandler = function (e) {
              w(t.options.enable, [t]) && n.handler(e);
            }),
            this.init();
        }
        function q(t, e, n) {
          var r = n.pointers.length,
            i = n.changedPointers.length,
            o = 1 & e && r - i === 0,
            s = 12 & e && r - i === 0;
          (n.isFirst = !!o),
            (n.isFinal = !!s),
            o && (t.session = {}),
            (n.eventType = e),
            (function (t, e) {
              var n = t.session,
                r = e.pointers,
                i = r.length;
              n.firstInput || (n.firstInput = $(e));
              i > 1 && !n.firstMultiple
                ? (n.firstMultiple = $(e))
                : 1 === i && (n.firstMultiple = !1);
              var o = n.firstInput,
                s = n.firstMultiple,
                l = s ? s.center : o.center,
                c = (e.center = G(r));
              (e.timeStamp = d()),
                (e.deltaTime = e.timeStamp - o.timeStamp),
                (e.angle = K(l, c)),
                (e.distance = X(l, c)),
                (function (t, e) {
                  var n = e.center,
                    r = t.offsetDelta || {},
                    i = t.prevDelta || {},
                    o = t.prevInput || {};
                  (1 !== e.eventType && 4 !== o.eventType) ||
                    ((i = t.prevDelta = { x: o.deltaX || 0, y: o.deltaY || 0 }),
                    (r = t.offsetDelta = { x: n.x, y: n.y }));
                  (e.deltaX = i.x + (n.x - r.x)),
                    (e.deltaY = i.y + (n.y - r.y));
                })(n, e),
                (e.offsetDirection = H(e.deltaX, e.deltaY));
              var u = W(e.deltaTime, e.deltaX, e.deltaY);
              (e.overallVelocityX = u.x),
                (e.overallVelocityY = u.y),
                (e.overallVelocity = p(u.x) > p(u.y) ? u.x : u.y),
                (e.scale = s
                  ? ((h = s.pointers),
                    (f = r),
                    X(f[0], f[1], Z) / X(h[0], h[1], Z))
                  : 1),
                (e.rotation = s
                  ? (function (t, e) {
                      return K(e[1], e[0], Z) + K(t[1], t[0], Z);
                    })(s.pointers, r)
                  : 0),
                (e.maxPointers = n.prevInput
                  ? e.pointers.length > n.prevInput.maxPointers
                    ? e.pointers.length
                    : n.prevInput.maxPointers
                  : e.pointers.length),
                (function (t, e) {
                  var n,
                    r,
                    i,
                    o,
                    s = t.lastInterval || e,
                    l = e.timeStamp - s.timeStamp;
                  if (8 != e.eventType && (l > 25 || s.velocity === a)) {
                    var c = e.deltaX - s.deltaX,
                      u = e.deltaY - s.deltaY,
                      h = W(l, c, u);
                    (r = h.x),
                      (i = h.y),
                      (n = p(h.x) > p(h.y) ? h.x : h.y),
                      (o = H(c, u)),
                      (t.lastInterval = e);
                  } else
                    (n = s.velocity),
                      (r = s.velocityX),
                      (i = s.velocityY),
                      (o = s.direction);
                  (e.velocity = n),
                    (e.velocityX = r),
                    (e.velocityY = i),
                    (e.direction = o);
                })(n, e);
              var h, f;
              var m = t.element;
              A(e.srcEvent.target, m) && (m = e.srcEvent.target);
              e.target = m;
            })(t, n),
            t.emit("hammer.input", n),
            t.recognize(n),
            (t.session.prevInput = n);
        }
        function $(t) {
          for (var e = [], n = 0; n < t.pointers.length; )
            (e[n] = {
              clientX: h(t.pointers[n].clientX),
              clientY: h(t.pointers[n].clientY),
            }),
              n++;
          return {
            timeStamp: d(),
            pointers: e,
            center: G(e),
            deltaX: t.deltaX,
            deltaY: t.deltaY,
          };
        }
        function G(t) {
          var e = t.length;
          if (1 === e) return { x: h(t[0].clientX), y: h(t[0].clientY) };
          for (var n = 0, r = 0, i = 0; i < e; )
            (n += t[i].clientX), (r += t[i].clientY), i++;
          return { x: h(n / e), y: h(r / e) };
        }
        function W(t, e, n) {
          return { x: e / t || 0, y: n / t || 0 };
        }
        function H(t, e) {
          return t === e ? 1 : p(t) >= p(e) ? (t < 0 ? 2 : 4) : e < 0 ? 8 : 16;
        }
        function X(t, e, n) {
          n || (n = U);
          var r = e[n[0]] - t[n[0]],
            i = e[n[1]] - t[n[1]];
          return Math.sqrt(r * r + i * i);
        }
        function K(t, e, n) {
          n || (n = U);
          var r = e[n[0]] - t[n[0]],
            i = e[n[1]] - t[n[1]];
          return (180 * Math.atan2(i, r)) / Math.PI;
        }
        V.prototype = {
          handler: function () {},
          init: function () {
            this.evEl && E(this.element, this.evEl, this.domHandler),
              this.evTarget && E(this.target, this.evTarget, this.domHandler),
              this.evWin && E(z(this.element), this.evWin, this.domHandler);
          },
          destroy: function () {
            this.evEl && T(this.element, this.evEl, this.domHandler),
              this.evTarget && T(this.target, this.evTarget, this.domHandler),
              this.evWin && T(z(this.element), this.evWin, this.domHandler);
          },
        };
        var Y = { mousedown: 1, mousemove: 2, mouseup: 4 },
          Q = "mousedown",
          J = "mousemove mouseup";
        function tt() {
          (this.evEl = Q),
            (this.evWin = J),
            (this.pressed = !1),
            V.apply(this, arguments);
        }
        b(tt, V, {
          handler: function (t) {
            var e = Y[t.type];
            1 & e && 0 === t.button && (this.pressed = !0),
              2 & e && 1 !== t.which && (e = 4),
              this.pressed &&
                (4 & e && (this.pressed = !1),
                this.callback(this.manager, e, {
                  pointers: [t],
                  changedPointers: [t],
                  pointerType: N,
                  srcEvent: t,
                }));
          },
        });
        var et = {
            pointerdown: 1,
            pointermove: 2,
            pointerup: 4,
            pointercancel: 8,
            pointerout: 8,
          },
          nt = { 2: B, 3: "pen", 4: N, 5: "kinect" },
          rt = "pointerdown",
          it = "pointermove pointerup pointercancel";
        function ot() {
          (this.evEl = rt),
            (this.evWin = it),
            V.apply(this, arguments),
            (this.store = this.manager.session.pointerEvents = []);
        }
        i.MSPointerEvent &&
          !i.PointerEvent &&
          ((rt = "MSPointerDown"),
          (it = "MSPointerMove MSPointerUp MSPointerCancel")),
          b(ot, V, {
            handler: function (t) {
              var e = this.store,
                n = !1,
                r = t.type.toLowerCase().replace("ms", ""),
                i = et[r],
                o = nt[t.pointerType] || t.pointerType,
                s = o == B,
                a = M(e, t.pointerId, "pointerId");
              1 & i && (0 === t.button || s)
                ? a < 0 && (e.push(t), (a = e.length - 1))
                : 12 & i && (n = !0),
                a < 0 ||
                  ((e[a] = t),
                  this.callback(this.manager, i, {
                    pointers: e,
                    changedPointers: [t],
                    pointerType: o,
                    srcEvent: t,
                  }),
                  n && e.splice(a, 1));
            },
          });
        var st = { touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8 },
          at = "touchstart",
          lt = "touchstart touchmove touchend touchcancel";
        function ct() {
          (this.evTarget = at),
            (this.evWin = lt),
            (this.started = !1),
            V.apply(this, arguments);
        }
        function ut(t, e) {
          var n = O(t.touches),
            r = O(t.changedTouches);
          return 12 & e && (n = k(n.concat(r), "identifier", !0)), [n, r];
        }
        b(ct, V, {
          handler: function (t) {
            var e = st[t.type];
            if ((1 === e && (this.started = !0), this.started)) {
              var n = ut.call(this, t, e);
              12 & e && n[0].length - n[1].length === 0 && (this.started = !1),
                this.callback(this.manager, e, {
                  pointers: n[0],
                  changedPointers: n[1],
                  pointerType: B,
                  srcEvent: t,
                });
            }
          },
        });
        var ht = { touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8 },
          pt = "touchstart touchmove touchend touchcancel";
        function dt() {
          (this.evTarget = pt), (this.targetIds = {}), V.apply(this, arguments);
        }
        function ft(t, e) {
          var n = O(t.touches),
            r = this.targetIds;
          if (3 & e && 1 === n.length) return (r[n[0].identifier] = !0), [n, n];
          var i,
            o,
            s = O(t.changedTouches),
            a = [],
            l = this.target;
          if (
            ((o = n.filter(function (t) {
              return A(t.target, l);
            })),
            1 === e)
          )
            for (i = 0; i < o.length; ) (r[o[i].identifier] = !0), i++;
          for (i = 0; i < s.length; )
            r[s[i].identifier] && a.push(s[i]),
              12 & e && delete r[s[i].identifier],
              i++;
          return a.length ? [k(o.concat(a), "identifier", !0), a] : void 0;
        }
        b(dt, V, {
          handler: function (t) {
            var e = ht[t.type],
              n = ft.call(this, t, e);
            n &&
              this.callback(this.manager, e, {
                pointers: n[0],
                changedPointers: n[1],
                pointerType: B,
                srcEvent: t,
              });
          },
        });
        function mt() {
          V.apply(this, arguments);
          var t = x(this.handler, this);
          (this.touch = new dt(this.manager, t)),
            (this.mouse = new tt(this.manager, t)),
            (this.primaryTouch = null),
            (this.lastTouches = []);
        }
        function gt(t, e) {
          1 & t
            ? ((this.primaryTouch = e.changedPointers[0].identifier),
              yt.call(this, e))
            : 12 & t && yt.call(this, e);
        }
        function yt(t) {
          var e = t.changedPointers[0];
          if (e.identifier === this.primaryTouch) {
            var n = { x: e.clientX, y: e.clientY };
            this.lastTouches.push(n);
            var r = this.lastTouches;
            setTimeout(function () {
              var t = r.indexOf(n);
              t > -1 && r.splice(t, 1);
            }, 2500);
          }
        }
        function _t(t) {
          for (
            var e = t.srcEvent.clientX, n = t.srcEvent.clientY, r = 0;
            r < this.lastTouches.length;
            r++
          ) {
            var i = this.lastTouches[r],
              o = Math.abs(e - i.x),
              s = Math.abs(n - i.y);
            if (o <= 25 && s <= 25) return !0;
          }
          return !1;
        }
        b(mt, V, {
          handler: function (t, e, n) {
            var r = n.pointerType == B,
              i = n.pointerType == N;
            if (
              !(
                i &&
                n.sourceCapabilities &&
                n.sourceCapabilities.firesTouchEvents
              )
            ) {
              if (r) gt.call(this, e, n);
              else if (i && _t.call(this, n)) return;
              this.callback(t, e, n);
            }
          },
          destroy: function () {
            this.touch.destroy(), this.mouse.destroy();
          },
        });
        var vt = I(u.style, "touchAction"),
          bt = vt !== a,
          xt = "compute",
          wt = "auto",
          St = "manipulation",
          Et = "none",
          Tt = "pan-x",
          At = "pan-y",
          Ct = (function () {
            if (!bt) return !1;
            var t = {},
              e = i.CSS && i.CSS.supports;
            return (
              [
                "auto",
                "manipulation",
                "pan-y",
                "pan-x",
                "pan-x pan-y",
                "none",
              ].forEach(function (n) {
                t[n] = !e || i.CSS.supports("touch-action", n);
              }),
              t
            );
          })();
        function Pt(t, e) {
          (this.manager = t), this.set(e);
        }
        Pt.prototype = {
          set: function (t) {
            t == xt && (t = this.compute()),
              bt &&
                this.manager.element.style &&
                Ct[t] &&
                (this.manager.element.style[vt] = t),
              (this.actions = t.toLowerCase().trim());
          },
          update: function () {
            this.set(this.manager.options.touchAction);
          },
          compute: function () {
            var t = [];
            return (
              g(this.manager.recognizers, function (e) {
                w(e.options.enable, [e]) && (t = t.concat(e.getTouchAction()));
              }),
              (function (t) {
                if (C(t, Et)) return Et;
                var e = C(t, Tt),
                  n = C(t, At);
                if (e && n) return Et;
                if (e || n) return e ? Tt : At;
                if (C(t, St)) return St;
                return wt;
              })(t.join(" "))
            );
          },
          preventDefaults: function (t) {
            var e = t.srcEvent,
              n = t.offsetDirection;
            if (this.manager.session.prevented) e.preventDefault();
            else {
              var r = this.actions,
                i = C(r, Et) && !Ct.none,
                o = C(r, At) && !Ct["pan-y"],
                s = C(r, Tt) && !Ct["pan-x"];
              if (i) {
                var a = 1 === t.pointers.length,
                  l = t.distance < 2,
                  c = t.deltaTime < 250;
                if (a && l && c) return;
              }
              if (!s || !o)
                return i || (o && 6 & n) || (s && n & j)
                  ? this.preventSrc(e)
                  : void 0;
            }
          },
          preventSrc: function (t) {
            (this.manager.session.prevented = !0), t.preventDefault();
          },
        };
        var Mt = 32;
        function Ot(t) {
          (this.options = l({}, this.defaults, t || {})),
            (this.id = D++),
            (this.manager = null),
            (this.options.enable = S(this.options.enable, !0)),
            (this.state = 1),
            (this.simultaneous = {}),
            (this.requireFail = []);
        }
        function kt(t) {
          return 16 & t
            ? "cancel"
            : 8 & t
            ? "end"
            : 4 & t
            ? "move"
            : 2 & t
            ? "start"
            : "";
        }
        function It(t) {
          return 16 == t
            ? "down"
            : 8 == t
            ? "up"
            : 2 == t
            ? "left"
            : 4 == t
            ? "right"
            : "";
        }
        function Dt(t, e) {
          var n = e.manager;
          return n ? n.get(t) : t;
        }
        function zt() {
          Ot.apply(this, arguments);
        }
        function Rt() {
          zt.apply(this, arguments), (this.pX = null), (this.pY = null);
        }
        function Lt() {
          zt.apply(this, arguments);
        }
        function Ft() {
          Ot.apply(this, arguments), (this._timer = null), (this._input = null);
        }
        function Bt() {
          zt.apply(this, arguments);
        }
        function Nt() {
          zt.apply(this, arguments);
        }
        function jt() {
          Ot.apply(this, arguments),
            (this.pTime = !1),
            (this.pCenter = !1),
            (this._timer = null),
            (this._input = null),
            (this.count = 0);
        }
        function Ut(t, e) {
          return (
            ((e = e || {}).recognizers = S(e.recognizers, Ut.defaults.preset)),
            new Zt(t, e)
          );
        }
        (Ot.prototype = {
          defaults: {},
          set: function (t) {
            return (
              l(this.options, t),
              this.manager && this.manager.touchAction.update(),
              this
            );
          },
          recognizeWith: function (t) {
            if (m(t, "recognizeWith", this)) return this;
            var e = this.simultaneous;
            return (
              e[(t = Dt(t, this)).id] || ((e[t.id] = t), t.recognizeWith(this)),
              this
            );
          },
          dropRecognizeWith: function (t) {
            return (
              m(t, "dropRecognizeWith", this) ||
                ((t = Dt(t, this)), delete this.simultaneous[t.id]),
              this
            );
          },
          requireFailure: function (t) {
            if (m(t, "requireFailure", this)) return this;
            var e = this.requireFail;
            return (
              -1 === M(e, (t = Dt(t, this))) &&
                (e.push(t), t.requireFailure(this)),
              this
            );
          },
          dropRequireFailure: function (t) {
            if (m(t, "dropRequireFailure", this)) return this;
            t = Dt(t, this);
            var e = M(this.requireFail, t);
            return e > -1 && this.requireFail.splice(e, 1), this;
          },
          hasRequireFailures: function () {
            return this.requireFail.length > 0;
          },
          canRecognizeWith: function (t) {
            return !!this.simultaneous[t.id];
          },
          emit: function (t) {
            var e = this,
              n = this.state;
            function r(n) {
              e.manager.emit(n, t);
            }
            n < 8 && r(e.options.event + kt(n)),
              r(e.options.event),
              t.additionalEvent && r(t.additionalEvent),
              n >= 8 && r(e.options.event + kt(n));
          },
          tryEmit: function (t) {
            if (this.canEmit()) return this.emit(t);
            this.state = Mt;
          },
          canEmit: function () {
            for (var t = 0; t < this.requireFail.length; ) {
              if (!(33 & this.requireFail[t].state)) return !1;
              t++;
            }
            return !0;
          },
          recognize: function (t) {
            var e = l({}, t);
            if (!w(this.options.enable, [this, e]))
              return this.reset(), void (this.state = Mt);
            56 & this.state && (this.state = 1),
              (this.state = this.process(e)),
              30 & this.state && this.tryEmit(e);
          },
          process: function (t) {},
          getTouchAction: function () {},
          reset: function () {},
        }),
          b(zt, Ot, {
            defaults: { pointers: 1 },
            attrTest: function (t) {
              var e = this.options.pointers;
              return 0 === e || t.pointers.length === e;
            },
            process: function (t) {
              var e = this.state,
                n = t.eventType,
                r = 6 & e,
                i = this.attrTest(t);
              return r && (8 & n || !i)
                ? 16 | e
                : r || i
                ? 4 & n
                  ? 8 | e
                  : 2 & e
                  ? 4 | e
                  : 2
                : Mt;
            },
          }),
          b(Rt, zt, {
            defaults: {
              event: "pan",
              threshold: 10,
              pointers: 1,
              direction: 30,
            },
            getTouchAction: function () {
              var t = this.options.direction,
                e = [];
              return 6 & t && e.push(At), t & j && e.push(Tt), e;
            },
            directionTest: function (t) {
              var e = this.options,
                n = !0,
                r = t.distance,
                i = t.direction,
                o = t.deltaX,
                s = t.deltaY;
              return (
                i & e.direction ||
                  (6 & e.direction
                    ? ((i = 0 === o ? 1 : o < 0 ? 2 : 4),
                      (n = o != this.pX),
                      (r = Math.abs(t.deltaX)))
                    : ((i = 0 === s ? 1 : s < 0 ? 8 : 16),
                      (n = s != this.pY),
                      (r = Math.abs(t.deltaY)))),
                (t.direction = i),
                n && r > e.threshold && i & e.direction
              );
            },
            attrTest: function (t) {
              return (
                zt.prototype.attrTest.call(this, t) &&
                (2 & this.state || (!(2 & this.state) && this.directionTest(t)))
              );
            },
            emit: function (t) {
              (this.pX = t.deltaX), (this.pY = t.deltaY);
              var e = It(t.direction);
              e && (t.additionalEvent = this.options.event + e),
                this._super.emit.call(this, t);
            },
          }),
          b(Lt, zt, {
            defaults: { event: "pinch", threshold: 0, pointers: 2 },
            getTouchAction: function () {
              return [Et];
            },
            attrTest: function (t) {
              return (
                this._super.attrTest.call(this, t) &&
                (Math.abs(t.scale - 1) > this.options.threshold ||
                  2 & this.state)
              );
            },
            emit: function (t) {
              if (1 !== t.scale) {
                var e = t.scale < 1 ? "in" : "out";
                t.additionalEvent = this.options.event + e;
              }
              this._super.emit.call(this, t);
            },
          }),
          b(Ft, Ot, {
            defaults: { event: "press", pointers: 1, time: 251, threshold: 9 },
            getTouchAction: function () {
              return [wt];
            },
            process: function (t) {
              var e = this.options,
                n = t.pointers.length === e.pointers,
                r = t.distance < e.threshold,
                i = t.deltaTime > e.time;
              if (((this._input = t), !r || !n || (12 & t.eventType && !i)))
                this.reset();
              else if (1 & t.eventType)
                this.reset(),
                  (this._timer = f(
                    function () {
                      (this.state = 8), this.tryEmit();
                    },
                    e.time,
                    this
                  ));
              else if (4 & t.eventType) return 8;
              return Mt;
            },
            reset: function () {
              clearTimeout(this._timer);
            },
            emit: function (t) {
              8 === this.state &&
                (t && 4 & t.eventType
                  ? this.manager.emit(this.options.event + "up", t)
                  : ((this._input.timeStamp = d()),
                    this.manager.emit(this.options.event, this._input)));
            },
          }),
          b(Bt, zt, {
            defaults: { event: "rotate", threshold: 0, pointers: 2 },
            getTouchAction: function () {
              return [Et];
            },
            attrTest: function (t) {
              return (
                this._super.attrTest.call(this, t) &&
                (Math.abs(t.rotation) > this.options.threshold ||
                  2 & this.state)
              );
            },
          }),
          b(Nt, zt, {
            defaults: {
              event: "swipe",
              threshold: 10,
              velocity: 0.3,
              direction: 30,
              pointers: 1,
            },
            getTouchAction: function () {
              return Rt.prototype.getTouchAction.call(this);
            },
            attrTest: function (t) {
              var e,
                n = this.options.direction;
              return (
                30 & n
                  ? (e = t.overallVelocity)
                  : 6 & n
                  ? (e = t.overallVelocityX)
                  : n & j && (e = t.overallVelocityY),
                this._super.attrTest.call(this, t) &&
                  n & t.offsetDirection &&
                  t.distance > this.options.threshold &&
                  t.maxPointers == this.options.pointers &&
                  p(e) > this.options.velocity &&
                  4 & t.eventType
              );
            },
            emit: function (t) {
              var e = It(t.offsetDirection);
              e && this.manager.emit(this.options.event + e, t),
                this.manager.emit(this.options.event, t);
            },
          }),
          b(jt, Ot, {
            defaults: {
              event: "tap",
              pointers: 1,
              taps: 1,
              interval: 300,
              time: 250,
              threshold: 9,
              posThreshold: 10,
            },
            getTouchAction: function () {
              return [St];
            },
            process: function (t) {
              var e = this.options,
                n = t.pointers.length === e.pointers,
                r = t.distance < e.threshold,
                i = t.deltaTime < e.time;
              if ((this.reset(), 1 & t.eventType && 0 === this.count))
                return this.failTimeout();
              if (r && i && n) {
                if (4 != t.eventType) return this.failTimeout();
                var o = !this.pTime || t.timeStamp - this.pTime < e.interval,
                  s =
                    !this.pCenter || X(this.pCenter, t.center) < e.posThreshold;
                if (
                  ((this.pTime = t.timeStamp),
                  (this.pCenter = t.center),
                  s && o ? (this.count += 1) : (this.count = 1),
                  (this._input = t),
                  0 === this.count % e.taps)
                )
                  return this.hasRequireFailures()
                    ? ((this._timer = f(
                        function () {
                          (this.state = 8), this.tryEmit();
                        },
                        e.interval,
                        this
                      )),
                      2)
                    : 8;
              }
              return Mt;
            },
            failTimeout: function () {
              return (
                (this._timer = f(
                  function () {
                    this.state = Mt;
                  },
                  this.options.interval,
                  this
                )),
                Mt
              );
            },
            reset: function () {
              clearTimeout(this._timer);
            },
            emit: function () {
              8 == this.state &&
                ((this._input.tapCount = this.count),
                this.manager.emit(this.options.event, this._input));
            },
          }),
          (Ut.VERSION = "2.0.7"),
          (Ut.defaults = {
            domEvents: !1,
            touchAction: xt,
            enable: !0,
            inputTarget: null,
            inputClass: null,
            preset: [
              [Bt, { enable: !1 }],
              [Lt, { enable: !1 }, ["rotate"]],
              [Nt, { direction: 6 }],
              [Rt, { direction: 6 }, ["swipe"]],
              [jt],
              [jt, { event: "doubletap", taps: 2 }, ["tap"]],
              [Ft],
            ],
            cssProps: {
              userSelect: "none",
              touchSelect: "none",
              touchCallout: "none",
              contentZooming: "none",
              userDrag: "none",
              tapHighlightColor: "rgba(0,0,0,0)",
            },
          });
        function Zt(t, e) {
          var n;
          (this.options = l({}, Ut.defaults, e || {})),
            (this.options.inputTarget = this.options.inputTarget || t),
            (this.handlers = {}),
            (this.session = {}),
            (this.recognizers = []),
            (this.oldCssProps = {}),
            (this.element = t),
            (this.input = new ((n = this).options.inputClass ||
              (L ? ot : F ? dt : R ? mt : tt))(n, q)),
            (this.touchAction = new Pt(this, this.options.touchAction)),
            Vt(this, !0),
            g(
              this.options.recognizers,
              function (t) {
                var e = this.add(new t[0](t[1]));
                t[2] && e.recognizeWith(t[2]), t[3] && e.requireFailure(t[3]);
              },
              this
            );
        }
        function Vt(t, e) {
          var n,
            r = t.element;
          r.style &&
            (g(t.options.cssProps, function (i, o) {
              (n = I(r.style, o)),
                e
                  ? ((t.oldCssProps[n] = r.style[n]), (r.style[n] = i))
                  : (r.style[n] = t.oldCssProps[n] || "");
            }),
            e || (t.oldCssProps = {}));
        }
        (Zt.prototype = {
          set: function (t) {
            return (
              l(this.options, t),
              t.touchAction && this.touchAction.update(),
              t.inputTarget &&
                (this.input.destroy(),
                (this.input.target = t.inputTarget),
                this.input.init()),
              this
            );
          },
          stop: function (t) {
            this.session.stopped = t ? 2 : 1;
          },
          recognize: function (t) {
            var e = this.session;
            if (!e.stopped) {
              var n;
              this.touchAction.preventDefaults(t);
              var r = this.recognizers,
                i = e.curRecognizer;
              (!i || (i && 8 & i.state)) && (i = e.curRecognizer = null);
              for (var o = 0; o < r.length; )
                (n = r[o]),
                  2 === e.stopped || (i && n != i && !n.canRecognizeWith(i))
                    ? n.reset()
                    : n.recognize(t),
                  !i && 14 & n.state && (i = e.curRecognizer = n),
                  o++;
            }
          },
          get: function (t) {
            if (t instanceof Ot) return t;
            for (var e = this.recognizers, n = 0; n < e.length; n++)
              if (e[n].options.event == t) return e[n];
            return null;
          },
          add: function (t) {
            if (m(t, "add", this)) return this;
            var e = this.get(t.options.event);
            return (
              e && this.remove(e),
              this.recognizers.push(t),
              (t.manager = this),
              this.touchAction.update(),
              t
            );
          },
          remove: function (t) {
            if (m(t, "remove", this)) return this;
            if ((t = this.get(t))) {
              var e = this.recognizers,
                n = M(e, t);
              -1 !== n && (e.splice(n, 1), this.touchAction.update());
            }
            return this;
          },
          on: function (t, e) {
            if (t !== a && e !== a) {
              var n = this.handlers;
              return (
                g(P(t), function (t) {
                  (n[t] = n[t] || []), n[t].push(e);
                }),
                this
              );
            }
          },
          off: function (t, e) {
            if (t !== a) {
              var n = this.handlers;
              return (
                g(P(t), function (t) {
                  e ? n[t] && n[t].splice(M(n[t], e), 1) : delete n[t];
                }),
                this
              );
            }
          },
          emit: function (t, e) {
            this.options.domEvents &&
              (function (t, e) {
                var n = o.createEvent("Event");
                n.initEvent(t, !0, !0),
                  (n.gesture = e),
                  e.target.dispatchEvent(n);
              })(t, e);
            var n = this.handlers[t] && this.handlers[t].slice();
            if (n && n.length) {
              (e.type = t),
                (e.preventDefault = function () {
                  e.srcEvent.preventDefault();
                });
              for (var r = 0; r < n.length; ) n[r](e), r++;
            }
          },
          destroy: function () {
            this.element && Vt(this, !1),
              (this.handlers = {}),
              (this.session = {}),
              this.input.destroy(),
              (this.element = null);
          },
        }),
          l(Ut, {
            INPUT_START: 1,
            INPUT_MOVE: 2,
            INPUT_END: 4,
            INPUT_CANCEL: 8,
            STATE_POSSIBLE: 1,
            STATE_BEGAN: 2,
            STATE_CHANGED: 4,
            STATE_ENDED: 8,
            STATE_RECOGNIZED: 8,
            STATE_CANCELLED: 16,
            STATE_FAILED: Mt,
            DIRECTION_NONE: 1,
            DIRECTION_LEFT: 2,
            DIRECTION_RIGHT: 4,
            DIRECTION_UP: 8,
            DIRECTION_DOWN: 16,
            DIRECTION_HORIZONTAL: 6,
            DIRECTION_VERTICAL: j,
            DIRECTION_ALL: 30,
            Manager: Zt,
            Input: V,
            TouchAction: Pt,
            TouchInput: dt,
            MouseInput: tt,
            PointerEventInput: ot,
            TouchMouseInput: mt,
            SingleTouchInput: ct,
            Recognizer: Ot,
            AttrRecognizer: zt,
            Tap: jt,
            Pan: Rt,
            Swipe: Nt,
            Pinch: Lt,
            Rotate: Bt,
            Press: Ft,
            on: E,
            off: T,
            each: g,
            merge: v,
            extend: _,
            assign: l,
            inherit: b,
            bindFn: x,
            prefixed: I,
          }),
          (("undefined" !== typeof i
            ? i
            : "undefined" !== typeof self
            ? self
            : {}
          ).Hammer = Ut),
          (r = function () {
            return Ut;
          }.call(e, n, e, t)) === a || (t.exports = r);
      })(window, document);
    },
    41405: function (t, e, n) {
      "use strict";
      var r = "undefined" !== typeof Symbol && Symbol,
        i = n(55419);
      t.exports = function () {
        return (
          "function" === typeof r &&
          "function" === typeof Symbol &&
          "symbol" === typeof r("foo") &&
          "symbol" === typeof Symbol("bar") &&
          i()
        );
      };
    },
    55419: function (t) {
      "use strict";
      t.exports = function () {
        if (
          "function" !== typeof Symbol ||
          "function" !== typeof Object.getOwnPropertySymbols
        )
          return !1;
        if ("symbol" === typeof Symbol.iterator) return !0;
        var t = {},
          e = Symbol("test"),
          n = Object(e);
        if ("string" === typeof e) return !1;
        if ("[object Symbol]" !== Object.prototype.toString.call(e)) return !1;
        if ("[object Symbol]" !== Object.prototype.toString.call(n)) return !1;
        for (e in ((t[e] = 42), t)) return !1;
        if ("function" === typeof Object.keys && 0 !== Object.keys(t).length)
          return !1;
        if (
          "function" === typeof Object.getOwnPropertyNames &&
          0 !== Object.getOwnPropertyNames(t).length
        )
          return !1;
        var r = Object.getOwnPropertySymbols(t);
        if (1 !== r.length || r[0] !== e) return !1;
        if (!Object.prototype.propertyIsEnumerable.call(t, e)) return !1;
        if ("function" === typeof Object.getOwnPropertyDescriptor) {
          var i = Object.getOwnPropertyDescriptor(t, e);
          if (42 !== i.value || !0 !== i.enumerable) return !1;
        }
        return !0;
      };
    },
    17642: function (t, e, n) {
      "use strict";
      var r = n(58612);
      t.exports = r.call(Function.call, Object.prototype.hasOwnProperty);
    },
    8679: function (t, e, n) {
      "use strict";
      var r = n(59864),
        i = {
          childContextTypes: !0,
          contextType: !0,
          contextTypes: !0,
          defaultProps: !0,
          displayName: !0,
          getDefaultProps: !0,
          getDerivedStateFromError: !0,
          getDerivedStateFromProps: !0,
          mixins: !0,
          propTypes: !0,
          type: !0,
        },
        o = {
          name: !0,
          length: !0,
          prototype: !0,
          caller: !0,
          callee: !0,
          arguments: !0,
          arity: !0,
        },
        s = {
          $$typeof: !0,
          compare: !0,
          defaultProps: !0,
          displayName: !0,
          propTypes: !0,
          type: !0,
        },
        a = {};
      function l(t) {
        return r.isMemo(t) ? s : a[t.$$typeof] || i;
      }
      (a[r.ForwardRef] = {
        $$typeof: !0,
        render: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0,
      }),
        (a[r.Memo] = s);
      var c = Object.defineProperty,
        u = Object.getOwnPropertyNames,
        h = Object.getOwnPropertySymbols,
        p = Object.getOwnPropertyDescriptor,
        d = Object.getPrototypeOf,
        f = Object.prototype;
      t.exports = function t(e, n, r) {
        if ("string" !== typeof n) {
          if (f) {
            var i = d(n);
            i && i !== f && t(e, i, r);
          }
          var s = u(n);
          h && (s = s.concat(h(n)));
          for (var a = l(e), m = l(n), g = 0; g < s.length; ++g) {
            var y = s[g];
            if (!o[y] && (!r || !r[y]) && (!m || !m[y]) && (!a || !a[y])) {
              var _ = p(n, y);
              try {
                c(e, y, _);
              } catch (v) {}
            }
          }
        }
        return e;
      };
    },
    48738: function (t) {
      function e(t) {
        return (
          !!t.constructor &&
          "function" === typeof t.constructor.isBuffer &&
          t.constructor.isBuffer(t)
        );
      }
      t.exports = function (t) {
        return (
          null != t &&
          (e(t) ||
            (function (t) {
              return (
                "function" === typeof t.readFloatLE &&
                "function" === typeof t.slice &&
                e(t.slice(0, 0))
              );
            })(t) ||
            !!t._isBuffer)
        );
      };
    },
    6158: function (t, e, n) {
      var r = n(34155);
      t.exports = (function () {
        "use strict";
        var t, e, n;
        function i(r, i) {
          if (t)
            if (e) {
              var o =
                  "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/api/#transpiling-v2'); }; var sharedChunk = {}; (" +
                  t +
                  ")(sharedChunk); (" +
                  e +
                  ")(sharedChunk); self.onerror = null;",
                s = {};
              t(s),
                (n = i(s)),
                "undefined" !== typeof window &&
                  (n.workerUrl = window.URL.createObjectURL(
                    new Blob([o], { type: "text/javascript" })
                  ));
            } else e = i;
          else t = i;
        }
        return (
          i(["exports"], function (t) {
            var e = "2.4.1",
              n = i;
            function i(t, e, n, r) {
              (this.cx = 3 * t),
                (this.bx = 3 * (n - t) - this.cx),
                (this.ax = 1 - this.cx - this.bx),
                (this.cy = 3 * e),
                (this.by = 3 * (r - e) - this.cy),
                (this.ay = 1 - this.cy - this.by),
                (this.p1x = t),
                (this.p1y = r),
                (this.p2x = n),
                (this.p2y = r);
            }
            (i.prototype.sampleCurveX = function (t) {
              return ((this.ax * t + this.bx) * t + this.cx) * t;
            }),
              (i.prototype.sampleCurveY = function (t) {
                return ((this.ay * t + this.by) * t + this.cy) * t;
              }),
              (i.prototype.sampleCurveDerivativeX = function (t) {
                return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
              }),
              (i.prototype.solveCurveX = function (t, e) {
                var n, r, i, o, s;
                for (void 0 === e && (e = 1e-6), i = t, s = 0; s < 8; s++) {
                  if (((o = this.sampleCurveX(i) - t), Math.abs(o) < e))
                    return i;
                  var a = this.sampleCurveDerivativeX(i);
                  if (Math.abs(a) < 1e-6) break;
                  i -= o / a;
                }
                if ((i = t) < (n = 0)) return n;
                if (i > (r = 1)) return r;
                for (; n < r; ) {
                  if (((o = this.sampleCurveX(i)), Math.abs(o - t) < e))
                    return i;
                  t > o ? (n = i) : (r = i), (i = 0.5 * (r - n) + n);
                }
                return i;
              }),
              (i.prototype.solve = function (t, e) {
                return this.sampleCurveY(this.solveCurveX(t, e));
              });
            var o = s;
            function s(t, e) {
              (this.x = t), (this.y = e);
            }
            (s.prototype = {
              clone: function () {
                return new s(this.x, this.y);
              },
              add: function (t) {
                return this.clone()._add(t);
              },
              sub: function (t) {
                return this.clone()._sub(t);
              },
              multByPoint: function (t) {
                return this.clone()._multByPoint(t);
              },
              divByPoint: function (t) {
                return this.clone()._divByPoint(t);
              },
              mult: function (t) {
                return this.clone()._mult(t);
              },
              div: function (t) {
                return this.clone()._div(t);
              },
              rotate: function (t) {
                return this.clone()._rotate(t);
              },
              rotateAround: function (t, e) {
                return this.clone()._rotateAround(t, e);
              },
              matMult: function (t) {
                return this.clone()._matMult(t);
              },
              unit: function () {
                return this.clone()._unit();
              },
              perp: function () {
                return this.clone()._perp();
              },
              round: function () {
                return this.clone()._round();
              },
              mag: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y);
              },
              equals: function (t) {
                return this.x === t.x && this.y === t.y;
              },
              dist: function (t) {
                return Math.sqrt(this.distSqr(t));
              },
              distSqr: function (t) {
                var e = t.x - this.x,
                  n = t.y - this.y;
                return e * e + n * n;
              },
              angle: function () {
                return Math.atan2(this.y, this.x);
              },
              angleTo: function (t) {
                return Math.atan2(this.y - t.y, this.x - t.x);
              },
              angleWith: function (t) {
                return this.angleWithSep(t.x, t.y);
              },
              angleWithSep: function (t, e) {
                return Math.atan2(
                  this.x * e - this.y * t,
                  this.x * t + this.y * e
                );
              },
              _matMult: function (t) {
                var e = t[2] * this.x + t[3] * this.y;
                return (
                  (this.x = t[0] * this.x + t[1] * this.y), (this.y = e), this
                );
              },
              _add: function (t) {
                return (this.x += t.x), (this.y += t.y), this;
              },
              _sub: function (t) {
                return (this.x -= t.x), (this.y -= t.y), this;
              },
              _mult: function (t) {
                return (this.x *= t), (this.y *= t), this;
              },
              _div: function (t) {
                return (this.x /= t), (this.y /= t), this;
              },
              _multByPoint: function (t) {
                return (this.x *= t.x), (this.y *= t.y), this;
              },
              _divByPoint: function (t) {
                return (this.x /= t.x), (this.y /= t.y), this;
              },
              _unit: function () {
                return this._div(this.mag()), this;
              },
              _perp: function () {
                var t = this.y;
                return (this.y = this.x), (this.x = -t), this;
              },
              _rotate: function (t) {
                var e = Math.cos(t),
                  n = Math.sin(t),
                  r = n * this.x + e * this.y;
                return (this.x = e * this.x - n * this.y), (this.y = r), this;
              },
              _rotateAround: function (t, e) {
                var n = Math.cos(t),
                  r = Math.sin(t),
                  i = e.y + r * (this.x - e.x) + n * (this.y - e.y);
                return (
                  (this.x = e.x + n * (this.x - e.x) - r * (this.y - e.y)),
                  (this.y = i),
                  this
                );
              },
              _round: function () {
                return (
                  (this.x = Math.round(this.x)),
                  (this.y = Math.round(this.y)),
                  this
                );
              },
            }),
              (s.convert = function (t) {
                return t instanceof s
                  ? t
                  : Array.isArray(t)
                  ? new s(t[0], t[1])
                  : t;
              });
            var a = "undefined" != typeof self ? self : {};
            const l = Math.pow(2, 53) - 1,
              c = Math.PI / 180,
              u = 180 / Math.PI;
            function h(t) {
              return t * c;
            }
            const p = [
              [0, 0],
              [1, 0],
              [1, 1],
              [0, 1],
            ];
            function d(t) {
              if (t <= 0) return 0;
              if (t >= 1) return 1;
              const e = t * t,
                n = e * t;
              return 4 * (t < 0.5 ? n : 3 * (t - e) + n - 0.75);
            }
            function f(t, e, r, i) {
              const o = new n(t, e, r, i);
              return function (t) {
                return o.solve(t);
              };
            }
            const m = f(0.25, 0.1, 0.25, 1);
            function g(t, e, n) {
              return Math.min(n, Math.max(e, t));
            }
            function y(t, e, n) {
              const r = n - e,
                i = ((((t - e) % r) + r) % r) + e;
              return i === e ? n : i;
            }
            function _(t, e, n) {
              if (!t.length) return n(null, []);
              let r = t.length;
              const i = new Array(t.length);
              let o = null;
              t.forEach((t, s) => {
                e(t, (t, e) => {
                  t && (o = t), (i[s] = e), 0 == --r && n(o, i);
                });
              });
            }
            function v(t) {
              const e = [];
              for (const n in t) e.push(t[n]);
              return e;
            }
            function b(t, ...e) {
              for (const n of e) for (const e in n) t[e] = n[e];
              return t;
            }
            let x = 1;
            function w() {
              return x++;
            }
            function S() {
              return (function t(e) {
                return e
                  ? (e ^ ((16 * Math.random()) >> (e / 4))).toString(16)
                  : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t);
              })();
            }
            function E(t) {
              return t <= 1
                ? 1
                : Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
            }
            function T(t) {
              return (
                !!t &&
                /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(
                  t
                )
              );
            }
            function A(t, e) {
              t.forEach((t) => {
                e[t] && (e[t] = e[t].bind(e));
              });
            }
            function C(t, e) {
              return -1 !== t.indexOf(e, t.length - e.length);
            }
            function P(t, e, n) {
              const r = {};
              for (const i in t) r[i] = e.call(n || this, t[i], i, t);
              return r;
            }
            function M(t, e, n) {
              const r = {};
              for (const i in t) e.call(n || this, t[i], i, t) && (r[i] = t[i]);
              return r;
            }
            function O(t) {
              return Array.isArray(t)
                ? t.map(O)
                : "object" == typeof t && t
                ? P(t, O)
                : t;
            }
            const k = {};
            function I(t) {
              k[t] ||
                ("undefined" != typeof console && console.warn(t), (k[t] = !0));
            }
            function D(t, e, n) {
              return (n.y - t.y) * (e.x - t.x) > (e.y - t.y) * (n.x - t.x);
            }
            function z(t) {
              let e = 0;
              for (let n, r, i = 0, o = t.length, s = o - 1; i < o; s = i++)
                (n = t[i]), (r = t[s]), (e += (r.x - n.x) * (n.y + r.y));
              return e;
            }
            function R() {
              return (
                "undefined" != typeof WorkerGlobalScope &&
                "undefined" != typeof self &&
                self instanceof WorkerGlobalScope
              );
            }
            function L(t) {
              const e = {};
              if (
                (t.replace(
                  /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g,
                  (t, n, r, i) => {
                    const o = r || i;
                    return (e[n] = !o || o.toLowerCase()), "";
                  }
                ),
                e["max-age"])
              ) {
                const t = parseInt(e["max-age"], 10);
                isNaN(t) ? delete e["max-age"] : (e["max-age"] = t);
              }
              return e;
            }
            let F,
              B,
              N,
              j = null;
            function U(t) {
              if (null == j) {
                const e = t.navigator ? t.navigator.userAgent : null;
                j =
                  !!t.safari ||
                  !(
                    !e ||
                    !(
                      /\b(iPad|iPhone|iPod)\b/.test(e) ||
                      (e.match("Safari") && !e.match("Chrome"))
                    )
                  );
              }
              return j;
            }
            function Z(t) {
              try {
                const e = a[t];
                return (
                  e.setItem("_mapbox_test_", 1),
                  e.removeItem("_mapbox_test_"),
                  !0
                );
              } catch (t) {
                return !1;
              }
            }
            const V = {
              now: () => (void 0 !== N ? N : a.performance.now()),
              setNow(t) {
                N = t;
              },
              restoreNow() {
                N = void 0;
              },
              frame(t) {
                const e = a.requestAnimationFrame(t);
                return { cancel: () => a.cancelAnimationFrame(e) };
              },
              getImageData(t, e = 0) {
                const n = a.document.createElement("canvas"),
                  r = n.getContext("2d");
                if (!r) throw new Error("failed to create canvas 2d context");
                return (
                  (n.width = t.width),
                  (n.height = t.height),
                  r.drawImage(t, 0, 0, t.width, t.height),
                  r.getImageData(-e, -e, t.width + 2 * e, t.height + 2 * e)
                );
              },
              resolveURL: (t) => (
                F || (F = a.document.createElement("a")), (F.href = t), F.href
              ),
              get devicePixelRatio() {
                return a.devicePixelRatio;
              },
              get prefersReducedMotion() {
                return (
                  !!a.matchMedia &&
                  (null == B &&
                    (B = a.matchMedia("(prefers-reduced-motion: reduce)")),
                  B.matches)
                );
              },
            };
            let q;
            const $ = {
                API_URL: "https://api.mapbox.com",
                get API_URL_REGEX() {
                  if (null == q) {
                    const t =
                      /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
                    try {
                      q =
                        null != r.env.API_URL_REGEX
                          ? new RegExp(r.env.API_URL_REGEX)
                          : t;
                    } catch (e) {
                      q = t;
                    }
                  }
                  return q;
                },
                get EVENTS_URL() {
                  return this.API_URL
                    ? 0 === this.API_URL.indexOf("https://api.mapbox.cn")
                      ? "https://events.mapbox.cn/events/v2"
                      : 0 === this.API_URL.indexOf("https://api.mapbox.com")
                      ? "https://events.mapbox.com/events/v2"
                      : null
                    : null;
                },
                SESSION_PATH: "/map-sessions/v1",
                FEEDBACK_URL: "https://apps.mapbox.com/feedback",
                TILE_URL_VERSION: "v4",
                RASTER_URL_PREFIX: "raster/v1",
                REQUIRE_ACCESS_TOKEN: !0,
                ACCESS_TOKEN: null,
                MAX_PARALLEL_IMAGE_REQUESTS: 16,
              },
              G = {
                supported: !1,
                testSupport: function (t) {
                  !X && H && (K ? Y(t) : (W = t));
                },
              };
            let W,
              H,
              X = !1,
              K = !1;
            function Y(t) {
              const e = t.createTexture();
              t.bindTexture(t.TEXTURE_2D, e);
              try {
                if (
                  (t.texImage2D(
                    t.TEXTURE_2D,
                    0,
                    t.RGBA,
                    t.RGBA,
                    t.UNSIGNED_BYTE,
                    H
                  ),
                  t.isContextLost())
                )
                  return;
                G.supported = !0;
              } catch (t) {}
              t.deleteTexture(e), (X = !0);
            }
            a.document &&
              ((H = a.document.createElement("img")),
              (H.onload = function () {
                W && Y(W), (W = null), (K = !0);
              }),
              (H.onerror = function () {
                (X = !0), (W = null);
              }),
              (H.src =
                "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="));
            const Q = "01",
              J = "NO_ACCESS_TOKEN";
            function tt(t) {
              return 0 === t.indexOf("mapbox:");
            }
            function et(t) {
              return $.API_URL_REGEX.test(t);
            }
            const nt = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
            function rt(t) {
              const e = t.match(nt);
              if (!e) throw new Error("Unable to parse URL object");
              return {
                protocol: e[1],
                authority: e[2],
                path: e[3] || "/",
                params: e[4] ? e[4].split("&") : [],
              };
            }
            function it(t) {
              const e = t.params.length ? `?${t.params.join("&")}` : "";
              return `${t.protocol}://${t.authority}${t.path}${e}`;
            }
            function ot(t) {
              if (!t) return null;
              const e = t.split(".");
              if (!e || 3 !== e.length) return null;
              try {
                return JSON.parse(
                  decodeURIComponent(
                    a
                      .atob(e[1])
                      .split("")
                      .map(
                        (t) =>
                          "%" + ("00" + t.charCodeAt(0).toString(16)).slice(-2)
                      )
                      .join("")
                  )
                );
              } catch (t) {
                return null;
              }
            }
            class st {
              constructor(t) {
                (this.type = t),
                  (this.anonId = null),
                  (this.eventData = {}),
                  (this.queue = []),
                  (this.pendingRequest = null);
              }
              getStorageKey(t) {
                const e = ot($.ACCESS_TOKEN);
                let n = "";
                return (
                  (n =
                    e && e.u
                      ? a.btoa(
                          encodeURIComponent(e.u).replace(
                            /%([0-9A-F]{2})/g,
                            (t, e) => String.fromCharCode(Number("0x" + e))
                          )
                        )
                      : $.ACCESS_TOKEN || ""),
                  t ? `mapbox.eventData.${t}:${n}` : `mapbox.eventData:${n}`
                );
              }
              fetchEventData() {
                const t = Z("localStorage"),
                  e = this.getStorageKey(),
                  n = this.getStorageKey("uuid");
                if (t)
                  try {
                    const t = a.localStorage.getItem(e);
                    t && (this.eventData = JSON.parse(t));
                    const r = a.localStorage.getItem(n);
                    r && (this.anonId = r);
                  } catch (t) {
                    I("Unable to read from LocalStorage");
                  }
              }
              saveEventData() {
                const t = Z("localStorage"),
                  e = this.getStorageKey(),
                  n = this.getStorageKey("uuid");
                if (t)
                  try {
                    a.localStorage.setItem(n, this.anonId),
                      Object.keys(this.eventData).length >= 1 &&
                        a.localStorage.setItem(
                          e,
                          JSON.stringify(this.eventData)
                        );
                  } catch (t) {
                    I("Unable to write to LocalStorage");
                  }
              }
              processRequests(t) {}
              postEvent(t, n, r, i) {
                if (!$.EVENTS_URL) return;
                const o = rt($.EVENTS_URL);
                o.params.push(`access_token=${i || $.ACCESS_TOKEN || ""}`);
                const s = {
                    event: this.type,
                    created: new Date(t).toISOString(),
                    sdkIdentifier: "mapbox-gl-js",
                    sdkVersion: e,
                    skuId: Q,
                    userId: this.anonId,
                  },
                  a = n ? b(s, n) : s,
                  l = {
                    url: it(o),
                    headers: { "Content-Type": "text/plain" },
                    body: JSON.stringify([a]),
                  };
                this.pendingRequest = Ct(l, (t) => {
                  (this.pendingRequest = null),
                    r(t),
                    this.saveEventData(),
                    this.processRequests(i);
                });
              }
              queueRequest(t, e) {
                this.queue.push(t), this.processRequests(e);
              }
            }
            const at = new (class extends st {
                constructor(t) {
                  super("appUserTurnstile"), (this._customAccessToken = t);
                }
                postTurnstileEvent(t, e) {
                  $.EVENTS_URL &&
                    $.ACCESS_TOKEN &&
                    Array.isArray(t) &&
                    t.some((t) => tt(t) || et(t)) &&
                    this.queueRequest(Date.now(), e);
                }
                processRequests(t) {
                  if (this.pendingRequest || 0 === this.queue.length) return;
                  (this.anonId &&
                    this.eventData.lastSuccess &&
                    this.eventData.tokenU) ||
                    this.fetchEventData();
                  const e = ot($.ACCESS_TOKEN),
                    n = e ? e.u : $.ACCESS_TOKEN;
                  let r = n !== this.eventData.tokenU;
                  T(this.anonId) || ((this.anonId = S()), (r = !0));
                  const i = this.queue.shift();
                  if (this.eventData.lastSuccess) {
                    const t = new Date(this.eventData.lastSuccess),
                      e = new Date(i),
                      n = (i - this.eventData.lastSuccess) / 864e5;
                    r = r || n >= 1 || n < -1 || t.getDate() !== e.getDate();
                  } else r = !0;
                  if (!r) return this.processRequests();
                  this.postEvent(
                    i,
                    { "enabled.telemetry": !1 },
                    (t) => {
                      t ||
                        ((this.eventData.lastSuccess = i),
                        (this.eventData.tokenU = n));
                    },
                    t
                  );
                }
              })(),
              lt = at.postTurnstileEvent.bind(at),
              ct = new (class extends st {
                constructor() {
                  super("map.load"), (this.success = {}), (this.skuToken = "");
                }
                postMapLoadEvent(t, e, n, r) {
                  (this.skuToken = e),
                    (this.errorCb = r),
                    $.EVENTS_URL &&
                      (n || $.ACCESS_TOKEN
                        ? this.queueRequest({ id: t, timestamp: Date.now() }, n)
                        : this.errorCb(new Error(J)));
                }
                processRequests(t) {
                  if (this.pendingRequest || 0 === this.queue.length) return;
                  const { id: e, timestamp: n } = this.queue.shift();
                  (e && this.success[e]) ||
                    (this.anonId || this.fetchEventData(),
                    T(this.anonId) || (this.anonId = S()),
                    this.postEvent(
                      n,
                      { skuToken: this.skuToken },
                      (t) => {
                        t ? this.errorCb(t) : e && (this.success[e] = !0);
                      },
                      t
                    ));
                }
              })(),
              ut = ct.postMapLoadEvent.bind(ct),
              ht = new (class extends st {
                constructor() {
                  super("map.auth"), (this.success = {}), (this.skuToken = "");
                }
                getSession(t, e, n, r) {
                  if (!$.API_URL || !$.SESSION_PATH) return;
                  const i = rt($.API_URL + $.SESSION_PATH);
                  i.params.push(`sku=${e || ""}`),
                    i.params.push(`access_token=${r || $.ACCESS_TOKEN || ""}`);
                  const o = {
                    url: it(i),
                    headers: { "Content-Type": "text/plain" },
                  };
                  this.pendingRequest = Pt(o, (t) => {
                    (this.pendingRequest = null),
                      n(t),
                      this.saveEventData(),
                      this.processRequests(r);
                  });
                }
                getSessionAPI(t, e, n, r) {
                  (this.skuToken = e),
                    (this.errorCb = r),
                    $.SESSION_PATH &&
                      $.API_URL &&
                      (n || $.ACCESS_TOKEN
                        ? this.queueRequest({ id: t, timestamp: Date.now() }, n)
                        : this.errorCb(new Error(J)));
                }
                processRequests(t) {
                  if (this.pendingRequest || 0 === this.queue.length) return;
                  const { id: e, timestamp: n } = this.queue.shift();
                  (e && this.success[e]) ||
                    this.getSession(
                      n,
                      this.skuToken,
                      (t) => {
                        t ? this.errorCb(t) : e && (this.success[e] = !0);
                      },
                      t
                    );
                }
              })(),
              pt = ht.getSessionAPI.bind(ht),
              dt = new Set(),
              ft = "mapbox-tiles";
            let mt,
              gt,
              yt = 500,
              _t = 50;
            function vt() {
              a.caches && !mt && (mt = a.caches.open(ft));
            }
            function bt(t) {
              const e = t.indexOf("?");
              return e < 0 ? t : t.slice(0, e);
            }
            let xt = 1 / 0;
            const wt = {
              Unknown: "Unknown",
              Style: "Style",
              Source: "Source",
              Tile: "Tile",
              Glyphs: "Glyphs",
              SpriteImage: "SpriteImage",
              SpriteJSON: "SpriteJSON",
              Image: "Image",
            };
            "function" == typeof Object.freeze && Object.freeze(wt);
            class St extends Error {
              constructor(t, e, n) {
                401 === e &&
                  et(n) &&
                  (t +=
                    ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"),
                  super(t),
                  (this.status = e),
                  (this.url = n);
              }
              toString() {
                return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
              }
            }
            const Et = R()
                ? () => self.worker && self.worker.referrer
                : () =>
                    ("blob:" === a.location.protocol ? a.parent : a).location
                      .href,
              Tt = function (t, e) {
                if (
                  !(
                    /^file:/.test((n = t.url)) ||
                    (/^file:/.test(Et()) && !/^\w+:/.test(n))
                  )
                ) {
                  if (
                    a.fetch &&
                    a.Request &&
                    a.AbortController &&
                    a.Request.prototype.hasOwnProperty("signal")
                  )
                    return (function (t, e) {
                      const n = new a.AbortController(),
                        r = new a.Request(t.url, {
                          method: t.method || "GET",
                          body: t.body,
                          credentials: t.credentials,
                          headers: t.headers,
                          referrer: Et(),
                          signal: n.signal,
                        });
                      let i = !1,
                        o = !1;
                      const s = (l = r.url).indexOf("sku=") > 0 && et(l);
                      var l;
                      "json" === t.type &&
                        r.headers.set("Accept", "application/json");
                      const c = (n, i, l) => {
                          if (o) return;
                          if (
                            (n && "SecurityError" !== n.message && I(n), i && l)
                          )
                            return u(i);
                          const c = Date.now();
                          a.fetch(r)
                            .then((n) => {
                              if (n.ok) {
                                const t = s ? n.clone() : null;
                                return u(n, t, c);
                              }
                              return e(new St(n.statusText, n.status, t.url));
                            })
                            .catch((t) => {
                              20 !== t.code && e(new Error(t.message));
                            });
                        },
                        u = (n, s, l) => {
                          ("arrayBuffer" === t.type
                            ? n.arrayBuffer()
                            : "json" === t.type
                            ? n.json()
                            : n.text()
                          )
                            .then((t) => {
                              o ||
                                (s &&
                                  l &&
                                  (function (t, e, n) {
                                    if ((vt(), !mt)) return;
                                    const r = {
                                      status: e.status,
                                      statusText: e.statusText,
                                      headers: new a.Headers(),
                                    };
                                    e.headers.forEach((t, e) =>
                                      r.headers.set(e, t)
                                    );
                                    const i = L(
                                      e.headers.get("Cache-Control") || ""
                                    );
                                    i["no-store"] ||
                                      (i["max-age"] &&
                                        r.headers.set(
                                          "Expires",
                                          new Date(
                                            n + 1e3 * i["max-age"]
                                          ).toUTCString()
                                        ),
                                      new Date(
                                        r.headers.get("Expires")
                                      ).getTime() -
                                        n <
                                        42e4 ||
                                        (function (t, e) {
                                          if (void 0 === gt)
                                            try {
                                              new Response(
                                                new ReadableStream()
                                              ),
                                                (gt = !0);
                                            } catch (t) {
                                              gt = !1;
                                            }
                                          gt ? e(t.body) : t.blob().then(e);
                                        })(e, (e) => {
                                          const n = new a.Response(e, r);
                                          vt(),
                                            mt &&
                                              mt
                                                .then((e) =>
                                                  e.put(bt(t.url), n)
                                                )
                                                .catch((t) => I(t.message));
                                        }));
                                  })(r, s, l),
                                (i = !0),
                                e(
                                  null,
                                  t,
                                  n.headers.get("Cache-Control"),
                                  n.headers.get("Expires")
                                ));
                            })
                            .catch((t) => {
                              o || e(new Error(t.message));
                            });
                        };
                      return (
                        s
                          ? (function (t, e) {
                              if ((vt(), !mt)) return e(null);
                              const n = bt(t.url);
                              mt.then((t) => {
                                t.match(n)
                                  .then((r) => {
                                    const i = (function (t) {
                                      if (!t) return !1;
                                      const e = new Date(
                                          t.headers.get("Expires") || 0
                                        ),
                                        n = L(
                                          t.headers.get("Cache-Control") || ""
                                        );
                                      return e > Date.now() && !n["no-cache"];
                                    })(r);
                                    t.delete(n),
                                      i && t.put(n, r.clone()),
                                      e(null, r, i);
                                  })
                                  .catch(e);
                              }).catch(e);
                            })(r, c)
                          : c(null, null),
                        {
                          cancel: () => {
                            (o = !0), i || n.abort();
                          },
                        }
                      );
                    })(t, e);
                  if (R() && self.worker && self.worker.actor)
                    return self.worker.actor.send(
                      "getResource",
                      t,
                      e,
                      void 0,
                      !0
                    );
                }
                var n;
                return (function (t, e) {
                  const n = new a.XMLHttpRequest();
                  n.open(t.method || "GET", t.url, !0),
                    "arrayBuffer" === t.type &&
                      (n.responseType = "arraybuffer");
                  for (const r in t.headers)
                    n.setRequestHeader(r, t.headers[r]);
                  return (
                    "json" === t.type &&
                      ((n.responseType = "text"),
                      n.setRequestHeader("Accept", "application/json")),
                    (n.withCredentials = "include" === t.credentials),
                    (n.onerror = () => {
                      e(new Error(n.statusText));
                    }),
                    (n.onload = () => {
                      if (
                        ((n.status >= 200 && n.status < 300) ||
                          0 === n.status) &&
                        null !== n.response
                      ) {
                        let r = n.response;
                        if ("json" === t.type)
                          try {
                            r = JSON.parse(n.response);
                          } catch (t) {
                            return e(t);
                          }
                        e(
                          null,
                          r,
                          n.getResponseHeader("Cache-Control"),
                          n.getResponseHeader("Expires")
                        );
                      } else e(new St(n.statusText, n.status, t.url));
                    }),
                    n.send(t.body),
                    { cancel: () => n.abort() }
                  );
                })(t, e);
              },
              At = function (t, e) {
                return Tt(b(t, { type: "arrayBuffer" }), e);
              },
              Ct = function (t, e) {
                return Tt(b(t, { method: "POST" }), e);
              },
              Pt = function (t, e) {
                return Tt(b(t, { method: "GET" }), e);
              };
            function Mt(t) {
              const e = a.document.createElement("a");
              return (
                (e.href = t),
                e.protocol === a.document.location.protocol &&
                  e.host === a.document.location.host
              );
            }
            const Ot =
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
            let kt, It;
            (kt = []), (It = 0);
            const Dt = function (t, e) {
              if (
                (G.supported &&
                  (t.headers || (t.headers = {}),
                  (t.headers.accept = "image/webp,*/*")),
                It >= $.MAX_PARALLEL_IMAGE_REQUESTS)
              ) {
                const n = {
                  requestParameters: t,
                  callback: e,
                  cancelled: !1,
                  cancel() {
                    this.cancelled = !0;
                  },
                };
                return kt.push(n), n;
              }
              It++;
              let n = !1;
              const r = () => {
                  if (!n)
                    for (
                      n = !0, It--;
                      kt.length && It < $.MAX_PARALLEL_IMAGE_REQUESTS;

                    ) {
                      const t = kt.shift(),
                        { requestParameters: e, callback: n, cancelled: r } = t;
                      r || (t.cancel = Dt(e, n).cancel);
                    }
                },
                i = At(t, (t, n, i, o) => {
                  r(),
                    t
                      ? e(t)
                      : n &&
                        (a.createImageBitmap
                          ? (function (t, e) {
                              const n = new a.Blob([new Uint8Array(t)], {
                                type: "image/png",
                              });
                              a.createImageBitmap(n)
                                .then((t) => {
                                  e(null, t);
                                })
                                .catch((t) => {
                                  e(
                                    new Error(
                                      `Could not load image because of ${t.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`
                                    )
                                  );
                                });
                            })(n, (t, n) => e(t, n, i, o))
                          : (function (t, e) {
                              const n = new a.Image(),
                                r = a.URL;
                              (n.onload = () => {
                                e(null, n),
                                  r.revokeObjectURL(n.src),
                                  (n.onload = null),
                                  a.requestAnimationFrame(() => {
                                    n.src = Ot;
                                  });
                              }),
                                (n.onerror = () =>
                                  e(
                                    new Error(
                                      "Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."
                                    )
                                  ));
                              const i = new a.Blob([new Uint8Array(t)], {
                                type: "image/png",
                              });
                              n.src = t.byteLength ? r.createObjectURL(i) : Ot;
                            })(n, (t, n) => e(t, n, i, o)));
                });
              return {
                cancel: () => {
                  i.cancel(), r();
                },
              };
            };
            function zt(t, e, n) {
              (n[t] && -1 !== n[t].indexOf(e)) ||
                ((n[t] = n[t] || []), n[t].push(e));
            }
            function Rt(t, e, n) {
              if (n && n[t]) {
                const r = n[t].indexOf(e);
                -1 !== r && n[t].splice(r, 1);
              }
            }
            class Lt {
              constructor(t, e = {}) {
                b(this, e), (this.type = t);
              }
            }
            class Ft extends Lt {
              constructor(t, e = {}) {
                super("error", b({ error: t }, e));
              }
            }
            class Bt {
              on(t, e) {
                return (
                  (this._listeners = this._listeners || {}),
                  zt(t, e, this._listeners),
                  this
                );
              }
              off(t, e) {
                return (
                  Rt(t, e, this._listeners),
                  Rt(t, e, this._oneTimeListeners),
                  this
                );
              }
              once(t, e) {
                return e
                  ? ((this._oneTimeListeners = this._oneTimeListeners || {}),
                    zt(t, e, this._oneTimeListeners),
                    this)
                  : new Promise((e) => this.once(t, e));
              }
              fire(t, e) {
                "string" == typeof t && (t = new Lt(t, e || {}));
                const n = t.type;
                if (this.listens(n)) {
                  t.target = this;
                  const e =
                    this._listeners && this._listeners[n]
                      ? this._listeners[n].slice()
                      : [];
                  for (const n of e) n.call(this, t);
                  const r =
                    this._oneTimeListeners && this._oneTimeListeners[n]
                      ? this._oneTimeListeners[n].slice()
                      : [];
                  for (const o of r)
                    Rt(n, o, this._oneTimeListeners), o.call(this, t);
                  const i = this._eventedParent;
                  i &&
                    (b(
                      t,
                      "function" == typeof this._eventedParentData
                        ? this._eventedParentData()
                        : this._eventedParentData
                    ),
                    i.fire(t));
                } else t instanceof Ft && console.error(t.error);
                return this;
              }
              listens(t) {
                return !!(
                  (this._listeners &&
                    this._listeners[t] &&
                    this._listeners[t].length > 0) ||
                  (this._oneTimeListeners &&
                    this._oneTimeListeners[t] &&
                    this._oneTimeListeners[t].length > 0) ||
                  (this._eventedParent && this._eventedParent.listens(t))
                );
              }
              setEventedParent(t, e) {
                return (
                  (this._eventedParent = t), (this._eventedParentData = e), this
                );
              }
            }
            var Nt = {
              $version: 8,
              $root: {
                version: { required: !0, type: "enum", values: [8] },
                name: { type: "string" },
                metadata: { type: "*" },
                center: { type: "array", value: "number" },
                zoom: { type: "number" },
                bearing: {
                  type: "number",
                  default: 0,
                  period: 360,
                  units: "degrees",
                },
                pitch: { type: "number", default: 0, units: "degrees" },
                light: { type: "light" },
                terrain: { type: "terrain" },
                fog: { type: "fog" },
                sources: { required: !0, type: "sources" },
                sprite: { type: "string" },
                glyphs: { type: "string" },
                transition: { type: "transition" },
                layers: { required: !0, type: "array", value: "layer" },
              },
              sources: { "*": { type: "source" } },
              source: [
                "source_vector",
                "source_raster",
                "source_raster_dem",
                "source_geojson",
                "source_video",
                "source_image",
              ],
              source_vector: {
                type: { required: !0, type: "enum", values: { vector: {} } },
                url: { type: "string" },
                tiles: { type: "array", value: "string" },
                bounds: {
                  type: "array",
                  value: "number",
                  length: 4,
                  default: [-180, -85.051129, 180, 85.051129],
                },
                scheme: {
                  type: "enum",
                  values: { xyz: {}, tms: {} },
                  default: "xyz",
                },
                minzoom: { type: "number", default: 0 },
                maxzoom: { type: "number", default: 22 },
                attribution: { type: "string" },
                promoteId: { type: "promoteId" },
                volatile: { type: "boolean", default: !1 },
                "*": { type: "*" },
              },
              source_raster: {
                type: { required: !0, type: "enum", values: { raster: {} } },
                url: { type: "string" },
                tiles: { type: "array", value: "string" },
                bounds: {
                  type: "array",
                  value: "number",
                  length: 4,
                  default: [-180, -85.051129, 180, 85.051129],
                },
                minzoom: { type: "number", default: 0 },
                maxzoom: { type: "number", default: 22 },
                tileSize: { type: "number", default: 512, units: "pixels" },
                scheme: {
                  type: "enum",
                  values: { xyz: {}, tms: {} },
                  default: "xyz",
                },
                attribution: { type: "string" },
                volatile: { type: "boolean", default: !1 },
                "*": { type: "*" },
              },
              source_raster_dem: {
                type: {
                  required: !0,
                  type: "enum",
                  values: { "raster-dem": {} },
                },
                url: { type: "string" },
                tiles: { type: "array", value: "string" },
                bounds: {
                  type: "array",
                  value: "number",
                  length: 4,
                  default: [-180, -85.051129, 180, 85.051129],
                },
                minzoom: { type: "number", default: 0 },
                maxzoom: { type: "number", default: 22 },
                tileSize: { type: "number", default: 512, units: "pixels" },
                attribution: { type: "string" },
                encoding: {
                  type: "enum",
                  values: { terrarium: {}, mapbox: {} },
                  default: "mapbox",
                },
                volatile: { type: "boolean", default: !1 },
                "*": { type: "*" },
              },
              source_geojson: {
                type: { required: !0, type: "enum", values: { geojson: {} } },
                data: { type: "*" },
                maxzoom: { type: "number", default: 18 },
                attribution: { type: "string" },
                buffer: {
                  type: "number",
                  default: 128,
                  maximum: 512,
                  minimum: 0,
                },
                filter: { type: "*" },
                tolerance: { type: "number", default: 0.375 },
                cluster: { type: "boolean", default: !1 },
                clusterRadius: { type: "number", default: 50, minimum: 0 },
                clusterMaxZoom: { type: "number" },
                clusterMinPoints: { type: "number" },
                clusterProperties: { type: "*" },
                lineMetrics: { type: "boolean", default: !1 },
                generateId: { type: "boolean", default: !1 },
                promoteId: { type: "promoteId" },
              },
              source_video: {
                type: { required: !0, type: "enum", values: { video: {} } },
                urls: { required: !0, type: "array", value: "string" },
                coordinates: {
                  required: !0,
                  type: "array",
                  length: 4,
                  value: { type: "array", length: 2, value: "number" },
                },
              },
              source_image: {
                type: { required: !0, type: "enum", values: { image: {} } },
                url: { required: !0, type: "string" },
                coordinates: {
                  required: !0,
                  type: "array",
                  length: 4,
                  value: { type: "array", length: 2, value: "number" },
                },
              },
              layer: {
                id: { type: "string", required: !0 },
                type: {
                  type: "enum",
                  values: {
                    fill: {},
                    line: {},
                    symbol: {},
                    circle: {},
                    heatmap: {},
                    "fill-extrusion": {},
                    raster: {},
                    hillshade: {},
                    background: {},
                    sky: {},
                  },
                  required: !0,
                },
                metadata: { type: "*" },
                source: { type: "string" },
                "source-layer": { type: "string" },
                minzoom: { type: "number", minimum: 0, maximum: 24 },
                maxzoom: { type: "number", minimum: 0, maximum: 24 },
                filter: { type: "filter" },
                layout: { type: "layout" },
                paint: { type: "paint" },
              },
              layout: [
                "layout_fill",
                "layout_line",
                "layout_circle",
                "layout_heatmap",
                "layout_fill-extrusion",
                "layout_symbol",
                "layout_raster",
                "layout_hillshade",
                "layout_background",
                "layout_sky",
              ],
              layout_background: {
                visibility: {
                  type: "enum",
                  values: { visible: {}, none: {} },
                  default: "visible",
                  "property-type": "constant",
                },
              },
              layout_sky: {
                visibility: {
                  type: "enum",
                  values: { visible: {}, none: {} },
                  default: "visible",
                  "property-type": "constant",
                },
              },
              layout_fill: {
                "fill-sort-key": {
                  type: "number",
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                visibility: {
                  type: "enum",
                  values: { visible: {}, none: {} },
                  default: "visible",
                  "property-type": "constant",
                },
              },
              layout_circle: {
                "circle-sort-key": {
                  type: "number",
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                visibility: {
                  type: "enum",
                  values: { visible: {}, none: {} },
                  default: "visible",
                  "property-type": "constant",
                },
              },
              layout_heatmap: {
                visibility: {
                  type: "enum",
                  values: { visible: {}, none: {} },
                  default: "visible",
                  "property-type": "constant",
                },
              },
              "layout_fill-extrusion": {
                visibility: {
                  type: "enum",
                  values: { visible: {}, none: {} },
                  default: "visible",
                  "property-type": "constant",
                },
              },
              layout_line: {
                "line-cap": {
                  type: "enum",
                  values: { butt: {}, round: {}, square: {} },
                  default: "butt",
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "line-join": {
                  type: "enum",
                  values: { bevel: {}, round: {}, miter: {} },
                  default: "miter",
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "line-miter-limit": {
                  type: "number",
                  default: 2,
                  requires: [{ "line-join": "miter" }],
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "line-round-limit": {
                  type: "number",
                  default: 1.05,
                  requires: [{ "line-join": "round" }],
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "line-sort-key": {
                  type: "number",
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                visibility: {
                  type: "enum",
                  values: { visible: {}, none: {} },
                  default: "visible",
                  "property-type": "constant",
                },
              },
              layout_symbol: {
                "symbol-placement": {
                  type: "enum",
                  values: { point: {}, line: {}, "line-center": {} },
                  default: "point",
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "symbol-spacing": {
                  type: "number",
                  default: 250,
                  minimum: 1,
                  units: "pixels",
                  requires: [{ "symbol-placement": "line" }],
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "symbol-avoid-edges": {
                  type: "boolean",
                  default: !1,
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "symbol-sort-key": {
                  type: "number",
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "symbol-z-order": {
                  type: "enum",
                  values: { auto: {}, "viewport-y": {}, source: {} },
                  default: "auto",
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "icon-allow-overlap": {
                  type: "boolean",
                  default: !1,
                  requires: ["icon-image"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "icon-ignore-placement": {
                  type: "boolean",
                  default: !1,
                  requires: ["icon-image"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "icon-optional": {
                  type: "boolean",
                  default: !1,
                  requires: ["icon-image", "text-field"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "icon-rotation-alignment": {
                  type: "enum",
                  values: { map: {}, viewport: {}, auto: {} },
                  default: "auto",
                  requires: ["icon-image"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "icon-size": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  units: "factor of the original icon size",
                  requires: ["icon-image"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "icon-text-fit": {
                  type: "enum",
                  values: { none: {}, width: {}, height: {}, both: {} },
                  default: "none",
                  requires: ["icon-image", "text-field"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "icon-text-fit-padding": {
                  type: "array",
                  value: "number",
                  length: 4,
                  default: [0, 0, 0, 0],
                  units: "pixels",
                  requires: [
                    "icon-image",
                    "text-field",
                    { "icon-text-fit": ["both", "width", "height"] },
                  ],
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "icon-image": {
                  type: "resolvedImage",
                  tokens: !0,
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "icon-rotate": {
                  type: "number",
                  default: 0,
                  period: 360,
                  units: "degrees",
                  requires: ["icon-image"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "icon-padding": {
                  type: "number",
                  default: 2,
                  minimum: 0,
                  units: "pixels",
                  requires: ["icon-image"],
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "icon-keep-upright": {
                  type: "boolean",
                  default: !1,
                  requires: [
                    "icon-image",
                    { "icon-rotation-alignment": "map" },
                    { "symbol-placement": ["line", "line-center"] },
                  ],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "icon-offset": {
                  type: "array",
                  value: "number",
                  length: 2,
                  default: [0, 0],
                  requires: ["icon-image"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "icon-anchor": {
                  type: "enum",
                  values: {
                    center: {},
                    left: {},
                    right: {},
                    top: {},
                    bottom: {},
                    "top-left": {},
                    "top-right": {},
                    "bottom-left": {},
                    "bottom-right": {},
                  },
                  default: "center",
                  requires: ["icon-image"],
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "icon-pitch-alignment": {
                  type: "enum",
                  values: { map: {}, viewport: {}, auto: {} },
                  default: "auto",
                  requires: ["icon-image"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-pitch-alignment": {
                  type: "enum",
                  values: { map: {}, viewport: {}, auto: {} },
                  default: "auto",
                  requires: ["text-field"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-rotation-alignment": {
                  type: "enum",
                  values: { map: {}, viewport: {}, auto: {} },
                  default: "auto",
                  requires: ["text-field"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-field": {
                  type: "formatted",
                  default: "",
                  tokens: !0,
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-font": {
                  type: "array",
                  value: "string",
                  default: ["Open Sans Regular", "Arial Unicode MS Regular"],
                  requires: ["text-field"],
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-size": {
                  type: "number",
                  default: 16,
                  minimum: 0,
                  units: "pixels",
                  requires: ["text-field"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-max-width": {
                  type: "number",
                  default: 10,
                  minimum: 0,
                  units: "ems",
                  requires: ["text-field", { "symbol-placement": ["point"] }],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-line-height": {
                  type: "number",
                  default: 1.2,
                  units: "ems",
                  requires: ["text-field"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-letter-spacing": {
                  type: "number",
                  default: 0,
                  units: "ems",
                  requires: ["text-field"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-justify": {
                  type: "enum",
                  values: { auto: {}, left: {}, center: {}, right: {} },
                  default: "center",
                  requires: ["text-field"],
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-radial-offset": {
                  type: "number",
                  units: "ems",
                  default: 0,
                  requires: ["text-field"],
                  "property-type": "data-driven",
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature"],
                  },
                },
                "text-variable-anchor": {
                  type: "array",
                  value: "enum",
                  values: {
                    center: {},
                    left: {},
                    right: {},
                    top: {},
                    bottom: {},
                    "top-left": {},
                    "top-right": {},
                    "bottom-left": {},
                    "bottom-right": {},
                  },
                  requires: ["text-field", { "symbol-placement": ["point"] }],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-anchor": {
                  type: "enum",
                  values: {
                    center: {},
                    left: {},
                    right: {},
                    top: {},
                    bottom: {},
                    "top-left": {},
                    "top-right": {},
                    "bottom-left": {},
                    "bottom-right": {},
                  },
                  default: "center",
                  requires: ["text-field", { "!": "text-variable-anchor" }],
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-max-angle": {
                  type: "number",
                  default: 45,
                  units: "degrees",
                  requires: [
                    "text-field",
                    { "symbol-placement": ["line", "line-center"] },
                  ],
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-writing-mode": {
                  type: "array",
                  value: "enum",
                  values: { horizontal: {}, vertical: {} },
                  requires: ["text-field"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-rotate": {
                  type: "number",
                  default: 0,
                  period: 360,
                  units: "degrees",
                  requires: ["text-field"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-padding": {
                  type: "number",
                  default: 2,
                  minimum: 0,
                  units: "pixels",
                  requires: ["text-field"],
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-keep-upright": {
                  type: "boolean",
                  default: !0,
                  requires: [
                    "text-field",
                    { "text-rotation-alignment": "map" },
                    { "symbol-placement": ["line", "line-center"] },
                  ],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-transform": {
                  type: "enum",
                  values: { none: {}, uppercase: {}, lowercase: {} },
                  default: "none",
                  requires: ["text-field"],
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-offset": {
                  type: "array",
                  value: "number",
                  units: "ems",
                  length: 2,
                  default: [0, 0],
                  requires: ["text-field", { "!": "text-radial-offset" }],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "data-driven",
                },
                "text-allow-overlap": {
                  type: "boolean",
                  default: !1,
                  requires: ["text-field"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-ignore-placement": {
                  type: "boolean",
                  default: !1,
                  requires: ["text-field"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-optional": {
                  type: "boolean",
                  default: !1,
                  requires: ["text-field", "icon-image"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                visibility: {
                  type: "enum",
                  values: { visible: {}, none: {} },
                  default: "visible",
                  "property-type": "constant",
                },
              },
              layout_raster: {
                visibility: {
                  type: "enum",
                  values: { visible: {}, none: {} },
                  default: "visible",
                  "property-type": "constant",
                },
              },
              layout_hillshade: {
                visibility: {
                  type: "enum",
                  values: { visible: {}, none: {} },
                  default: "visible",
                  "property-type": "constant",
                },
              },
              filter: { type: "array", value: "*" },
              filter_operator: {
                type: "enum",
                values: {
                  "==": {},
                  "!=": {},
                  ">": {},
                  ">=": {},
                  "<": {},
                  "<=": {},
                  in: {},
                  "!in": {},
                  all: {},
                  any: {},
                  none: {},
                  has: {},
                  "!has": {},
                  within: {},
                },
              },
              geometry_type: {
                type: "enum",
                values: { Point: {}, LineString: {}, Polygon: {} },
              },
              function: {
                expression: { type: "expression" },
                stops: { type: "array", value: "function_stop" },
                base: { type: "number", default: 1, minimum: 0 },
                property: { type: "string", default: "$zoom" },
                type: {
                  type: "enum",
                  values: {
                    identity: {},
                    exponential: {},
                    interval: {},
                    categorical: {},
                  },
                  default: "exponential",
                },
                colorSpace: {
                  type: "enum",
                  values: { rgb: {}, lab: {}, hcl: {} },
                  default: "rgb",
                },
                default: { type: "*", required: !1 },
              },
              function_stop: {
                type: "array",
                minimum: 0,
                maximum: 24,
                value: ["number", "color"],
                length: 2,
              },
              expression: { type: "array", value: "*", minimum: 1 },
              fog: {
                range: {
                  type: "array",
                  default: [0.5, 10],
                  minimum: -20,
                  maximum: 20,
                  length: 2,
                  value: "number",
                  "property-type": "data-constant",
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                },
                color: {
                  type: "color",
                  "property-type": "data-constant",
                  default: "#ffffff",
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  transition: !0,
                },
                "horizon-blend": {
                  type: "number",
                  "property-type": "data-constant",
                  default: 0.1,
                  minimum: 0,
                  maximum: 1,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  transition: !0,
                },
              },
              light: {
                anchor: {
                  type: "enum",
                  default: "viewport",
                  values: { map: {}, viewport: {} },
                  "property-type": "data-constant",
                  transition: !1,
                  expression: { interpolated: !1, parameters: ["zoom"] },
                },
                position: {
                  type: "array",
                  default: [1.15, 210, 30],
                  length: 3,
                  value: "number",
                  "property-type": "data-constant",
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                },
                color: {
                  type: "color",
                  "property-type": "data-constant",
                  default: "#ffffff",
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  transition: !0,
                },
                intensity: {
                  type: "number",
                  "property-type": "data-constant",
                  default: 0.5,
                  minimum: 0,
                  maximum: 1,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  transition: !0,
                },
              },
              terrain: {
                source: { type: "string", required: !0 },
                exaggeration: {
                  type: "number",
                  "property-type": "data-constant",
                  default: 1,
                  minimum: 0,
                  maximum: 1e3,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  transition: !0,
                },
              },
              paint: [
                "paint_fill",
                "paint_line",
                "paint_circle",
                "paint_heatmap",
                "paint_fill-extrusion",
                "paint_symbol",
                "paint_raster",
                "paint_hillshade",
                "paint_background",
                "paint_sky",
              ],
              paint_fill: {
                "fill-antialias": {
                  type: "boolean",
                  default: !0,
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "fill-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "fill-color": {
                  type: "color",
                  default: "#000000",
                  transition: !0,
                  requires: [{ "!": "fill-pattern" }],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "fill-outline-color": {
                  type: "color",
                  transition: !0,
                  requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "fill-translate": {
                  type: "array",
                  value: "number",
                  length: 2,
                  default: [0, 0],
                  transition: !0,
                  units: "pixels",
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "fill-translate-anchor": {
                  type: "enum",
                  values: { map: {}, viewport: {} },
                  default: "map",
                  requires: ["fill-translate"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "fill-pattern": {
                  type: "resolvedImage",
                  transition: !0,
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "cross-faded-data-driven",
                },
              },
              "paint_fill-extrusion": {
                "fill-extrusion-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "fill-extrusion-color": {
                  type: "color",
                  default: "#000000",
                  transition: !0,
                  requires: [{ "!": "fill-extrusion-pattern" }],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "fill-extrusion-translate": {
                  type: "array",
                  value: "number",
                  length: 2,
                  default: [0, 0],
                  transition: !0,
                  units: "pixels",
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "fill-extrusion-translate-anchor": {
                  type: "enum",
                  values: { map: {}, viewport: {} },
                  default: "map",
                  requires: ["fill-extrusion-translate"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "fill-extrusion-pattern": {
                  type: "resolvedImage",
                  transition: !0,
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "cross-faded-data-driven",
                },
                "fill-extrusion-height": {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  units: "meters",
                  transition: !0,
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "fill-extrusion-base": {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  units: "meters",
                  transition: !0,
                  requires: ["fill-extrusion-height"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "fill-extrusion-vertical-gradient": {
                  type: "boolean",
                  default: !0,
                  transition: !1,
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
              },
              paint_line: {
                "line-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "line-color": {
                  type: "color",
                  default: "#000000",
                  transition: !0,
                  requires: [{ "!": "line-pattern" }],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "line-translate": {
                  type: "array",
                  value: "number",
                  length: 2,
                  default: [0, 0],
                  transition: !0,
                  units: "pixels",
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "line-translate-anchor": {
                  type: "enum",
                  values: { map: {}, viewport: {} },
                  default: "map",
                  requires: ["line-translate"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "line-width": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  transition: !0,
                  units: "pixels",
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "line-gap-width": {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  transition: !0,
                  units: "pixels",
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "line-offset": {
                  type: "number",
                  default: 0,
                  transition: !0,
                  units: "pixels",
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "line-blur": {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  transition: !0,
                  units: "pixels",
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "line-dasharray": {
                  type: "array",
                  value: "number",
                  minimum: 0,
                  transition: !0,
                  units: "line widths",
                  requires: [{ "!": "line-pattern" }],
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "cross-faded-data-driven",
                },
                "line-pattern": {
                  type: "resolvedImage",
                  transition: !0,
                  expression: {
                    interpolated: !1,
                    parameters: ["zoom", "feature"],
                  },
                  "property-type": "cross-faded-data-driven",
                },
                "line-gradient": {
                  type: "color",
                  transition: !1,
                  requires: [
                    { "!": "line-dasharray" },
                    { "!": "line-pattern" },
                    { source: "geojson", has: { lineMetrics: !0 } },
                  ],
                  expression: {
                    interpolated: !0,
                    parameters: ["line-progress"],
                  },
                  "property-type": "color-ramp",
                },
              },
              paint_circle: {
                "circle-radius": {
                  type: "number",
                  default: 5,
                  minimum: 0,
                  transition: !0,
                  units: "pixels",
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "circle-color": {
                  type: "color",
                  default: "#000000",
                  transition: !0,
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "circle-blur": {
                  type: "number",
                  default: 0,
                  transition: !0,
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "circle-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "circle-translate": {
                  type: "array",
                  value: "number",
                  length: 2,
                  default: [0, 0],
                  transition: !0,
                  units: "pixels",
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "circle-translate-anchor": {
                  type: "enum",
                  values: { map: {}, viewport: {} },
                  default: "map",
                  requires: ["circle-translate"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "circle-pitch-scale": {
                  type: "enum",
                  values: { map: {}, viewport: {} },
                  default: "map",
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "circle-pitch-alignment": {
                  type: "enum",
                  values: { map: {}, viewport: {} },
                  default: "viewport",
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "circle-stroke-width": {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  transition: !0,
                  units: "pixels",
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "circle-stroke-color": {
                  type: "color",
                  default: "#000000",
                  transition: !0,
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "circle-stroke-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
              },
              paint_heatmap: {
                "heatmap-radius": {
                  type: "number",
                  default: 30,
                  minimum: 1,
                  transition: !0,
                  units: "pixels",
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "heatmap-weight": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  transition: !1,
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "heatmap-intensity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "heatmap-color": {
                  type: "color",
                  default: [
                    "interpolate",
                    ["linear"],
                    ["heatmap-density"],
                    0,
                    "rgba(0, 0, 255, 0)",
                    0.1,
                    "royalblue",
                    0.3,
                    "cyan",
                    0.5,
                    "lime",
                    0.7,
                    "yellow",
                    1,
                    "red",
                  ],
                  transition: !1,
                  expression: {
                    interpolated: !0,
                    parameters: ["heatmap-density"],
                  },
                  "property-type": "color-ramp",
                },
                "heatmap-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
              },
              paint_symbol: {
                "icon-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  requires: ["icon-image"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "icon-color": {
                  type: "color",
                  default: "#000000",
                  transition: !0,
                  requires: ["icon-image"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "icon-halo-color": {
                  type: "color",
                  default: "rgba(0, 0, 0, 0)",
                  transition: !0,
                  requires: ["icon-image"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "icon-halo-width": {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  transition: !0,
                  units: "pixels",
                  requires: ["icon-image"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "icon-halo-blur": {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  transition: !0,
                  units: "pixels",
                  requires: ["icon-image"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "icon-translate": {
                  type: "array",
                  value: "number",
                  length: 2,
                  default: [0, 0],
                  transition: !0,
                  units: "pixels",
                  requires: ["icon-image"],
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "icon-translate-anchor": {
                  type: "enum",
                  values: { map: {}, viewport: {} },
                  default: "map",
                  requires: ["icon-image", "icon-translate"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  requires: ["text-field"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "text-color": {
                  type: "color",
                  default: "#000000",
                  transition: !0,
                  overridable: !0,
                  requires: ["text-field"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "text-halo-color": {
                  type: "color",
                  default: "rgba(0, 0, 0, 0)",
                  transition: !0,
                  requires: ["text-field"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "text-halo-width": {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  transition: !0,
                  units: "pixels",
                  requires: ["text-field"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "text-halo-blur": {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  transition: !0,
                  units: "pixels",
                  requires: ["text-field"],
                  expression: {
                    interpolated: !0,
                    parameters: ["zoom", "feature", "feature-state"],
                  },
                  "property-type": "data-driven",
                },
                "text-translate": {
                  type: "array",
                  value: "number",
                  length: 2,
                  default: [0, 0],
                  transition: !0,
                  units: "pixels",
                  requires: ["text-field"],
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "text-translate-anchor": {
                  type: "enum",
                  values: { map: {}, viewport: {} },
                  default: "map",
                  requires: ["text-field", "text-translate"],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
              },
              paint_raster: {
                "raster-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "raster-hue-rotate": {
                  type: "number",
                  default: 0,
                  period: 360,
                  transition: !0,
                  units: "degrees",
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "raster-brightness-min": {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "raster-brightness-max": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "raster-saturation": {
                  type: "number",
                  default: 0,
                  minimum: -1,
                  maximum: 1,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "raster-contrast": {
                  type: "number",
                  default: 0,
                  minimum: -1,
                  maximum: 1,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "raster-resampling": {
                  type: "enum",
                  values: { linear: {}, nearest: {} },
                  default: "linear",
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "raster-fade-duration": {
                  type: "number",
                  default: 300,
                  minimum: 0,
                  transition: !1,
                  units: "milliseconds",
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
              },
              paint_hillshade: {
                "hillshade-illumination-direction": {
                  type: "number",
                  default: 335,
                  minimum: 0,
                  maximum: 359,
                  transition: !1,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "hillshade-illumination-anchor": {
                  type: "enum",
                  values: { map: {}, viewport: {} },
                  default: "viewport",
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "hillshade-exaggeration": {
                  type: "number",
                  default: 0.5,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "hillshade-shadow-color": {
                  type: "color",
                  default: "#000000",
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "hillshade-highlight-color": {
                  type: "color",
                  default: "#FFFFFF",
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "hillshade-accent-color": {
                  type: "color",
                  default: "#000000",
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
              },
              paint_background: {
                "background-color": {
                  type: "color",
                  default: "#000000",
                  transition: !0,
                  requires: [{ "!": "background-pattern" }],
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "background-pattern": {
                  type: "resolvedImage",
                  transition: !0,
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "cross-faded",
                },
                "background-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
              },
              paint_sky: {
                "sky-type": {
                  type: "enum",
                  values: { gradient: {}, atmosphere: {} },
                  default: "atmosphere",
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "sky-atmosphere-sun": {
                  type: "array",
                  value: "number",
                  length: 2,
                  units: "degrees",
                  minimum: [0, 0],
                  maximum: [360, 180],
                  transition: !1,
                  requires: [{ "sky-type": "atmosphere" }],
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "sky-atmosphere-sun-intensity": {
                  type: "number",
                  requires: [{ "sky-type": "atmosphere" }],
                  default: 10,
                  minimum: 0,
                  maximum: 100,
                  transition: !1,
                  "property-type": "data-constant",
                },
                "sky-gradient-center": {
                  type: "array",
                  requires: [{ "sky-type": "gradient" }],
                  value: "number",
                  default: [0, 0],
                  length: 2,
                  units: "degrees",
                  minimum: [0, 0],
                  maximum: [360, 180],
                  transition: !1,
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "sky-gradient-radius": {
                  type: "number",
                  requires: [{ "sky-type": "gradient" }],
                  default: 90,
                  minimum: 0,
                  maximum: 180,
                  transition: !1,
                  expression: { interpolated: !1, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
                "sky-gradient": {
                  type: "color",
                  default: [
                    "interpolate",
                    ["linear"],
                    ["sky-radial-progress"],
                    0.8,
                    "#87ceeb",
                    1,
                    "white",
                  ],
                  transition: !1,
                  requires: [{ "sky-type": "gradient" }],
                  expression: {
                    interpolated: !0,
                    parameters: ["sky-radial-progress"],
                  },
                  "property-type": "color-ramp",
                },
                "sky-atmosphere-halo-color": {
                  type: "color",
                  default: "white",
                  transition: !1,
                  requires: [{ "sky-type": "atmosphere" }],
                  "property-type": "data-constant",
                },
                "sky-atmosphere-color": {
                  type: "color",
                  default: "white",
                  transition: !1,
                  requires: [{ "sky-type": "atmosphere" }],
                  "property-type": "data-constant",
                },
                "sky-opacity": {
                  type: "number",
                  default: 1,
                  minimum: 0,
                  maximum: 1,
                  transition: !0,
                  expression: { interpolated: !0, parameters: ["zoom"] },
                  "property-type": "data-constant",
                },
              },
              transition: {
                duration: {
                  type: "number",
                  default: 300,
                  minimum: 0,
                  units: "milliseconds",
                },
                delay: {
                  type: "number",
                  default: 0,
                  minimum: 0,
                  units: "milliseconds",
                },
              },
              "property-type": {
                "data-driven": { type: "property-type" },
                "cross-faded": { type: "property-type" },
                "cross-faded-data-driven": { type: "property-type" },
                "color-ramp": { type: "property-type" },
                "data-constant": { type: "property-type" },
                constant: { type: "property-type" },
              },
              promoteId: { "*": { type: "string" } },
            };
            class jt {
              constructor(t, e, n, r) {
                (this.message = (t ? `${t}: ` : "") + n),
                  r && (this.identifier = r),
                  null != e && e.__line__ && (this.line = e.__line__);
              }
            }
            function Ut(t) {
              const e = t.value;
              return e
                ? [new jt(t.key, e, "constants have been deprecated as of v8")]
                : [];
            }
            function Zt(t, ...e) {
              for (const n of e) for (const e in n) t[e] = n[e];
              return t;
            }
            function Vt(t) {
              return t instanceof Number ||
                t instanceof String ||
                t instanceof Boolean
                ? t.valueOf()
                : t;
            }
            function qt(t) {
              if (Array.isArray(t)) return t.map(qt);
              if (
                t instanceof Object &&
                !(
                  t instanceof Number ||
                  t instanceof String ||
                  t instanceof Boolean
                )
              ) {
                const e = {};
                for (const n in t) e[n] = qt(t[n]);
                return e;
              }
              return Vt(t);
            }
            class $t extends Error {
              constructor(t, e) {
                super(e), (this.message = e), (this.key = t);
              }
            }
            class Gt {
              constructor(t, e = []) {
                (this.parent = t), (this.bindings = {});
                for (const [n, r] of e) this.bindings[n] = r;
              }
              concat(t) {
                return new Gt(this, t);
              }
              get(t) {
                if (this.bindings[t]) return this.bindings[t];
                if (this.parent) return this.parent.get(t);
                throw new Error(`${t} not found in scope.`);
              }
              has(t) {
                return (
                  !!this.bindings[t] || (!!this.parent && this.parent.has(t))
                );
              }
            }
            const Wt = { kind: "null" },
              Ht = { kind: "number" },
              Xt = { kind: "string" },
              Kt = { kind: "boolean" },
              Yt = { kind: "color" },
              Qt = { kind: "object" },
              Jt = { kind: "value" },
              te = { kind: "collator" },
              ee = { kind: "formatted" },
              ne = { kind: "resolvedImage" };
            function re(t, e) {
              return { kind: "array", itemType: t, N: e };
            }
            function ie(t) {
              if ("array" === t.kind) {
                const e = ie(t.itemType);
                return "number" == typeof t.N
                  ? `array<${e}, ${t.N}>`
                  : "value" === t.itemType.kind
                  ? "array"
                  : `array<${e}>`;
              }
              return t.kind;
            }
            const oe = [Wt, Ht, Xt, Kt, Yt, ee, Qt, re(Jt), ne];
            function se(t, e) {
              if ("error" === e.kind) return null;
              if ("array" === t.kind) {
                if (
                  "array" === e.kind &&
                  ((0 === e.N && "value" === e.itemType.kind) ||
                    !se(t.itemType, e.itemType)) &&
                  ("number" != typeof t.N || t.N === e.N)
                )
                  return null;
              } else {
                if (t.kind === e.kind) return null;
                if ("value" === t.kind)
                  for (const t of oe) if (!se(t, e)) return null;
              }
              return `Expected ${ie(t)} but found ${ie(e)} instead.`;
            }
            function ae(t, e) {
              return e.some((e) => e.kind === t.kind);
            }
            function le(t, e) {
              return e.some((e) =>
                "null" === e
                  ? null === t
                  : "array" === e
                  ? Array.isArray(t)
                  : "object" === e
                  ? t && !Array.isArray(t) && "object" == typeof t
                  : e === typeof t
              );
            }
            function ce(t) {
              var e = { exports: {} };
              return t(e, e.exports), e.exports;
            }
            var ue = ce(function (t, e) {
              var n = {
                transparent: [0, 0, 0, 0],
                aliceblue: [240, 248, 255, 1],
                antiquewhite: [250, 235, 215, 1],
                aqua: [0, 255, 255, 1],
                aquamarine: [127, 255, 212, 1],
                azure: [240, 255, 255, 1],
                beige: [245, 245, 220, 1],
                bisque: [255, 228, 196, 1],
                black: [0, 0, 0, 1],
                blanchedalmond: [255, 235, 205, 1],
                blue: [0, 0, 255, 1],
                blueviolet: [138, 43, 226, 1],
                brown: [165, 42, 42, 1],
                burlywood: [222, 184, 135, 1],
                cadetblue: [95, 158, 160, 1],
                chartreuse: [127, 255, 0, 1],
                chocolate: [210, 105, 30, 1],
                coral: [255, 127, 80, 1],
                cornflowerblue: [100, 149, 237, 1],
                cornsilk: [255, 248, 220, 1],
                crimson: [220, 20, 60, 1],
                cyan: [0, 255, 255, 1],
                darkblue: [0, 0, 139, 1],
                darkcyan: [0, 139, 139, 1],
                darkgoldenrod: [184, 134, 11, 1],
                darkgray: [169, 169, 169, 1],
                darkgreen: [0, 100, 0, 1],
                darkgrey: [169, 169, 169, 1],
                darkkhaki: [189, 183, 107, 1],
                darkmagenta: [139, 0, 139, 1],
                darkolivegreen: [85, 107, 47, 1],
                darkorange: [255, 140, 0, 1],
                darkorchid: [153, 50, 204, 1],
                darkred: [139, 0, 0, 1],
                darksalmon: [233, 150, 122, 1],
                darkseagreen: [143, 188, 143, 1],
                darkslateblue: [72, 61, 139, 1],
                darkslategray: [47, 79, 79, 1],
                darkslategrey: [47, 79, 79, 1],
                darkturquoise: [0, 206, 209, 1],
                darkviolet: [148, 0, 211, 1],
                deeppink: [255, 20, 147, 1],
                deepskyblue: [0, 191, 255, 1],
                dimgray: [105, 105, 105, 1],
                dimgrey: [105, 105, 105, 1],
                dodgerblue: [30, 144, 255, 1],
                firebrick: [178, 34, 34, 1],
                floralwhite: [255, 250, 240, 1],
                forestgreen: [34, 139, 34, 1],
                fuchsia: [255, 0, 255, 1],
                gainsboro: [220, 220, 220, 1],
                ghostwhite: [248, 248, 255, 1],
                gold: [255, 215, 0, 1],
                goldenrod: [218, 165, 32, 1],
                gray: [128, 128, 128, 1],
                green: [0, 128, 0, 1],
                greenyellow: [173, 255, 47, 1],
                grey: [128, 128, 128, 1],
                honeydew: [240, 255, 240, 1],
                hotpink: [255, 105, 180, 1],
                indianred: [205, 92, 92, 1],
                indigo: [75, 0, 130, 1],
                ivory: [255, 255, 240, 1],
                khaki: [240, 230, 140, 1],
                lavender: [230, 230, 250, 1],
                lavenderblush: [255, 240, 245, 1],
                lawngreen: [124, 252, 0, 1],
                lemonchiffon: [255, 250, 205, 1],
                lightblue: [173, 216, 230, 1],
                lightcoral: [240, 128, 128, 1],
                lightcyan: [224, 255, 255, 1],
                lightgoldenrodyellow: [250, 250, 210, 1],
                lightgray: [211, 211, 211, 1],
                lightgreen: [144, 238, 144, 1],
                lightgrey: [211, 211, 211, 1],
                lightpink: [255, 182, 193, 1],
                lightsalmon: [255, 160, 122, 1],
                lightseagreen: [32, 178, 170, 1],
                lightskyblue: [135, 206, 250, 1],
                lightslategray: [119, 136, 153, 1],
                lightslategrey: [119, 136, 153, 1],
                lightsteelblue: [176, 196, 222, 1],
                lightyellow: [255, 255, 224, 1],
                lime: [0, 255, 0, 1],
                limegreen: [50, 205, 50, 1],
                linen: [250, 240, 230, 1],
                magenta: [255, 0, 255, 1],
                maroon: [128, 0, 0, 1],
                mediumaquamarine: [102, 205, 170, 1],
                mediumblue: [0, 0, 205, 1],
                mediumorchid: [186, 85, 211, 1],
                mediumpurple: [147, 112, 219, 1],
                mediumseagreen: [60, 179, 113, 1],
                mediumslateblue: [123, 104, 238, 1],
                mediumspringgreen: [0, 250, 154, 1],
                mediumturquoise: [72, 209, 204, 1],
                mediumvioletred: [199, 21, 133, 1],
                midnightblue: [25, 25, 112, 1],
                mintcream: [245, 255, 250, 1],
                mistyrose: [255, 228, 225, 1],
                moccasin: [255, 228, 181, 1],
                navajowhite: [255, 222, 173, 1],
                navy: [0, 0, 128, 1],
                oldlace: [253, 245, 230, 1],
                olive: [128, 128, 0, 1],
                olivedrab: [107, 142, 35, 1],
                orange: [255, 165, 0, 1],
                orangered: [255, 69, 0, 1],
                orchid: [218, 112, 214, 1],
                palegoldenrod: [238, 232, 170, 1],
                palegreen: [152, 251, 152, 1],
                paleturquoise: [175, 238, 238, 1],
                palevioletred: [219, 112, 147, 1],
                papayawhip: [255, 239, 213, 1],
                peachpuff: [255, 218, 185, 1],
                peru: [205, 133, 63, 1],
                pink: [255, 192, 203, 1],
                plum: [221, 160, 221, 1],
                powderblue: [176, 224, 230, 1],
                purple: [128, 0, 128, 1],
                rebeccapurple: [102, 51, 153, 1],
                red: [255, 0, 0, 1],
                rosybrown: [188, 143, 143, 1],
                royalblue: [65, 105, 225, 1],
                saddlebrown: [139, 69, 19, 1],
                salmon: [250, 128, 114, 1],
                sandybrown: [244, 164, 96, 1],
                seagreen: [46, 139, 87, 1],
                seashell: [255, 245, 238, 1],
                sienna: [160, 82, 45, 1],
                silver: [192, 192, 192, 1],
                skyblue: [135, 206, 235, 1],
                slateblue: [106, 90, 205, 1],
                slategray: [112, 128, 144, 1],
                slategrey: [112, 128, 144, 1],
                snow: [255, 250, 250, 1],
                springgreen: [0, 255, 127, 1],
                steelblue: [70, 130, 180, 1],
                tan: [210, 180, 140, 1],
                teal: [0, 128, 128, 1],
                thistle: [216, 191, 216, 1],
                tomato: [255, 99, 71, 1],
                turquoise: [64, 224, 208, 1],
                violet: [238, 130, 238, 1],
                wheat: [245, 222, 179, 1],
                white: [255, 255, 255, 1],
                whitesmoke: [245, 245, 245, 1],
                yellow: [255, 255, 0, 1],
                yellowgreen: [154, 205, 50, 1],
              };
              function r(t) {
                return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t;
              }
              function i(t) {
                return r(
                  "%" === t[t.length - 1]
                    ? (parseFloat(t) / 100) * 255
                    : parseInt(t)
                );
              }
              function o(t) {
                return (e =
                  "%" === t[t.length - 1]
                    ? parseFloat(t) / 100
                    : parseFloat(t)) < 0
                  ? 0
                  : e > 1
                  ? 1
                  : e;
                var e;
              }
              function s(t, e, n) {
                return (
                  n < 0 ? (n += 1) : n > 1 && (n -= 1),
                  6 * n < 1
                    ? t + (e - t) * n * 6
                    : 2 * n < 1
                    ? e
                    : 3 * n < 2
                    ? t + (e - t) * (2 / 3 - n) * 6
                    : t
                );
              }
              try {
                e.parseCSSColor = function (t) {
                  var e,
                    a = t.replace(/ /g, "").toLowerCase();
                  if (a in n) return n[a].slice();
                  if ("#" === a[0])
                    return 4 === a.length
                      ? (e = parseInt(a.substr(1), 16)) >= 0 && e <= 4095
                        ? [
                            ((3840 & e) >> 4) | ((3840 & e) >> 8),
                            (240 & e) | ((240 & e) >> 4),
                            (15 & e) | ((15 & e) << 4),
                            1,
                          ]
                        : null
                      : 7 === a.length &&
                        (e = parseInt(a.substr(1), 16)) >= 0 &&
                        e <= 16777215
                      ? [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 1]
                      : null;
                  var l = a.indexOf("("),
                    c = a.indexOf(")");
                  if (-1 !== l && c + 1 === a.length) {
                    var u = a.substr(0, l),
                      h = a.substr(l + 1, c - (l + 1)).split(","),
                      p = 1;
                    switch (u) {
                      case "rgba":
                        if (4 !== h.length) return null;
                        p = o(h.pop());
                      case "rgb":
                        return 3 !== h.length
                          ? null
                          : [i(h[0]), i(h[1]), i(h[2]), p];
                      case "hsla":
                        if (4 !== h.length) return null;
                        p = o(h.pop());
                      case "hsl":
                        if (3 !== h.length) return null;
                        var d = (((parseFloat(h[0]) % 360) + 360) % 360) / 360,
                          f = o(h[1]),
                          m = o(h[2]),
                          g = m <= 0.5 ? m * (f + 1) : m + f - m * f,
                          y = 2 * m - g;
                        return [
                          r(255 * s(y, g, d + 1 / 3)),
                          r(255 * s(y, g, d)),
                          r(255 * s(y, g, d - 1 / 3)),
                          p,
                        ];
                      default:
                        return null;
                    }
                  }
                  return null;
                };
              } catch (t) {}
            });
            class he {
              constructor(t, e, n, r = 1) {
                (this.r = t), (this.g = e), (this.b = n), (this.a = r);
              }
              static parse(t) {
                if (!t) return;
                if (t instanceof he) return t;
                if ("string" != typeof t) return;
                const e = ue.parseCSSColor(t);
                return e
                  ? new he(
                      (e[0] / 255) * e[3],
                      (e[1] / 255) * e[3],
                      (e[2] / 255) * e[3],
                      e[3]
                    )
                  : void 0;
              }
              toString() {
                const [t, e, n, r] = this.toArray();
                return `rgba(${Math.round(
                  t
                )},${Math.round(e)},${Math.round(n)},${r})`;
              }
              toArray() {
                const { r: t, g: e, b: n, a: r } = this;
                return 0 === r
                  ? [0, 0, 0, 0]
                  : [(255 * t) / r, (255 * e) / r, (255 * n) / r, r];
              }
            }
            (he.black = new he(0, 0, 0, 1)),
              (he.white = new he(1, 1, 1, 1)),
              (he.transparent = new he(0, 0, 0, 0)),
              (he.red = new he(1, 0, 0, 1)),
              (he.blue = new he(0, 0, 1, 1));
            class pe {
              constructor(t, e, n) {
                (this.sensitivity = t
                  ? e
                    ? "variant"
                    : "case"
                  : e
                  ? "accent"
                  : "base"),
                  (this.locale = n),
                  (this.collator = new Intl.Collator(
                    this.locale ? this.locale : [],
                    { sensitivity: this.sensitivity, usage: "search" }
                  ));
              }
              compare(t, e) {
                return this.collator.compare(t, e);
              }
              resolvedLocale() {
                return new Intl.Collator(
                  this.locale ? this.locale : []
                ).resolvedOptions().locale;
              }
            }
            class de {
              constructor(t, e, n, r, i) {
                (this.text = t),
                  (this.image = e),
                  (this.scale = n),
                  (this.fontStack = r),
                  (this.textColor = i);
              }
            }
            class fe {
              constructor(t) {
                this.sections = t;
              }
              static fromString(t) {
                return new fe([new de(t, null, null, null, null)]);
              }
              isEmpty() {
                return (
                  0 === this.sections.length ||
                  !this.sections.some(
                    (t) =>
                      0 !== t.text.length ||
                      (t.image && 0 !== t.image.name.length)
                  )
                );
              }
              static factory(t) {
                return t instanceof fe ? t : fe.fromString(t);
              }
              toString() {
                return 0 === this.sections.length
                  ? ""
                  : this.sections.map((t) => t.text).join("");
              }
              serialize() {
                const t = ["format"];
                for (const e of this.sections) {
                  if (e.image) {
                    t.push(["image", e.image.name]);
                    continue;
                  }
                  t.push(e.text);
                  const n = {};
                  e.fontStack &&
                    (n["text-font"] = ["literal", e.fontStack.split(",")]),
                    e.scale && (n["font-scale"] = e.scale),
                    e.textColor &&
                      (n["text-color"] = ["rgba"].concat(
                        e.textColor.toArray()
                      )),
                    t.push(n);
                }
                return t;
              }
            }
            class me {
              constructor(t) {
                (this.name = t.name), (this.available = t.available);
              }
              toString() {
                return this.name;
              }
              static fromString(t) {
                return t ? new me({ name: t, available: !1 }) : null;
              }
              serialize() {
                return ["image", this.name];
              }
            }
            function ge(t, e, n, r) {
              return "number" == typeof t &&
                t >= 0 &&
                t <= 255 &&
                "number" == typeof e &&
                e >= 0 &&
                e <= 255 &&
                "number" == typeof n &&
                n >= 0 &&
                n <= 255
                ? void 0 === r || ("number" == typeof r && r >= 0 && r <= 1)
                  ? null
                  : `Invalid rgba value [${[t, e, n, r].join(
                      ", "
                    )}]: 'a' must be between 0 and 1.`
                : `Invalid rgba value [${("number" == typeof r
                    ? [t, e, n, r]
                    : [t, e, n]
                  ).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
            }
            function ye(t) {
              if (null === t) return !0;
              if ("string" == typeof t) return !0;
              if ("boolean" == typeof t) return !0;
              if ("number" == typeof t) return !0;
              if (t instanceof he) return !0;
              if (t instanceof pe) return !0;
              if (t instanceof fe) return !0;
              if (t instanceof me) return !0;
              if (Array.isArray(t)) {
                for (const e of t) if (!ye(e)) return !1;
                return !0;
              }
              if ("object" == typeof t) {
                for (const e in t) if (!ye(t[e])) return !1;
                return !0;
              }
              return !1;
            }
            function _e(t) {
              if (null === t) return Wt;
              if ("string" == typeof t) return Xt;
              if ("boolean" == typeof t) return Kt;
              if ("number" == typeof t) return Ht;
              if (t instanceof he) return Yt;
              if (t instanceof pe) return te;
              if (t instanceof fe) return ee;
              if (t instanceof me) return ne;
              if (Array.isArray(t)) {
                const e = t.length;
                let n;
                for (const r of t) {
                  const t = _e(r);
                  if (n) {
                    if (n === t) continue;
                    n = Jt;
                    break;
                  }
                  n = t;
                }
                return re(n || Jt, e);
              }
              return Qt;
            }
            function ve(t) {
              const e = typeof t;
              return null === t
                ? ""
                : "string" === e || "number" === e || "boolean" === e
                ? String(t)
                : t instanceof he || t instanceof fe || t instanceof me
                ? t.toString()
                : JSON.stringify(t);
            }
            class be {
              constructor(t, e) {
                (this.type = t), (this.value = e);
              }
              static parse(t, e) {
                if (2 !== t.length)
                  return e.error(
                    `'literal' expression requires exactly one argument, but found ${
                      t.length - 1
                    } instead.`
                  );
                if (!ye(t[1])) return e.error("invalid value");
                const n = t[1];
                let r = _e(n);
                const i = e.expectedType;
                return (
                  "array" !== r.kind ||
                    0 !== r.N ||
                    !i ||
                    "array" !== i.kind ||
                    ("number" == typeof i.N && 0 !== i.N) ||
                    (r = i),
                  new be(r, n)
                );
              }
              evaluate() {
                return this.value;
              }
              eachChild() {}
              outputDefined() {
                return !0;
              }
              serialize() {
                return "array" === this.type.kind || "object" === this.type.kind
                  ? ["literal", this.value]
                  : this.value instanceof he
                  ? ["rgba"].concat(this.value.toArray())
                  : this.value instanceof fe
                  ? this.value.serialize()
                  : this.value;
              }
            }
            class xe {
              constructor(t) {
                (this.name = "ExpressionEvaluationError"), (this.message = t);
              }
              toJSON() {
                return this.message;
              }
            }
            const we = { string: Xt, number: Ht, boolean: Kt, object: Qt };
            class Se {
              constructor(t, e) {
                (this.type = t), (this.args = e);
              }
              static parse(t, e) {
                if (t.length < 2)
                  return e.error("Expected at least one argument.");
                let n,
                  r = 1;
                const i = t[0];
                if ("array" === i) {
                  let i, o;
                  if (t.length > 2) {
                    const n = t[1];
                    if ("string" != typeof n || !(n in we) || "object" === n)
                      return e.error(
                        'The item type argument of "array" must be one of string, number, boolean',
                        1
                      );
                    (i = we[n]), r++;
                  } else i = Jt;
                  if (t.length > 3) {
                    if (
                      null !== t[2] &&
                      ("number" != typeof t[2] ||
                        t[2] < 0 ||
                        t[2] !== Math.floor(t[2]))
                    )
                      return e.error(
                        'The length argument to "array" must be a positive integer literal',
                        2
                      );
                    (o = t[2]), r++;
                  }
                  n = re(i, o);
                } else n = we[i];
                const o = [];
                for (; r < t.length; r++) {
                  const n = e.parse(t[r], r, Jt);
                  if (!n) return null;
                  o.push(n);
                }
                return new Se(n, o);
              }
              evaluate(t) {
                for (let e = 0; e < this.args.length; e++) {
                  const n = this.args[e].evaluate(t);
                  if (!se(this.type, _e(n))) return n;
                  if (e === this.args.length - 1)
                    throw new xe(
                      `Expected value to be of type ${ie(
                        this.type
                      )}, but found ${ie(_e(n))} instead.`
                    );
                }
                return null;
              }
              eachChild(t) {
                this.args.forEach(t);
              }
              outputDefined() {
                return this.args.every((t) => t.outputDefined());
              }
              serialize() {
                const t = this.type,
                  e = [t.kind];
                if ("array" === t.kind) {
                  const n = t.itemType;
                  if (
                    "string" === n.kind ||
                    "number" === n.kind ||
                    "boolean" === n.kind
                  ) {
                    e.push(n.kind);
                    const r = t.N;
                    ("number" == typeof r || this.args.length > 1) && e.push(r);
                  }
                }
                return e.concat(this.args.map((t) => t.serialize()));
              }
            }
            class Ee {
              constructor(t) {
                (this.type = ee), (this.sections = t);
              }
              static parse(t, e) {
                if (t.length < 2)
                  return e.error("Expected at least one argument.");
                const n = t[1];
                if (!Array.isArray(n) && "object" == typeof n)
                  return e.error(
                    "First argument must be an image or text section."
                  );
                const r = [];
                let i = !1;
                for (let o = 1; o <= t.length - 1; ++o) {
                  const n = t[o];
                  if (i && "object" == typeof n && !Array.isArray(n)) {
                    i = !1;
                    let t = null;
                    if (
                      n["font-scale"] &&
                      ((t = e.parse(n["font-scale"], 1, Ht)), !t)
                    )
                      return null;
                    let o = null;
                    if (
                      n["text-font"] &&
                      ((o = e.parse(n["text-font"], 1, re(Xt))), !o)
                    )
                      return null;
                    let s = null;
                    if (
                      n["text-color"] &&
                      ((s = e.parse(n["text-color"], 1, Yt)), !s)
                    )
                      return null;
                    const a = r[r.length - 1];
                    (a.scale = t), (a.font = o), (a.textColor = s);
                  } else {
                    const n = e.parse(t[o], 1, Jt);
                    if (!n) return null;
                    const s = n.type.kind;
                    if (
                      "string" !== s &&
                      "value" !== s &&
                      "null" !== s &&
                      "resolvedImage" !== s
                    )
                      return e.error(
                        "Formatted text type must be 'string', 'value', 'image' or 'null'."
                      );
                    (i = !0),
                      r.push({
                        content: n,
                        scale: null,
                        font: null,
                        textColor: null,
                      });
                  }
                }
                return new Ee(r);
              }
              evaluate(t) {
                return new fe(
                  this.sections.map((e) => {
                    const n = e.content.evaluate(t);
                    return _e(n) === ne
                      ? new de("", n, null, null, null)
                      : new de(
                          ve(n),
                          null,
                          e.scale ? e.scale.evaluate(t) : null,
                          e.font ? e.font.evaluate(t).join(",") : null,
                          e.textColor ? e.textColor.evaluate(t) : null
                        );
                  })
                );
              }
              eachChild(t) {
                for (const e of this.sections)
                  t(e.content),
                    e.scale && t(e.scale),
                    e.font && t(e.font),
                    e.textColor && t(e.textColor);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                const t = ["format"];
                for (const e of this.sections) {
                  t.push(e.content.serialize());
                  const n = {};
                  e.scale && (n["font-scale"] = e.scale.serialize()),
                    e.font && (n["text-font"] = e.font.serialize()),
                    e.textColor && (n["text-color"] = e.textColor.serialize()),
                    t.push(n);
                }
                return t;
              }
            }
            class Te {
              constructor(t) {
                (this.type = ne), (this.input = t);
              }
              static parse(t, e) {
                if (2 !== t.length) return e.error("Expected two arguments.");
                const n = e.parse(t[1], 1, Xt);
                return n ? new Te(n) : e.error("No image name provided.");
              }
              evaluate(t) {
                const e = this.input.evaluate(t),
                  n = me.fromString(e);
                return (
                  n &&
                    t.availableImages &&
                    (n.available = t.availableImages.indexOf(e) > -1),
                  n
                );
              }
              eachChild(t) {
                t(this.input);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                return ["image", this.input.serialize()];
              }
            }
            const Ae = {
              "to-boolean": Kt,
              "to-color": Yt,
              "to-number": Ht,
              "to-string": Xt,
            };
            class Ce {
              constructor(t, e) {
                (this.type = t), (this.args = e);
              }
              static parse(t, e) {
                if (t.length < 2)
                  return e.error("Expected at least one argument.");
                const n = t[0];
                if (("to-boolean" === n || "to-string" === n) && 2 !== t.length)
                  return e.error("Expected one argument.");
                const r = Ae[n],
                  i = [];
                for (let o = 1; o < t.length; o++) {
                  const n = e.parse(t[o], o, Jt);
                  if (!n) return null;
                  i.push(n);
                }
                return new Ce(r, i);
              }
              evaluate(t) {
                if ("boolean" === this.type.kind)
                  return Boolean(this.args[0].evaluate(t));
                if ("color" === this.type.kind) {
                  let e, n;
                  for (const r of this.args) {
                    if (((e = r.evaluate(t)), (n = null), e instanceof he))
                      return e;
                    if ("string" == typeof e) {
                      const n = t.parseColor(e);
                      if (n) return n;
                    } else if (
                      Array.isArray(e) &&
                      ((n =
                        e.length < 3 || e.length > 4
                          ? `Invalid rbga value ${JSON.stringify(
                              e
                            )}: expected an array containing either three or four numeric values.`
                          : ge(e[0], e[1], e[2], e[3])),
                      !n)
                    )
                      return new he(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);
                  }
                  throw new xe(
                    n ||
                      `Could not parse color from value '${
                        "string" == typeof e ? e : String(JSON.stringify(e))
                      }'`
                  );
                }
                if ("number" === this.type.kind) {
                  let e = null;
                  for (const n of this.args) {
                    if (((e = n.evaluate(t)), null === e)) return 0;
                    const r = Number(e);
                    if (!isNaN(r)) return r;
                  }
                  throw new xe(
                    `Could not convert ${JSON.stringify(e)} to number.`
                  );
                }
                return "formatted" === this.type.kind
                  ? fe.fromString(ve(this.args[0].evaluate(t)))
                  : "resolvedImage" === this.type.kind
                  ? me.fromString(ve(this.args[0].evaluate(t)))
                  : ve(this.args[0].evaluate(t));
              }
              eachChild(t) {
                this.args.forEach(t);
              }
              outputDefined() {
                return this.args.every((t) => t.outputDefined());
              }
              serialize() {
                if ("formatted" === this.type.kind)
                  return new Ee([
                    {
                      content: this.args[0],
                      scale: null,
                      font: null,
                      textColor: null,
                    },
                  ]).serialize();
                if ("resolvedImage" === this.type.kind)
                  return new Te(this.args[0]).serialize();
                const t = [`to-${this.type.kind}`];
                return (
                  this.eachChild((e) => {
                    t.push(e.serialize());
                  }),
                  t
                );
              }
            }
            const Pe = ["Unknown", "Point", "LineString", "Polygon"];
            class Me {
              constructor() {
                (this.globals = null),
                  (this.feature = null),
                  (this.featureState = null),
                  (this.formattedSection = null),
                  (this._parseColorCache = {}),
                  (this.availableImages = null),
                  (this.canonical = null);
              }
              id() {
                return this.feature && "id" in this.feature
                  ? this.feature.id
                  : null;
              }
              geometryType() {
                return this.feature
                  ? "number" == typeof this.feature.type
                    ? Pe[this.feature.type]
                    : this.feature.type
                  : null;
              }
              geometry() {
                return this.feature && "geometry" in this.feature
                  ? this.feature.geometry
                  : null;
              }
              canonicalID() {
                return this.canonical;
              }
              properties() {
                return (this.feature && this.feature.properties) || {};
              }
              parseColor(t) {
                let e = this._parseColorCache[t];
                return e || (e = this._parseColorCache[t] = he.parse(t)), e;
              }
            }
            class Oe {
              constructor(t, e, n, r) {
                (this.name = t),
                  (this.type = e),
                  (this._evaluate = n),
                  (this.args = r);
              }
              evaluate(t) {
                return this._evaluate(t, this.args);
              }
              eachChild(t) {
                this.args.forEach(t);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                return [this.name].concat(this.args.map((t) => t.serialize()));
              }
              static parse(t, e) {
                const n = t[0],
                  r = Oe.definitions[n];
                if (!r)
                  return e.error(
                    `Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`,
                    0
                  );
                const i = Array.isArray(r) ? r[0] : r.type,
                  o = Array.isArray(r) ? [[r[1], r[2]]] : r.overloads,
                  s = o.filter(
                    ([e]) => !Array.isArray(e) || e.length === t.length - 1
                  );
                let a = null;
                for (const [l, c] of s) {
                  a = new Je(e.registry, e.path, null, e.scope);
                  const r = [];
                  let o = !1;
                  for (let e = 1; e < t.length; e++) {
                    const n = t[e],
                      i = Array.isArray(l) ? l[e - 1] : l.type,
                      s = a.parse(n, 1 + r.length, i);
                    if (!s) {
                      o = !0;
                      break;
                    }
                    r.push(s);
                  }
                  if (!o)
                    if (Array.isArray(l) && l.length !== r.length)
                      a.error(
                        `Expected ${l.length} arguments, but found ${r.length} instead.`
                      );
                    else {
                      for (let t = 0; t < r.length; t++) {
                        const e = Array.isArray(l) ? l[t] : l.type,
                          n = r[t];
                        a.concat(t + 1).checkSubtype(e, n.type);
                      }
                      if (0 === a.errors.length) return new Oe(n, i, c, r);
                    }
                }
                if (1 === s.length) e.errors.push(...a.errors);
                else {
                  const n = (s.length ? s : o)
                      .map(([t]) => {
                        return (
                          (e = t),
                          Array.isArray(e)
                            ? `(${e.map(ie).join(", ")})`
                            : `(${ie(e.type)}...)`
                        );
                        var e;
                      })
                      .join(" | "),
                    r = [];
                  for (let i = 1; i < t.length; i++) {
                    const n = e.parse(t[i], 1 + r.length);
                    if (!n) return null;
                    r.push(ie(n.type));
                  }
                  e.error(
                    `Expected arguments of type ${n}, but found (${r.join(
                      ", "
                    )}) instead.`
                  );
                }
                return null;
              }
              static register(t, e) {
                Oe.definitions = e;
                for (const n in e) t[n] = Oe;
              }
            }
            class ke {
              constructor(t, e, n) {
                (this.type = te),
                  (this.locale = n),
                  (this.caseSensitive = t),
                  (this.diacriticSensitive = e);
              }
              static parse(t, e) {
                if (2 !== t.length) return e.error("Expected one argument.");
                const n = t[1];
                if ("object" != typeof n || Array.isArray(n))
                  return e.error(
                    "Collator options argument must be an object."
                  );
                const r = e.parse(
                  void 0 !== n["case-sensitive"] && n["case-sensitive"],
                  1,
                  Kt
                );
                if (!r) return null;
                const i = e.parse(
                  void 0 !== n["diacritic-sensitive"] &&
                    n["diacritic-sensitive"],
                  1,
                  Kt
                );
                if (!i) return null;
                let o = null;
                return n.locale && ((o = e.parse(n.locale, 1, Xt)), !o)
                  ? null
                  : new ke(r, i, o);
              }
              evaluate(t) {
                return new pe(
                  this.caseSensitive.evaluate(t),
                  this.diacriticSensitive.evaluate(t),
                  this.locale ? this.locale.evaluate(t) : null
                );
              }
              eachChild(t) {
                t(this.caseSensitive),
                  t(this.diacriticSensitive),
                  this.locale && t(this.locale);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                const t = {};
                return (
                  (t["case-sensitive"] = this.caseSensitive.serialize()),
                  (t["diacritic-sensitive"] =
                    this.diacriticSensitive.serialize()),
                  this.locale && (t.locale = this.locale.serialize()),
                  ["collator", t]
                );
              }
            }
            const Ie = 8192;
            function De(t, e) {
              (t[0] = Math.min(t[0], e[0])),
                (t[1] = Math.min(t[1], e[1])),
                (t[2] = Math.max(t[2], e[0])),
                (t[3] = Math.max(t[3], e[1]));
            }
            function ze(t, e) {
              return !(
                t[0] <= e[0] ||
                t[2] >= e[2] ||
                t[1] <= e[1] ||
                t[3] >= e[3]
              );
            }
            function Re(t, e) {
              const n = (180 + t[0]) / 360,
                r =
                  (180 -
                    (180 / Math.PI) *
                      Math.log(
                        Math.tan(Math.PI / 4 + (t[1] * Math.PI) / 360)
                      )) /
                  360,
                i = Math.pow(2, e.z);
              return [Math.round(n * i * Ie), Math.round(r * i * Ie)];
            }
            function Le(t, e, n) {
              const r = t[0] - e[0],
                i = t[1] - e[1],
                o = t[0] - n[0],
                s = t[1] - n[1];
              return r * s - o * i == 0 && r * o <= 0 && i * s <= 0;
            }
            function Fe(t, e) {
              let n = !1;
              for (let s = 0, a = e.length; s < a; s++) {
                const a = e[s];
                for (let e = 0, s = a.length; e < s - 1; e++) {
                  if (Le(t, a[e], a[e + 1])) return !1;
                  (i = a[e])[1] > (r = t)[1] != (o = a[e + 1])[1] > r[1] &&
                    r[0] <
                      ((o[0] - i[0]) * (r[1] - i[1])) / (o[1] - i[1]) + i[0] &&
                    (n = !n);
                }
              }
              var r, i, o;
              return n;
            }
            function Be(t, e) {
              for (let n = 0; n < e.length; n++) if (Fe(t, e[n])) return !0;
              return !1;
            }
            function Ne(t, e, n, r) {
              const i = r[0] - n[0],
                o = r[1] - n[1],
                s = (t[0] - n[0]) * o - i * (t[1] - n[1]),
                a = (e[0] - n[0]) * o - i * (e[1] - n[1]);
              return (s > 0 && a < 0) || (s < 0 && a > 0);
            }
            function je(t, e, n) {
              for (const c of n)
                for (let n = 0; n < c.length - 1; ++n)
                  if (
                    0 !=
                      (a = [
                        (s = c[n + 1])[0] - (o = c[n])[0],
                        s[1] - o[1],
                      ])[0] *
                        (l = [(i = e)[0] - (r = t)[0], i[1] - r[1]])[1] -
                        a[1] * l[0] &&
                    Ne(r, i, o, s) &&
                    Ne(o, s, r, i)
                  )
                    return !0;
              var r, i, o, s, a, l;
              return !1;
            }
            function Ue(t, e) {
              for (let n = 0; n < t.length; ++n) if (!Fe(t[n], e)) return !1;
              for (let n = 0; n < t.length - 1; ++n)
                if (je(t[n], t[n + 1], e)) return !1;
              return !0;
            }
            function Ze(t, e) {
              for (let n = 0; n < e.length; n++) if (Ue(t, e[n])) return !0;
              return !1;
            }
            function Ve(t, e, n) {
              const r = [];
              for (let i = 0; i < t.length; i++) {
                const o = [];
                for (let r = 0; r < t[i].length; r++) {
                  const s = Re(t[i][r], n);
                  De(e, s), o.push(s);
                }
                r.push(o);
              }
              return r;
            }
            function qe(t, e, n) {
              const r = [];
              for (let i = 0; i < t.length; i++) {
                const o = Ve(t[i], e, n);
                r.push(o);
              }
              return r;
            }
            function $e(t, e, n, r) {
              if (t[0] < n[0] || t[0] > n[2]) {
                const e = 0.5 * r;
                let i = t[0] - n[0] > e ? -r : n[0] - t[0] > e ? r : 0;
                0 === i && (i = t[0] - n[2] > e ? -r : n[2] - t[0] > e ? r : 0),
                  (t[0] += i);
              }
              De(e, t);
            }
            function Ge(t, e, n, r) {
              const i = Math.pow(2, r.z) * Ie,
                o = [r.x * Ie, r.y * Ie],
                s = [];
              for (const a of t)
                for (const t of a) {
                  const r = [t.x + o[0], t.y + o[1]];
                  $e(r, e, n, i), s.push(r);
                }
              return s;
            }
            function We(t, e, n, r) {
              const i = Math.pow(2, r.z) * Ie,
                o = [r.x * Ie, r.y * Ie],
                s = [];
              for (const l of t) {
                const t = [];
                for (const n of l) {
                  const r = [n.x + o[0], n.y + o[1]];
                  De(e, r), t.push(r);
                }
                s.push(t);
              }
              if (e[2] - e[0] <= i / 2) {
                ((a = e)[0] = a[1] = 1 / 0), (a[2] = a[3] = -1 / 0);
                for (const t of s) for (const r of t) $e(r, e, n, i);
              }
              var a;
              return s;
            }
            class He {
              constructor(t, e) {
                (this.type = Kt), (this.geojson = t), (this.geometries = e);
              }
              static parse(t, e) {
                if (2 !== t.length)
                  return e.error(
                    `'within' expression requires exactly one argument, but found ${
                      t.length - 1
                    } instead.`
                  );
                if (ye(t[1])) {
                  const e = t[1];
                  if ("FeatureCollection" === e.type)
                    for (let t = 0; t < e.features.length; ++t) {
                      const n = e.features[t].geometry.type;
                      if ("Polygon" === n || "MultiPolygon" === n)
                        return new He(e, e.features[t].geometry);
                    }
                  else if ("Feature" === e.type) {
                    const t = e.geometry.type;
                    if ("Polygon" === t || "MultiPolygon" === t)
                      return new He(e, e.geometry);
                  } else if ("Polygon" === e.type || "MultiPolygon" === e.type)
                    return new He(e, e);
                }
                return e.error(
                  "'within' expression requires valid geojson object that contains polygon geometry type."
                );
              }
              evaluate(t) {
                if (null != t.geometry() && null != t.canonicalID()) {
                  if ("Point" === t.geometryType())
                    return (function (t, e) {
                      const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        i = t.canonicalID();
                      if ("Polygon" === e.type) {
                        const o = Ve(e.coordinates, r, i),
                          s = Ge(t.geometry(), n, r, i);
                        if (!ze(n, r)) return !1;
                        for (const t of s) if (!Fe(t, o)) return !1;
                      }
                      if ("MultiPolygon" === e.type) {
                        const o = qe(e.coordinates, r, i),
                          s = Ge(t.geometry(), n, r, i);
                        if (!ze(n, r)) return !1;
                        for (const t of s) if (!Be(t, o)) return !1;
                      }
                      return !0;
                    })(t, this.geometries);
                  if ("LineString" === t.geometryType())
                    return (function (t, e) {
                      const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        i = t.canonicalID();
                      if ("Polygon" === e.type) {
                        const o = Ve(e.coordinates, r, i),
                          s = We(t.geometry(), n, r, i);
                        if (!ze(n, r)) return !1;
                        for (const t of s) if (!Ue(t, o)) return !1;
                      }
                      if ("MultiPolygon" === e.type) {
                        const o = qe(e.coordinates, r, i),
                          s = We(t.geometry(), n, r, i);
                        if (!ze(n, r)) return !1;
                        for (const t of s) if (!Ze(t, o)) return !1;
                      }
                      return !0;
                    })(t, this.geometries);
                }
                return !1;
              }
              eachChild() {}
              outputDefined() {
                return !0;
              }
              serialize() {
                return ["within", this.geojson];
              }
            }
            function Xe(t) {
              if (t instanceof Oe) {
                if ("get" === t.name && 1 === t.args.length) return !1;
                if ("feature-state" === t.name) return !1;
                if ("has" === t.name && 1 === t.args.length) return !1;
                if (
                  "properties" === t.name ||
                  "geometry-type" === t.name ||
                  "id" === t.name
                )
                  return !1;
                if (/^filter-/.test(t.name)) return !1;
              }
              if (t instanceof He) return !1;
              let e = !0;
              return (
                t.eachChild((t) => {
                  e && !Xe(t) && (e = !1);
                }),
                e
              );
            }
            function Ke(t) {
              if (t instanceof Oe && "feature-state" === t.name) return !1;
              let e = !0;
              return (
                t.eachChild((t) => {
                  e && !Ke(t) && (e = !1);
                }),
                e
              );
            }
            function Ye(t, e) {
              if (t instanceof Oe && e.indexOf(t.name) >= 0) return !1;
              let n = !0;
              return (
                t.eachChild((t) => {
                  n && !Ye(t, e) && (n = !1);
                }),
                n
              );
            }
            class Qe {
              constructor(t, e) {
                (this.type = e.type),
                  (this.name = t),
                  (this.boundExpression = e);
              }
              static parse(t, e) {
                if (2 !== t.length || "string" != typeof t[1])
                  return e.error(
                    "'var' expression requires exactly one string literal argument."
                  );
                const n = t[1];
                return e.scope.has(n)
                  ? new Qe(n, e.scope.get(n))
                  : e.error(
                      `Unknown variable "${n}". Make sure "${n}" has been bound in an enclosing "let" expression before using it.`,
                      1
                    );
              }
              evaluate(t) {
                return this.boundExpression.evaluate(t);
              }
              eachChild() {}
              outputDefined() {
                return !1;
              }
              serialize() {
                return ["var", this.name];
              }
            }
            class Je {
              constructor(t, e = [], n, r = new Gt(), i = []) {
                (this.registry = t),
                  (this.path = e),
                  (this.key = e.map((t) => `[${t}]`).join("")),
                  (this.scope = r),
                  (this.errors = i),
                  (this.expectedType = n);
              }
              parse(t, e, n, r, i = {}) {
                return e
                  ? this.concat(e, n, r)._parse(t, i)
                  : this._parse(t, i);
              }
              _parse(t, e) {
                function n(t, e, n) {
                  return "assert" === n
                    ? new Se(e, [t])
                    : "coerce" === n
                    ? new Ce(e, [t])
                    : t;
                }
                if (
                  ((null !== t &&
                    "string" != typeof t &&
                    "boolean" != typeof t &&
                    "number" != typeof t) ||
                    (t = ["literal", t]),
                  Array.isArray(t))
                ) {
                  if (0 === t.length)
                    return this.error(
                      'Expected an array with at least one element. If you wanted a literal array, use ["literal", []].'
                    );
                  const r = t[0];
                  if ("string" != typeof r)
                    return (
                      this.error(
                        `Expression name must be a string, but found ${typeof r} instead. If you wanted a literal array, use ["literal", [...]].`,
                        0
                      ),
                      null
                    );
                  const i = this.registry[r];
                  if (i) {
                    let r = i.parse(t, this);
                    if (!r) return null;
                    if (this.expectedType) {
                      const t = this.expectedType,
                        i = r.type;
                      if (
                        ("string" !== t.kind &&
                          "number" !== t.kind &&
                          "boolean" !== t.kind &&
                          "object" !== t.kind &&
                          "array" !== t.kind) ||
                        "value" !== i.kind
                      )
                        if (
                          ("color" !== t.kind &&
                            "formatted" !== t.kind &&
                            "resolvedImage" !== t.kind) ||
                          ("value" !== i.kind && "string" !== i.kind)
                        ) {
                          if (this.checkSubtype(t, i)) return null;
                        } else r = n(r, t, e.typeAnnotation || "coerce");
                      else r = n(r, t, e.typeAnnotation || "assert");
                    }
                    if (
                      !(r instanceof be) &&
                      "resolvedImage" !== r.type.kind &&
                      tn(r)
                    ) {
                      const e = new Me();
                      try {
                        r = new be(r.type, r.evaluate(e));
                      } catch (t) {
                        return this.error(t.message), null;
                      }
                    }
                    return r;
                  }
                  return this.error(
                    `Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`,
                    0
                  );
                }
                return this.error(
                  void 0 === t
                    ? "'undefined' value invalid. Use null instead."
                    : "object" == typeof t
                    ? 'Bare objects invalid. Use ["literal", {...}] instead.'
                    : `Expected an array, but found ${typeof t} instead.`
                );
              }
              concat(t, e, n) {
                const r =
                    "number" == typeof t ? this.path.concat(t) : this.path,
                  i = n ? this.scope.concat(n) : this.scope;
                return new Je(this.registry, r, e || null, i, this.errors);
              }
              error(t, ...e) {
                const n = `${this.key}${e.map((t) => `[${t}]`).join("")}`;
                this.errors.push(new $t(n, t));
              }
              checkSubtype(t, e) {
                const n = se(t, e);
                return n && this.error(n), n;
              }
            }
            function tn(t) {
              if (t instanceof Qe) return tn(t.boundExpression);
              if (t instanceof Oe && "error" === t.name) return !1;
              if (t instanceof ke) return !1;
              if (t instanceof He) return !1;
              const e = t instanceof Ce || t instanceof Se;
              let n = !0;
              return (
                t.eachChild((t) => {
                  n = e ? n && tn(t) : n && t instanceof be;
                }),
                !!n &&
                  Xe(t) &&
                  Ye(t, [
                    "zoom",
                    "heatmap-density",
                    "line-progress",
                    "sky-radial-progress",
                    "accumulated",
                    "is-supported-script",
                  ])
              );
            }
            function en(t, e) {
              const n = t.length - 1;
              let r,
                i,
                o = 0,
                s = n,
                a = 0;
              for (; o <= s; )
                if (
                  ((a = Math.floor((o + s) / 2)),
                  (r = t[a]),
                  (i = t[a + 1]),
                  r <= e)
                ) {
                  if (a === n || e < i) return a;
                  o = a + 1;
                } else {
                  if (!(r > e)) throw new xe("Input is not a number.");
                  s = a - 1;
                }
              return 0;
            }
            class nn {
              constructor(t, e, n) {
                (this.type = t),
                  (this.input = e),
                  (this.labels = []),
                  (this.outputs = []);
                for (const [r, i] of n)
                  this.labels.push(r), this.outputs.push(i);
              }
              static parse(t, e) {
                if (t.length - 1 < 4)
                  return e.error(
                    `Expected at least 4 arguments, but found only ${
                      t.length - 1
                    }.`
                  );
                if ((t.length - 1) % 2 != 0)
                  return e.error("Expected an even number of arguments.");
                const n = e.parse(t[1], 1, Ht);
                if (!n) return null;
                const r = [];
                let i = null;
                e.expectedType &&
                  "value" !== e.expectedType.kind &&
                  (i = e.expectedType);
                for (let o = 1; o < t.length; o += 2) {
                  const n = 1 === o ? -1 / 0 : t[o],
                    s = t[o + 1],
                    a = o,
                    l = o + 1;
                  if ("number" != typeof n)
                    return e.error(
                      'Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
                      a
                    );
                  if (r.length && r[r.length - 1][0] >= n)
                    return e.error(
                      'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',
                      a
                    );
                  const c = e.parse(s, l, i);
                  if (!c) return null;
                  (i = i || c.type), r.push([n, c]);
                }
                return new nn(i, n, r);
              }
              evaluate(t) {
                const e = this.labels,
                  n = this.outputs;
                if (1 === e.length) return n[0].evaluate(t);
                const r = this.input.evaluate(t);
                if (r <= e[0]) return n[0].evaluate(t);
                const i = e.length;
                return r >= e[i - 1]
                  ? n[i - 1].evaluate(t)
                  : n[en(e, r)].evaluate(t);
              }
              eachChild(t) {
                t(this.input);
                for (const e of this.outputs) t(e);
              }
              outputDefined() {
                return this.outputs.every((t) => t.outputDefined());
              }
              serialize() {
                const t = ["step", this.input.serialize()];
                for (let e = 0; e < this.labels.length; e++)
                  e > 0 && t.push(this.labels[e]),
                    t.push(this.outputs[e].serialize());
                return t;
              }
            }
            function rn(t, e, n) {
              return t * (1 - n) + e * n;
            }
            var on = Object.freeze({
              __proto__: null,
              number: rn,
              color: function (t, e, n) {
                return new he(
                  rn(t.r, e.r, n),
                  rn(t.g, e.g, n),
                  rn(t.b, e.b, n),
                  rn(t.a, e.a, n)
                );
              },
              array: function (t, e, n) {
                return t.map((t, r) => rn(t, e[r], n));
              },
            });
            const sn = 0.95047,
              an = 1.08883,
              ln = 4 / 29,
              cn = 6 / 29,
              un = 3 * cn * cn,
              hn = Math.PI / 180,
              pn = 180 / Math.PI;
            function dn(t) {
              return t > 0.008856451679035631
                ? Math.pow(t, 1 / 3)
                : t / un + ln;
            }
            function fn(t) {
              return t > cn ? t * t * t : un * (t - ln);
            }
            function mn(t) {
              return (
                255 *
                (t <= 0.0031308
                  ? 12.92 * t
                  : 1.055 * Math.pow(t, 1 / 2.4) - 0.055)
              );
            }
            function gn(t) {
              return (t /= 255) <= 0.04045
                ? t / 12.92
                : Math.pow((t + 0.055) / 1.055, 2.4);
            }
            function yn(t) {
              const e = gn(t.r),
                n = gn(t.g),
                r = gn(t.b),
                i = dn((0.4124564 * e + 0.3575761 * n + 0.1804375 * r) / sn),
                o = dn((0.2126729 * e + 0.7151522 * n + 0.072175 * r) / 1);
              return {
                l: 116 * o - 16,
                a: 500 * (i - o),
                b:
                  200 *
                  (o - dn((0.0193339 * e + 0.119192 * n + 0.9503041 * r) / an)),
                alpha: t.a,
              };
            }
            function _n(t) {
              let e = (t.l + 16) / 116,
                n = isNaN(t.a) ? e : e + t.a / 500,
                r = isNaN(t.b) ? e : e - t.b / 200;
              return (
                (e = 1 * fn(e)),
                (n = sn * fn(n)),
                (r = an * fn(r)),
                new he(
                  mn(3.2404542 * n - 1.5371385 * e - 0.4985314 * r),
                  mn(-0.969266 * n + 1.8760108 * e + 0.041556 * r),
                  mn(0.0556434 * n - 0.2040259 * e + 1.0572252 * r),
                  t.alpha
                )
              );
            }
            function vn(t, e, n) {
              const r = e - t;
              return (
                t +
                n * (r > 180 || r < -180 ? r - 360 * Math.round(r / 360) : r)
              );
            }
            const bn = {
                forward: yn,
                reverse: _n,
                interpolate: function (t, e, n) {
                  return {
                    l: rn(t.l, e.l, n),
                    a: rn(t.a, e.a, n),
                    b: rn(t.b, e.b, n),
                    alpha: rn(t.alpha, e.alpha, n),
                  };
                },
              },
              xn = {
                forward: function (t) {
                  const { l: e, a: n, b: r } = yn(t),
                    i = Math.atan2(r, n) * pn;
                  return {
                    h: i < 0 ? i + 360 : i,
                    c: Math.sqrt(n * n + r * r),
                    l: e,
                    alpha: t.a,
                  };
                },
                reverse: function (t) {
                  const e = t.h * hn,
                    n = t.c;
                  return _n({
                    l: t.l,
                    a: Math.cos(e) * n,
                    b: Math.sin(e) * n,
                    alpha: t.alpha,
                  });
                },
                interpolate: function (t, e, n) {
                  return {
                    h: vn(t.h, e.h, n),
                    c: rn(t.c, e.c, n),
                    l: rn(t.l, e.l, n),
                    alpha: rn(t.alpha, e.alpha, n),
                  };
                },
              };
            var wn = Object.freeze({ __proto__: null, lab: bn, hcl: xn });
            class Sn {
              constructor(t, e, n, r, i) {
                (this.type = t),
                  (this.operator = e),
                  (this.interpolation = n),
                  (this.input = r),
                  (this.labels = []),
                  (this.outputs = []);
                for (const [o, s] of i)
                  this.labels.push(o), this.outputs.push(s);
              }
              static interpolationFactor(t, e, r, i) {
                let o = 0;
                if ("exponential" === t.name) o = En(e, t.base, r, i);
                else if ("linear" === t.name) o = En(e, 1, r, i);
                else if ("cubic-bezier" === t.name) {
                  const s = t.controlPoints;
                  o = new n(s[0], s[1], s[2], s[3]).solve(En(e, 1, r, i));
                }
                return o;
              }
              static parse(t, e) {
                let [n, r, i, ...o] = t;
                if (!Array.isArray(r) || 0 === r.length)
                  return e.error(
                    "Expected an interpolation type expression.",
                    1
                  );
                if ("linear" === r[0]) r = { name: "linear" };
                else if ("exponential" === r[0]) {
                  const t = r[1];
                  if ("number" != typeof t)
                    return e.error(
                      "Exponential interpolation requires a numeric base.",
                      1,
                      1
                    );
                  r = { name: "exponential", base: t };
                } else {
                  if ("cubic-bezier" !== r[0])
                    return e.error(
                      `Unknown interpolation type ${String(r[0])}`,
                      1,
                      0
                    );
                  {
                    const t = r.slice(1);
                    if (
                      4 !== t.length ||
                      t.some((t) => "number" != typeof t || t < 0 || t > 1)
                    )
                      return e.error(
                        "Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",
                        1
                      );
                    r = { name: "cubic-bezier", controlPoints: t };
                  }
                }
                if (t.length - 1 < 4)
                  return e.error(
                    `Expected at least 4 arguments, but found only ${
                      t.length - 1
                    }.`
                  );
                if ((t.length - 1) % 2 != 0)
                  return e.error("Expected an even number of arguments.");
                if (((i = e.parse(i, 2, Ht)), !i)) return null;
                const s = [];
                let a = null;
                "interpolate-hcl" === n || "interpolate-lab" === n
                  ? (a = Yt)
                  : e.expectedType &&
                    "value" !== e.expectedType.kind &&
                    (a = e.expectedType);
                for (let l = 0; l < o.length; l += 2) {
                  const t = o[l],
                    n = o[l + 1],
                    r = l + 3,
                    i = l + 4;
                  if ("number" != typeof t)
                    return e.error(
                      'Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
                      r
                    );
                  if (s.length && s[s.length - 1][0] >= t)
                    return e.error(
                      'Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',
                      r
                    );
                  const c = e.parse(n, i, a);
                  if (!c) return null;
                  (a = a || c.type), s.push([t, c]);
                }
                return "number" === a.kind ||
                  "color" === a.kind ||
                  ("array" === a.kind &&
                    "number" === a.itemType.kind &&
                    "number" == typeof a.N)
                  ? new Sn(a, n, r, i, s)
                  : e.error(`Type ${ie(a)} is not interpolatable.`);
              }
              evaluate(t) {
                const e = this.labels,
                  n = this.outputs;
                if (1 === e.length) return n[0].evaluate(t);
                const r = this.input.evaluate(t);
                if (r <= e[0]) return n[0].evaluate(t);
                const i = e.length;
                if (r >= e[i - 1]) return n[i - 1].evaluate(t);
                const o = en(e, r),
                  s = Sn.interpolationFactor(
                    this.interpolation,
                    r,
                    e[o],
                    e[o + 1]
                  ),
                  a = n[o].evaluate(t),
                  l = n[o + 1].evaluate(t);
                return "interpolate" === this.operator
                  ? on[this.type.kind.toLowerCase()](a, l, s)
                  : "interpolate-hcl" === this.operator
                  ? xn.reverse(xn.interpolate(xn.forward(a), xn.forward(l), s))
                  : bn.reverse(bn.interpolate(bn.forward(a), bn.forward(l), s));
              }
              eachChild(t) {
                t(this.input);
                for (const e of this.outputs) t(e);
              }
              outputDefined() {
                return this.outputs.every((t) => t.outputDefined());
              }
              serialize() {
                let t;
                t =
                  "linear" === this.interpolation.name
                    ? ["linear"]
                    : "exponential" === this.interpolation.name
                    ? 1 === this.interpolation.base
                      ? ["linear"]
                      : ["exponential", this.interpolation.base]
                    : ["cubic-bezier"].concat(this.interpolation.controlPoints);
                const e = [this.operator, t, this.input.serialize()];
                for (let n = 0; n < this.labels.length; n++)
                  e.push(this.labels[n], this.outputs[n].serialize());
                return e;
              }
            }
            function En(t, e, n, r) {
              const i = r - n,
                o = t - n;
              return 0 === i
                ? 0
                : 1 === e
                ? o / i
                : (Math.pow(e, o) - 1) / (Math.pow(e, i) - 1);
            }
            class Tn {
              constructor(t, e) {
                (this.type = t), (this.args = e);
              }
              static parse(t, e) {
                if (t.length < 2)
                  return e.error("Expectected at least one argument.");
                let n = null;
                const r = e.expectedType;
                r && "value" !== r.kind && (n = r);
                const i = [];
                for (const s of t.slice(1)) {
                  const t = e.parse(s, 1 + i.length, n, void 0, {
                    typeAnnotation: "omit",
                  });
                  if (!t) return null;
                  (n = n || t.type), i.push(t);
                }
                const o = r && i.some((t) => se(r, t.type));
                return new Tn(o ? Jt : n, i);
              }
              evaluate(t) {
                let e,
                  n = null,
                  r = 0;
                for (const i of this.args)
                  if (
                    (r++,
                    (n = i.evaluate(t)),
                    n &&
                      n instanceof me &&
                      !n.available &&
                      (e || (e = n.name),
                      (n = null),
                      r === this.args.length && (n = e)),
                    null !== n)
                  )
                    break;
                return n;
              }
              eachChild(t) {
                this.args.forEach(t);
              }
              outputDefined() {
                return this.args.every((t) => t.outputDefined());
              }
              serialize() {
                const t = ["coalesce"];
                return (
                  this.eachChild((e) => {
                    t.push(e.serialize());
                  }),
                  t
                );
              }
            }
            class An {
              constructor(t, e) {
                (this.type = e.type),
                  (this.bindings = [].concat(t)),
                  (this.result = e);
              }
              evaluate(t) {
                return this.result.evaluate(t);
              }
              eachChild(t) {
                for (const e of this.bindings) t(e[1]);
                t(this.result);
              }
              static parse(t, e) {
                if (t.length < 4)
                  return e.error(
                    `Expected at least 3 arguments, but found ${
                      t.length - 1
                    } instead.`
                  );
                const n = [];
                for (let i = 1; i < t.length - 1; i += 2) {
                  const r = t[i];
                  if ("string" != typeof r)
                    return e.error(
                      `Expected string, but found ${typeof r} instead.`,
                      i
                    );
                  if (/[^a-zA-Z0-9_]/.test(r))
                    return e.error(
                      "Variable names must contain only alphanumeric characters or '_'.",
                      i
                    );
                  const o = e.parse(t[i + 1], i + 1);
                  if (!o) return null;
                  n.push([r, o]);
                }
                const r = e.parse(
                  t[t.length - 1],
                  t.length - 1,
                  e.expectedType,
                  n
                );
                return r ? new An(n, r) : null;
              }
              outputDefined() {
                return this.result.outputDefined();
              }
              serialize() {
                const t = ["let"];
                for (const [e, n] of this.bindings) t.push(e, n.serialize());
                return t.push(this.result.serialize()), t;
              }
            }
            class Cn {
              constructor(t, e, n) {
                (this.type = t), (this.index = e), (this.input = n);
              }
              static parse(t, e) {
                if (3 !== t.length)
                  return e.error(
                    `Expected 2 arguments, but found ${t.length - 1} instead.`
                  );
                const n = e.parse(t[1], 1, Ht),
                  r = e.parse(t[2], 2, re(e.expectedType || Jt));
                return n && r ? new Cn(r.type.itemType, n, r) : null;
              }
              evaluate(t) {
                const e = this.index.evaluate(t),
                  n = this.input.evaluate(t);
                if (e < 0) throw new xe(`Array index out of bounds: ${e} < 0.`);
                if (e >= n.length)
                  throw new xe(
                    `Array index out of bounds: ${e} > ${n.length - 1}.`
                  );
                if (e !== Math.floor(e))
                  throw new xe(
                    `Array index must be an integer, but found ${e} instead.`
                  );
                return n[e];
              }
              eachChild(t) {
                t(this.index), t(this.input);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                return ["at", this.index.serialize(), this.input.serialize()];
              }
            }
            class Pn {
              constructor(t, e) {
                (this.type = Kt), (this.needle = t), (this.haystack = e);
              }
              static parse(t, e) {
                if (3 !== t.length)
                  return e.error(
                    `Expected 2 arguments, but found ${t.length - 1} instead.`
                  );
                const n = e.parse(t[1], 1, Jt),
                  r = e.parse(t[2], 2, Jt);
                return n && r
                  ? ae(n.type, [Kt, Xt, Ht, Wt, Jt])
                    ? new Pn(n, r)
                    : e.error(
                        `Expected first argument to be of type boolean, string, number or null, but found ${ie(
                          n.type
                        )} instead`
                      )
                  : null;
              }
              evaluate(t) {
                const e = this.needle.evaluate(t),
                  n = this.haystack.evaluate(t);
                if (!n) return !1;
                if (!le(e, ["boolean", "string", "number", "null"]))
                  throw new xe(
                    `Expected first argument to be of type boolean, string, number or null, but found ${ie(
                      _e(e)
                    )} instead.`
                  );
                if (!le(n, ["string", "array"]))
                  throw new xe(
                    `Expected second argument to be of type array or string, but found ${ie(
                      _e(n)
                    )} instead.`
                  );
                return n.indexOf(e) >= 0;
              }
              eachChild(t) {
                t(this.needle), t(this.haystack);
              }
              outputDefined() {
                return !0;
              }
              serialize() {
                return [
                  "in",
                  this.needle.serialize(),
                  this.haystack.serialize(),
                ];
              }
            }
            class Mn {
              constructor(t, e, n) {
                (this.type = Ht),
                  (this.needle = t),
                  (this.haystack = e),
                  (this.fromIndex = n);
              }
              static parse(t, e) {
                if (t.length <= 2 || t.length >= 5)
                  return e.error(
                    `Expected 3 or 4 arguments, but found ${
                      t.length - 1
                    } instead.`
                  );
                const n = e.parse(t[1], 1, Jt),
                  r = e.parse(t[2], 2, Jt);
                if (!n || !r) return null;
                if (!ae(n.type, [Kt, Xt, Ht, Wt, Jt]))
                  return e.error(
                    `Expected first argument to be of type boolean, string, number or null, but found ${ie(
                      n.type
                    )} instead`
                  );
                if (4 === t.length) {
                  const i = e.parse(t[3], 3, Ht);
                  return i ? new Mn(n, r, i) : null;
                }
                return new Mn(n, r);
              }
              evaluate(t) {
                const e = this.needle.evaluate(t),
                  n = this.haystack.evaluate(t);
                if (!le(e, ["boolean", "string", "number", "null"]))
                  throw new xe(
                    `Expected first argument to be of type boolean, string, number or null, but found ${ie(
                      _e(e)
                    )} instead.`
                  );
                if (!le(n, ["string", "array"]))
                  throw new xe(
                    `Expected second argument to be of type array or string, but found ${ie(
                      _e(n)
                    )} instead.`
                  );
                if (this.fromIndex) {
                  const r = this.fromIndex.evaluate(t);
                  return n.indexOf(e, r);
                }
                return n.indexOf(e);
              }
              eachChild(t) {
                t(this.needle),
                  t(this.haystack),
                  this.fromIndex && t(this.fromIndex);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                if (null != this.fromIndex && void 0 !== this.fromIndex) {
                  const t = this.fromIndex.serialize();
                  return [
                    "index-of",
                    this.needle.serialize(),
                    this.haystack.serialize(),
                    t,
                  ];
                }
                return [
                  "index-of",
                  this.needle.serialize(),
                  this.haystack.serialize(),
                ];
              }
            }
            class On {
              constructor(t, e, n, r, i, o) {
                (this.inputType = t),
                  (this.type = e),
                  (this.input = n),
                  (this.cases = r),
                  (this.outputs = i),
                  (this.otherwise = o);
              }
              static parse(t, e) {
                if (t.length < 5)
                  return e.error(
                    `Expected at least 4 arguments, but found only ${
                      t.length - 1
                    }.`
                  );
                if (t.length % 2 != 1)
                  return e.error("Expected an even number of arguments.");
                let n, r;
                e.expectedType &&
                  "value" !== e.expectedType.kind &&
                  (r = e.expectedType);
                const i = {},
                  o = [];
                for (let l = 2; l < t.length - 1; l += 2) {
                  let s = t[l];
                  const a = t[l + 1];
                  Array.isArray(s) || (s = [s]);
                  const c = e.concat(l);
                  if (0 === s.length)
                    return c.error("Expected at least one branch label.");
                  for (const t of s) {
                    if ("number" != typeof t && "string" != typeof t)
                      return c.error(
                        "Branch labels must be numbers or strings."
                      );
                    if (
                      "number" == typeof t &&
                      Math.abs(t) > Number.MAX_SAFE_INTEGER
                    )
                      return c.error(
                        `Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`
                      );
                    if ("number" == typeof t && Math.floor(t) !== t)
                      return c.error(
                        "Numeric branch labels must be integer values."
                      );
                    if (n) {
                      if (c.checkSubtype(n, _e(t))) return null;
                    } else n = _e(t);
                    if (void 0 !== i[String(t)])
                      return c.error("Branch labels must be unique.");
                    i[String(t)] = o.length;
                  }
                  const u = e.parse(a, l, r);
                  if (!u) return null;
                  (r = r || u.type), o.push(u);
                }
                const s = e.parse(t[1], 1, Jt);
                if (!s) return null;
                const a = e.parse(t[t.length - 1], t.length - 1, r);
                return a
                  ? "value" !== s.type.kind &&
                    e.concat(1).checkSubtype(n, s.type)
                    ? null
                    : new On(n, r, s, i, o, a)
                  : null;
              }
              evaluate(t) {
                const e = this.input.evaluate(t);
                return (
                  (_e(e) === this.inputType && this.outputs[this.cases[e]]) ||
                  this.otherwise
                ).evaluate(t);
              }
              eachChild(t) {
                t(this.input), this.outputs.forEach(t), t(this.otherwise);
              }
              outputDefined() {
                return (
                  this.outputs.every((t) => t.outputDefined()) &&
                  this.otherwise.outputDefined()
                );
              }
              serialize() {
                const t = ["match", this.input.serialize()],
                  e = Object.keys(this.cases).sort(),
                  n = [],
                  r = {};
                for (const o of e) {
                  const t = r[this.cases[o]];
                  void 0 === t
                    ? ((r[this.cases[o]] = n.length),
                      n.push([this.cases[o], [o]]))
                    : n[t][1].push(o);
                }
                const i = (t) =>
                  "number" === this.inputType.kind ? Number(t) : t;
                for (const [o, s] of n)
                  t.push(1 === s.length ? i(s[0]) : s.map(i)),
                    t.push(this.outputs[o].serialize());
                return t.push(this.otherwise.serialize()), t;
              }
            }
            class kn {
              constructor(t, e, n) {
                (this.type = t), (this.branches = e), (this.otherwise = n);
              }
              static parse(t, e) {
                if (t.length < 4)
                  return e.error(
                    `Expected at least 3 arguments, but found only ${
                      t.length - 1
                    }.`
                  );
                if (t.length % 2 != 0)
                  return e.error("Expected an odd number of arguments.");
                let n;
                e.expectedType &&
                  "value" !== e.expectedType.kind &&
                  (n = e.expectedType);
                const r = [];
                for (let o = 1; o < t.length - 1; o += 2) {
                  const i = e.parse(t[o], o, Kt);
                  if (!i) return null;
                  const s = e.parse(t[o + 1], o + 1, n);
                  if (!s) return null;
                  r.push([i, s]), (n = n || s.type);
                }
                const i = e.parse(t[t.length - 1], t.length - 1, n);
                return i ? new kn(n, r, i) : null;
              }
              evaluate(t) {
                for (const [e, n] of this.branches)
                  if (e.evaluate(t)) return n.evaluate(t);
                return this.otherwise.evaluate(t);
              }
              eachChild(t) {
                for (const [e, n] of this.branches) t(e), t(n);
                t(this.otherwise);
              }
              outputDefined() {
                return (
                  this.branches.every(([t, e]) => e.outputDefined()) &&
                  this.otherwise.outputDefined()
                );
              }
              serialize() {
                const t = ["case"];
                return (
                  this.eachChild((e) => {
                    t.push(e.serialize());
                  }),
                  t
                );
              }
            }
            class In {
              constructor(t, e, n, r) {
                (this.type = t),
                  (this.input = e),
                  (this.beginIndex = n),
                  (this.endIndex = r);
              }
              static parse(t, e) {
                if (t.length <= 2 || t.length >= 5)
                  return e.error(
                    `Expected 3 or 4 arguments, but found ${
                      t.length - 1
                    } instead.`
                  );
                const n = e.parse(t[1], 1, Jt),
                  r = e.parse(t[2], 2, Ht);
                if (!n || !r) return null;
                if (!ae(n.type, [re(Jt), Xt, Jt]))
                  return e.error(
                    `Expected first argument to be of type array or string, but found ${ie(
                      n.type
                    )} instead`
                  );
                if (4 === t.length) {
                  const i = e.parse(t[3], 3, Ht);
                  return i ? new In(n.type, n, r, i) : null;
                }
                return new In(n.type, n, r);
              }
              evaluate(t) {
                const e = this.input.evaluate(t),
                  n = this.beginIndex.evaluate(t);
                if (!le(e, ["string", "array"]))
                  throw new xe(
                    `Expected first argument to be of type array or string, but found ${ie(
                      _e(e)
                    )} instead.`
                  );
                if (this.endIndex) {
                  const r = this.endIndex.evaluate(t);
                  return e.slice(n, r);
                }
                return e.slice(n);
              }
              eachChild(t) {
                t(this.input),
                  t(this.beginIndex),
                  this.endIndex && t(this.endIndex);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                if (null != this.endIndex && void 0 !== this.endIndex) {
                  const t = this.endIndex.serialize();
                  return [
                    "slice",
                    this.input.serialize(),
                    this.beginIndex.serialize(),
                    t,
                  ];
                }
                return [
                  "slice",
                  this.input.serialize(),
                  this.beginIndex.serialize(),
                ];
              }
            }
            function Dn(t, e) {
              return "==" === t || "!=" === t
                ? "boolean" === e.kind ||
                    "string" === e.kind ||
                    "number" === e.kind ||
                    "null" === e.kind ||
                    "value" === e.kind
                : "string" === e.kind ||
                    "number" === e.kind ||
                    "value" === e.kind;
            }
            function zn(t, e, n, r) {
              return 0 === r.compare(e, n);
            }
            function Rn(t, e, n) {
              const r = "==" !== t && "!=" !== t;
              return class i {
                constructor(t, e, n) {
                  (this.type = Kt),
                    (this.lhs = t),
                    (this.rhs = e),
                    (this.collator = n),
                    (this.hasUntypedArgument =
                      "value" === t.type.kind || "value" === e.type.kind);
                }
                static parse(t, e) {
                  if (3 !== t.length && 4 !== t.length)
                    return e.error("Expected two or three arguments.");
                  const n = t[0];
                  let o = e.parse(t[1], 1, Jt);
                  if (!o) return null;
                  if (!Dn(n, o.type))
                    return e
                      .concat(1)
                      .error(
                        `"${n}" comparisons are not supported for type '${ie(
                          o.type
                        )}'.`
                      );
                  let s = e.parse(t[2], 2, Jt);
                  if (!s) return null;
                  if (!Dn(n, s.type))
                    return e
                      .concat(2)
                      .error(
                        `"${n}" comparisons are not supported for type '${ie(
                          s.type
                        )}'.`
                      );
                  if (
                    o.type.kind !== s.type.kind &&
                    "value" !== o.type.kind &&
                    "value" !== s.type.kind
                  )
                    return e.error(
                      `Cannot compare types '${ie(o.type)}' and '${ie(
                        s.type
                      )}'.`
                    );
                  r &&
                    ("value" === o.type.kind && "value" !== s.type.kind
                      ? (o = new Se(s.type, [o]))
                      : "value" !== o.type.kind &&
                        "value" === s.type.kind &&
                        (s = new Se(o.type, [s])));
                  let a = null;
                  if (4 === t.length) {
                    if (
                      "string" !== o.type.kind &&
                      "string" !== s.type.kind &&
                      "value" !== o.type.kind &&
                      "value" !== s.type.kind
                    )
                      return e.error(
                        "Cannot use collator to compare non-string types."
                      );
                    if (((a = e.parse(t[3], 3, te)), !a)) return null;
                  }
                  return new i(o, s, a);
                }
                evaluate(i) {
                  const o = this.lhs.evaluate(i),
                    s = this.rhs.evaluate(i);
                  if (r && this.hasUntypedArgument) {
                    const e = _e(o),
                      n = _e(s);
                    if (
                      e.kind !== n.kind ||
                      ("string" !== e.kind && "number" !== e.kind)
                    )
                      throw new xe(
                        `Expected arguments for "${t}" to be (string, string) or (number, number), but found (${e.kind}, ${n.kind}) instead.`
                      );
                  }
                  if (this.collator && !r && this.hasUntypedArgument) {
                    const t = _e(o),
                      n = _e(s);
                    if ("string" !== t.kind || "string" !== n.kind)
                      return e(i, o, s);
                  }
                  return this.collator
                    ? n(i, o, s, this.collator.evaluate(i))
                    : e(i, o, s);
                }
                eachChild(t) {
                  t(this.lhs), t(this.rhs), this.collator && t(this.collator);
                }
                outputDefined() {
                  return !0;
                }
                serialize() {
                  const e = [t];
                  return (
                    this.eachChild((t) => {
                      e.push(t.serialize());
                    }),
                    e
                  );
                }
              };
            }
            const Ln = Rn(
                "==",
                function (t, e, n) {
                  return e === n;
                },
                zn
              ),
              Fn = Rn(
                "!=",
                function (t, e, n) {
                  return e !== n;
                },
                function (t, e, n, r) {
                  return !zn(0, e, n, r);
                }
              ),
              Bn = Rn(
                "<",
                function (t, e, n) {
                  return e < n;
                },
                function (t, e, n, r) {
                  return r.compare(e, n) < 0;
                }
              ),
              Nn = Rn(
                ">",
                function (t, e, n) {
                  return e > n;
                },
                function (t, e, n, r) {
                  return r.compare(e, n) > 0;
                }
              ),
              jn = Rn(
                "<=",
                function (t, e, n) {
                  return e <= n;
                },
                function (t, e, n, r) {
                  return r.compare(e, n) <= 0;
                }
              ),
              Un = Rn(
                ">=",
                function (t, e, n) {
                  return e >= n;
                },
                function (t, e, n, r) {
                  return r.compare(e, n) >= 0;
                }
              );
            class Zn {
              constructor(t, e, n, r, i) {
                (this.type = Xt),
                  (this.number = t),
                  (this.locale = e),
                  (this.currency = n),
                  (this.minFractionDigits = r),
                  (this.maxFractionDigits = i);
              }
              static parse(t, e) {
                if (3 !== t.length) return e.error("Expected two arguments.");
                const n = e.parse(t[1], 1, Ht);
                if (!n) return null;
                const r = t[2];
                if ("object" != typeof r || Array.isArray(r))
                  return e.error(
                    "NumberFormat options argument must be an object."
                  );
                let i = null;
                if (r.locale && ((i = e.parse(r.locale, 1, Xt)), !i))
                  return null;
                let o = null;
                if (r.currency && ((o = e.parse(r.currency, 1, Xt)), !o))
                  return null;
                let s = null;
                if (
                  r["min-fraction-digits"] &&
                  ((s = e.parse(r["min-fraction-digits"], 1, Ht)), !s)
                )
                  return null;
                let a = null;
                return r["max-fraction-digits"] &&
                  ((a = e.parse(r["max-fraction-digits"], 1, Ht)), !a)
                  ? null
                  : new Zn(n, i, o, s, a);
              }
              evaluate(t) {
                return new Intl.NumberFormat(
                  this.locale ? this.locale.evaluate(t) : [],
                  {
                    style: this.currency ? "currency" : "decimal",
                    currency: this.currency
                      ? this.currency.evaluate(t)
                      : void 0,
                    minimumFractionDigits: this.minFractionDigits
                      ? this.minFractionDigits.evaluate(t)
                      : void 0,
                    maximumFractionDigits: this.maxFractionDigits
                      ? this.maxFractionDigits.evaluate(t)
                      : void 0,
                  }
                ).format(this.number.evaluate(t));
              }
              eachChild(t) {
                t(this.number),
                  this.locale && t(this.locale),
                  this.currency && t(this.currency),
                  this.minFractionDigits && t(this.minFractionDigits),
                  this.maxFractionDigits && t(this.maxFractionDigits);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                const t = {};
                return (
                  this.locale && (t.locale = this.locale.serialize()),
                  this.currency && (t.currency = this.currency.serialize()),
                  this.minFractionDigits &&
                    (t["min-fraction-digits"] =
                      this.minFractionDigits.serialize()),
                  this.maxFractionDigits &&
                    (t["max-fraction-digits"] =
                      this.maxFractionDigits.serialize()),
                  ["number-format", this.number.serialize(), t]
                );
              }
            }
            class Vn {
              constructor(t) {
                (this.type = Ht), (this.input = t);
              }
              static parse(t, e) {
                if (2 !== t.length)
                  return e.error(
                    `Expected 1 argument, but found ${t.length - 1} instead.`
                  );
                const n = e.parse(t[1], 1);
                return n
                  ? "array" !== n.type.kind &&
                    "string" !== n.type.kind &&
                    "value" !== n.type.kind
                    ? e.error(
                        `Expected argument of type string or array, but found ${ie(
                          n.type
                        )} instead.`
                      )
                    : new Vn(n)
                  : null;
              }
              evaluate(t) {
                const e = this.input.evaluate(t);
                if ("string" == typeof e) return e.length;
                if (Array.isArray(e)) return e.length;
                throw new xe(
                  `Expected value to be of type string or array, but found ${ie(
                    _e(e)
                  )} instead.`
                );
              }
              eachChild(t) {
                t(this.input);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                const t = ["length"];
                return (
                  this.eachChild((e) => {
                    t.push(e.serialize());
                  }),
                  t
                );
              }
            }
            const qn = {
              "==": Ln,
              "!=": Fn,
              ">": Nn,
              "<": Bn,
              ">=": Un,
              "<=": jn,
              array: Se,
              at: Cn,
              boolean: Se,
              case: kn,
              coalesce: Tn,
              collator: ke,
              format: Ee,
              image: Te,
              in: Pn,
              "index-of": Mn,
              interpolate: Sn,
              "interpolate-hcl": Sn,
              "interpolate-lab": Sn,
              length: Vn,
              let: An,
              literal: be,
              match: On,
              number: Se,
              "number-format": Zn,
              object: Se,
              slice: In,
              step: nn,
              string: Se,
              "to-boolean": Ce,
              "to-color": Ce,
              "to-number": Ce,
              "to-string": Ce,
              var: Qe,
              within: He,
            };
            function $n(t, [e, n, r, i]) {
              (e = e.evaluate(t)), (n = n.evaluate(t)), (r = r.evaluate(t));
              const o = i ? i.evaluate(t) : 1,
                s = ge(e, n, r, o);
              if (s) throw new xe(s);
              return new he((e / 255) * o, (n / 255) * o, (r / 255) * o, o);
            }
            function Gn(t, e) {
              return t in e;
            }
            function Wn(t, e) {
              const n = e[t];
              return void 0 === n ? null : n;
            }
            function Hn(t) {
              return { type: t };
            }
            function Xn(t) {
              return { result: "success", value: t };
            }
            function Kn(t) {
              return { result: "error", value: t };
            }
            function Yn(t) {
              return (
                "data-driven" === t["property-type"] ||
                "cross-faded-data-driven" === t["property-type"]
              );
            }
            function Qn(t) {
              return (
                !!t.expression && t.expression.parameters.indexOf("zoom") > -1
              );
            }
            function Jn(t) {
              return !!t.expression && t.expression.interpolated;
            }
            function tr(t) {
              return t instanceof Number
                ? "number"
                : t instanceof String
                ? "string"
                : t instanceof Boolean
                ? "boolean"
                : Array.isArray(t)
                ? "array"
                : null === t
                ? "null"
                : typeof t;
            }
            function er(t) {
              return "object" == typeof t && null !== t && !Array.isArray(t);
            }
            function nr(t) {
              return t;
            }
            function rr(t, e) {
              const n = "color" === e.type,
                r = t.stops && "object" == typeof t.stops[0][0],
                i = r || !(r || void 0 !== t.property),
                o = t.type || (Jn(e) ? "exponential" : "interval");
              if (
                (n &&
                  ((t = Zt({}, t)).stops &&
                    (t.stops = t.stops.map((t) => [t[0], he.parse(t[1])])),
                  (t.default = he.parse(t.default ? t.default : e.default))),
                t.colorSpace && "rgb" !== t.colorSpace && !wn[t.colorSpace])
              )
                throw new Error(`Unknown color space: ${t.colorSpace}`);
              let s, a, l;
              if ("exponential" === o) s = ar;
              else if ("interval" === o) s = sr;
              else if ("categorical" === o) {
                (s = or), (a = Object.create(null));
                for (const e of t.stops) a[e[0]] = e[1];
                l = typeof t.stops[0][0];
              } else {
                if ("identity" !== o)
                  throw new Error(`Unknown function type "${o}"`);
                s = lr;
              }
              if (r) {
                const n = {},
                  r = [];
                for (let e = 0; e < t.stops.length; e++) {
                  const i = t.stops[e],
                    o = i[0].zoom;
                  void 0 === n[o] &&
                    ((n[o] = {
                      zoom: o,
                      type: t.type,
                      property: t.property,
                      default: t.default,
                      stops: [],
                    }),
                    r.push(o)),
                    n[o].stops.push([i[0].value, i[1]]);
                }
                const i = [];
                for (const t of r) i.push([n[t].zoom, rr(n[t], e)]);
                const o = { name: "linear" };
                return {
                  kind: "composite",
                  interpolationType: o,
                  interpolationFactor: Sn.interpolationFactor.bind(void 0, o),
                  zoomStops: i.map((t) => t[0]),
                  evaluate: ({ zoom: n }, r) =>
                    ar({ stops: i, base: t.base }, e, n).evaluate(n, r),
                };
              }
              if (i) {
                const n =
                  "exponential" === o
                    ? {
                        name: "exponential",
                        base: void 0 !== t.base ? t.base : 1,
                      }
                    : null;
                return {
                  kind: "camera",
                  interpolationType: n,
                  interpolationFactor: Sn.interpolationFactor.bind(void 0, n),
                  zoomStops: t.stops.map((t) => t[0]),
                  evaluate: ({ zoom: n }) => s(t, e, n, a, l),
                };
              }
              return {
                kind: "source",
                evaluate(n, r) {
                  const i =
                    r && r.properties ? r.properties[t.property] : void 0;
                  return void 0 === i
                    ? ir(t.default, e.default)
                    : s(t, e, i, a, l);
                },
              };
            }
            function ir(t, e, n) {
              return void 0 !== t
                ? t
                : void 0 !== e
                ? e
                : void 0 !== n
                ? n
                : void 0;
            }
            function or(t, e, n, r, i) {
              return ir(typeof n === i ? r[n] : void 0, t.default, e.default);
            }
            function sr(t, e, n) {
              if ("number" !== tr(n)) return ir(t.default, e.default);
              const r = t.stops.length;
              if (1 === r) return t.stops[0][1];
              if (n <= t.stops[0][0]) return t.stops[0][1];
              if (n >= t.stops[r - 1][0]) return t.stops[r - 1][1];
              const i = en(
                t.stops.map((t) => t[0]),
                n
              );
              return t.stops[i][1];
            }
            function ar(t, e, n) {
              const r = void 0 !== t.base ? t.base : 1;
              if ("number" !== tr(n)) return ir(t.default, e.default);
              const i = t.stops.length;
              if (1 === i) return t.stops[0][1];
              if (n <= t.stops[0][0]) return t.stops[0][1];
              if (n >= t.stops[i - 1][0]) return t.stops[i - 1][1];
              const o = en(
                  t.stops.map((t) => t[0]),
                  n
                ),
                s = (function (t, e, n, r) {
                  const i = r - n,
                    o = t - n;
                  return 0 === i
                    ? 0
                    : 1 === e
                    ? o / i
                    : (Math.pow(e, o) - 1) / (Math.pow(e, i) - 1);
                })(n, r, t.stops[o][0], t.stops[o + 1][0]),
                a = t.stops[o][1],
                l = t.stops[o + 1][1];
              let c = on[e.type] || nr;
              if (t.colorSpace && "rgb" !== t.colorSpace) {
                const e = wn[t.colorSpace];
                c = (t, n) =>
                  e.reverse(e.interpolate(e.forward(t), e.forward(n), s));
              }
              return "function" == typeof a.evaluate
                ? {
                    evaluate(...t) {
                      const e = a.evaluate.apply(void 0, t),
                        n = l.evaluate.apply(void 0, t);
                      if (void 0 !== e && void 0 !== n) return c(e, n, s);
                    },
                  }
                : c(a, l, s);
            }
            function lr(t, e, n) {
              return (
                "color" === e.type
                  ? (n = he.parse(n))
                  : "formatted" === e.type
                  ? (n = fe.fromString(n.toString()))
                  : "resolvedImage" === e.type
                  ? (n = me.fromString(n.toString()))
                  : tr(n) === e.type ||
                    ("enum" === e.type && e.values[n]) ||
                    (n = void 0),
                ir(n, t.default, e.default)
              );
            }
            Oe.register(qn, {
              error: [
                { kind: "error" },
                [Xt],
                (t, [e]) => {
                  throw new xe(e.evaluate(t));
                },
              ],
              typeof: [Xt, [Jt], (t, [e]) => ie(_e(e.evaluate(t)))],
              "to-rgba": [re(Ht, 4), [Yt], (t, [e]) => e.evaluate(t).toArray()],
              rgb: [Yt, [Ht, Ht, Ht], $n],
              rgba: [Yt, [Ht, Ht, Ht, Ht], $n],
              has: {
                type: Kt,
                overloads: [
                  [[Xt], (t, [e]) => Gn(e.evaluate(t), t.properties())],
                  [[Xt, Qt], (t, [e, n]) => Gn(e.evaluate(t), n.evaluate(t))],
                ],
              },
              get: {
                type: Jt,
                overloads: [
                  [[Xt], (t, [e]) => Wn(e.evaluate(t), t.properties())],
                  [[Xt, Qt], (t, [e, n]) => Wn(e.evaluate(t), n.evaluate(t))],
                ],
              },
              "feature-state": [
                Jt,
                [Xt],
                (t, [e]) => Wn(e.evaluate(t), t.featureState || {}),
              ],
              properties: [Qt, [], (t) => t.properties()],
              "geometry-type": [Xt, [], (t) => t.geometryType()],
              id: [Jt, [], (t) => t.id()],
              zoom: [Ht, [], (t) => t.globals.zoom],
              "heatmap-density": [Ht, [], (t) => t.globals.heatmapDensity || 0],
              "line-progress": [Ht, [], (t) => t.globals.lineProgress || 0],
              "sky-radial-progress": [
                Ht,
                [],
                (t) => t.globals.skyRadialProgress || 0,
              ],
              accumulated: [
                Jt,
                [],
                (t) =>
                  void 0 === t.globals.accumulated
                    ? null
                    : t.globals.accumulated,
              ],
              "+": [
                Ht,
                Hn(Ht),
                (t, e) => {
                  let n = 0;
                  for (const r of e) n += r.evaluate(t);
                  return n;
                },
              ],
              "*": [
                Ht,
                Hn(Ht),
                (t, e) => {
                  let n = 1;
                  for (const r of e) n *= r.evaluate(t);
                  return n;
                },
              ],
              "-": {
                type: Ht,
                overloads: [
                  [[Ht, Ht], (t, [e, n]) => e.evaluate(t) - n.evaluate(t)],
                  [[Ht], (t, [e]) => -e.evaluate(t)],
                ],
              },
              "/": [Ht, [Ht, Ht], (t, [e, n]) => e.evaluate(t) / n.evaluate(t)],
              "%": [Ht, [Ht, Ht], (t, [e, n]) => e.evaluate(t) % n.evaluate(t)],
              ln2: [Ht, [], () => Math.LN2],
              pi: [Ht, [], () => Math.PI],
              e: [Ht, [], () => Math.E],
              "^": [
                Ht,
                [Ht, Ht],
                (t, [e, n]) => Math.pow(e.evaluate(t), n.evaluate(t)),
              ],
              sqrt: [Ht, [Ht], (t, [e]) => Math.sqrt(e.evaluate(t))],
              log10: [
                Ht,
                [Ht],
                (t, [e]) => Math.log(e.evaluate(t)) / Math.LN10,
              ],
              ln: [Ht, [Ht], (t, [e]) => Math.log(e.evaluate(t))],
              log2: [Ht, [Ht], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN2],
              sin: [Ht, [Ht], (t, [e]) => Math.sin(e.evaluate(t))],
              cos: [Ht, [Ht], (t, [e]) => Math.cos(e.evaluate(t))],
              tan: [Ht, [Ht], (t, [e]) => Math.tan(e.evaluate(t))],
              asin: [Ht, [Ht], (t, [e]) => Math.asin(e.evaluate(t))],
              acos: [Ht, [Ht], (t, [e]) => Math.acos(e.evaluate(t))],
              atan: [Ht, [Ht], (t, [e]) => Math.atan(e.evaluate(t))],
              min: [
                Ht,
                Hn(Ht),
                (t, e) => Math.min(...e.map((e) => e.evaluate(t))),
              ],
              max: [
                Ht,
                Hn(Ht),
                (t, e) => Math.max(...e.map((e) => e.evaluate(t))),
              ],
              abs: [Ht, [Ht], (t, [e]) => Math.abs(e.evaluate(t))],
              round: [
                Ht,
                [Ht],
                (t, [e]) => {
                  const n = e.evaluate(t);
                  return n < 0 ? -Math.round(-n) : Math.round(n);
                },
              ],
              floor: [Ht, [Ht], (t, [e]) => Math.floor(e.evaluate(t))],
              ceil: [Ht, [Ht], (t, [e]) => Math.ceil(e.evaluate(t))],
              "filter-==": [
                Kt,
                [Xt, Jt],
                (t, [e, n]) => t.properties()[e.value] === n.value,
              ],
              "filter-id-==": [Kt, [Jt], (t, [e]) => t.id() === e.value],
              "filter-type-==": [
                Kt,
                [Xt],
                (t, [e]) => t.geometryType() === e.value,
              ],
              "filter-<": [
                Kt,
                [Xt, Jt],
                (t, [e, n]) => {
                  const r = t.properties()[e.value],
                    i = n.value;
                  return typeof r == typeof i && r < i;
                },
              ],
              "filter-id-<": [
                Kt,
                [Jt],
                (t, [e]) => {
                  const n = t.id(),
                    r = e.value;
                  return typeof n == typeof r && n < r;
                },
              ],
              "filter->": [
                Kt,
                [Xt, Jt],
                (t, [e, n]) => {
                  const r = t.properties()[e.value],
                    i = n.value;
                  return typeof r == typeof i && r > i;
                },
              ],
              "filter-id->": [
                Kt,
                [Jt],
                (t, [e]) => {
                  const n = t.id(),
                    r = e.value;
                  return typeof n == typeof r && n > r;
                },
              ],
              "filter-<=": [
                Kt,
                [Xt, Jt],
                (t, [e, n]) => {
                  const r = t.properties()[e.value],
                    i = n.value;
                  return typeof r == typeof i && r <= i;
                },
              ],
              "filter-id-<=": [
                Kt,
                [Jt],
                (t, [e]) => {
                  const n = t.id(),
                    r = e.value;
                  return typeof n == typeof r && n <= r;
                },
              ],
              "filter->=": [
                Kt,
                [Xt, Jt],
                (t, [e, n]) => {
                  const r = t.properties()[e.value],
                    i = n.value;
                  return typeof r == typeof i && r >= i;
                },
              ],
              "filter-id->=": [
                Kt,
                [Jt],
                (t, [e]) => {
                  const n = t.id(),
                    r = e.value;
                  return typeof n == typeof r && n >= r;
                },
              ],
              "filter-has": [Kt, [Jt], (t, [e]) => e.value in t.properties()],
              "filter-has-id": [
                Kt,
                [],
                (t) => null !== t.id() && void 0 !== t.id(),
              ],
              "filter-type-in": [
                Kt,
                [re(Xt)],
                (t, [e]) => e.value.indexOf(t.geometryType()) >= 0,
              ],
              "filter-id-in": [
                Kt,
                [re(Jt)],
                (t, [e]) => e.value.indexOf(t.id()) >= 0,
              ],
              "filter-in-small": [
                Kt,
                [Xt, re(Jt)],
                (t, [e, n]) => n.value.indexOf(t.properties()[e.value]) >= 0,
              ],
              "filter-in-large": [
                Kt,
                [Xt, re(Jt)],
                (t, [e, n]) =>
                  (function (t, e, n, r) {
                    for (; n <= r; ) {
                      const i = (n + r) >> 1;
                      if (e[i] === t) return !0;
                      e[i] > t ? (r = i - 1) : (n = i + 1);
                    }
                    return !1;
                  })(t.properties()[e.value], n.value, 0, n.value.length - 1),
              ],
              all: {
                type: Kt,
                overloads: [
                  [[Kt, Kt], (t, [e, n]) => e.evaluate(t) && n.evaluate(t)],
                  [
                    Hn(Kt),
                    (t, e) => {
                      for (const n of e) if (!n.evaluate(t)) return !1;
                      return !0;
                    },
                  ],
                ],
              },
              any: {
                type: Kt,
                overloads: [
                  [[Kt, Kt], (t, [e, n]) => e.evaluate(t) || n.evaluate(t)],
                  [
                    Hn(Kt),
                    (t, e) => {
                      for (const n of e) if (n.evaluate(t)) return !0;
                      return !1;
                    },
                  ],
                ],
              },
              "!": [Kt, [Kt], (t, [e]) => !e.evaluate(t)],
              "is-supported-script": [
                Kt,
                [Xt],
                (t, [e]) => {
                  const n = t.globals && t.globals.isSupportedScript;
                  return !n || n(e.evaluate(t));
                },
              ],
              upcase: [Xt, [Xt], (t, [e]) => e.evaluate(t).toUpperCase()],
              downcase: [Xt, [Xt], (t, [e]) => e.evaluate(t).toLowerCase()],
              concat: [
                Xt,
                Hn(Jt),
                (t, e) => e.map((e) => ve(e.evaluate(t))).join(""),
              ],
              "resolved-locale": [
                Xt,
                [te],
                (t, [e]) => e.evaluate(t).resolvedLocale(),
              ],
            });
            class cr {
              constructor(t, e) {
                (this.expression = t),
                  (this._warningHistory = {}),
                  (this._evaluator = new Me()),
                  (this._defaultValue = e
                    ? (function (t) {
                        return "color" === t.type && er(t.default)
                          ? new he(0, 0, 0, 0)
                          : "color" === t.type
                          ? he.parse(t.default) || null
                          : void 0 === t.default
                          ? null
                          : t.default;
                      })(e)
                    : null),
                  (this._enumValues = e && "enum" === e.type ? e.values : null);
              }
              evaluateWithoutErrorHandling(t, e, n, r, i, o) {
                return (
                  (this._evaluator.globals = t),
                  (this._evaluator.feature = e),
                  (this._evaluator.featureState = n),
                  (this._evaluator.canonical = r),
                  (this._evaluator.availableImages = i || null),
                  (this._evaluator.formattedSection = o),
                  this.expression.evaluate(this._evaluator)
                );
              }
              evaluate(t, e, n, r, i, o) {
                (this._evaluator.globals = t),
                  (this._evaluator.feature = e || null),
                  (this._evaluator.featureState = n || null),
                  (this._evaluator.canonical = r),
                  (this._evaluator.availableImages = i || null),
                  (this._evaluator.formattedSection = o || null);
                try {
                  const t = this.expression.evaluate(this._evaluator);
                  if (null == t || ("number" == typeof t && t != t))
                    return this._defaultValue;
                  if (this._enumValues && !(t in this._enumValues))
                    throw new xe(
                      `Expected value to be one of ${Object.keys(
                        this._enumValues
                      )
                        .map((t) => JSON.stringify(t))
                        .join(", ")}, but found ${JSON.stringify(t)} instead.`
                    );
                  return t;
                } catch (t) {
                  return (
                    this._warningHistory[t.message] ||
                      ((this._warningHistory[t.message] = !0),
                      "undefined" != typeof console && console.warn(t.message)),
                    this._defaultValue
                  );
                }
              }
            }
            function ur(t) {
              return (
                Array.isArray(t) &&
                t.length > 0 &&
                "string" == typeof t[0] &&
                t[0] in qn
              );
            }
            function hr(t, e) {
              const n = new Je(
                  qn,
                  [],
                  e
                    ? (function (t) {
                        const e = {
                          color: Yt,
                          string: Xt,
                          number: Ht,
                          enum: Xt,
                          boolean: Kt,
                          formatted: ee,
                          resolvedImage: ne,
                        };
                        return "array" === t.type
                          ? re(e[t.value] || Jt, t.length)
                          : e[t.type];
                      })(e)
                    : void 0
                ),
                r = n.parse(
                  t,
                  void 0,
                  void 0,
                  void 0,
                  e && "string" === e.type
                    ? { typeAnnotation: "coerce" }
                    : void 0
                );
              return r ? Xn(new cr(r, e)) : Kn(n.errors);
            }
            class pr {
              constructor(t, e) {
                (this.kind = t),
                  (this._styleExpression = e),
                  (this.isStateDependent =
                    "constant" !== t && !Ke(e.expression));
              }
              evaluateWithoutErrorHandling(t, e, n, r, i, o) {
                return this._styleExpression.evaluateWithoutErrorHandling(
                  t,
                  e,
                  n,
                  r,
                  i,
                  o
                );
              }
              evaluate(t, e, n, r, i, o) {
                return this._styleExpression.evaluate(t, e, n, r, i, o);
              }
            }
            class dr {
              constructor(t, e, n, r) {
                (this.kind = t),
                  (this.zoomStops = n),
                  (this._styleExpression = e),
                  (this.isStateDependent = "camera" !== t && !Ke(e.expression)),
                  (this.interpolationType = r);
              }
              evaluateWithoutErrorHandling(t, e, n, r, i, o) {
                return this._styleExpression.evaluateWithoutErrorHandling(
                  t,
                  e,
                  n,
                  r,
                  i,
                  o
                );
              }
              evaluate(t, e, n, r, i, o) {
                return this._styleExpression.evaluate(t, e, n, r, i, o);
              }
              interpolationFactor(t, e, n) {
                return this.interpolationType
                  ? Sn.interpolationFactor(this.interpolationType, t, e, n)
                  : 0;
              }
            }
            function fr(t, e) {
              if ("error" === (t = hr(t, e)).result) return t;
              const n = t.value.expression,
                r = Xe(n);
              if (!r && !Yn(e))
                return Kn([new $t("", "data expressions not supported")]);
              const i = Ye(n, ["zoom"]);
              if (!i && !Qn(e))
                return Kn([new $t("", "zoom expressions not supported")]);
              const o = gr(n);
              return o || i
                ? o instanceof $t
                  ? Kn([o])
                  : o instanceof Sn && !Jn(e)
                  ? Kn([
                      new $t(
                        "",
                        '"interpolate" expressions cannot be used with this property'
                      ),
                    ])
                  : Xn(
                      o
                        ? new dr(
                            r ? "camera" : "composite",
                            t.value,
                            o.labels,
                            o instanceof Sn ? o.interpolation : void 0
                          )
                        : new pr(r ? "constant" : "source", t.value)
                    )
                : Kn([
                    new $t(
                      "",
                      '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'
                    ),
                  ]);
            }
            class mr {
              constructor(t, e) {
                (this._parameters = t),
                  (this._specification = e),
                  Zt(this, rr(this._parameters, this._specification));
              }
              static deserialize(t) {
                return new mr(t._parameters, t._specification);
              }
              static serialize(t) {
                return {
                  _parameters: t._parameters,
                  _specification: t._specification,
                };
              }
            }
            function gr(t) {
              let e = null;
              if (t instanceof An) e = gr(t.result);
              else if (t instanceof Tn) {
                for (const n of t.args) if (((e = gr(n)), e)) break;
              } else
                (t instanceof nn || t instanceof Sn) &&
                  t.input instanceof Oe &&
                  "zoom" === t.input.name &&
                  (e = t);
              return (
                e instanceof $t ||
                  t.eachChild((t) => {
                    const n = gr(t);
                    n instanceof $t
                      ? (e = n)
                      : !e && n
                      ? (e = new $t(
                          "",
                          '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'
                        ))
                      : e &&
                        n &&
                        e !== n &&
                        (e = new $t(
                          "",
                          'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'
                        ));
                  }),
                e
              );
            }
            function yr(t) {
              const e = t.key,
                n = t.value,
                r = t.valueSpec || {},
                i = t.objectElementValidators || {},
                o = t.style,
                s = t.styleSpec;
              let a = [];
              const l = tr(n);
              if ("object" !== l)
                return [new jt(e, n, `object expected, ${l} found`)];
              for (const c in n) {
                const t = c.split(".")[0],
                  l = r[t] || r["*"];
                let u;
                if (i[t]) u = i[t];
                else if (r[t]) u = Gr;
                else if (i["*"]) u = i["*"];
                else {
                  if (!r["*"]) {
                    a.push(new jt(e, n[c], `unknown property "${c}"`));
                    continue;
                  }
                  u = Gr;
                }
                a = a.concat(
                  u(
                    {
                      key: (e ? `${e}.` : e) + c,
                      value: n[c],
                      valueSpec: l,
                      style: o,
                      styleSpec: s,
                      object: n,
                      objectKey: c,
                    },
                    n
                  )
                );
              }
              for (const c in r)
                i[c] ||
                  (r[c].required &&
                    void 0 === r[c].default &&
                    void 0 === n[c] &&
                    a.push(new jt(e, n, `missing required property "${c}"`)));
              return a;
            }
            function _r(t) {
              const e = t.value,
                n = t.valueSpec,
                r = t.style,
                i = t.styleSpec,
                o = t.key,
                s = t.arrayElementValidator || Gr;
              if ("array" !== tr(e))
                return [new jt(o, e, `array expected, ${tr(e)} found`)];
              if (n.length && e.length !== n.length)
                return [
                  new jt(
                    o,
                    e,
                    `array length ${n.length} expected, length ${e.length} found`
                  ),
                ];
              if (n["min-length"] && e.length < n["min-length"])
                return [
                  new jt(
                    o,
                    e,
                    `array length at least ${n["min-length"]} expected, length ${e.length} found`
                  ),
                ];
              let a = {
                type: n.value,
                values: n.values,
                minimum: n.minimum,
                maximum: n.maximum,
              };
              i.$version < 7 && (a.function = n.function),
                "object" === tr(n.value) && (a = n.value);
              let l = [];
              for (let c = 0; c < e.length; c++)
                l = l.concat(
                  s({
                    array: e,
                    arrayIndex: c,
                    value: e[c],
                    valueSpec: a,
                    style: r,
                    styleSpec: i,
                    key: `${o}[${c}]`,
                  })
                );
              return l;
            }
            function vr(t) {
              const e = t.key,
                n = t.value,
                r = t.valueSpec;
              let i = tr(n);
              if (("number" === i && n != n && (i = "NaN"), "number" !== i))
                return [new jt(e, n, `number expected, ${i} found`)];
              if ("minimum" in r) {
                let i = r.minimum;
                if (
                  ("array" === tr(r.minimum) && (i = r.minimum[t.arrayIndex]),
                  n < i)
                )
                  return [
                    new jt(e, n, `${n} is less than the minimum value ${i}`),
                  ];
              }
              if ("maximum" in r) {
                let i = r.maximum;
                if (
                  ("array" === tr(r.maximum) && (i = r.maximum[t.arrayIndex]),
                  n > i)
                )
                  return [
                    new jt(e, n, `${n} is greater than the maximum value ${i}`),
                  ];
              }
              return [];
            }
            function br(t) {
              const e = t.valueSpec,
                n = Vt(t.value.type);
              let r,
                i,
                o,
                s = {};
              const a = "categorical" !== n && void 0 === t.value.property,
                l = !a,
                c =
                  "array" === tr(t.value.stops) &&
                  "array" === tr(t.value.stops[0]) &&
                  "object" === tr(t.value.stops[0][0]),
                u = yr({
                  key: t.key,
                  value: t.value,
                  valueSpec: t.styleSpec.function,
                  style: t.style,
                  styleSpec: t.styleSpec,
                  objectElementValidators: {
                    stops: function (t) {
                      if ("identity" === n)
                        return [
                          new jt(
                            t.key,
                            t.value,
                            'identity function may not have a "stops" property'
                          ),
                        ];
                      let e = [];
                      const r = t.value;
                      return (
                        (e = e.concat(
                          _r({
                            key: t.key,
                            value: r,
                            valueSpec: t.valueSpec,
                            style: t.style,
                            styleSpec: t.styleSpec,
                            arrayElementValidator: h,
                          })
                        )),
                        "array" === tr(r) &&
                          0 === r.length &&
                          e.push(
                            new jt(
                              t.key,
                              r,
                              "array must have at least one stop"
                            )
                          ),
                        e
                      );
                    },
                    default: function (t) {
                      return Gr({
                        key: t.key,
                        value: t.value,
                        valueSpec: e,
                        style: t.style,
                        styleSpec: t.styleSpec,
                      });
                    },
                  },
                });
              return (
                "identity" === n &&
                  a &&
                  u.push(
                    new jt(
                      t.key,
                      t.value,
                      'missing required property "property"'
                    )
                  ),
                "identity" === n ||
                  t.value.stops ||
                  u.push(
                    new jt(t.key, t.value, 'missing required property "stops"')
                  ),
                "exponential" === n &&
                  t.valueSpec.expression &&
                  !Jn(t.valueSpec) &&
                  u.push(
                    new jt(
                      t.key,
                      t.value,
                      "exponential functions not supported"
                    )
                  ),
                t.styleSpec.$version >= 8 &&
                  (l && !Yn(t.valueSpec)
                    ? u.push(
                        new jt(
                          t.key,
                          t.value,
                          "property functions not supported"
                        )
                      )
                    : a &&
                      !Qn(t.valueSpec) &&
                      u.push(
                        new jt(t.key, t.value, "zoom functions not supported")
                      )),
                ("categorical" !== n && !c) ||
                  void 0 !== t.value.property ||
                  u.push(
                    new jt(t.key, t.value, '"property" property is required')
                  ),
                u
              );
              function h(t) {
                let n = [];
                const r = t.value,
                  a = t.key;
                if ("array" !== tr(r))
                  return [new jt(a, r, `array expected, ${tr(r)} found`)];
                if (2 !== r.length)
                  return [
                    new jt(
                      a,
                      r,
                      `array length 2 expected, length ${r.length} found`
                    ),
                  ];
                if (c) {
                  if ("object" !== tr(r[0]))
                    return [new jt(a, r, `object expected, ${tr(r[0])} found`)];
                  if (void 0 === r[0].zoom)
                    return [new jt(a, r, "object stop key must have zoom")];
                  if (void 0 === r[0].value)
                    return [new jt(a, r, "object stop key must have value")];
                  if (o && o > Vt(r[0].zoom))
                    return [
                      new jt(
                        a,
                        r[0].zoom,
                        "stop zoom values must appear in ascending order"
                      ),
                    ];
                  Vt(r[0].zoom) !== o &&
                    ((o = Vt(r[0].zoom)), (i = void 0), (s = {})),
                    (n = n.concat(
                      yr({
                        key: `${a}[0]`,
                        value: r[0],
                        valueSpec: { zoom: {} },
                        style: t.style,
                        styleSpec: t.styleSpec,
                        objectElementValidators: { zoom: vr, value: p },
                      })
                    ));
                } else n = n.concat(p({ key: `${a}[0]`, value: r[0], valueSpec: {}, style: t.style, styleSpec: t.styleSpec }, r));
                return ur(qt(r[1]))
                  ? n.concat([
                      new jt(
                        `${a}[1]`,
                        r[1],
                        "expressions are not allowed in function stops."
                      ),
                    ])
                  : n.concat(
                      Gr({
                        key: `${a}[1]`,
                        value: r[1],
                        valueSpec: e,
                        style: t.style,
                        styleSpec: t.styleSpec,
                      })
                    );
              }
              function p(t, o) {
                const a = tr(t.value),
                  l = Vt(t.value),
                  c = null !== t.value ? t.value : o;
                if (r) {
                  if (a !== r)
                    return [
                      new jt(
                        t.key,
                        c,
                        `${a} stop domain type must match previous stop domain type ${r}`
                      ),
                    ];
                } else r = a;
                if ("number" !== a && "string" !== a && "boolean" !== a)
                  return [
                    new jt(
                      t.key,
                      c,
                      "stop domain value must be a number, string, or boolean"
                    ),
                  ];
                if ("number" !== a && "categorical" !== n) {
                  let r = `number expected, ${a} found`;
                  return (
                    Yn(e) &&
                      void 0 === n &&
                      (r +=
                        '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),
                    [new jt(t.key, c, r)]
                  );
                }
                return "categorical" !== n ||
                  "number" !== a ||
                  (isFinite(l) && Math.floor(l) === l)
                  ? "categorical" !== n &&
                    "number" === a &&
                    void 0 !== i &&
                    l < i
                    ? [
                        new jt(
                          t.key,
                          c,
                          "stop domain values must appear in ascending order"
                        ),
                      ]
                    : ((i = l),
                      "categorical" === n && l in s
                        ? [
                            new jt(
                              t.key,
                              c,
                              "stop domain values must be unique"
                            ),
                          ]
                        : ((s[l] = !0), []))
                  : [new jt(t.key, c, `integer expected, found ${l}`)];
              }
            }
            function xr(t) {
              const e = ("property" === t.expressionContext ? fr : hr)(
                qt(t.value),
                t.valueSpec
              );
              if ("error" === e.result)
                return e.value.map(
                  (e) => new jt(`${t.key}${e.key}`, t.value, e.message)
                );
              const n =
                e.value.expression || e.value._styleExpression.expression;
              if (
                "property" === t.expressionContext &&
                "text-font" === t.propertyKey &&
                !n.outputDefined()
              )
                return [
                  new jt(
                    t.key,
                    t.value,
                    `Invalid data expression for "${t.propertyKey}". Output values must be contained as literals within the expression.`
                  ),
                ];
              if (
                "property" === t.expressionContext &&
                "layout" === t.propertyType &&
                !Ke(n)
              )
                return [
                  new jt(
                    t.key,
                    t.value,
                    '"feature-state" data expressions are not supported with layout properties.'
                  ),
                ];
              if ("filter" === t.expressionContext && !Ke(n))
                return [
                  new jt(
                    t.key,
                    t.value,
                    '"feature-state" data expressions are not supported with filters.'
                  ),
                ];
              if (
                t.expressionContext &&
                0 === t.expressionContext.indexOf("cluster")
              ) {
                if (!Ye(n, ["zoom", "feature-state"]))
                  return [
                    new jt(
                      t.key,
                      t.value,
                      '"zoom" and "feature-state" expressions are not supported with cluster properties.'
                    ),
                  ];
                if ("cluster-initial" === t.expressionContext && !Xe(n))
                  return [
                    new jt(
                      t.key,
                      t.value,
                      "Feature data expressions are not supported with initial expression part of cluster properties."
                    ),
                  ];
              }
              return [];
            }
            function wr(t) {
              const e = t.key,
                n = t.value,
                r = t.valueSpec,
                i = [];
              return (
                Array.isArray(r.values)
                  ? -1 === r.values.indexOf(Vt(n)) &&
                    i.push(
                      new jt(
                        e,
                        n,
                        `expected one of [${r.values.join(
                          ", "
                        )}], ${JSON.stringify(n)} found`
                      )
                    )
                  : -1 === Object.keys(r.values).indexOf(Vt(n)) &&
                    i.push(
                      new jt(
                        e,
                        n,
                        `expected one of [${Object.keys(r.values).join(
                          ", "
                        )}], ${JSON.stringify(n)} found`
                      )
                    ),
                i
              );
            }
            function Sr(t) {
              if (!0 === t || !1 === t) return !0;
              if (!Array.isArray(t) || 0 === t.length) return !1;
              switch (t[0]) {
                case "has":
                  return t.length >= 2 && "$id" !== t[1] && "$type" !== t[1];
                case "in":
                  return (
                    t.length >= 3 &&
                    ("string" != typeof t[1] || Array.isArray(t[2]))
                  );
                case "!in":
                case "!has":
                case "none":
                  return !1;
                case "==":
                case "!=":
                case ">":
                case ">=":
                case "<":
                case "<=":
                  return (
                    3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2])
                  );
                case "any":
                case "all":
                  for (const e of t.slice(1))
                    if (!Sr(e) && "boolean" != typeof e) return !1;
                  return !0;
                default:
                  return !0;
              }
            }
            const Er = {
              type: "boolean",
              default: !1,
              transition: !1,
              "property-type": "data-driven",
              expression: { interpolated: !1, parameters: ["zoom", "feature"] },
            };
            function Tr(t) {
              if (null == t) return { filter: () => !0, needGeometry: !1 };
              Sr(t) || (t = Pr(t));
              const e = hr(t, Er);
              if ("error" === e.result)
                throw new Error(
                  e.value.map((t) => `${t.key}: ${t.message}`).join(", ")
                );
              return {
                filter: (t, n, r) => e.value.evaluate(t, n, {}, r),
                needGeometry: Cr(t),
              };
            }
            function Ar(t, e) {
              return t < e ? -1 : t > e ? 1 : 0;
            }
            function Cr(t) {
              if (!Array.isArray(t)) return !1;
              if ("within" === t[0]) return !0;
              for (let e = 1; e < t.length; e++) if (Cr(t[e])) return !0;
              return !1;
            }
            function Pr(t) {
              if (!t) return !0;
              const e = t[0];
              return t.length <= 1
                ? "any" !== e
                : "==" === e
                ? Mr(t[1], t[2], "==")
                : "!=" === e
                ? Ir(Mr(t[1], t[2], "=="))
                : "<" === e || ">" === e || "<=" === e || ">=" === e
                ? Mr(t[1], t[2], e)
                : "any" === e
                ? ((n = t.slice(1)), ["any"].concat(n.map(Pr)))
                : "all" === e
                ? ["all"].concat(t.slice(1).map(Pr))
                : "none" === e
                ? ["all"].concat(t.slice(1).map(Pr).map(Ir))
                : "in" === e
                ? Or(t[1], t.slice(2))
                : "!in" === e
                ? Ir(Or(t[1], t.slice(2)))
                : "has" === e
                ? kr(t[1])
                : "!has" === e
                ? Ir(kr(t[1]))
                : "within" !== e || t;
              var n;
            }
            function Mr(t, e, n) {
              switch (t) {
                case "$type":
                  return [`filter-type-${n}`, e];
                case "$id":
                  return [`filter-id-${n}`, e];
                default:
                  return [`filter-${n}`, t, e];
              }
            }
            function Or(t, e) {
              if (0 === e.length) return !1;
              switch (t) {
                case "$type":
                  return ["filter-type-in", ["literal", e]];
                case "$id":
                  return ["filter-id-in", ["literal", e]];
                default:
                  return e.length > 200 &&
                    !e.some((t) => typeof t != typeof e[0])
                    ? ["filter-in-large", t, ["literal", e.sort(Ar)]]
                    : ["filter-in-small", t, ["literal", e]];
              }
            }
            function kr(t) {
              switch (t) {
                case "$type":
                  return !0;
                case "$id":
                  return ["filter-has-id"];
                default:
                  return ["filter-has", t];
              }
            }
            function Ir(t) {
              return ["!", t];
            }
            function Dr(t) {
              return Sr(qt(t.value))
                ? xr(
                    Zt({}, t, {
                      expressionContext: "filter",
                      valueSpec: { value: "boolean" },
                    })
                  )
                : zr(t);
            }
            function zr(t) {
              const e = t.value,
                n = t.key;
              if ("array" !== tr(e))
                return [new jt(n, e, `array expected, ${tr(e)} found`)];
              const r = t.styleSpec;
              let i,
                o = [];
              if (e.length < 1)
                return [
                  new jt(n, e, "filter array must have at least 1 element"),
                ];
              switch (
                ((o = o.concat(
                  wr({
                    key: `${n}[0]`,
                    value: e[0],
                    valueSpec: r.filter_operator,
                    style: t.style,
                    styleSpec: t.styleSpec,
                  })
                )),
                Vt(e[0]))
              ) {
                case "<":
                case "<=":
                case ">":
                case ">=":
                  e.length >= 2 &&
                    "$type" === Vt(e[1]) &&
                    o.push(
                      new jt(
                        n,
                        e,
                        `"$type" cannot be use with operator "${e[0]}"`
                      )
                    );
                case "==":
                case "!=":
                  3 !== e.length &&
                    o.push(
                      new jt(
                        n,
                        e,
                        `filter array for operator "${e[0]}" must have 3 elements`
                      )
                    );
                case "in":
                case "!in":
                  e.length >= 2 &&
                    ((i = tr(e[1])),
                    "string" !== i &&
                      o.push(
                        new jt(`${n}[1]`, e[1], `string expected, ${i} found`)
                      ));
                  for (let s = 2; s < e.length; s++)
                    (i = tr(e[s])),
                      "$type" === Vt(e[1])
                        ? (o = o.concat(
                            wr({
                              key: `${n}[${s}]`,
                              value: e[s],
                              valueSpec: r.geometry_type,
                              style: t.style,
                              styleSpec: t.styleSpec,
                            })
                          ))
                        : "string" !== i &&
                          "number" !== i &&
                          "boolean" !== i &&
                          o.push(
                            new jt(
                              `${n}[${s}]`,
                              e[s],
                              `string, number, or boolean expected, ${i} found`
                            )
                          );
                  break;
                case "any":
                case "all":
                case "none":
                  for (let r = 1; r < e.length; r++)
                    o = o.concat(
                      zr({
                        key: `${n}[${r}]`,
                        value: e[r],
                        style: t.style,
                        styleSpec: t.styleSpec,
                      })
                    );
                  break;
                case "has":
                case "!has":
                  (i = tr(e[1])),
                    2 !== e.length
                      ? o.push(
                          new jt(
                            n,
                            e,
                            `filter array for "${e[0]}" operator must have 2 elements`
                          )
                        )
                      : "string" !== i &&
                        o.push(
                          new jt(`${n}[1]`, e[1], `string expected, ${i} found`)
                        );
                  break;
                case "within":
                  (i = tr(e[1])),
                    2 !== e.length
                      ? o.push(
                          new jt(
                            n,
                            e,
                            `filter array for "${e[0]}" operator must have 2 elements`
                          )
                        )
                      : "object" !== i &&
                        o.push(
                          new jt(`${n}[1]`, e[1], `object expected, ${i} found`)
                        );
              }
              return o;
            }
            function Rr(t, e) {
              const n = t.key,
                r = t.style,
                i = t.styleSpec,
                o = t.value,
                s = t.objectKey,
                a = i[`${e}_${t.layerType}`];
              if (!a) return [];
              const l = s.match(/^(.*)-transition$/);
              if ("paint" === e && l && a[l[1]] && a[l[1]].transition)
                return Gr({
                  key: n,
                  value: o,
                  valueSpec: i.transition,
                  style: r,
                  styleSpec: i,
                });
              const c = t.valueSpec || a[s];
              if (!c) return [new jt(n, o, `unknown property "${s}"`)];
              let u;
              if (
                "string" === tr(o) &&
                Yn(c) &&
                !c.tokens &&
                (u = /^{([^}]+)}$/.exec(o))
              )
                return [
                  new jt(
                    n,
                    o,
                    `"${s}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(
                      u[1]
                    )} }\`.`
                  ),
                ];
              const h = [];
              return (
                "symbol" === t.layerType &&
                  ("text-field" === s &&
                    r &&
                    !r.glyphs &&
                    h.push(
                      new jt(
                        n,
                        o,
                        'use of "text-field" requires a style "glyphs" property'
                      )
                    ),
                  "text-font" === s &&
                    er(qt(o)) &&
                    "identity" === Vt(o.type) &&
                    h.push(
                      new jt(
                        n,
                        o,
                        '"text-font" does not support identity functions'
                      )
                    )),
                h.concat(
                  Gr({
                    key: t.key,
                    value: o,
                    valueSpec: c,
                    style: r,
                    styleSpec: i,
                    expressionContext: "property",
                    propertyType: e,
                    propertyKey: s,
                  })
                )
              );
            }
            function Lr(t) {
              return Rr(t, "paint");
            }
            function Fr(t) {
              return Rr(t, "layout");
            }
            function Br(t) {
              let e = [];
              const n = t.value,
                r = t.key,
                i = t.style,
                o = t.styleSpec;
              n.type ||
                n.ref ||
                e.push(new jt(r, n, 'either "type" or "ref" is required'));
              let s = Vt(n.type);
              const a = Vt(n.ref);
              if (n.id) {
                const o = Vt(n.id);
                for (let s = 0; s < t.arrayIndex; s++) {
                  const t = i.layers[s];
                  Vt(t.id) === o &&
                    e.push(
                      new jt(
                        r,
                        n.id,
                        `duplicate layer id "${n.id}", previously used at line ${t.id.__line__}`
                      )
                    );
                }
              }
              if ("ref" in n) {
                let t;
                ["type", "source", "source-layer", "filter", "layout"].forEach(
                  (t) => {
                    t in n &&
                      e.push(
                        new jt(r, n[t], `"${t}" is prohibited for ref layers`)
                      );
                  }
                ),
                  i.layers.forEach((e) => {
                    Vt(e.id) === a && (t = e);
                  }),
                  t
                    ? t.ref
                      ? e.push(
                          new jt(
                            r,
                            n.ref,
                            "ref cannot reference another ref layer"
                          )
                        )
                      : (s = Vt(t.type))
                    : e.push(new jt(r, n.ref, `ref layer "${a}" not found`));
              } else if ("background" !== s && "sky" !== s)
                if (n.source) {
                  const t = i.sources && i.sources[n.source],
                    o = t && Vt(t.type);
                  t
                    ? "vector" === o && "raster" === s
                      ? e.push(
                          new jt(
                            r,
                            n.source,
                            `layer "${n.id}" requires a raster source`
                          )
                        )
                      : "raster" === o && "raster" !== s
                      ? e.push(
                          new jt(
                            r,
                            n.source,
                            `layer "${n.id}" requires a vector source`
                          )
                        )
                      : "vector" !== o || n["source-layer"]
                      ? "raster-dem" === o && "hillshade" !== s
                        ? e.push(
                            new jt(
                              r,
                              n.source,
                              "raster-dem source can only be used with layer type 'hillshade'."
                            )
                          )
                        : "line" !== s ||
                          !n.paint ||
                          !n.paint["line-gradient"] ||
                          ("geojson" === o && t.lineMetrics) ||
                          e.push(
                            new jt(
                              r,
                              n,
                              `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`
                            )
                          )
                      : e.push(
                          new jt(
                            r,
                            n,
                            `layer "${n.id}" must specify a "source-layer"`
                          )
                        )
                    : e.push(
                        new jt(r, n.source, `source "${n.source}" not found`)
                      );
                } else
                  e.push(new jt(r, n, 'missing required property "source"'));
              return (
                (e = e.concat(
                  yr({
                    key: r,
                    value: n,
                    valueSpec: o.layer,
                    style: t.style,
                    styleSpec: t.styleSpec,
                    objectElementValidators: {
                      "*": () => [],
                      type: () =>
                        Gr({
                          key: `${r}.type`,
                          value: n.type,
                          valueSpec: o.layer.type,
                          style: t.style,
                          styleSpec: t.styleSpec,
                          object: n,
                          objectKey: "type",
                        }),
                      filter: Dr,
                      layout: (t) =>
                        yr({
                          layer: n,
                          key: t.key,
                          value: t.value,
                          style: t.style,
                          styleSpec: t.styleSpec,
                          objectElementValidators: {
                            "*": (t) => Fr(Zt({ layerType: s }, t)),
                          },
                        }),
                      paint: (t) =>
                        yr({
                          layer: n,
                          key: t.key,
                          value: t.value,
                          style: t.style,
                          styleSpec: t.styleSpec,
                          objectElementValidators: {
                            "*": (t) => Lr(Zt({ layerType: s }, t)),
                          },
                        }),
                    },
                  })
                )),
                e
              );
            }
            function Nr(t) {
              const e = t.value,
                n = t.key,
                r = tr(e);
              return "string" !== r
                ? [new jt(n, e, `string expected, ${r} found`)]
                : [];
            }
            const jr = {
              promoteId: function ({ key: t, value: e }) {
                if ("string" === tr(e)) return Nr({ key: t, value: e });
                {
                  const n = [];
                  for (const r in e)
                    n.push(...Nr({ key: `${t}.${r}`, value: e[r] }));
                  return n;
                }
              },
            };
            function Ur(t) {
              const e = t.value,
                n = t.key,
                r = t.styleSpec,
                i = t.style;
              if (!e.type) return [new jt(n, e, '"type" is required')];
              const o = Vt(e.type);
              let s;
              switch (o) {
                case "vector":
                case "raster":
                case "raster-dem":
                  return (
                    (s = yr({
                      key: n,
                      value: e,
                      valueSpec: r[`source_${o.replace("-", "_")}`],
                      style: t.style,
                      styleSpec: r,
                      objectElementValidators: jr,
                    })),
                    s
                  );
                case "geojson":
                  if (
                    ((s = yr({
                      key: n,
                      value: e,
                      valueSpec: r.source_geojson,
                      style: i,
                      styleSpec: r,
                      objectElementValidators: jr,
                    })),
                    e.cluster)
                  )
                    for (const t in e.clusterProperties) {
                      const [r, i] = e.clusterProperties[t],
                        o =
                          "string" == typeof r
                            ? [r, ["accumulated"], ["get", t]]
                            : r;
                      s.push(
                        ...xr({
                          key: `${n}.${t}.map`,
                          value: i,
                          expressionContext: "cluster-map",
                        })
                      ),
                        s.push(
                          ...xr({
                            key: `${n}.${t}.reduce`,
                            value: o,
                            expressionContext: "cluster-reduce",
                          })
                        );
                    }
                  return s;
                case "video":
                  return yr({
                    key: n,
                    value: e,
                    valueSpec: r.source_video,
                    style: i,
                    styleSpec: r,
                  });
                case "image":
                  return yr({
                    key: n,
                    value: e,
                    valueSpec: r.source_image,
                    style: i,
                    styleSpec: r,
                  });
                case "canvas":
                  return [
                    new jt(
                      n,
                      null,
                      "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.",
                      "source.canvas"
                    ),
                  ];
                default:
                  return wr({
                    key: `${n}.type`,
                    value: e.type,
                    valueSpec: {
                      values: [
                        "vector",
                        "raster",
                        "raster-dem",
                        "geojson",
                        "video",
                        "image",
                      ],
                    },
                    style: i,
                    styleSpec: r,
                  });
              }
            }
            function Zr(t) {
              const e = t.value,
                n = t.styleSpec,
                r = n.light,
                i = t.style;
              let o = [];
              const s = tr(e);
              if (void 0 === e) return o;
              if ("object" !== s)
                return (
                  (o = o.concat([
                    new jt("light", e, `object expected, ${s} found`),
                  ])),
                  o
                );
              for (const a in e) {
                const t = a.match(/^(.*)-transition$/);
                o = o.concat(
                  t && r[t[1]] && r[t[1]].transition
                    ? Gr({
                        key: a,
                        value: e[a],
                        valueSpec: n.transition,
                        style: i,
                        styleSpec: n,
                      })
                    : r[a]
                    ? Gr({
                        key: a,
                        value: e[a],
                        valueSpec: r[a],
                        style: i,
                        styleSpec: n,
                      })
                    : [new jt(a, e[a], `unknown property "${a}"`)]
                );
              }
              return o;
            }
            function Vr(t) {
              const e = t.value,
                n = t.key,
                r = t.style,
                i = t.styleSpec,
                o = i.terrain;
              let s = [];
              const a = tr(e);
              if (void 0 === e) return s;
              if ("object" !== a)
                return (
                  (s = s.concat([
                    new jt("terrain", e, `object expected, ${a} found`),
                  ])),
                  s
                );
              for (const l in e) {
                const t = l.match(/^(.*)-transition$/);
                s = s.concat(
                  t && o[t[1]] && o[t[1]].transition
                    ? Gr({
                        key: l,
                        value: e[l],
                        valueSpec: i.transition,
                        style: r,
                        styleSpec: i,
                      })
                    : o[l]
                    ? Gr({
                        key: l,
                        value: e[l],
                        valueSpec: o[l],
                        style: r,
                        styleSpec: i,
                      })
                    : [new jt(l, e[l], `unknown property "${l}"`)]
                );
              }
              if (e.source) {
                const t = r.sources && r.sources[e.source],
                  i = t && Vt(t.type);
                t
                  ? "raster-dem" !== i &&
                    s.push(
                      new jt(
                        n,
                        e.source,
                        `terrain cannot be used with a source of type ${i}, it only be used with a "raster-dem" source type`
                      )
                    )
                  : s.push(
                      new jt(n, e.source, `source "${e.source}" not found`)
                    );
              } else s.push(new jt(n, e, 'terrain is missing required property "source"'));
              return s;
            }
            function qr(t) {
              const e = t.value,
                n = t.style,
                r = t.styleSpec,
                i = r.fog;
              let o = [];
              const s = tr(e);
              if (void 0 === e) return o;
              if ("object" !== s)
                return (
                  (o = o.concat([
                    new jt("fog", e, `object expected, ${s} found`),
                  ])),
                  o
                );
              for (const a in e) {
                const t = a.match(/^(.*)-transition$/);
                o = o.concat(
                  t && i[t[1]] && i[t[1]].transition
                    ? Gr({
                        key: a,
                        value: e[a],
                        valueSpec: r.transition,
                        style: n,
                        styleSpec: r,
                      })
                    : i[a]
                    ? Gr({
                        key: a,
                        value: e[a],
                        valueSpec: i[a],
                        style: n,
                        styleSpec: r,
                      })
                    : [new jt(a, e[a], `unknown property "${a}"`)]
                );
              }
              return o;
            }
            const $r = {
              "*": () => [],
              array: _r,
              boolean: function (t) {
                const e = t.value,
                  n = t.key,
                  r = tr(e);
                return "boolean" !== r
                  ? [new jt(n, e, `boolean expected, ${r} found`)]
                  : [];
              },
              number: vr,
              color: function (t) {
                const e = t.key,
                  n = t.value,
                  r = tr(n);
                return "string" !== r
                  ? [new jt(e, n, `color expected, ${r} found`)]
                  : null === ue.parseCSSColor(n)
                  ? [new jt(e, n, `color expected, "${n}" found`)]
                  : [];
              },
              constants: Ut,
              enum: wr,
              filter: Dr,
              function: br,
              layer: Br,
              object: yr,
              source: Ur,
              light: Zr,
              terrain: Vr,
              fog: qr,
              string: Nr,
              formatted: function (t) {
                return 0 === Nr(t).length ? [] : xr(t);
              },
              resolvedImage: function (t) {
                return 0 === Nr(t).length ? [] : xr(t);
              },
            };
            function Gr(t) {
              const e = t.value,
                n = t.valueSpec,
                r = t.styleSpec;
              return n.expression && er(Vt(e))
                ? br(t)
                : n.expression && ur(qt(e))
                ? xr(t)
                : n.type && $r[n.type]
                ? $r[n.type](t)
                : yr(Zt({}, t, { valueSpec: n.type ? r[n.type] : n }));
            }
            function Wr(t) {
              const e = t.value,
                n = t.key,
                r = Nr(t);
              return (
                r.length ||
                  (-1 === e.indexOf("{fontstack}") &&
                    r.push(
                      new jt(
                        n,
                        e,
                        '"glyphs" url must include a "{fontstack}" token'
                      )
                    ),
                  -1 === e.indexOf("{range}") &&
                    r.push(
                      new jt(
                        n,
                        e,
                        '"glyphs" url must include a "{range}" token'
                      )
                    )),
                r
              );
            }
            function Hr(t, e = Nt) {
              let n = [];
              return (
                (n = n.concat(
                  Gr({
                    key: "",
                    value: t,
                    valueSpec: e.$root,
                    styleSpec: e,
                    style: t,
                    objectElementValidators: { glyphs: Wr, "*": () => [] },
                  })
                )),
                t.constants &&
                  (n = n.concat(
                    Ut({
                      key: "constants",
                      value: t.constants,
                      style: t,
                      styleSpec: e,
                    })
                  )),
                Xr(n)
              );
            }
            function Xr(t) {
              return [].concat(t).sort((t, e) => t.line - e.line);
            }
            function Kr(t) {
              return function (...e) {
                return Xr(t.apply(this, e));
              };
            }
            (Hr.source = Kr(Ur)),
              (Hr.light = Kr(Zr)),
              (Hr.terrain = Kr(Vr)),
              (Hr.fog = Kr(qr)),
              (Hr.layer = Kr(Br)),
              (Hr.filter = Kr(Dr)),
              (Hr.paintProperty = Kr(Lr)),
              (Hr.layoutProperty = Kr(Fr));
            const Yr = Hr,
              Qr = Yr.light,
              Jr = Yr.fog,
              ti = Yr.paintProperty,
              ei = Yr.layoutProperty;
            function ni(t, e) {
              let n = !1;
              if (e && e.length)
                for (const r of e)
                  t.fire(new Ft(new Error(r.message))), (n = !0);
              return n;
            }
            var ri = ii;
            function ii(t, e, n) {
              var r = (this.cells = []);
              if (t instanceof ArrayBuffer) {
                this.arrayBuffer = t;
                var i = new Int32Array(this.arrayBuffer);
                (t = i[0]), (this.d = (e = i[1]) + 2 * (n = i[2]));
                for (var o = 0; o < this.d * this.d; o++) {
                  var s = i[3 + o],
                    a = i[3 + o + 1];
                  r.push(s === a ? null : i.subarray(s, a));
                }
                var l = i[3 + r.length + 1];
                (this.keys = i.subarray(i[3 + r.length], l)),
                  (this.bboxes = i.subarray(l)),
                  (this.insert = this._insertReadonly);
              } else {
                this.d = e + 2 * n;
                for (var c = 0; c < this.d * this.d; c++) r.push([]);
                (this.keys = []), (this.bboxes = []);
              }
              (this.n = e),
                (this.extent = t),
                (this.padding = n),
                (this.scale = e / t),
                (this.uid = 0);
              var u = (n / e) * t;
              (this.min = -u), (this.max = t + u);
            }
            (ii.prototype.insert = function (t, e, n, r, i) {
              this._forEachCell(e, n, r, i, this._insertCell, this.uid++),
                this.keys.push(t),
                this.bboxes.push(e),
                this.bboxes.push(n),
                this.bboxes.push(r),
                this.bboxes.push(i);
            }),
              (ii.prototype._insertReadonly = function () {
                throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
              }),
              (ii.prototype._insertCell = function (t, e, n, r, i, o) {
                this.cells[i].push(o);
              }),
              (ii.prototype.query = function (t, e, n, r, i) {
                var o = this.min,
                  s = this.max;
                if (t <= o && e <= o && s <= n && s <= r && !i)
                  return Array.prototype.slice.call(this.keys);
                var a = [];
                return (
                  this._forEachCell(t, e, n, r, this._queryCell, a, {}, i), a
                );
              }),
              (ii.prototype._queryCell = function (t, e, n, r, i, o, s, a) {
                var l = this.cells[i];
                if (null !== l)
                  for (
                    var c = this.keys, u = this.bboxes, h = 0;
                    h < l.length;
                    h++
                  ) {
                    var p = l[h];
                    if (void 0 === s[p]) {
                      var d = 4 * p;
                      (
                        a
                          ? a(u[d + 0], u[d + 1], u[d + 2], u[d + 3])
                          : t <= u[d + 2] &&
                            e <= u[d + 3] &&
                            n >= u[d + 0] &&
                            r >= u[d + 1]
                      )
                        ? ((s[p] = !0), o.push(c[p]))
                        : (s[p] = !1);
                    }
                  }
              }),
              (ii.prototype._forEachCell = function (t, e, n, r, i, o, s, a) {
                for (
                  var l = this._convertToCellCoord(t),
                    c = this._convertToCellCoord(e),
                    u = this._convertToCellCoord(n),
                    h = this._convertToCellCoord(r),
                    p = l;
                  p <= u;
                  p++
                )
                  for (var d = c; d <= h; d++) {
                    var f = this.d * d + p;
                    if (
                      (!a ||
                        a(
                          this._convertFromCellCoord(p),
                          this._convertFromCellCoord(d),
                          this._convertFromCellCoord(p + 1),
                          this._convertFromCellCoord(d + 1)
                        )) &&
                      i.call(this, t, e, n, r, f, o, s, a)
                    )
                      return;
                  }
              }),
              (ii.prototype._convertFromCellCoord = function (t) {
                return (t - this.padding) / this.scale;
              }),
              (ii.prototype._convertToCellCoord = function (t) {
                return Math.max(
                  0,
                  Math.min(
                    this.d - 1,
                    Math.floor(t * this.scale) + this.padding
                  )
                );
              }),
              (ii.prototype.toArrayBuffer = function () {
                if (this.arrayBuffer) return this.arrayBuffer;
                for (
                  var t = this.cells,
                    e = 3 + this.cells.length + 1 + 1,
                    n = 0,
                    r = 0;
                  r < this.cells.length;
                  r++
                )
                  n += this.cells[r].length;
                var i = new Int32Array(
                  e + n + this.keys.length + this.bboxes.length
                );
                (i[0] = this.extent), (i[1] = this.n), (i[2] = this.padding);
                for (var o = e, s = 0; s < t.length; s++) {
                  var a = t[s];
                  (i[3 + s] = o), i.set(a, o), (o += a.length);
                }
                return (
                  (i[3 + t.length] = o),
                  i.set(this.keys, o),
                  (i[3 + t.length + 1] = o += this.keys.length),
                  i.set(this.bboxes, o),
                  (o += this.bboxes.length),
                  i.buffer
                );
              });
            const { ImageData: oi, ImageBitmap: si } = a,
              ai = {};
            function li(t, e, n = {}) {
              Object.defineProperty(e, "_classRegistryKey", {
                value: t,
                writeable: !1,
              }),
                (ai[t] = {
                  klass: e,
                  omit: n.omit || [],
                  shallow: n.shallow || [],
                });
            }
            li("Object", Object),
              (ri.serialize = function (t, e) {
                const n = t.toArrayBuffer();
                return e && e.push(n), { buffer: n };
              }),
              (ri.deserialize = function (t) {
                return new ri(t.buffer);
              }),
              li("Grid", ri),
              li("Color", he),
              li("Error", Error),
              li("ResolvedImage", me),
              li("StylePropertyFunction", mr),
              li("StyleExpression", cr, { omit: ["_evaluator"] }),
              li("ZoomDependentExpression", dr),
              li("ZoomConstantExpression", pr),
              li("CompoundExpression", Oe, { omit: ["_evaluate"] });
            for (const r in qn)
              qn[r]._classRegistryKey || li(`Expression_${r}`, qn[r]);
            function ci(t) {
              return (
                t &&
                "undefined" != typeof ArrayBuffer &&
                (t instanceof ArrayBuffer ||
                  (t.constructor && "ArrayBuffer" === t.constructor.name))
              );
            }
            function ui(t) {
              return si && t instanceof si;
            }
            function hi(t, e) {
              if (
                null == t ||
                "boolean" == typeof t ||
                "number" == typeof t ||
                "string" == typeof t ||
                t instanceof Boolean ||
                t instanceof Number ||
                t instanceof String ||
                t instanceof Date ||
                t instanceof RegExp
              )
                return t;
              if (ci(t) || ui(t)) return e && e.push(t), t;
              if (ArrayBuffer.isView(t)) {
                const n = t;
                return e && e.push(n.buffer), n;
              }
              if (t instanceof oi) return e && e.push(t.data.buffer), t;
              if (Array.isArray(t)) {
                const n = [];
                for (const r of t) n.push(hi(r, e));
                return n;
              }
              if ("object" == typeof t) {
                const n = t.constructor,
                  r = n._classRegistryKey;
                if (!r)
                  throw new Error(
                    "can't serialize object of unregistered class"
                  );
                const i = n.serialize ? n.serialize(t, e) : {};
                if (!n.serialize) {
                  for (const n in t) {
                    if (!t.hasOwnProperty(n)) continue;
                    if (ai[r].omit.indexOf(n) >= 0) continue;
                    const o = t[n];
                    i[n] = ai[r].shallow.indexOf(n) >= 0 ? o : hi(o, e);
                  }
                  t instanceof Error && (i.message = t.message);
                }
                if (i.$name)
                  throw new Error(
                    "$name property is reserved for worker serialization logic."
                  );
                return "Object" !== r && (i.$name = r), i;
              }
              throw new Error("can't serialize object of type " + typeof t);
            }
            function pi(t) {
              if (
                null == t ||
                "boolean" == typeof t ||
                "number" == typeof t ||
                "string" == typeof t ||
                t instanceof Boolean ||
                t instanceof Number ||
                t instanceof String ||
                t instanceof Date ||
                t instanceof RegExp ||
                ci(t) ||
                ui(t) ||
                ArrayBuffer.isView(t) ||
                t instanceof oi
              )
                return t;
              if (Array.isArray(t)) return t.map(pi);
              if ("object" == typeof t) {
                const e = t.$name || "Object",
                  { klass: n } = ai[e];
                if (!n)
                  throw new Error(`can't deserialize unregistered class ${e}`);
                if (n.deserialize) return n.deserialize(t);
                const r = Object.create(n.prototype);
                for (const i of Object.keys(t)) {
                  if ("$name" === i) continue;
                  const n = t[i];
                  r[i] = ai[e].shallow.indexOf(i) >= 0 ? n : pi(n);
                }
                return r;
              }
              throw new Error("can't deserialize object of type " + typeof t);
            }
            class di {
              constructor() {
                this.first = !0;
              }
              update(t, e) {
                const n = Math.floor(t);
                return this.first
                  ? ((this.first = !1),
                    (this.lastIntegerZoom = n),
                    (this.lastIntegerZoomTime = 0),
                    (this.lastZoom = t),
                    (this.lastFloorZoom = n),
                    !0)
                  : (this.lastFloorZoom > n
                      ? ((this.lastIntegerZoom = n + 1),
                        (this.lastIntegerZoomTime = e))
                      : this.lastFloorZoom < n &&
                        ((this.lastIntegerZoom = n),
                        (this.lastIntegerZoomTime = e)),
                    t !== this.lastZoom &&
                      ((this.lastZoom = t), (this.lastFloorZoom = n), !0));
              }
            }
            const fi = (t) => t >= 1536 && t <= 1791,
              mi = (t) => t >= 1872 && t <= 1919,
              gi = (t) => t >= 2208 && t <= 2303,
              yi = (t) => t >= 11904 && t <= 12031,
              _i = (t) => t >= 12032 && t <= 12255,
              vi = (t) => t >= 12272 && t <= 12287,
              bi = (t) => t >= 12288 && t <= 12351,
              xi = (t) => t >= 12352 && t <= 12447,
              wi = (t) => t >= 12448 && t <= 12543,
              Si = (t) => t >= 12544 && t <= 12591,
              Ei = (t) => t >= 12704 && t <= 12735,
              Ti = (t) => t >= 12736 && t <= 12783,
              Ai = (t) => t >= 12784 && t <= 12799,
              Ci = (t) => t >= 12800 && t <= 13055,
              Pi = (t) => t >= 13056 && t <= 13311,
              Mi = (t) => t >= 13312 && t <= 19903,
              Oi = (t) => t >= 19968 && t <= 40959,
              ki = (t) => t >= 40960 && t <= 42127,
              Ii = (t) => t >= 42128 && t <= 42191,
              Di = (t) => t >= 44032 && t <= 55215,
              zi = (t) => t >= 63744 && t <= 64255,
              Ri = (t) => t >= 64336 && t <= 65023,
              Li = (t) => t >= 65040 && t <= 65055,
              Fi = (t) => t >= 65072 && t <= 65103,
              Bi = (t) => t >= 65104 && t <= 65135,
              Ni = (t) => t >= 65136 && t <= 65279,
              ji = (t) => t >= 65280 && t <= 65519;
            function Ui(t) {
              for (const e of t) if (qi(e.charCodeAt(0))) return !0;
              return !1;
            }
            function Zi(t) {
              for (const e of t) if (!Vi(e.charCodeAt(0))) return !1;
              return !0;
            }
            function Vi(t) {
              return !(fi(t) || mi(t) || gi(t) || Ri(t) || Ni(t));
            }
            function qi(t) {
              return !(
                746 !== t &&
                747 !== t &&
                (t < 4352 ||
                  !(
                    Ei(t) ||
                    Si(t) ||
                    (Fi(t) && !(t >= 65097 && t <= 65103)) ||
                    zi(t) ||
                    Pi(t) ||
                    yi(t) ||
                    Ti(t) ||
                    !(
                      !bi(t) ||
                      (t >= 12296 && t <= 12305) ||
                      (t >= 12308 && t <= 12319) ||
                      12336 === t
                    ) ||
                    Mi(t) ||
                    Oi(t) ||
                    Ci(t) ||
                    ((t) => t >= 12592 && t <= 12687)(t) ||
                    ((t) => t >= 43360 && t <= 43391)(t) ||
                    ((t) => t >= 55216 && t <= 55295)(t) ||
                    ((t) => t >= 4352 && t <= 4607)(t) ||
                    Di(t) ||
                    xi(t) ||
                    vi(t) ||
                    ((t) => t >= 12688 && t <= 12703)(t) ||
                    _i(t) ||
                    Ai(t) ||
                    (wi(t) && 12540 !== t) ||
                    !(
                      !ji(t) ||
                      65288 === t ||
                      65289 === t ||
                      65293 === t ||
                      (t >= 65306 && t <= 65310) ||
                      65339 === t ||
                      65341 === t ||
                      65343 === t ||
                      (t >= 65371 && t <= 65503) ||
                      65507 === t ||
                      (t >= 65512 && t <= 65519)
                    ) ||
                    !(
                      !Bi(t) ||
                      (t >= 65112 && t <= 65118) ||
                      (t >= 65123 && t <= 65126)
                    ) ||
                    ((t) => t >= 5120 && t <= 5759)(t) ||
                    ((t) => t >= 6320 && t <= 6399)(t) ||
                    Li(t) ||
                    ((t) => t >= 19904 && t <= 19967)(t) ||
                    ki(t) ||
                    Ii(t)
                  ))
              );
            }
            function $i(t) {
              return !(
                qi(t) ||
                (function (t) {
                  return !!(
                    (((t) => t >= 128 && t <= 255)(t) &&
                      (167 === t ||
                        169 === t ||
                        174 === t ||
                        177 === t ||
                        188 === t ||
                        189 === t ||
                        190 === t ||
                        215 === t ||
                        247 === t)) ||
                    (((t) => t >= 8192 && t <= 8303)(t) &&
                      (8214 === t ||
                        8224 === t ||
                        8225 === t ||
                        8240 === t ||
                        8241 === t ||
                        8251 === t ||
                        8252 === t ||
                        8258 === t ||
                        8263 === t ||
                        8264 === t ||
                        8265 === t ||
                        8273 === t)) ||
                    ((t) => t >= 8448 && t <= 8527)(t) ||
                    ((t) => t >= 8528 && t <= 8591)(t) ||
                    (((t) => t >= 8960 && t <= 9215)(t) &&
                      ((t >= 8960 && t <= 8967) ||
                        (t >= 8972 && t <= 8991) ||
                        (t >= 8996 && t <= 9e3) ||
                        9003 === t ||
                        (t >= 9085 && t <= 9114) ||
                        (t >= 9150 && t <= 9165) ||
                        9167 === t ||
                        (t >= 9169 && t <= 9179) ||
                        (t >= 9186 && t <= 9215))) ||
                    (((t) => t >= 9216 && t <= 9279)(t) && 9251 !== t) ||
                    ((t) => t >= 9280 && t <= 9311)(t) ||
                    ((t) => t >= 9312 && t <= 9471)(t) ||
                    ((t) => t >= 9632 && t <= 9727)(t) ||
                    (((t) => t >= 9728 && t <= 9983)(t) &&
                      !(t >= 9754 && t <= 9759)) ||
                    (((t) => t >= 11008 && t <= 11263)(t) &&
                      ((t >= 11026 && t <= 11055) ||
                        (t >= 11088 && t <= 11097) ||
                        (t >= 11192 && t <= 11243))) ||
                    bi(t) ||
                    wi(t) ||
                    ((t) => t >= 57344 && t <= 63743)(t) ||
                    Fi(t) ||
                    Bi(t) ||
                    ji(t) ||
                    8734 === t ||
                    8756 === t ||
                    8757 === t ||
                    (t >= 9984 && t <= 10087) ||
                    (t >= 10102 && t <= 10131) ||
                    65532 === t ||
                    65533 === t
                  );
                })(t)
              );
            }
            function Gi(t) {
              return (t >= 1424 && t <= 2303) || Ri(t) || Ni(t);
            }
            function Wi(t, e) {
              return !(
                (!e && Gi(t)) ||
                (t >= 2304 && t <= 3583) ||
                (t >= 3840 && t <= 4255) ||
                ((t) => t >= 6016 && t <= 6143)(t)
              );
            }
            function Hi(t) {
              for (const e of t) if (Gi(e.charCodeAt(0))) return !0;
              return !1;
            }
            const Xi = "deferred",
              Ki = "loading",
              Yi = "loaded";
            let Qi = null,
              Ji = "unavailable",
              to = null;
            const eo = function (t) {
              t &&
                "string" == typeof t &&
                t.indexOf("NetworkError") > -1 &&
                (Ji = "error"),
                Qi && Qi(t);
            };
            function no() {
              ro.fire(
                new Lt("pluginStateChange", { pluginStatus: Ji, pluginURL: to })
              );
            }
            const ro = new Bt(),
              io = function () {
                return Ji;
              },
              oo = function () {
                if (Ji !== Xi || !to)
                  throw new Error(
                    "rtl-text-plugin cannot be downloaded unless a pluginURL is specified"
                  );
                (Ji = Ki),
                  no(),
                  to &&
                    At({ url: to }, (t) => {
                      t ? eo(t) : ((Ji = Yi), no());
                    });
              },
              so = {
                applyArabicShaping: null,
                processBidirectionalText: null,
                processStyledBidirectionalText: null,
                isLoaded: () => Ji === Yi || null != so.applyArabicShaping,
                isLoading: () => Ji === Ki,
                setState(t) {
                  (Ji = t.pluginStatus), (to = t.pluginURL);
                },
                isParsed: () =>
                  null != so.applyArabicShaping &&
                  null != so.processBidirectionalText &&
                  null != so.processStyledBidirectionalText,
                getPluginURL: () => to,
              };
            class ao {
              constructor(t, e) {
                (this.zoom = t),
                  e
                    ? ((this.now = e.now),
                      (this.fadeDuration = e.fadeDuration),
                      (this.zoomHistory = e.zoomHistory),
                      (this.transition = e.transition))
                    : ((this.now = 0),
                      (this.fadeDuration = 0),
                      (this.zoomHistory = new di()),
                      (this.transition = {}));
              }
              isSupportedScript(t) {
                return (function (t, e) {
                  for (const n of t) if (!Wi(n.charCodeAt(0), e)) return !1;
                  return !0;
                })(t, so.isLoaded());
              }
              crossFadingFactor() {
                return 0 === this.fadeDuration
                  ? 1
                  : Math.min(
                      (this.now - this.zoomHistory.lastIntegerZoomTime) /
                        this.fadeDuration,
                      1
                    );
              }
              getCrossfadeParameters() {
                const t = this.zoom,
                  e = t - Math.floor(t),
                  n = this.crossFadingFactor();
                return t > this.zoomHistory.lastIntegerZoom
                  ? { fromScale: 2, toScale: 1, t: e + (1 - e) * n }
                  : { fromScale: 0.5, toScale: 1, t: 1 - (1 - n) * e };
              }
            }
            class lo {
              constructor(t, e) {
                (this.property = t),
                  (this.value = e),
                  (this.expression = (function (t, e) {
                    if (er(t)) return new mr(t, e);
                    if (ur(t)) {
                      const n = fr(t, e);
                      if ("error" === n.result)
                        throw new Error(
                          n.value
                            .map((t) => `${t.key}: ${t.message}`)
                            .join(", ")
                        );
                      return n.value;
                    }
                    {
                      let n = t;
                      return (
                        "string" == typeof t &&
                          "color" === e.type &&
                          (n = he.parse(t)),
                        { kind: "constant", evaluate: () => n }
                      );
                    }
                  })(
                    void 0 === e ? t.specification.default : e,
                    t.specification
                  ));
              }
              isDataDriven() {
                return (
                  "source" === this.expression.kind ||
                  "composite" === this.expression.kind
                );
              }
              possiblyEvaluate(t, e, n) {
                return this.property.possiblyEvaluate(this, t, e, n);
              }
            }
            class co {
              constructor(t) {
                (this.property = t), (this.value = new lo(t, void 0));
              }
              transitioned(t, e) {
                return new ho(
                  this.property,
                  this.value,
                  e,
                  b({}, t.transition, this.transition),
                  t.now
                );
              }
              untransitioned() {
                return new ho(this.property, this.value, null, {}, 0);
              }
            }
            class uo {
              constructor(t) {
                (this._properties = t),
                  (this._values = Object.create(
                    t.defaultTransitionablePropertyValues
                  ));
              }
              getValue(t) {
                return O(this._values[t].value.value);
              }
              setValue(t, e) {
                this._values.hasOwnProperty(t) ||
                  (this._values[t] = new co(this._values[t].property)),
                  (this._values[t].value = new lo(
                    this._values[t].property,
                    null === e ? void 0 : O(e)
                  ));
              }
              getTransition(t) {
                return O(this._values[t].transition);
              }
              setTransition(t, e) {
                this._values.hasOwnProperty(t) ||
                  (this._values[t] = new co(this._values[t].property)),
                  (this._values[t].transition = O(e) || void 0);
              }
              serialize() {
                const t = {};
                for (const e of Object.keys(this._values)) {
                  const n = this.getValue(e);
                  void 0 !== n && (t[e] = n);
                  const r = this.getTransition(e);
                  void 0 !== r && (t[`${e}-transition`] = r);
                }
                return t;
              }
              transitioned(t, e) {
                const n = new po(this._properties);
                for (const r of Object.keys(this._values))
                  n._values[r] = this._values[r].transitioned(t, e._values[r]);
                return n;
              }
              untransitioned() {
                const t = new po(this._properties);
                for (const e of Object.keys(this._values))
                  t._values[e] = this._values[e].untransitioned();
                return t;
              }
            }
            class ho {
              constructor(t, e, n, r, i) {
                const o = r.delay || 0,
                  s = r.duration || 0;
                (i = i || 0),
                  (this.property = t),
                  (this.value = e),
                  (this.begin = i + o),
                  (this.end = this.begin + s),
                  t.specification.transition &&
                    (r.delay || r.duration) &&
                    (this.prior = n);
              }
              possiblyEvaluate(t, e, n) {
                const r = t.now || 0,
                  i = this.value.possiblyEvaluate(t, e, n),
                  o = this.prior;
                if (o) {
                  if (r > this.end) return (this.prior = null), i;
                  if (this.value.isDataDriven()) return (this.prior = null), i;
                  if (r < this.begin) return o.possiblyEvaluate(t, e, n);
                  {
                    const s = (r - this.begin) / (this.end - this.begin);
                    return this.property.interpolate(
                      o.possiblyEvaluate(t, e, n),
                      i,
                      d(s)
                    );
                  }
                }
                return i;
              }
            }
            class po {
              constructor(t) {
                (this._properties = t),
                  (this._values = Object.create(
                    t.defaultTransitioningPropertyValues
                  ));
              }
              possiblyEvaluate(t, e, n) {
                const r = new go(this._properties);
                for (const i of Object.keys(this._values))
                  r._values[i] = this._values[i].possiblyEvaluate(t, e, n);
                return r;
              }
              hasTransition() {
                for (const t of Object.keys(this._values))
                  if (this._values[t].prior) return !0;
                return !1;
              }
            }
            class fo {
              constructor(t) {
                (this._properties = t),
                  (this._values = Object.create(t.defaultPropertyValues));
              }
              getValue(t) {
                return O(this._values[t].value);
              }
              setValue(t, e) {
                this._values[t] = new lo(
                  this._values[t].property,
                  null === e ? void 0 : O(e)
                );
              }
              serialize() {
                const t = {};
                for (const e of Object.keys(this._values)) {
                  const n = this.getValue(e);
                  void 0 !== n && (t[e] = n);
                }
                return t;
              }
              possiblyEvaluate(t, e, n) {
                const r = new go(this._properties);
                for (const i of Object.keys(this._values))
                  r._values[i] = this._values[i].possiblyEvaluate(t, e, n);
                return r;
              }
            }
            class mo {
              constructor(t, e, n) {
                (this.property = t), (this.value = e), (this.parameters = n);
              }
              isConstant() {
                return "constant" === this.value.kind;
              }
              constantOr(t) {
                return "constant" === this.value.kind ? this.value.value : t;
              }
              evaluate(t, e, n, r) {
                return this.property.evaluate(
                  this.value,
                  this.parameters,
                  t,
                  e,
                  n,
                  r
                );
              }
            }
            class go {
              constructor(t) {
                (this._properties = t),
                  (this._values = Object.create(
                    t.defaultPossiblyEvaluatedValues
                  ));
              }
              get(t) {
                return this._values[t];
              }
            }
            class yo {
              constructor(t) {
                this.specification = t;
              }
              possiblyEvaluate(t, e) {
                return t.expression.evaluate(e);
              }
              interpolate(t, e, n) {
                const r = on[this.specification.type];
                return r ? r(t, e, n) : t;
              }
            }
            class _o {
              constructor(t, e) {
                (this.specification = t), (this.overrides = e);
              }
              possiblyEvaluate(t, e, n, r) {
                return new mo(
                  this,
                  "constant" === t.expression.kind ||
                  "camera" === t.expression.kind
                    ? {
                        kind: "constant",
                        value: t.expression.evaluate(e, null, {}, n, r),
                      }
                    : t.expression,
                  e
                );
              }
              interpolate(t, e, n) {
                if ("constant" !== t.value.kind || "constant" !== e.value.kind)
                  return t;
                if (void 0 === t.value.value || void 0 === e.value.value)
                  return new mo(
                    this,
                    { kind: "constant", value: void 0 },
                    t.parameters
                  );
                const r = on[this.specification.type];
                return r
                  ? new mo(
                      this,
                      {
                        kind: "constant",
                        value: r(t.value.value, e.value.value, n),
                      },
                      t.parameters
                    )
                  : t;
              }
              evaluate(t, e, n, r, i, o) {
                return "constant" === t.kind
                  ? t.value
                  : t.evaluate(e, n, r, i, o);
              }
            }
            class vo extends _o {
              possiblyEvaluate(t, e, n, r) {
                if (void 0 === t.value)
                  return new mo(this, { kind: "constant", value: void 0 }, e);
                if ("constant" === t.expression.kind) {
                  const i = t.expression.evaluate(e, null, {}, n, r),
                    o =
                      "resolvedImage" === t.property.specification.type &&
                      "string" != typeof i
                        ? i.name
                        : i,
                    s = this._calculate(o, o, o, e);
                  return new mo(this, { kind: "constant", value: s }, e);
                }
                if ("camera" === t.expression.kind) {
                  const n = this._calculate(
                    t.expression.evaluate({ zoom: e.zoom - 1 }),
                    t.expression.evaluate({ zoom: e.zoom }),
                    t.expression.evaluate({ zoom: e.zoom + 1 }),
                    e
                  );
                  return new mo(this, { kind: "constant", value: n }, e);
                }
                return new mo(this, t.expression, e);
              }
              evaluate(t, e, n, r, i, o) {
                if ("source" === t.kind) {
                  const s = t.evaluate(e, n, r, i, o);
                  return this._calculate(s, s, s, e);
                }
                return "composite" === t.kind
                  ? this._calculate(
                      t.evaluate({ zoom: Math.floor(e.zoom) - 1 }, n, r),
                      t.evaluate({ zoom: Math.floor(e.zoom) }, n, r),
                      t.evaluate({ zoom: Math.floor(e.zoom) + 1 }, n, r),
                      e
                    )
                  : t.value;
              }
              _calculate(t, e, n, r) {
                return r.zoom > r.zoomHistory.lastIntegerZoom
                  ? { from: t, to: e, other: n }
                  : { from: n, to: e, other: t };
              }
              interpolate(t) {
                return t;
              }
            }
            class bo {
              constructor(t) {
                this.specification = t;
              }
              possiblyEvaluate(t, e, n, r) {
                if (void 0 !== t.value) {
                  if ("constant" === t.expression.kind) {
                    const i = t.expression.evaluate(e, null, {}, n, r);
                    return this._calculate(i, i, i, e);
                  }
                  return this._calculate(
                    t.expression.evaluate(new ao(Math.floor(e.zoom - 1), e)),
                    t.expression.evaluate(new ao(Math.floor(e.zoom), e)),
                    t.expression.evaluate(new ao(Math.floor(e.zoom + 1), e)),
                    e
                  );
                }
              }
              _calculate(t, e, n, r) {
                return r.zoom > r.zoomHistory.lastIntegerZoom
                  ? { from: t, to: e }
                  : { from: n, to: e };
              }
              interpolate(t) {
                return t;
              }
            }
            class xo {
              constructor(t) {
                this.specification = t;
              }
              possiblyEvaluate(t, e, n, r) {
                return !!t.expression.evaluate(e, null, {}, n, r);
              }
              interpolate() {
                return !1;
              }
            }
            class wo {
              constructor(t) {
                (this.properties = t),
                  (this.defaultPropertyValues = {}),
                  (this.defaultTransitionablePropertyValues = {}),
                  (this.defaultTransitioningPropertyValues = {}),
                  (this.defaultPossiblyEvaluatedValues = {}),
                  (this.overridableProperties = []);
                for (const e in t) {
                  const n = t[e];
                  n.specification.overridable &&
                    this.overridableProperties.push(e);
                  const r = (this.defaultPropertyValues[e] = new lo(n, void 0)),
                    i = (this.defaultTransitionablePropertyValues[e] = new co(
                      n
                    ));
                  (this.defaultTransitioningPropertyValues[e] =
                    i.untransitioned()),
                    (this.defaultPossiblyEvaluatedValues[e] =
                      r.possiblyEvaluate({}));
                }
              }
            }
            function So(t, e) {
              return (
                256 * (t = g(Math.floor(t), 0, 255)) + g(Math.floor(e), 0, 255)
              );
            }
            li("DataDrivenProperty", _o),
              li("DataConstantProperty", yo),
              li("CrossFadedDataDrivenProperty", vo),
              li("CrossFadedProperty", bo),
              li("ColorRampProperty", xo);
            const Eo = {
              Int8: Int8Array,
              Uint8: Uint8Array,
              Int16: Int16Array,
              Uint16: Uint16Array,
              Int32: Int32Array,
              Uint32: Uint32Array,
              Float32: Float32Array,
            };
            class To {
              constructor(t, e) {
                (this._structArray = t),
                  (this._pos1 = e * this.size),
                  (this._pos2 = this._pos1 / 2),
                  (this._pos4 = this._pos1 / 4),
                  (this._pos8 = this._pos1 / 8);
              }
            }
            class Ao {
              constructor() {
                (this.isTransferred = !1), (this.capacity = -1), this.resize(0);
              }
              static serialize(t, e) {
                return (
                  t._trim(),
                  e && ((t.isTransferred = !0), e.push(t.arrayBuffer)),
                  { length: t.length, arrayBuffer: t.arrayBuffer }
                );
              }
              static deserialize(t) {
                const e = Object.create(this.prototype);
                return (
                  (e.arrayBuffer = t.arrayBuffer),
                  (e.length = t.length),
                  (e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement),
                  e._refreshViews(),
                  e
                );
              }
              _trim() {
                this.length !== this.capacity &&
                  ((this.capacity = this.length),
                  (this.arrayBuffer = this.arrayBuffer.slice(
                    0,
                    this.length * this.bytesPerElement
                  )),
                  this._refreshViews());
              }
              clear() {
                this.length = 0;
              }
              resize(t) {
                this.reserve(t), (this.length = t);
              }
              reserve(t) {
                if (t > this.capacity) {
                  (this.capacity = Math.max(
                    t,
                    Math.floor(5 * this.capacity),
                    128
                  )),
                    (this.arrayBuffer = new ArrayBuffer(
                      this.capacity * this.bytesPerElement
                    ));
                  const e = this.uint8;
                  this._refreshViews(), e && this.uint8.set(e);
                }
              }
              _refreshViews() {
                throw new Error(
                  "_refreshViews() must be implemented by each concrete StructArray layout"
                );
              }
            }
            function Co(t, e = 1) {
              let n = 0,
                r = 0;
              return {
                members: t.map((t) => {
                  const i = Eo[t.type].BYTES_PER_ELEMENT,
                    o = (n = Po(n, Math.max(e, i))),
                    s = t.components || 1;
                  return (
                    (r = Math.max(r, i)),
                    (n += i * s),
                    { name: t.name, type: t.type, components: s, offset: o }
                  );
                }),
                size: Po(n, Math.max(r, e)),
                alignment: e,
              };
            }
            function Po(t, e) {
              return Math.ceil(t / e) * e;
            }
            class Mo extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(t, e) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t, e);
              }
              emplace(t, e, n) {
                const r = 2 * t;
                return (this.int16[r + 0] = e), (this.int16[r + 1] = n), t;
              }
            }
            (Mo.prototype.bytesPerElement = 4), li("StructArrayLayout2i4", Mo);
            class Oo extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(t, e, n, r) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t, e, n, r);
              }
              emplace(t, e, n, r, i) {
                const o = 4 * t;
                return (
                  (this.int16[o + 0] = e),
                  (this.int16[o + 1] = n),
                  (this.int16[o + 2] = r),
                  (this.int16[o + 3] = i),
                  t
                );
              }
            }
            (Oo.prototype.bytesPerElement = 8), li("StructArrayLayout4i8", Oo);
            class ko extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(t, e, n, r, i, o, s) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t, e, n, r, i, o, s);
              }
              emplace(t, e, n, r, i, o, s, a) {
                const l = 6 * t,
                  c = 12 * t,
                  u = 3 * t;
                return (
                  (this.int16[l + 0] = e),
                  (this.int16[l + 1] = n),
                  (this.uint8[c + 4] = r),
                  (this.uint8[c + 5] = i),
                  (this.uint8[c + 6] = o),
                  (this.uint8[c + 7] = s),
                  (this.float32[u + 2] = a),
                  t
                );
              }
            }
            (ko.prototype.bytesPerElement = 12),
              li("StructArrayLayout2i4ub1f12", ko);
            class Io extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(t, e) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t, e);
              }
              emplace(t, e, n) {
                const r = 2 * t;
                return (this.float32[r + 0] = e), (this.float32[r + 1] = n), t;
              }
            }
            (Io.prototype.bytesPerElement = 8), li("StructArrayLayout2f8", Io);
            class Do extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(t, e, n, r, i, o, s, a, l, c) {
                const u = this.length;
                return (
                  this.resize(u + 1),
                  this.emplace(u, t, e, n, r, i, o, s, a, l, c)
                );
              }
              emplace(t, e, n, r, i, o, s, a, l, c, u) {
                const h = 10 * t;
                return (
                  (this.uint16[h + 0] = e),
                  (this.uint16[h + 1] = n),
                  (this.uint16[h + 2] = r),
                  (this.uint16[h + 3] = i),
                  (this.uint16[h + 4] = o),
                  (this.uint16[h + 5] = s),
                  (this.uint16[h + 6] = a),
                  (this.uint16[h + 7] = l),
                  (this.uint16[h + 8] = c),
                  (this.uint16[h + 9] = u),
                  t
                );
              }
            }
            (Do.prototype.bytesPerElement = 20),
              li("StructArrayLayout10ui20", Do);
            class zo extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(t, e, n, r, i, o, s, a) {
                const l = this.length;
                return (
                  this.resize(l + 1), this.emplace(l, t, e, n, r, i, o, s, a)
                );
              }
              emplace(t, e, n, r, i, o, s, a, l) {
                const c = 8 * t;
                return (
                  (this.uint16[c + 0] = e),
                  (this.uint16[c + 1] = n),
                  (this.uint16[c + 2] = r),
                  (this.uint16[c + 3] = i),
                  (this.uint16[c + 4] = o),
                  (this.uint16[c + 5] = s),
                  (this.uint16[c + 6] = a),
                  (this.uint16[c + 7] = l),
                  t
                );
              }
            }
            (zo.prototype.bytesPerElement = 16),
              li("StructArrayLayout8ui16", zo);
            class Ro extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(t, e, n, r, i, o, s, a, l, c, u, h) {
                const p = this.length;
                return (
                  this.resize(p + 1),
                  this.emplace(p, t, e, n, r, i, o, s, a, l, c, u, h)
                );
              }
              emplace(t, e, n, r, i, o, s, a, l, c, u, h, p) {
                const d = 12 * t;
                return (
                  (this.int16[d + 0] = e),
                  (this.int16[d + 1] = n),
                  (this.int16[d + 2] = r),
                  (this.int16[d + 3] = i),
                  (this.uint16[d + 4] = o),
                  (this.uint16[d + 5] = s),
                  (this.uint16[d + 6] = a),
                  (this.uint16[d + 7] = l),
                  (this.int16[d + 8] = c),
                  (this.int16[d + 9] = u),
                  (this.int16[d + 10] = h),
                  (this.int16[d + 11] = p),
                  t
                );
              }
            }
            (Ro.prototype.bytesPerElement = 24),
              li("StructArrayLayout4i4ui4i24", Ro);
            class Lo extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(t, e, n) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t, e, n);
              }
              emplace(t, e, n, r) {
                const i = 3 * t;
                return (
                  (this.float32[i + 0] = e),
                  (this.float32[i + 1] = n),
                  (this.float32[i + 2] = r),
                  t
                );
              }
            }
            (Lo.prototype.bytesPerElement = 12),
              li("StructArrayLayout3f12", Lo);
            class Fo extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer));
              }
              emplaceBack(t) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t);
              }
              emplace(t, e) {
                return (this.uint32[1 * t + 0] = e), t;
              }
            }
            (Fo.prototype.bytesPerElement = 4), li("StructArrayLayout1ul4", Fo);
            class Bo extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(t, e, n, r, i, o, s, a, l, c) {
                const u = this.length;
                return (
                  this.resize(u + 1),
                  this.emplace(u, t, e, n, r, i, o, s, a, l, c)
                );
              }
              emplace(t, e, n, r, i, o, s, a, l, c, u) {
                const h = 16 * t,
                  p = 8 * t;
                return (
                  (this.int16[h + 0] = e),
                  (this.int16[h + 1] = n),
                  (this.float32[p + 1] = r),
                  (this.float32[p + 2] = i),
                  (this.float32[p + 3] = o),
                  (this.float32[p + 4] = s),
                  (this.int16[h + 10] = a),
                  (this.uint32[p + 6] = l),
                  (this.uint16[h + 14] = c),
                  (this.uint16[h + 15] = u),
                  t
                );
              }
            }
            (Bo.prototype.bytesPerElement = 32),
              li("StructArrayLayout2i4f1i1ul2ui32", Bo);
            class No extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(t, e, n, r, i, o) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t, e, n, r, i, o);
              }
              emplace(t, e, n, r, i, o, s) {
                const a = 6 * t;
                return (
                  (this.int16[a + 0] = e),
                  (this.int16[a + 1] = n),
                  (this.int16[a + 2] = r),
                  (this.int16[a + 3] = i),
                  (this.int16[a + 4] = o),
                  (this.int16[a + 5] = s),
                  t
                );
              }
            }
            (No.prototype.bytesPerElement = 12),
              li("StructArrayLayout2i2i2i12", No);
            class jo extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(t, e, n, r, i) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, t, e, n, r, i);
              }
              emplace(t, e, n, r, i, o) {
                const s = 4 * t,
                  a = 8 * t;
                return (
                  (this.float32[s + 0] = e),
                  (this.float32[s + 1] = n),
                  (this.float32[s + 2] = r),
                  (this.int16[a + 6] = i),
                  (this.int16[a + 7] = o),
                  t
                );
              }
            }
            (jo.prototype.bytesPerElement = 16),
              li("StructArrayLayout2f1f2i16", jo);
            class Uo extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(t, e, n, r) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t, e, n, r);
              }
              emplace(t, e, n, r, i) {
                const o = 12 * t,
                  s = 3 * t;
                return (
                  (this.uint8[o + 0] = e),
                  (this.uint8[o + 1] = n),
                  (this.float32[s + 1] = r),
                  (this.float32[s + 2] = i),
                  t
                );
              }
            }
            (Uo.prototype.bytesPerElement = 12),
              li("StructArrayLayout2ub2f12", Uo);
            class Zo extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(t, e, n) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t, e, n);
              }
              emplace(t, e, n, r) {
                const i = 3 * t;
                return (
                  (this.uint16[i + 0] = e),
                  (this.uint16[i + 1] = n),
                  (this.uint16[i + 2] = r),
                  t
                );
              }
            }
            (Zo.prototype.bytesPerElement = 6), li("StructArrayLayout3ui6", Zo);
            class Vo extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(
                t,
                e,
                n,
                r,
                i,
                o,
                s,
                a,
                l,
                c,
                u,
                h,
                p,
                d,
                f,
                m,
                g,
                y
              ) {
                const _ = this.length;
                return (
                  this.resize(_ + 1),
                  this.emplace(
                    _,
                    t,
                    e,
                    n,
                    r,
                    i,
                    o,
                    s,
                    a,
                    l,
                    c,
                    u,
                    h,
                    p,
                    d,
                    f,
                    m,
                    g,
                    y
                  )
                );
              }
              emplace(t, e, n, r, i, o, s, a, l, c, u, h, p, d, f, m, g, y, _) {
                const v = 13 * t,
                  b = 26 * t,
                  x = 52 * t;
                return (
                  (this.float32[v + 0] = e),
                  (this.float32[v + 1] = n),
                  (this.uint16[b + 4] = r),
                  (this.uint16[b + 5] = i),
                  (this.uint32[v + 3] = o),
                  (this.uint32[v + 4] = s),
                  (this.uint32[v + 5] = a),
                  (this.uint16[b + 12] = l),
                  (this.uint16[b + 13] = c),
                  (this.uint16[b + 14] = u),
                  (this.float32[v + 8] = h),
                  (this.float32[v + 9] = p),
                  (this.uint8[x + 40] = d),
                  (this.uint8[x + 41] = f),
                  (this.uint8[x + 42] = m),
                  (this.uint32[v + 11] = g),
                  (this.int16[b + 24] = y),
                  (this.uint8[x + 50] = _),
                  t
                );
              }
            }
            (Vo.prototype.bytesPerElement = 52),
              li("StructArrayLayout2f2ui3ul3ui2f3ub1ul1i1ub52", Vo);
            class qo extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer));
              }
              emplaceBack(
                t,
                e,
                n,
                r,
                i,
                o,
                s,
                a,
                l,
                c,
                u,
                h,
                p,
                d,
                f,
                m,
                g,
                y,
                _,
                v,
                b,
                x,
                w,
                S,
                E,
                T,
                A
              ) {
                const C = this.length;
                return (
                  this.resize(C + 1),
                  this.emplace(
                    C,
                    t,
                    e,
                    n,
                    r,
                    i,
                    o,
                    s,
                    a,
                    l,
                    c,
                    u,
                    h,
                    p,
                    d,
                    f,
                    m,
                    g,
                    y,
                    _,
                    v,
                    b,
                    x,
                    w,
                    S,
                    E,
                    T,
                    A
                  )
                );
              }
              emplace(
                t,
                e,
                n,
                r,
                i,
                o,
                s,
                a,
                l,
                c,
                u,
                h,
                p,
                d,
                f,
                m,
                g,
                y,
                _,
                v,
                b,
                x,
                w,
                S,
                E,
                T,
                A,
                C
              ) {
                const P = 17 * t,
                  M = 34 * t;
                return (
                  (this.float32[P + 0] = e),
                  (this.float32[P + 1] = n),
                  (this.int16[M + 4] = r),
                  (this.int16[M + 5] = i),
                  (this.int16[M + 6] = o),
                  (this.int16[M + 7] = s),
                  (this.int16[M + 8] = a),
                  (this.int16[M + 9] = l),
                  (this.uint16[M + 10] = c),
                  (this.uint16[M + 11] = u),
                  (this.uint16[M + 12] = h),
                  (this.uint16[M + 13] = p),
                  (this.uint16[M + 14] = d),
                  (this.uint16[M + 15] = f),
                  (this.uint16[M + 16] = m),
                  (this.uint16[M + 17] = g),
                  (this.uint16[M + 18] = y),
                  (this.uint16[M + 19] = _),
                  (this.uint16[M + 20] = v),
                  (this.uint16[M + 21] = b),
                  (this.uint16[M + 22] = x),
                  (this.uint16[M + 23] = w),
                  (this.uint16[M + 24] = S),
                  (this.uint32[P + 13] = E),
                  (this.float32[P + 14] = T),
                  (this.float32[P + 15] = A),
                  (this.float32[P + 16] = C),
                  t
                );
              }
            }
            (qo.prototype.bytesPerElement = 68),
              li("StructArrayLayout2f6i15ui1ul3f68", qo);
            class $o extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(t) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t);
              }
              emplace(t, e) {
                return (this.float32[1 * t + 0] = e), t;
              }
            }
            ($o.prototype.bytesPerElement = 4), li("StructArrayLayout1f4", $o);
            class Go extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(t, e, n) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t, e, n);
              }
              emplace(t, e, n, r) {
                const i = 3 * t;
                return (
                  (this.int16[i + 0] = e),
                  (this.int16[i + 1] = n),
                  (this.int16[i + 2] = r),
                  t
                );
              }
            }
            (Go.prototype.bytesPerElement = 6), li("StructArrayLayout3i6", Go);
            class Wo extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(t, e, n, r) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t, e, n, r);
              }
              emplace(t, e, n, r, i) {
                const o = 6 * t;
                return (
                  (this.uint32[3 * t + 0] = e),
                  (this.uint16[o + 2] = n),
                  (this.uint16[o + 3] = r),
                  (this.uint16[o + 4] = i),
                  t
                );
              }
            }
            (Wo.prototype.bytesPerElement = 12),
              li("StructArrayLayout1ul3ui12", Wo);
            class Ho extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(t, e) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t, e);
              }
              emplace(t, e, n) {
                const r = 2 * t;
                return (this.uint16[r + 0] = e), (this.uint16[r + 1] = n), t;
              }
            }
            (Ho.prototype.bytesPerElement = 4), li("StructArrayLayout2ui4", Ho);
            class Xo extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(t) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t);
              }
              emplace(t, e) {
                return (this.uint16[1 * t + 0] = e), t;
              }
            }
            (Xo.prototype.bytesPerElement = 2), li("StructArrayLayout1ui2", Xo);
            class Ko extends Ao {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(t, e, n, r) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t, e, n, r);
              }
              emplace(t, e, n, r, i) {
                const o = 4 * t;
                return (
                  (this.float32[o + 0] = e),
                  (this.float32[o + 1] = n),
                  (this.float32[o + 2] = r),
                  (this.float32[o + 3] = i),
                  t
                );
              }
            }
            (Ko.prototype.bytesPerElement = 16),
              li("StructArrayLayout4f16", Ko);
            class Yo extends To {
              get anchorPointX() {
                return this._structArray.int16[this._pos2 + 0];
              }
              get anchorPointY() {
                return this._structArray.int16[this._pos2 + 1];
              }
              get x1() {
                return this._structArray.float32[this._pos4 + 1];
              }
              get y1() {
                return this._structArray.float32[this._pos4 + 2];
              }
              get x2() {
                return this._structArray.float32[this._pos4 + 3];
              }
              get y2() {
                return this._structArray.float32[this._pos4 + 4];
              }
              get padding() {
                return this._structArray.int16[this._pos2 + 10];
              }
              get featureIndex() {
                return this._structArray.uint32[this._pos4 + 6];
              }
              get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 14];
              }
              get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 15];
              }
              get anchorPoint() {
                return new o(this.anchorPointX, this.anchorPointY);
              }
            }
            Yo.prototype.size = 32;
            class Qo extends Bo {
              get(t) {
                return new Yo(this, t);
              }
            }
            li("CollisionBoxArray", Qo);
            class Jo extends To {
              get anchorX() {
                return this._structArray.float32[this._pos4 + 0];
              }
              get anchorY() {
                return this._structArray.float32[this._pos4 + 1];
              }
              get glyphStartIndex() {
                return this._structArray.uint16[this._pos2 + 4];
              }
              get numGlyphs() {
                return this._structArray.uint16[this._pos2 + 5];
              }
              get vertexStartIndex() {
                return this._structArray.uint32[this._pos4 + 3];
              }
              get lineStartIndex() {
                return this._structArray.uint32[this._pos4 + 4];
              }
              get lineLength() {
                return this._structArray.uint32[this._pos4 + 5];
              }
              get segment() {
                return this._structArray.uint16[this._pos2 + 12];
              }
              get lowerSize() {
                return this._structArray.uint16[this._pos2 + 13];
              }
              get upperSize() {
                return this._structArray.uint16[this._pos2 + 14];
              }
              get lineOffsetX() {
                return this._structArray.float32[this._pos4 + 8];
              }
              get lineOffsetY() {
                return this._structArray.float32[this._pos4 + 9];
              }
              get writingMode() {
                return this._structArray.uint8[this._pos1 + 40];
              }
              get placedOrientation() {
                return this._structArray.uint8[this._pos1 + 41];
              }
              set placedOrientation(t) {
                this._structArray.uint8[this._pos1 + 41] = t;
              }
              get hidden() {
                return this._structArray.uint8[this._pos1 + 42];
              }
              set hidden(t) {
                this._structArray.uint8[this._pos1 + 42] = t;
              }
              get crossTileID() {
                return this._structArray.uint32[this._pos4 + 11];
              }
              set crossTileID(t) {
                this._structArray.uint32[this._pos4 + 11] = t;
              }
              get associatedIconIndex() {
                return this._structArray.int16[this._pos2 + 24];
              }
              get flipState() {
                return this._structArray.uint8[this._pos1 + 50];
              }
              set flipState(t) {
                this._structArray.uint8[this._pos1 + 50] = t;
              }
            }
            Jo.prototype.size = 52;
            class ts extends Vo {
              get(t) {
                return new Jo(this, t);
              }
            }
            li("PlacedSymbolArray", ts);
            class es extends To {
              get anchorX() {
                return this._structArray.float32[this._pos4 + 0];
              }
              get anchorY() {
                return this._structArray.float32[this._pos4 + 1];
              }
              get rightJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 4];
              }
              get centerJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 5];
              }
              get leftJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 6];
              }
              get verticalPlacedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 7];
              }
              get placedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 8];
              }
              get verticalPlacedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 9];
              }
              get key() {
                return this._structArray.uint16[this._pos2 + 10];
              }
              get textBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 11];
              }
              get textBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 12];
              }
              get verticalTextBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 13];
              }
              get verticalTextBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 14];
              }
              get iconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 15];
              }
              get iconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 16];
              }
              get verticalIconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 17];
              }
              get verticalIconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 18];
              }
              get featureIndex() {
                return this._structArray.uint16[this._pos2 + 19];
              }
              get numHorizontalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 20];
              }
              get numVerticalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 21];
              }
              get numIconVertices() {
                return this._structArray.uint16[this._pos2 + 22];
              }
              get numVerticalIconVertices() {
                return this._structArray.uint16[this._pos2 + 23];
              }
              get useRuntimeCollisionCircles() {
                return this._structArray.uint16[this._pos2 + 24];
              }
              get crossTileID() {
                return this._structArray.uint32[this._pos4 + 13];
              }
              set crossTileID(t) {
                this._structArray.uint32[this._pos4 + 13] = t;
              }
              get textOffset0() {
                return this._structArray.float32[this._pos4 + 14];
              }
              get textOffset1() {
                return this._structArray.float32[this._pos4 + 15];
              }
              get collisionCircleDiameter() {
                return this._structArray.float32[this._pos4 + 16];
              }
            }
            es.prototype.size = 68;
            class ns extends qo {
              get(t) {
                return new es(this, t);
              }
            }
            li("SymbolInstanceArray", ns);
            class rs extends $o {
              getoffsetX(t) {
                return this.float32[1 * t + 0];
              }
            }
            li("GlyphOffsetArray", rs);
            class is extends Go {
              getx(t) {
                return this.int16[3 * t + 0];
              }
              gety(t) {
                return this.int16[3 * t + 1];
              }
              gettileUnitDistanceFromAnchor(t) {
                return this.int16[3 * t + 2];
              }
            }
            li("SymbolLineVertexArray", is);
            class os extends To {
              get featureIndex() {
                return this._structArray.uint32[this._pos4 + 0];
              }
              get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 2];
              }
              get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 3];
              }
              get layoutVertexArrayOffset() {
                return this._structArray.uint16[this._pos2 + 4];
              }
            }
            os.prototype.size = 12;
            class ss extends Wo {
              get(t) {
                return new os(this, t);
              }
            }
            li("FeatureIndexArray", ss);
            class as extends To {
              get a_centroid_pos0() {
                return this._structArray.uint16[this._pos2 + 0];
              }
              get a_centroid_pos1() {
                return this._structArray.uint16[this._pos2 + 1];
              }
            }
            as.prototype.size = 4;
            class ls extends Ho {
              get(t) {
                return new as(this, t);
              }
            }
            li("FillExtrusionCentroidArray", ls);
            const cs = Co([
                { name: "a_pattern_to", components: 4, type: "Uint16" },
                { name: "a_pattern_from", components: 4, type: "Uint16" },
                { name: "a_pixel_ratio_to", components: 1, type: "Uint16" },
                { name: "a_pixel_ratio_from", components: 1, type: "Uint16" },
              ]),
              us = Co([
                { name: "a_dash_to", components: 4, type: "Uint16" },
                { name: "a_dash_from", components: 4, type: "Uint16" },
              ]);
            var hs = ce(function (t) {
                t.exports = function (t, e) {
                  var n, r, i, o, s, a, l, c;
                  for (
                    r = t.length - (n = 3 & t.length),
                      i = e,
                      s = 3432918353,
                      a = 461845907,
                      c = 0;
                    c < r;

                  )
                    (l =
                      (255 & t.charCodeAt(c)) |
                      ((255 & t.charCodeAt(++c)) << 8) |
                      ((255 & t.charCodeAt(++c)) << 16) |
                      ((255 & t.charCodeAt(++c)) << 24)),
                      ++c,
                      (i =
                        27492 +
                        (65535 &
                          (o =
                            (5 *
                              (65535 &
                                (i =
                                  ((i ^= l =
                                    ((65535 &
                                      (l =
                                        ((l =
                                          ((65535 & l) * s +
                                            ((((l >>> 16) * s) & 65535) <<
                                              16)) &
                                          4294967295) <<
                                          15) |
                                        (l >>> 17))) *
                                      a +
                                      ((((l >>> 16) * a) & 65535) << 16)) &
                                    4294967295) <<
                                    13) |
                                  (i >>> 19))) +
                              (((5 * (i >>> 16)) & 65535) << 16)) &
                            4294967295)) +
                        (((58964 + (o >>> 16)) & 65535) << 16));
                  switch (((l = 0), n)) {
                    case 3:
                      l ^= (255 & t.charCodeAt(c + 2)) << 16;
                    case 2:
                      l ^= (255 & t.charCodeAt(c + 1)) << 8;
                    case 1:
                      i ^= l =
                        ((65535 &
                          (l =
                            ((l =
                              ((65535 & (l ^= 255 & t.charCodeAt(c))) * s +
                                ((((l >>> 16) * s) & 65535) << 16)) &
                              4294967295) <<
                              15) |
                            (l >>> 17))) *
                          a +
                          ((((l >>> 16) * a) & 65535) << 16)) &
                        4294967295;
                  }
                  return (
                    (i ^= t.length),
                    (i =
                      (2246822507 * (65535 & (i ^= i >>> 16)) +
                        (((2246822507 * (i >>> 16)) & 65535) << 16)) &
                      4294967295),
                    (i =
                      (3266489909 * (65535 & (i ^= i >>> 13)) +
                        (((3266489909 * (i >>> 16)) & 65535) << 16)) &
                      4294967295),
                    (i ^= i >>> 16) >>> 0
                  );
                };
              }),
              ps = ce(function (t) {
                t.exports = function (t, e) {
                  for (var n, r = t.length, i = e ^ r, o = 0; r >= 4; )
                    (n =
                      1540483477 *
                        (65535 &
                          (n =
                            (255 & t.charCodeAt(o)) |
                            ((255 & t.charCodeAt(++o)) << 8) |
                            ((255 & t.charCodeAt(++o)) << 16) |
                            ((255 & t.charCodeAt(++o)) << 24))) +
                      (((1540483477 * (n >>> 16)) & 65535) << 16)),
                      (i =
                        (1540483477 * (65535 & i) +
                          (((1540483477 * (i >>> 16)) & 65535) << 16)) ^
                        (n =
                          1540483477 * (65535 & (n ^= n >>> 24)) +
                          (((1540483477 * (n >>> 16)) & 65535) << 16))),
                      (r -= 4),
                      ++o;
                  switch (r) {
                    case 3:
                      i ^= (255 & t.charCodeAt(o + 2)) << 16;
                    case 2:
                      i ^= (255 & t.charCodeAt(o + 1)) << 8;
                    case 1:
                      i =
                        1540483477 * (65535 & (i ^= 255 & t.charCodeAt(o))) +
                        (((1540483477 * (i >>> 16)) & 65535) << 16);
                  }
                  return (
                    (i =
                      1540483477 * (65535 & (i ^= i >>> 13)) +
                      (((1540483477 * (i >>> 16)) & 65535) << 16)),
                    (i ^= i >>> 15) >>> 0
                  );
                };
              }),
              ds = hs,
              fs = ps;
            (ds.murmur3 = hs), (ds.murmur2 = fs);
            class ms {
              constructor() {
                (this.ids = []), (this.positions = []), (this.indexed = !1);
              }
              add(t, e, n, r) {
                this.ids.push(gs(t)), this.positions.push(e, n, r);
              }
              getPositions(t) {
                const e = gs(t);
                let n = 0,
                  r = this.ids.length - 1;
                for (; n < r; ) {
                  const t = (n + r) >> 1;
                  this.ids[t] >= e ? (r = t) : (n = t + 1);
                }
                const i = [];
                for (; this.ids[n] === e; )
                  i.push({
                    index: this.positions[3 * n],
                    start: this.positions[3 * n + 1],
                    end: this.positions[3 * n + 2],
                  }),
                    n++;
                return i;
              }
              static serialize(t, e) {
                const n = new Float64Array(t.ids),
                  r = new Uint32Array(t.positions);
                return (
                  ys(n, r, 0, n.length - 1),
                  e && e.push(n.buffer, r.buffer),
                  { ids: n, positions: r }
                );
              }
              static deserialize(t) {
                const e = new ms();
                return (
                  (e.ids = t.ids),
                  (e.positions = t.positions),
                  (e.indexed = !0),
                  e
                );
              }
            }
            function gs(t) {
              const e = +t;
              return !isNaN(e) && e <= l ? e : ds(String(t));
            }
            function ys(t, e, n, r) {
              for (; n < r; ) {
                const i = t[(n + r) >> 1];
                let o = n - 1,
                  s = r + 1;
                for (;;) {
                  do {
                    o++;
                  } while (t[o] < i);
                  do {
                    s--;
                  } while (t[s] > i);
                  if (o >= s) break;
                  _s(t, o, s),
                    _s(e, 3 * o, 3 * s),
                    _s(e, 3 * o + 1, 3 * s + 1),
                    _s(e, 3 * o + 2, 3 * s + 2);
                }
                s - n < r - s
                  ? (ys(t, e, n, s), (n = s + 1))
                  : (ys(t, e, s + 1, r), (r = s));
              }
            }
            function _s(t, e, n) {
              const r = t[e];
              (t[e] = t[n]), (t[n] = r);
            }
            li("FeaturePositionMap", ms);
            class vs {
              constructor(t, e) {
                (this.gl = t.gl), (this.location = e);
              }
            }
            class bs extends vs {
              constructor(t, e) {
                super(t, e), (this.current = 0);
              }
              set(t) {
                this.current !== t &&
                  ((this.current = t), this.gl.uniform1f(this.location, t));
              }
            }
            class xs extends vs {
              constructor(t, e) {
                super(t, e), (this.current = [0, 0, 0, 0]);
              }
              set(t) {
                (t[0] === this.current[0] &&
                  t[1] === this.current[1] &&
                  t[2] === this.current[2] &&
                  t[3] === this.current[3]) ||
                  ((this.current = t),
                  this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));
              }
            }
            class ws extends vs {
              constructor(t, e) {
                super(t, e), (this.current = he.transparent);
              }
              set(t) {
                (t.r === this.current.r &&
                  t.g === this.current.g &&
                  t.b === this.current.b &&
                  t.a === this.current.a) ||
                  ((this.current = t),
                  this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));
              }
            }
            const Ss = new Float32Array(16),
              Es = new Float32Array(9);
            function Ts(t) {
              return [So(255 * t.r, 255 * t.g), So(255 * t.b, 255 * t.a)];
            }
            class As {
              constructor(t, e, n) {
                (this.value = t),
                  (this.uniformNames = e.map((t) => `u_${t}`)),
                  (this.type = n);
              }
              setUniform(t, e, n) {
                t.set(n.constantOr(this.value));
              }
              getBinding(t, e, n) {
                return "color" === this.type ? new ws(t, e) : new bs(t, e);
              }
            }
            class Cs {
              constructor(t, e) {
                (this.uniformNames = e.map((t) => `u_${t}`)),
                  (this.patternFrom = null),
                  (this.patternTo = null),
                  (this.pixelRatioFrom = 1),
                  (this.pixelRatioTo = 1);
              }
              setConstantPatternPositions(t, e) {
                (this.pixelRatioFrom = e.pixelRatio),
                  (this.pixelRatioTo = t.pixelRatio),
                  (this.patternFrom = e.tl.concat(e.br)),
                  (this.patternTo = t.tl.concat(t.br));
              }
              setUniform(t, e, n, r) {
                const i =
                  "u_pattern_to" === r || "u_dash_to" === r
                    ? this.patternTo
                    : "u_pattern_from" === r || "u_dash_from" === r
                    ? this.patternFrom
                    : "u_pixel_ratio_to" === r
                    ? this.pixelRatioTo
                    : "u_pixel_ratio_from" === r
                    ? this.pixelRatioFrom
                    : null;
                i && t.set(i);
              }
              getBinding(t, e, n) {
                return "u_pattern_from" === n ||
                  "u_pattern_to" === n ||
                  "u_dash_from" === n ||
                  "u_dash_to" === n
                  ? new xs(t, e)
                  : new bs(t, e);
              }
            }
            class Ps {
              constructor(t, e, n, r) {
                (this.expression = t),
                  (this.type = n),
                  (this.maxValue = 0),
                  (this.paintVertexAttributes = e.map((t) => ({
                    name: `a_${t}`,
                    type: "Float32",
                    components: "color" === n ? 2 : 1,
                    offset: 0,
                  }))),
                  (this.paintVertexArray = new r());
              }
              populatePaintArray(t, e, n, r, i) {
                const o = this.paintVertexArray.length,
                  s = this.expression.evaluate(new ao(0), e, {}, r, [], i);
                this.paintVertexArray.resize(t), this._setPaintValue(o, t, s);
              }
              updatePaintArray(t, e, n, r) {
                const i = this.expression.evaluate({ zoom: 0 }, n, r);
                this._setPaintValue(t, e, i);
              }
              _setPaintValue(t, e, n) {
                if ("color" === this.type) {
                  const r = Ts(n);
                  for (let n = t; n < e; n++)
                    this.paintVertexArray.emplace(n, r[0], r[1]);
                } else {
                  for (let r = t; r < e; r++)
                    this.paintVertexArray.emplace(r, n);
                  this.maxValue = Math.max(this.maxValue, Math.abs(n));
                }
              }
              upload(t) {
                this.paintVertexArray &&
                  this.paintVertexArray.arrayBuffer &&
                  (this.paintVertexBuffer && this.paintVertexBuffer.buffer
                    ? this.paintVertexBuffer.updateData(this.paintVertexArray)
                    : (this.paintVertexBuffer = t.createVertexBuffer(
                        this.paintVertexArray,
                        this.paintVertexAttributes,
                        this.expression.isStateDependent
                      )));
              }
              destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
              }
            }
            class Ms {
              constructor(t, e, n, r, i, o) {
                (this.expression = t),
                  (this.uniformNames = e.map((t) => `u_${t}_t`)),
                  (this.type = n),
                  (this.useIntegerZoom = r),
                  (this.zoom = i),
                  (this.maxValue = 0),
                  (this.paintVertexAttributes = e.map((t) => ({
                    name: `a_${t}`,
                    type: "Float32",
                    components: "color" === n ? 4 : 2,
                    offset: 0,
                  }))),
                  (this.paintVertexArray = new o());
              }
              populatePaintArray(t, e, n, r, i) {
                const o = this.expression.evaluate(
                    new ao(this.zoom),
                    e,
                    {},
                    r,
                    [],
                    i
                  ),
                  s = this.expression.evaluate(
                    new ao(this.zoom + 1),
                    e,
                    {},
                    r,
                    [],
                    i
                  ),
                  a = this.paintVertexArray.length;
                this.paintVertexArray.resize(t),
                  this._setPaintValue(a, t, o, s);
              }
              updatePaintArray(t, e, n, r) {
                const i = this.expression.evaluate({ zoom: this.zoom }, n, r),
                  o = this.expression.evaluate({ zoom: this.zoom + 1 }, n, r);
                this._setPaintValue(t, e, i, o);
              }
              _setPaintValue(t, e, n, r) {
                if ("color" === this.type) {
                  const i = Ts(n),
                    o = Ts(r);
                  for (let n = t; n < e; n++)
                    this.paintVertexArray.emplace(n, i[0], i[1], o[0], o[1]);
                } else {
                  for (let i = t; i < e; i++)
                    this.paintVertexArray.emplace(i, n, r);
                  this.maxValue = Math.max(
                    this.maxValue,
                    Math.abs(n),
                    Math.abs(r)
                  );
                }
              }
              upload(t) {
                this.paintVertexArray &&
                  this.paintVertexArray.arrayBuffer &&
                  (this.paintVertexBuffer && this.paintVertexBuffer.buffer
                    ? this.paintVertexBuffer.updateData(this.paintVertexArray)
                    : (this.paintVertexBuffer = t.createVertexBuffer(
                        this.paintVertexArray,
                        this.paintVertexAttributes,
                        this.expression.isStateDependent
                      )));
              }
              destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
              }
              setUniform(t, e) {
                const n = this.useIntegerZoom ? Math.floor(e.zoom) : e.zoom,
                  r = g(
                    this.expression.interpolationFactor(
                      n,
                      this.zoom,
                      this.zoom + 1
                    ),
                    0,
                    1
                  );
                t.set(r);
              }
              getBinding(t, e, n) {
                return new bs(t, e);
              }
            }
            class Os {
              constructor(t, e, n, r, i, o, s) {
                (this.expression = t),
                  (this.type = n),
                  (this.useIntegerZoom = r),
                  (this.zoom = i),
                  (this.layerId = s),
                  (this.paintVertexAttributes = (
                    "array" === n ? us : cs
                  ).members);
                for (let a = 0; a < e.length; ++a);
                (this.zoomInPaintVertexArray = new o()),
                  (this.zoomOutPaintVertexArray = new o());
              }
              populatePaintArray(t, e, n) {
                const r = this.zoomInPaintVertexArray.length;
                this.zoomInPaintVertexArray.resize(t),
                  this.zoomOutPaintVertexArray.resize(t),
                  this._setPaintValues(
                    r,
                    t,
                    e.patterns && e.patterns[this.layerId],
                    n
                  );
              }
              updatePaintArray(t, e, n, r, i) {
                this._setPaintValues(
                  t,
                  e,
                  n.patterns && n.patterns[this.layerId],
                  i
                );
              }
              _setPaintValues(t, e, n, r) {
                if (!r || !n) return;
                const { min: i, mid: o, max: s } = n,
                  a = r[i],
                  l = r[o],
                  c = r[s];
                if (a && l && c)
                  for (let u = t; u < e; u++)
                    this._setPaintValue(this.zoomInPaintVertexArray, u, l, a),
                      this._setPaintValue(
                        this.zoomOutPaintVertexArray,
                        u,
                        l,
                        c
                      );
              }
              _setPaintValue(t, e, n, r) {
                t.emplace(
                  e,
                  n.tl[0],
                  n.tl[1],
                  n.br[0],
                  n.br[1],
                  r.tl[0],
                  r.tl[1],
                  r.br[0],
                  r.br[1],
                  n.pixelRatio,
                  r.pixelRatio
                );
              }
              upload(t) {
                this.zoomInPaintVertexArray &&
                  this.zoomInPaintVertexArray.arrayBuffer &&
                  this.zoomOutPaintVertexArray &&
                  this.zoomOutPaintVertexArray.arrayBuffer &&
                  ((this.zoomInPaintVertexBuffer = t.createVertexBuffer(
                    this.zoomInPaintVertexArray,
                    this.paintVertexAttributes,
                    this.expression.isStateDependent
                  )),
                  (this.zoomOutPaintVertexBuffer = t.createVertexBuffer(
                    this.zoomOutPaintVertexArray,
                    this.paintVertexAttributes,
                    this.expression.isStateDependent
                  )));
              }
              destroy() {
                this.zoomOutPaintVertexBuffer &&
                  this.zoomOutPaintVertexBuffer.destroy(),
                  this.zoomInPaintVertexBuffer &&
                    this.zoomInPaintVertexBuffer.destroy();
              }
            }
            class ks {
              constructor(t, e, n = () => !0) {
                (this.binders = {}), (this._buffers = []);
                const r = [];
                for (const i in t.paint._values) {
                  if (!n(i)) continue;
                  const o = t.paint.get(i);
                  if (!(o instanceof mo && Yn(o.property.specification)))
                    continue;
                  const s = zs(i, t.type),
                    a = o.value,
                    l = o.property.specification.type,
                    c = o.property.useIntegerZoom,
                    u = o.property.specification["property-type"],
                    h = "cross-faded" === u || "cross-faded-data-driven" === u,
                    p =
                      "line-dasharray" === String(i) &&
                      "constant" !== t.layout.get("line-cap").value.kind;
                  if ("constant" !== a.kind || p)
                    if ("source" === a.kind || p || h) {
                      const n = Fs(i, l, "source");
                      (this.binders[i] = h
                        ? new Os(a, s, l, c, e, n, t.id)
                        : new Ps(a, s, l, n)),
                        r.push(`/a_${i}`);
                    } else {
                      const t = Fs(i, l, "composite");
                      (this.binders[i] = new Ms(a, s, l, c, e, t)),
                        r.push(`/z_${i}`);
                    }
                  else
                    (this.binders[i] = h
                      ? new Cs(a.value, s)
                      : new As(a.value, s, l)),
                      r.push(`/u_${i}`);
                }
                this.cacheKey = r.sort().join("");
              }
              getMaxValue(t) {
                const e = this.binders[t];
                return e instanceof Ps || e instanceof Ms ? e.maxValue : 0;
              }
              populatePaintArrays(t, e, n, r, i) {
                for (const o in this.binders) {
                  const s = this.binders[o];
                  (s instanceof Ps || s instanceof Ms || s instanceof Os) &&
                    s.populatePaintArray(t, e, n, r, i);
                }
              }
              setConstantPatternPositions(t, e) {
                for (const n in this.binders) {
                  const r = this.binders[n];
                  r instanceof Cs && r.setConstantPatternPositions(t, e);
                }
              }
              updatePaintArrays(t, e, n, r, i) {
                let o = !1;
                for (const s in t) {
                  const a = e.getPositions(s);
                  for (const e of a) {
                    const a = n.feature(e.index);
                    for (const n in this.binders) {
                      const l = this.binders[n];
                      if (
                        (l instanceof Ps ||
                          l instanceof Ms ||
                          l instanceof Os) &&
                        !0 === l.expression.isStateDependent
                      ) {
                        const c = r.paint.get(n);
                        (l.expression = c.value),
                          l.updatePaintArray(e.start, e.end, a, t[s], i),
                          (o = !0);
                      }
                    }
                  }
                }
                return o;
              }
              defines() {
                const t = [];
                for (const e in this.binders) {
                  const n = this.binders[e];
                  (n instanceof As || n instanceof Cs) &&
                    t.push(
                      ...n.uniformNames.map((t) => `#define HAS_UNIFORM_${t}`)
                    );
                }
                return t;
              }
              getBinderAttributes() {
                const t = [];
                for (const e in this.binders) {
                  const n = this.binders[e];
                  if (n instanceof Ps || n instanceof Ms || n instanceof Os)
                    for (let e = 0; e < n.paintVertexAttributes.length; e++)
                      t.push(n.paintVertexAttributes[e].name);
                }
                return t;
              }
              getBinderUniforms() {
                const t = [];
                for (const e in this.binders) {
                  const n = this.binders[e];
                  if (n instanceof As || n instanceof Cs || n instanceof Ms)
                    for (const e of n.uniformNames) t.push(e);
                }
                return t;
              }
              getPaintVertexBuffers() {
                return this._buffers;
              }
              getUniforms(t, e) {
                const n = [];
                for (const r in this.binders) {
                  const i = this.binders[r];
                  if (i instanceof As || i instanceof Cs || i instanceof Ms)
                    for (const o of i.uniformNames)
                      if (e[o]) {
                        const s = i.getBinding(t, e[o], o);
                        n.push({ name: o, property: r, binding: s });
                      }
                }
                return n;
              }
              setUniforms(t, e, n, r) {
                for (const { name: i, property: o, binding: s } of e)
                  this.binders[o].setUniform(s, r, n.get(o), i);
              }
              updatePaintBuffers(t) {
                this._buffers = [];
                for (const e in this.binders) {
                  const n = this.binders[e];
                  if (t && n instanceof Os) {
                    const e =
                      2 === t.fromScale
                        ? n.zoomInPaintVertexBuffer
                        : n.zoomOutPaintVertexBuffer;
                    e && this._buffers.push(e);
                  } else
                    (n instanceof Ps || n instanceof Ms) &&
                      n.paintVertexBuffer &&
                      this._buffers.push(n.paintVertexBuffer);
                }
              }
              upload(t) {
                for (const e in this.binders) {
                  const n = this.binders[e];
                  (n instanceof Ps || n instanceof Ms || n instanceof Os) &&
                    n.upload(t);
                }
                this.updatePaintBuffers();
              }
              destroy() {
                for (const t in this.binders) {
                  const e = this.binders[t];
                  (e instanceof Ps || e instanceof Ms || e instanceof Os) &&
                    e.destroy();
                }
              }
            }
            class Is {
              constructor(t, e, n = () => !0) {
                this.programConfigurations = {};
                for (const r of t)
                  this.programConfigurations[r.id] = new ks(r, e, n);
                (this.needsUpload = !1),
                  (this._featureMap = new ms()),
                  (this._bufferOffset = 0);
              }
              populatePaintArrays(t, e, n, r, i, o) {
                for (const s in this.programConfigurations)
                  this.programConfigurations[s].populatePaintArrays(
                    t,
                    e,
                    r,
                    i,
                    o
                  );
                void 0 !== e.id &&
                  this._featureMap.add(e.id, n, this._bufferOffset, t),
                  (this._bufferOffset = t),
                  (this.needsUpload = !0);
              }
              updatePaintArrays(t, e, n, r) {
                for (const i of n)
                  this.needsUpload =
                    this.programConfigurations[i.id].updatePaintArrays(
                      t,
                      this._featureMap,
                      e,
                      i,
                      r
                    ) || this.needsUpload;
              }
              get(t) {
                return this.programConfigurations[t];
              }
              upload(t) {
                if (this.needsUpload) {
                  for (const e in this.programConfigurations)
                    this.programConfigurations[e].upload(t);
                  this.needsUpload = !1;
                }
              }
              destroy() {
                for (const t in this.programConfigurations)
                  this.programConfigurations[t].destroy();
              }
            }
            const Ds = {
              "text-opacity": ["opacity"],
              "icon-opacity": ["opacity"],
              "text-color": ["fill_color"],
              "icon-color": ["fill_color"],
              "text-halo-color": ["halo_color"],
              "icon-halo-color": ["halo_color"],
              "text-halo-blur": ["halo_blur"],
              "icon-halo-blur": ["halo_blur"],
              "text-halo-width": ["halo_width"],
              "icon-halo-width": ["halo_width"],
              "line-gap-width": ["gapwidth"],
              "line-pattern": [
                "pattern_to",
                "pattern_from",
                "pixel_ratio_to",
                "pixel_ratio_from",
              ],
              "fill-pattern": [
                "pattern_to",
                "pattern_from",
                "pixel_ratio_to",
                "pixel_ratio_from",
              ],
              "fill-extrusion-pattern": [
                "pattern_to",
                "pattern_from",
                "pixel_ratio_to",
                "pixel_ratio_from",
              ],
              "line-dasharray": ["dash_to", "dash_from"],
            };
            function zs(t, e) {
              return Ds[t] || [t.replace(`${e}-`, "").replace(/-/g, "_")];
            }
            const Rs = {
                "line-pattern": { source: Do, composite: Do },
                "fill-pattern": { source: Do, composite: Do },
                "fill-extrusion-pattern": { source: Do, composite: Do },
                "line-dasharray": { source: zo, composite: zo },
              },
              Ls = {
                color: { source: Io, composite: Ko },
                number: { source: $o, composite: Io },
              };
            function Fs(t, e, n) {
              const r = Rs[t];
              return (r && r[n]) || Ls[e][n];
            }
            li("ConstantBinder", As),
              li("CrossFadedConstantBinder", Cs),
              li("SourceExpressionBinder", Ps),
              li("CrossFadedCompositeBinder", Os),
              li("CompositeExpressionBinder", Ms),
              li("ProgramConfiguration", ks, { omit: ["_buffers"] }),
              li("ProgramConfigurationSet", Is);
            const Bs = "-transition";
            class Ns extends Bt {
              constructor(t, e) {
                if (
                  (super(),
                  (this.id = t.id),
                  (this.type = t.type),
                  (this._featureFilter = {
                    filter: () => !0,
                    needGeometry: !1,
                  }),
                  "custom" !== t.type &&
                    ((this.metadata = t.metadata),
                    (this.minzoom = t.minzoom),
                    (this.maxzoom = t.maxzoom),
                    "background" !== t.type &&
                      "sky" !== t.type &&
                      ((this.source = t.source),
                      (this.sourceLayer = t["source-layer"]),
                      (this.filter = t.filter)),
                    e.layout && (this._unevaluatedLayout = new fo(e.layout)),
                    e.paint))
                ) {
                  this._transitionablePaint = new uo(e.paint);
                  for (const e in t.paint)
                    this.setPaintProperty(e, t.paint[e], { validate: !1 });
                  for (const e in t.layout)
                    this.setLayoutProperty(e, t.layout[e], { validate: !1 });
                  (this._transitioningPaint =
                    this._transitionablePaint.untransitioned()),
                    (this.paint = new go(e.paint));
                }
              }
              getCrossfadeParameters() {
                return this._crossfadeParameters;
              }
              getLayoutProperty(t) {
                return "visibility" === t
                  ? this.visibility
                  : this._unevaluatedLayout.getValue(t);
              }
              setLayoutProperty(t, e, n = {}) {
                (null != e &&
                  this._validate(
                    ei,
                    `layers.${this.id}.layout.${t}`,
                    t,
                    e,
                    n
                  )) ||
                  ("visibility" !== t
                    ? this._unevaluatedLayout.setValue(t, e)
                    : (this.visibility = e));
              }
              getPaintProperty(t) {
                return C(t, Bs)
                  ? this._transitionablePaint.getTransition(
                      t.slice(0, -Bs.length)
                    )
                  : this._transitionablePaint.getValue(t);
              }
              setPaintProperty(t, e, n = {}) {
                if (
                  null != e &&
                  this._validate(ti, `layers.${this.id}.paint.${t}`, t, e, n)
                )
                  return !1;
                if (C(t, Bs))
                  return (
                    this._transitionablePaint.setTransition(
                      t.slice(0, -Bs.length),
                      e || void 0
                    ),
                    !1
                  );
                {
                  const n = this._transitionablePaint._values[t],
                    r =
                      "cross-faded-data-driven" ===
                      n.property.specification["property-type"],
                    i = n.value.isDataDriven(),
                    o = n.value;
                  this._transitionablePaint.setValue(t, e),
                    this._handleSpecialPaintPropertyUpdate(t);
                  const s = this._transitionablePaint._values[t].value;
                  return (
                    s.isDataDriven() ||
                    i ||
                    r ||
                    this._handleOverridablePaintPropertyUpdate(t, o, s)
                  );
                }
              }
              _handleSpecialPaintPropertyUpdate(t) {}
              getProgramIds() {
                return null;
              }
              getProgramConfiguration(t) {
                return null;
              }
              _handleOverridablePaintPropertyUpdate(t, e, n) {
                return !1;
              }
              isHidden(t) {
                return (
                  !!(this.minzoom && t < this.minzoom) ||
                  !!(this.maxzoom && t >= this.maxzoom) ||
                  "none" === this.visibility
                );
              }
              updateTransitions(t) {
                this._transitioningPaint =
                  this._transitionablePaint.transitioned(
                    t,
                    this._transitioningPaint
                  );
              }
              hasTransition() {
                return this._transitioningPaint.hasTransition();
              }
              recalculate(t, e) {
                t.getCrossfadeParameters &&
                  (this._crossfadeParameters = t.getCrossfadeParameters()),
                  this._unevaluatedLayout &&
                    (this.layout = this._unevaluatedLayout.possiblyEvaluate(
                      t,
                      void 0,
                      e
                    )),
                  (this.paint = this._transitioningPaint.possiblyEvaluate(
                    t,
                    void 0,
                    e
                  ));
              }
              serialize() {
                const t = {
                  id: this.id,
                  type: this.type,
                  source: this.source,
                  "source-layer": this.sourceLayer,
                  metadata: this.metadata,
                  minzoom: this.minzoom,
                  maxzoom: this.maxzoom,
                  filter: this.filter,
                  layout:
                    this._unevaluatedLayout &&
                    this._unevaluatedLayout.serialize(),
                  paint:
                    this._transitionablePaint &&
                    this._transitionablePaint.serialize(),
                };
                return (
                  this.visibility &&
                    ((t.layout = t.layout || {}),
                    (t.layout.visibility = this.visibility)),
                  M(
                    t,
                    (t, e) =>
                      !(
                        void 0 === t ||
                        ("layout" === e && !Object.keys(t).length) ||
                        ("paint" === e && !Object.keys(t).length)
                      )
                  )
                );
              }
              _validate(t, e, n, r, i = {}) {
                return (
                  (!i || !1 !== i.validate) &&
                  ni(
                    this,
                    t.call(Yr, {
                      key: e,
                      layerType: this.type,
                      objectKey: n,
                      value: r,
                      styleSpec: Nt,
                      style: { glyphs: !0, sprite: !0 },
                    })
                  )
                );
              }
              is3D() {
                return !1;
              }
              isSky() {
                return !1;
              }
              isTileClipped() {
                return !1;
              }
              hasOffscreenPass() {
                return !1;
              }
              resize() {}
              isStateDependent() {
                for (const t in this.paint._values) {
                  const e = this.paint.get(t);
                  if (
                    e instanceof mo &&
                    Yn(e.property.specification) &&
                    ("source" === e.value.kind ||
                      "composite" === e.value.kind) &&
                    e.value.isStateDependent
                  )
                    return !0;
                }
                return !1;
              }
            }
            const js = Co([{ name: "a_pos", components: 2, type: "Int16" }], 4),
              { members: Us } = js;
            class Zs {
              constructor(t = []) {
                this.segments = t;
              }
              prepareSegment(t, e, n, r) {
                let i = this.segments[this.segments.length - 1];
                return (
                  t > Zs.MAX_VERTEX_ARRAY_LENGTH &&
                    I(
                      `Max vertices per segment is ${Zs.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`
                    ),
                  (!i ||
                    i.vertexLength + t > Zs.MAX_VERTEX_ARRAY_LENGTH ||
                    i.sortKey !== r) &&
                    ((i = {
                      vertexOffset: e.length,
                      primitiveOffset: n.length,
                      vertexLength: 0,
                      primitiveLength: 0,
                    }),
                    void 0 !== r && (i.sortKey = r),
                    this.segments.push(i)),
                  i
                );
              }
              get() {
                return this.segments;
              }
              destroy() {
                for (const t of this.segments)
                  for (const e in t.vaos) t.vaos[e].destroy();
              }
              static simpleSegment(t, e, n, r) {
                return new Zs([
                  {
                    vertexOffset: t,
                    primitiveOffset: e,
                    vertexLength: n,
                    primitiveLength: r,
                    vaos: {},
                    sortKey: 0,
                  },
                ]);
              }
            }
            (Zs.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1),
              li("SegmentVector", Zs);
            var Vs = 8192;
            const qs = Math.pow(2, 14) - 1,
              $s = -qs - 1;
            function Gs(t) {
              const e = Vs / t.extent,
                n = t.loadGeometry();
              for (let r = 0; r < n.length; r++) {
                const t = n[r];
                for (let n = 0; n < t.length; n++) {
                  const r = t[n],
                    i = Math.round(r.x * e),
                    o = Math.round(r.y * e);
                  (r.x = g(i, $s, qs)),
                    (r.y = g(o, $s, qs)),
                    (i < r.x || i > r.x + 1 || o < r.y || o > r.y + 1) &&
                      I(
                        "Geometry exceeds allowed extent, reduce your vector tile buffer size"
                      );
                }
              }
              return n;
            }
            function Ws(t, e) {
              return {
                type: t.type,
                id: t.id,
                properties: t.properties,
                geometry: e ? Gs(t) : [],
              };
            }
            function Hs(t, e, n, r, i) {
              t.emplaceBack(2 * e + (r + 1) / 2, 2 * n + (i + 1) / 2);
            }
            class Xs {
              constructor(t) {
                (this.zoom = t.zoom),
                  (this.overscaling = t.overscaling),
                  (this.layers = t.layers),
                  (this.layerIds = this.layers.map((t) => t.id)),
                  (this.index = t.index),
                  (this.hasPattern = !1),
                  (this.layoutVertexArray = new Mo()),
                  (this.indexArray = new Zo()),
                  (this.segments = new Zs()),
                  (this.programConfigurations = new Is(t.layers, t.zoom)),
                  (this.stateDependentLayerIds = this.layers
                    .filter((t) => t.isStateDependent())
                    .map((t) => t.id));
              }
              populate(t, e, n) {
                const r = this.layers[0],
                  i = [];
                let o = null;
                "circle" === r.type && (o = r.layout.get("circle-sort-key"));
                for (const {
                  feature: s,
                  id: a,
                  index: l,
                  sourceLayerIndex: c,
                } of t) {
                  const t = this.layers[0]._featureFilter.needGeometry,
                    e = Ws(s, t);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new ao(this.zoom),
                      e,
                      n
                    )
                  )
                    continue;
                  const r = o ? o.evaluate(e, {}, n) : void 0,
                    u = {
                      id: a,
                      properties: s.properties,
                      type: s.type,
                      sourceLayerIndex: c,
                      index: l,
                      geometry: t ? e.geometry : Gs(s),
                      patterns: {},
                      sortKey: r,
                    };
                  i.push(u);
                }
                o && i.sort((t, e) => t.sortKey - e.sortKey);
                for (const s of i) {
                  const { geometry: r, index: i, sourceLayerIndex: o } = s,
                    a = t[i].feature;
                  this.addFeature(s, r, i, n),
                    e.featureIndex.insert(a, r, i, o, this.index);
                }
              }
              update(t, e, n) {
                this.stateDependentLayers.length &&
                  this.programConfigurations.updatePaintArrays(
                    t,
                    e,
                    this.stateDependentLayers,
                    n
                  );
              }
              isEmpty() {
                return 0 === this.layoutVertexArray.length;
              }
              uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
              }
              upload(t) {
                this.uploaded ||
                  ((this.layoutVertexBuffer = t.createVertexBuffer(
                    this.layoutVertexArray,
                    Us
                  )),
                  (this.indexBuffer = t.createIndexBuffer(this.indexArray))),
                  this.programConfigurations.upload(t),
                  (this.uploaded = !0);
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy());
              }
              addFeature(t, e, n, r) {
                for (const i of e)
                  for (const e of i) {
                    const n = e.x,
                      r = e.y;
                    if (n < 0 || n >= Vs || r < 0 || r >= Vs) continue;
                    const i = this.segments.prepareSegment(
                        4,
                        this.layoutVertexArray,
                        this.indexArray,
                        t.sortKey
                      ),
                      o = i.vertexLength;
                    Hs(this.layoutVertexArray, n, r, -1, -1),
                      Hs(this.layoutVertexArray, n, r, 1, -1),
                      Hs(this.layoutVertexArray, n, r, 1, 1),
                      Hs(this.layoutVertexArray, n, r, -1, 1),
                      this.indexArray.emplaceBack(o, o + 1, o + 2),
                      this.indexArray.emplaceBack(o, o + 3, o + 2),
                      (i.vertexLength += 4),
                      (i.primitiveLength += 2);
                  }
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  t,
                  n,
                  {},
                  r
                );
              }
            }
            function Ks(t, e) {
              for (let n = 0; n < t.length; n++) if (oa(e, t[n])) return !0;
              for (let n = 0; n < e.length; n++) if (oa(t, e[n])) return !0;
              return !!ta(t, e);
            }
            function Ys(t, e, n) {
              return !!oa(t, e) || !!na(e, t, n);
            }
            function Qs(t, e) {
              if (1 === t.length) return ia(e, t[0]);
              for (let n = 0; n < e.length; n++) {
                const r = e[n];
                for (let e = 0; e < r.length; e++) if (oa(t, r[e])) return !0;
              }
              for (let n = 0; n < t.length; n++) if (ia(e, t[n])) return !0;
              for (let n = 0; n < e.length; n++) if (ta(t, e[n])) return !0;
              return !1;
            }
            function Js(t, e, n) {
              if (t.length > 1) {
                if (ta(t, e)) return !0;
                for (let r = 0; r < e.length; r++)
                  if (na(e[r], t, n)) return !0;
              }
              for (let r = 0; r < t.length; r++) if (na(t[r], e, n)) return !0;
              return !1;
            }
            function ta(t, e) {
              if (0 === t.length || 0 === e.length) return !1;
              for (let n = 0; n < t.length - 1; n++) {
                const r = t[n],
                  i = t[n + 1];
                for (let t = 0; t < e.length - 1; t++)
                  if (ea(r, i, e[t], e[t + 1])) return !0;
              }
              return !1;
            }
            function ea(t, e, n, r) {
              return D(t, n, r) !== D(e, n, r) && D(t, e, n) !== D(t, e, r);
            }
            function na(t, e, n) {
              const r = n * n;
              if (1 === e.length) return t.distSqr(e[0]) < r;
              for (let i = 1; i < e.length; i++)
                if (ra(t, e[i - 1], e[i]) < r) return !0;
              return !1;
            }
            function ra(t, e, n) {
              const r = e.distSqr(n);
              if (0 === r) return t.distSqr(e);
              const i =
                ((t.x - e.x) * (n.x - e.x) + (t.y - e.y) * (n.y - e.y)) / r;
              return t.distSqr(
                i < 0 ? e : i > 1 ? n : n.sub(e)._mult(i)._add(e)
              );
            }
            function ia(t, e) {
              let n,
                r,
                i,
                o = !1;
              for (let s = 0; s < t.length; s++) {
                n = t[s];
                for (let t = 0, s = n.length - 1; t < n.length; s = t++)
                  (r = n[t]),
                    (i = n[s]),
                    r.y > e.y != i.y > e.y &&
                      e.x < ((i.x - r.x) * (e.y - r.y)) / (i.y - r.y) + r.x &&
                      (o = !o);
              }
              return o;
            }
            function oa(t, e) {
              let n = !1;
              for (let r = 0, i = t.length - 1; r < t.length; i = r++) {
                const o = t[r],
                  s = t[i];
                o.y > e.y != s.y > e.y &&
                  e.x < ((s.x - o.x) * (e.y - o.y)) / (s.y - o.y) + o.x &&
                  (n = !n);
              }
              return n;
            }
            function sa(t, e, n, r, i) {
              for (const o of t)
                if (e <= o.x && n <= o.y && r >= o.x && i >= o.y) return !0;
              const s = [new o(e, n), new o(e, i), new o(r, i), new o(r, n)];
              if (t.length > 2) for (const o of s) if (oa(t, o)) return !0;
              for (let o = 0; o < t.length - 1; o++)
                if (aa(t[o], t[o + 1], s)) return !0;
              return !1;
            }
            function aa(t, e, n) {
              const r = n[0],
                i = n[2];
              if (
                (t.x < r.x && e.x < r.x) ||
                (t.x > i.x && e.x > i.x) ||
                (t.y < r.y && e.y < r.y) ||
                (t.y > i.y && e.y > i.y)
              )
                return !1;
              const o = D(t, e, n[0]);
              return (
                o !== D(t, e, n[1]) ||
                o !== D(t, e, n[2]) ||
                o !== D(t, e, n[3])
              );
            }
            function la(t, e, n) {
              const r = e.paint.get(t).value;
              return "constant" === r.kind
                ? r.value
                : n.programConfigurations.get(e.id).getMaxValue(t);
            }
            function ca(t) {
              return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
            }
            function ua(t, e, n, r, i) {
              if (!e[0] && !e[1]) return t;
              const s = o.convert(e)._mult(i);
              "viewport" === n && s._rotate(-r);
              const a = [];
              for (let o = 0; o < t.length; o++) a.push(t[o].sub(s));
              return a;
            }
            function ha(t, e, n, r) {
              const i = o.convert(t)._mult(r);
              return "viewport" === e && i._rotate(-n), i;
            }
            li("CircleBucket", Xs, { omit: ["layers"] });
            const pa = new wo({
              "circle-sort-key": new _o(Nt.layout_circle["circle-sort-key"]),
            });
            var da = {
                paint: new wo({
                  "circle-radius": new _o(Nt.paint_circle["circle-radius"]),
                  "circle-color": new _o(Nt.paint_circle["circle-color"]),
                  "circle-blur": new _o(Nt.paint_circle["circle-blur"]),
                  "circle-opacity": new _o(Nt.paint_circle["circle-opacity"]),
                  "circle-translate": new yo(
                    Nt.paint_circle["circle-translate"]
                  ),
                  "circle-translate-anchor": new yo(
                    Nt.paint_circle["circle-translate-anchor"]
                  ),
                  "circle-pitch-scale": new yo(
                    Nt.paint_circle["circle-pitch-scale"]
                  ),
                  "circle-pitch-alignment": new yo(
                    Nt.paint_circle["circle-pitch-alignment"]
                  ),
                  "circle-stroke-width": new _o(
                    Nt.paint_circle["circle-stroke-width"]
                  ),
                  "circle-stroke-color": new _o(
                    Nt.paint_circle["circle-stroke-color"]
                  ),
                  "circle-stroke-opacity": new _o(
                    Nt.paint_circle["circle-stroke-opacity"]
                  ),
                }),
                layout: pa,
              },
              fa = "undefined" != typeof Float32Array ? Float32Array : Array;
            function ma() {
              var t = new fa(9);
              return (
                fa != Float32Array &&
                  ((t[1] = 0),
                  (t[2] = 0),
                  (t[3] = 0),
                  (t[5] = 0),
                  (t[6] = 0),
                  (t[7] = 0)),
                (t[0] = 1),
                (t[4] = 1),
                (t[8] = 1),
                t
              );
            }
            function ga(t) {
              return (
                (t[0] = 1),
                (t[1] = 0),
                (t[2] = 0),
                (t[3] = 0),
                (t[4] = 0),
                (t[5] = 1),
                (t[6] = 0),
                (t[7] = 0),
                (t[8] = 0),
                (t[9] = 0),
                (t[10] = 1),
                (t[11] = 0),
                (t[12] = 0),
                (t[13] = 0),
                (t[14] = 0),
                (t[15] = 1),
                t
              );
            }
            function ya(t, e, n) {
              var r = e[0],
                i = e[1],
                o = e[2],
                s = e[3],
                a = e[4],
                l = e[5],
                c = e[6],
                u = e[7],
                h = e[8],
                p = e[9],
                d = e[10],
                f = e[11],
                m = e[12],
                g = e[13],
                y = e[14],
                _ = e[15],
                v = n[0],
                b = n[1],
                x = n[2],
                w = n[3];
              return (
                (t[0] = v * r + b * a + x * h + w * m),
                (t[1] = v * i + b * l + x * p + w * g),
                (t[2] = v * o + b * c + x * d + w * y),
                (t[3] = v * s + b * u + x * f + w * _),
                (t[4] =
                  (v = n[4]) * r +
                  (b = n[5]) * a +
                  (x = n[6]) * h +
                  (w = n[7]) * m),
                (t[5] = v * i + b * l + x * p + w * g),
                (t[6] = v * o + b * c + x * d + w * y),
                (t[7] = v * s + b * u + x * f + w * _),
                (t[8] =
                  (v = n[8]) * r +
                  (b = n[9]) * a +
                  (x = n[10]) * h +
                  (w = n[11]) * m),
                (t[9] = v * i + b * l + x * p + w * g),
                (t[10] = v * o + b * c + x * d + w * y),
                (t[11] = v * s + b * u + x * f + w * _),
                (t[12] =
                  (v = n[12]) * r +
                  (b = n[13]) * a +
                  (x = n[14]) * h +
                  (w = n[15]) * m),
                (t[13] = v * i + b * l + x * p + w * g),
                (t[14] = v * o + b * c + x * d + w * y),
                (t[15] = v * s + b * u + x * f + w * _),
                t
              );
            }
            Math.hypot ||
              (Math.hypot = function () {
                for (var t = 0, e = arguments.length; e--; )
                  t += arguments[e] * arguments[e];
                return Math.sqrt(t);
              });
            var _a = ya;
            function va() {
              var t = new fa(3);
              return (
                fa != Float32Array && ((t[0] = 0), (t[1] = 0), (t[2] = 0)), t
              );
            }
            function ba(t) {
              return Math.hypot(t[0], t[1], t[2]);
            }
            function xa(t, e, n) {
              var r = new fa(3);
              return (r[0] = t), (r[1] = e), (r[2] = n), r;
            }
            function wa(t, e, n) {
              return (
                (t[0] = e[0] - n[0]),
                (t[1] = e[1] - n[1]),
                (t[2] = e[2] - n[2]),
                t
              );
            }
            function Sa(t, e, n) {
              return (
                (t[0] = e[0] * n[0]),
                (t[1] = e[1] * n[1]),
                (t[2] = e[2] * n[2]),
                t
              );
            }
            function Ea(t, e, n, r) {
              return (
                (t[0] = e[0] + n[0] * r),
                (t[1] = e[1] + n[1] * r),
                (t[2] = e[2] + n[2] * r),
                t
              );
            }
            function Ta(t, e) {
              var n = e[0],
                r = e[1],
                i = e[2],
                o = n * n + r * r + i * i;
              return (
                o > 0 && (o = 1 / Math.sqrt(o)),
                (t[0] = e[0] * o),
                (t[1] = e[1] * o),
                (t[2] = e[2] * o),
                t
              );
            }
            function Aa(t, e, n) {
              var r = n[0],
                i = n[1],
                o = n[2],
                s = e[0],
                a = e[1],
                l = e[2],
                c = i * l - o * a,
                u = o * s - r * l,
                h = r * a - i * s,
                p = i * h - o * u,
                d = o * c - r * h,
                f = r * u - i * c,
                m = 2 * n[3];
              return (
                (u *= m),
                (h *= m),
                (d *= 2),
                (f *= 2),
                (t[0] = s + (c *= m) + (p *= 2)),
                (t[1] = a + u + d),
                (t[2] = l + h + f),
                t
              );
            }
            var Ca,
              Pa = wa,
              Ma = Sa,
              Oa = ba;
            function ka(t, e, n) {
              var r = e[0],
                i = e[1],
                o = e[2],
                s = e[3];
              return (
                (t[0] = n[0] * r + n[4] * i + n[8] * o + n[12] * s),
                (t[1] = n[1] * r + n[5] * i + n[9] * o + n[13] * s),
                (t[2] = n[2] * r + n[6] * i + n[10] * o + n[14] * s),
                (t[3] = n[3] * r + n[7] * i + n[11] * o + n[15] * s),
                t
              );
            }
            function Ia() {
              var t = new fa(4);
              return (
                fa != Float32Array && ((t[0] = 0), (t[1] = 0), (t[2] = 0)),
                (t[3] = 1),
                t
              );
            }
            function Da(t) {
              return (t[0] = 0), (t[1] = 0), (t[2] = 0), (t[3] = 1), t;
            }
            function za(t, e, n) {
              n *= 0.5;
              var r = e[0],
                i = e[1],
                o = e[2],
                s = e[3],
                a = Math.sin(n),
                l = Math.cos(n);
              return (
                (t[0] = r * l + s * a),
                (t[1] = i * l + o * a),
                (t[2] = o * l - i * a),
                (t[3] = s * l - r * a),
                t
              );
            }
            function Ra(t, e, n) {
              const r = ka([], [t.x, t.y, e, 1], n);
              return new o(r[0] / r[3], r[1] / r[3]);
            }
            va(),
              (Ca = new fa(4)),
              fa != Float32Array &&
                ((Ca[0] = 0), (Ca[1] = 0), (Ca[2] = 0), (Ca[3] = 0)),
              va(),
              xa(1, 0, 0),
              xa(0, 1, 0),
              Ia(),
              Ia(),
              ma();
            const La = xa(0, 0, 0),
              Fa = xa(0, 0, 1);
            function Ba(t, e) {
              const n = va();
              return (
                (La[2] = e), t.intersectsPlane(La, Fa, n), new o(n[0], n[1])
              );
            }
            class Na extends Xs {}
            function ja(t, { width: e, height: n }, r, i) {
              if (i) {
                if (i instanceof Uint8ClampedArray)
                  i = new Uint8Array(i.buffer);
                else if (i.length !== e * n * r)
                  throw new RangeError("mismatched image size");
              } else i = new Uint8Array(e * n * r);
              return (t.width = e), (t.height = n), (t.data = i), t;
            }
            function Ua(t, { width: e, height: n }, r) {
              if (e === t.width && n === t.height) return;
              const i = ja({}, { width: e, height: n }, r);
              Za(
                t,
                i,
                { x: 0, y: 0 },
                { x: 0, y: 0 },
                { width: Math.min(t.width, e), height: Math.min(t.height, n) },
                r
              ),
                (t.width = e),
                (t.height = n),
                (t.data = i.data);
            }
            function Za(t, e, n, r, i, o) {
              if (0 === i.width || 0 === i.height) return e;
              if (
                i.width > t.width ||
                i.height > t.height ||
                n.x > t.width - i.width ||
                n.y > t.height - i.height
              )
                throw new RangeError(
                  "out of range source coordinates for image copy"
                );
              if (
                i.width > e.width ||
                i.height > e.height ||
                r.x > e.width - i.width ||
                r.y > e.height - i.height
              )
                throw new RangeError(
                  "out of range destination coordinates for image copy"
                );
              const s = t.data,
                a = e.data;
              for (let l = 0; l < i.height; l++) {
                const c = ((n.y + l) * t.width + n.x) * o,
                  u = ((r.y + l) * e.width + r.x) * o;
                for (let t = 0; t < i.width * o; t++) a[u + t] = s[c + t];
              }
              return e;
            }
            li("HeatmapBucket", Na, { omit: ["layers"] });
            class Va {
              constructor(t, e) {
                ja(this, t, 1, e);
              }
              resize(t) {
                Ua(this, t, 1);
              }
              clone() {
                return new Va(
                  { width: this.width, height: this.height },
                  new Uint8Array(this.data)
                );
              }
              static copy(t, e, n, r, i) {
                Za(t, e, n, r, i, 1);
              }
            }
            class qa {
              constructor(t, e) {
                ja(this, t, 4, e);
              }
              resize(t) {
                Ua(this, t, 4);
              }
              replace(t, e) {
                e
                  ? this.data.set(t)
                  : (this.data =
                      t instanceof Uint8ClampedArray
                        ? new Uint8Array(t.buffer)
                        : t);
              }
              clone() {
                return new qa(
                  { width: this.width, height: this.height },
                  new Uint8Array(this.data)
                );
              }
              static copy(t, e, n, r, i) {
                Za(t, e, n, r, i, 4);
              }
            }
            li("AlphaImage", Va), li("RGBAImage", qa);
            var $a = {
              paint: new wo({
                "heatmap-radius": new _o(Nt.paint_heatmap["heatmap-radius"]),
                "heatmap-weight": new _o(Nt.paint_heatmap["heatmap-weight"]),
                "heatmap-intensity": new yo(
                  Nt.paint_heatmap["heatmap-intensity"]
                ),
                "heatmap-color": new xo(Nt.paint_heatmap["heatmap-color"]),
                "heatmap-opacity": new yo(Nt.paint_heatmap["heatmap-opacity"]),
              }),
            };
            function Ga(t) {
              const e = {},
                n = t.resolution || 256,
                r = t.clips ? t.clips.length : 1,
                i = t.image || new qa({ width: n, height: r }),
                o = (n, r, o) => {
                  e[t.evaluationKey] = o;
                  const s = t.expression.evaluate(e);
                  (i.data[n + r + 0] = Math.floor((255 * s.r) / s.a)),
                    (i.data[n + r + 1] = Math.floor((255 * s.g) / s.a)),
                    (i.data[n + r + 2] = Math.floor((255 * s.b) / s.a)),
                    (i.data[n + r + 3] = Math.floor(255 * s.a));
                };
              if (t.clips)
                for (let s = 0, a = 0; s < r; ++s, a += 4 * n)
                  for (let e = 0, r = 0; e < n; e++, r += 4) {
                    const i = e / (n - 1),
                      { start: l, end: c } = t.clips[s];
                    o(a, r, l * (1 - i) + c * i);
                  }
              else
                for (let s = 0, a = 0; s < n; s++, a += 4) o(0, a, s / (n - 1));
              return i;
            }
            var Wa = {
              paint: new wo({
                "hillshade-illumination-direction": new yo(
                  Nt.paint_hillshade["hillshade-illumination-direction"]
                ),
                "hillshade-illumination-anchor": new yo(
                  Nt.paint_hillshade["hillshade-illumination-anchor"]
                ),
                "hillshade-exaggeration": new yo(
                  Nt.paint_hillshade["hillshade-exaggeration"]
                ),
                "hillshade-shadow-color": new yo(
                  Nt.paint_hillshade["hillshade-shadow-color"]
                ),
                "hillshade-highlight-color": new yo(
                  Nt.paint_hillshade["hillshade-highlight-color"]
                ),
                "hillshade-accent-color": new yo(
                  Nt.paint_hillshade["hillshade-accent-color"]
                ),
              }),
            };
            const Ha = Co([{ name: "a_pos", components: 2, type: "Int16" }], 4),
              { members: Xa } = Ha;
            var Ka = Qa,
              Ya = Qa;
            function Qa(t, e, n) {
              n = n || 2;
              var r,
                i,
                o,
                s,
                a,
                l,
                c,
                u = e && e.length,
                h = u ? e[0] * n : t.length,
                p = Ja(t, 0, h, n, !0),
                d = [];
              if (!p || p.next === p.prev) return d;
              if (
                (u &&
                  (p = (function (t, e, n, r) {
                    var i,
                      o,
                      s,
                      a = [];
                    for (i = 0, o = e.length; i < o; i++)
                      (s = Ja(
                        t,
                        e[i] * r,
                        i < o - 1 ? e[i + 1] * r : t.length,
                        r,
                        !1
                      )) === s.next && (s.steiner = !0),
                        a.push(ul(s));
                    for (a.sort(sl), i = 0; i < a.length; i++)
                      al(a[i], n), (n = tl(n, n.next));
                    return n;
                  })(t, e, p, n)),
                t.length > 80 * n)
              ) {
                (r = o = t[0]), (i = s = t[1]);
                for (var f = n; f < h; f += n)
                  (a = t[f]) < r && (r = a),
                    (l = t[f + 1]) < i && (i = l),
                    a > o && (o = a),
                    l > s && (s = l);
                c = 0 !== (c = Math.max(o - r, s - i)) ? 1 / c : 0;
              }
              return el(p, d, n, r, i, c), d;
            }
            function Ja(t, e, n, r, i) {
              var o, s;
              if (i === Sl(t, e, n, r) > 0)
                for (o = e; o < n; o += r) s = bl(o, t[o], t[o + 1], s);
              else for (o = n - r; o >= e; o -= r) s = bl(o, t[o], t[o + 1], s);
              return s && fl(s, s.next) && (xl(s), (s = s.next)), s;
            }
            function tl(t, e) {
              if (!t) return t;
              e || (e = t);
              var n,
                r = t;
              do {
                if (
                  ((n = !1),
                  r.steiner || (!fl(r, r.next) && 0 !== dl(r.prev, r, r.next)))
                )
                  r = r.next;
                else {
                  if ((xl(r), (r = e = r.prev) === r.next)) break;
                  n = !0;
                }
              } while (n || r !== e);
              return e;
            }
            function el(t, e, n, r, i, o, s) {
              if (t) {
                !s &&
                  o &&
                  (function (t, e, n, r) {
                    var i = t;
                    do {
                      null === i.z && (i.z = cl(i.x, i.y, e, n, r)),
                        (i.prevZ = i.prev),
                        (i.nextZ = i.next),
                        (i = i.next);
                    } while (i !== t);
                    (i.prevZ.nextZ = null),
                      (i.prevZ = null),
                      (function (t) {
                        var e,
                          n,
                          r,
                          i,
                          o,
                          s,
                          a,
                          l,
                          c = 1;
                        do {
                          for (n = t, t = null, o = null, s = 0; n; ) {
                            for (
                              s++, r = n, a = 0, e = 0;
                              e < c && (a++, (r = r.nextZ));
                              e++
                            );
                            for (l = c; a > 0 || (l > 0 && r); )
                              0 !== a && (0 === l || !r || n.z <= r.z)
                                ? ((i = n), (n = n.nextZ), a--)
                                : ((i = r), (r = r.nextZ), l--),
                                o ? (o.nextZ = i) : (t = i),
                                (i.prevZ = o),
                                (o = i);
                            n = r;
                          }
                          (o.nextZ = null), (c *= 2);
                        } while (s > 1);
                      })(i);
                  })(t, r, i, o);
                for (var a, l, c = t; t.prev !== t.next; )
                  if (((a = t.prev), (l = t.next), o ? rl(t, r, i, o) : nl(t)))
                    e.push(a.i / n),
                      e.push(t.i / n),
                      e.push(l.i / n),
                      xl(t),
                      (t = l.next),
                      (c = l.next);
                  else if ((t = l) === c) {
                    s
                      ? 1 === s
                        ? el((t = il(tl(t), e, n)), e, n, r, i, o, 2)
                        : 2 === s && ol(t, e, n, r, i, o)
                      : el(tl(t), e, n, r, i, o, 1);
                    break;
                  }
              }
            }
            function nl(t) {
              var e = t.prev,
                n = t,
                r = t.next;
              if (dl(e, n, r) >= 0) return !1;
              for (var i = t.next.next; i !== t.prev; ) {
                if (
                  hl(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) &&
                  dl(i.prev, i, i.next) >= 0
                )
                  return !1;
                i = i.next;
              }
              return !0;
            }
            function rl(t, e, n, r) {
              var i = t.prev,
                o = t,
                s = t.next;
              if (dl(i, o, s) >= 0) return !1;
              for (
                var a =
                    i.x > o.x ? (i.x > s.x ? i.x : s.x) : o.x > s.x ? o.x : s.x,
                  l =
                    i.y > o.y ? (i.y > s.y ? i.y : s.y) : o.y > s.y ? o.y : s.y,
                  c = cl(
                    i.x < o.x ? (i.x < s.x ? i.x : s.x) : o.x < s.x ? o.x : s.x,
                    i.y < o.y ? (i.y < s.y ? i.y : s.y) : o.y < s.y ? o.y : s.y,
                    e,
                    n,
                    r
                  ),
                  u = cl(a, l, e, n, r),
                  h = t.prevZ,
                  p = t.nextZ;
                h && h.z >= c && p && p.z <= u;

              ) {
                if (
                  h !== t.prev &&
                  h !== t.next &&
                  hl(i.x, i.y, o.x, o.y, s.x, s.y, h.x, h.y) &&
                  dl(h.prev, h, h.next) >= 0
                )
                  return !1;
                if (
                  ((h = h.prevZ),
                  p !== t.prev &&
                    p !== t.next &&
                    hl(i.x, i.y, o.x, o.y, s.x, s.y, p.x, p.y) &&
                    dl(p.prev, p, p.next) >= 0)
                )
                  return !1;
                p = p.nextZ;
              }
              for (; h && h.z >= c; ) {
                if (
                  h !== t.prev &&
                  h !== t.next &&
                  hl(i.x, i.y, o.x, o.y, s.x, s.y, h.x, h.y) &&
                  dl(h.prev, h, h.next) >= 0
                )
                  return !1;
                h = h.prevZ;
              }
              for (; p && p.z <= u; ) {
                if (
                  p !== t.prev &&
                  p !== t.next &&
                  hl(i.x, i.y, o.x, o.y, s.x, s.y, p.x, p.y) &&
                  dl(p.prev, p, p.next) >= 0
                )
                  return !1;
                p = p.nextZ;
              }
              return !0;
            }
            function il(t, e, n) {
              var r = t;
              do {
                var i = r.prev,
                  o = r.next.next;
                !fl(i, o) &&
                  ml(i, r, r.next, o) &&
                  _l(i, o) &&
                  _l(o, i) &&
                  (e.push(i.i / n),
                  e.push(r.i / n),
                  e.push(o.i / n),
                  xl(r),
                  xl(r.next),
                  (r = t = o)),
                  (r = r.next);
              } while (r !== t);
              return tl(r);
            }
            function ol(t, e, n, r, i, o) {
              var s = t;
              do {
                for (var a = s.next.next; a !== s.prev; ) {
                  if (s.i !== a.i && pl(s, a)) {
                    var l = vl(s, a);
                    return (
                      (s = tl(s, s.next)),
                      (l = tl(l, l.next)),
                      el(s, e, n, r, i, o),
                      void el(l, e, n, r, i, o)
                    );
                  }
                  a = a.next;
                }
                s = s.next;
              } while (s !== t);
            }
            function sl(t, e) {
              return t.x - e.x;
            }
            function al(t, e) {
              if (
                (e = (function (t, e) {
                  var n,
                    r = e,
                    i = t.x,
                    o = t.y,
                    s = -1 / 0;
                  do {
                    if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {
                      var a =
                        r.x + ((o - r.y) * (r.next.x - r.x)) / (r.next.y - r.y);
                      if (a <= i && a > s) {
                        if (((s = a), a === i)) {
                          if (o === r.y) return r;
                          if (o === r.next.y) return r.next;
                        }
                        n = r.x < r.next.x ? r : r.next;
                      }
                    }
                    r = r.next;
                  } while (r !== e);
                  if (!n) return null;
                  if (i === s) return n;
                  var l,
                    c = n,
                    u = n.x,
                    h = n.y,
                    p = 1 / 0;
                  r = n;
                  do {
                    i >= r.x &&
                      r.x >= u &&
                      i !== r.x &&
                      hl(o < h ? i : s, o, u, h, o < h ? s : i, o, r.x, r.y) &&
                      ((l = Math.abs(o - r.y) / (i - r.x)),
                      _l(r, t) &&
                        (l < p ||
                          (l === p &&
                            (r.x > n.x || (r.x === n.x && ll(n, r))))) &&
                        ((n = r), (p = l))),
                      (r = r.next);
                  } while (r !== c);
                  return n;
                })(t, e))
              ) {
                var n = vl(e, t);
                tl(e, e.next), tl(n, n.next);
              }
            }
            function ll(t, e) {
              return dl(t.prev, t, e.prev) < 0 && dl(e.next, t, t.next) < 0;
            }
            function cl(t, e, n, r, i) {
              return (
                (t =
                  1431655765 &
                  ((t =
                    858993459 &
                    ((t =
                      252645135 &
                      ((t = 16711935 & ((t = 32767 * (t - n) * i) | (t << 8))) |
                        (t << 4))) |
                      (t << 2))) |
                    (t << 1))) |
                ((e =
                  1431655765 &
                  ((e =
                    858993459 &
                    ((e =
                      252645135 &
                      ((e = 16711935 & ((e = 32767 * (e - r) * i) | (e << 8))) |
                        (e << 4))) |
                      (e << 2))) |
                    (e << 1))) <<
                  1)
              );
            }
            function ul(t) {
              var e = t,
                n = t;
              do {
                (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e),
                  (e = e.next);
              } while (e !== t);
              return n;
            }
            function hl(t, e, n, r, i, o, s, a) {
              return (
                (i - s) * (e - a) - (t - s) * (o - a) >= 0 &&
                (t - s) * (r - a) - (n - s) * (e - a) >= 0 &&
                (n - s) * (o - a) - (i - s) * (r - a) >= 0
              );
            }
            function pl(t, e) {
              return (
                t.next.i !== e.i &&
                t.prev.i !== e.i &&
                !(function (t, e) {
                  var n = t;
                  do {
                    if (
                      n.i !== t.i &&
                      n.next.i !== t.i &&
                      n.i !== e.i &&
                      n.next.i !== e.i &&
                      ml(n, n.next, t, e)
                    )
                      return !0;
                    n = n.next;
                  } while (n !== t);
                  return !1;
                })(t, e) &&
                ((_l(t, e) &&
                  _l(e, t) &&
                  (function (t, e) {
                    var n = t,
                      r = !1,
                      i = (t.x + e.x) / 2,
                      o = (t.y + e.y) / 2;
                    do {
                      n.y > o != n.next.y > o &&
                        n.next.y !== n.y &&
                        i <
                          ((n.next.x - n.x) * (o - n.y)) / (n.next.y - n.y) +
                            n.x &&
                        (r = !r),
                        (n = n.next);
                    } while (n !== t);
                    return r;
                  })(t, e) &&
                  (dl(t.prev, t, e.prev) || dl(t, e.prev, e))) ||
                  (fl(t, e) &&
                    dl(t.prev, t, t.next) > 0 &&
                    dl(e.prev, e, e.next) > 0))
              );
            }
            function dl(t, e, n) {
              return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
            }
            function fl(t, e) {
              return t.x === e.x && t.y === e.y;
            }
            function ml(t, e, n, r) {
              var i = yl(dl(t, e, n)),
                o = yl(dl(t, e, r)),
                s = yl(dl(n, r, t)),
                a = yl(dl(n, r, e));
              return (
                (i !== o && s !== a) ||
                !(0 !== i || !gl(t, n, e)) ||
                !(0 !== o || !gl(t, r, e)) ||
                !(0 !== s || !gl(n, t, r)) ||
                !(0 !== a || !gl(n, e, r))
              );
            }
            function gl(t, e, n) {
              return (
                e.x <= Math.max(t.x, n.x) &&
                e.x >= Math.min(t.x, n.x) &&
                e.y <= Math.max(t.y, n.y) &&
                e.y >= Math.min(t.y, n.y)
              );
            }
            function yl(t) {
              return t > 0 ? 1 : t < 0 ? -1 : 0;
            }
            function _l(t, e) {
              return dl(t.prev, t, t.next) < 0
                ? dl(t, e, t.next) >= 0 && dl(t, t.prev, e) >= 0
                : dl(t, e, t.prev) < 0 || dl(t, t.next, e) < 0;
            }
            function vl(t, e) {
              var n = new wl(t.i, t.x, t.y),
                r = new wl(e.i, e.x, e.y),
                i = t.next,
                o = e.prev;
              return (
                (t.next = e),
                (e.prev = t),
                (n.next = i),
                (i.prev = n),
                (r.next = n),
                (n.prev = r),
                (o.next = r),
                (r.prev = o),
                r
              );
            }
            function bl(t, e, n, r) {
              var i = new wl(t, e, n);
              return (
                r
                  ? ((i.next = r.next),
                    (i.prev = r),
                    (r.next.prev = i),
                    (r.next = i))
                  : ((i.prev = i), (i.next = i)),
                i
              );
            }
            function xl(t) {
              (t.next.prev = t.prev),
                (t.prev.next = t.next),
                t.prevZ && (t.prevZ.nextZ = t.nextZ),
                t.nextZ && (t.nextZ.prevZ = t.prevZ);
            }
            function wl(t, e, n) {
              (this.i = t),
                (this.x = e),
                (this.y = n),
                (this.prev = null),
                (this.next = null),
                (this.z = null),
                (this.prevZ = null),
                (this.nextZ = null),
                (this.steiner = !1);
            }
            function Sl(t, e, n, r) {
              for (var i = 0, o = e, s = n - r; o < n; o += r)
                (i += (t[s] - t[o]) * (t[o + 1] + t[s + 1])), (s = o);
              return i;
            }
            function El(t, e, n, r, i) {
              Tl(t, e, n || 0, r || t.length - 1, i || Cl);
            }
            function Tl(t, e, n, r, i) {
              for (; r > n; ) {
                if (r - n > 600) {
                  var o = r - n + 1,
                    s = e - n + 1,
                    a = Math.log(o),
                    l = 0.5 * Math.exp((2 * a) / 3),
                    c =
                      0.5 *
                      Math.sqrt((a * l * (o - l)) / o) *
                      (s - o / 2 < 0 ? -1 : 1);
                  Tl(
                    t,
                    e,
                    Math.max(n, Math.floor(e - (s * l) / o + c)),
                    Math.min(r, Math.floor(e + ((o - s) * l) / o + c)),
                    i
                  );
                }
                var u = t[e],
                  h = n,
                  p = r;
                for (Al(t, n, e), i(t[r], u) > 0 && Al(t, n, r); h < p; ) {
                  for (Al(t, h, p), h++, p--; i(t[h], u) < 0; ) h++;
                  for (; i(t[p], u) > 0; ) p--;
                }
                0 === i(t[n], u) ? Al(t, n, p) : Al(t, ++p, r),
                  p <= e && (n = p + 1),
                  e <= p && (r = p - 1);
              }
            }
            function Al(t, e, n) {
              var r = t[e];
              (t[e] = t[n]), (t[n] = r);
            }
            function Cl(t, e) {
              return t < e ? -1 : t > e ? 1 : 0;
            }
            function Pl(t, e) {
              const n = t.length;
              if (n <= 1) return [t];
              const r = [];
              let i, o;
              for (let s = 0; s < n; s++) {
                const e = z(t[s]);
                0 !== e &&
                  ((t[s].area = Math.abs(e)),
                  void 0 === o && (o = e < 0),
                  o === e < 0 ? (i && r.push(i), (i = [t[s]])) : i.push(t[s]));
              }
              if ((i && r.push(i), e > 1))
                for (let s = 0; s < r.length; s++)
                  r[s].length <= e ||
                    (El(r[s], e, 1, r[s].length - 1, Ml),
                    (r[s] = r[s].slice(0, e)));
              return r;
            }
            function Ml(t, e) {
              return e.area - t.area;
            }
            function Ol(t, e, n) {
              const r = n.patternDependencies;
              let i = !1;
              for (const o of e) {
                const e = o.paint.get(`${t}-pattern`);
                e.isConstant() || (i = !0);
                const n = e.constantOr(null);
                n && ((i = !0), (r[n.to] = !0), (r[n.from] = !0));
              }
              return i;
            }
            function kl(t, e, n, r, i) {
              const o = i.patternDependencies;
              for (const s of e) {
                const e = s.paint.get(`${t}-pattern`).value;
                if ("constant" !== e.kind) {
                  let t = e.evaluate({ zoom: r - 1 }, n, {}, i.availableImages),
                    a = e.evaluate({ zoom: r }, n, {}, i.availableImages),
                    l = e.evaluate({ zoom: r + 1 }, n, {}, i.availableImages);
                  (t = t && t.name ? t.name : t),
                    (a = a && a.name ? a.name : a),
                    (l = l && l.name ? l.name : l),
                    (o[t] = !0),
                    (o[a] = !0),
                    (o[l] = !0),
                    (n.patterns[s.id] = { min: t, mid: a, max: l });
                }
              }
              return n;
            }
            (Qa.deviation = function (t, e, n, r) {
              var i = e && e.length,
                o = Math.abs(Sl(t, 0, i ? e[0] * n : t.length, n));
              if (i)
                for (var s = 0, a = e.length; s < a; s++)
                  o -= Math.abs(
                    Sl(t, e[s] * n, s < a - 1 ? e[s + 1] * n : t.length, n)
                  );
              var l = 0;
              for (s = 0; s < r.length; s += 3) {
                var c = r[s] * n,
                  u = r[s + 1] * n,
                  h = r[s + 2] * n;
                l += Math.abs(
                  (t[c] - t[h]) * (t[u + 1] - t[c + 1]) -
                    (t[c] - t[u]) * (t[h + 1] - t[c + 1])
                );
              }
              return 0 === o && 0 === l ? 0 : Math.abs((l - o) / o);
            }),
              (Qa.flatten = function (t) {
                for (
                  var e = t[0][0].length,
                    n = { vertices: [], holes: [], dimensions: e },
                    r = 0,
                    i = 0;
                  i < t.length;
                  i++
                ) {
                  for (var o = 0; o < t[i].length; o++)
                    for (var s = 0; s < e; s++) n.vertices.push(t[i][o][s]);
                  i > 0 && n.holes.push((r += t[i - 1].length));
                }
                return n;
              }),
              (Ka.default = Ya);
            class Il {
              constructor(t) {
                (this.zoom = t.zoom),
                  (this.overscaling = t.overscaling),
                  (this.layers = t.layers),
                  (this.layerIds = this.layers.map((t) => t.id)),
                  (this.index = t.index),
                  (this.hasPattern = !1),
                  (this.patternFeatures = []),
                  (this.layoutVertexArray = new Mo()),
                  (this.indexArray = new Zo()),
                  (this.indexArray2 = new Ho()),
                  (this.programConfigurations = new Is(t.layers, t.zoom)),
                  (this.segments = new Zs()),
                  (this.segments2 = new Zs()),
                  (this.stateDependentLayerIds = this.layers
                    .filter((t) => t.isStateDependent())
                    .map((t) => t.id));
              }
              populate(t, e, n) {
                this.hasPattern = Ol("fill", this.layers, e);
                const r = this.layers[0].layout.get("fill-sort-key"),
                  i = [];
                for (const {
                  feature: o,
                  id: s,
                  index: a,
                  sourceLayerIndex: l,
                } of t) {
                  const t = this.layers[0]._featureFilter.needGeometry,
                    c = Ws(o, t);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new ao(this.zoom),
                      c,
                      n
                    )
                  )
                    continue;
                  const u = r
                      ? r.evaluate(c, {}, n, e.availableImages)
                      : void 0,
                    h = {
                      id: s,
                      properties: o.properties,
                      type: o.type,
                      sourceLayerIndex: l,
                      index: a,
                      geometry: t ? c.geometry : Gs(o),
                      patterns: {},
                      sortKey: u,
                    };
                  i.push(h);
                }
                r && i.sort((t, e) => t.sortKey - e.sortKey);
                for (const o of i) {
                  const { geometry: r, index: i, sourceLayerIndex: s } = o;
                  if (this.hasPattern) {
                    const t = kl("fill", this.layers, o, this.zoom, e);
                    this.patternFeatures.push(t);
                  } else this.addFeature(o, r, i, n, {});
                  e.featureIndex.insert(t[i].feature, r, i, s, this.index);
                }
              }
              update(t, e, n) {
                this.stateDependentLayers.length &&
                  this.programConfigurations.updatePaintArrays(
                    t,
                    e,
                    this.stateDependentLayers,
                    n
                  );
              }
              addFeatures(t, e, n) {
                for (const r of this.patternFeatures)
                  this.addFeature(r, r.geometry, r.index, e, n);
              }
              isEmpty() {
                return 0 === this.layoutVertexArray.length;
              }
              uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
              }
              upload(t) {
                this.uploaded ||
                  ((this.layoutVertexBuffer = t.createVertexBuffer(
                    this.layoutVertexArray,
                    Xa
                  )),
                  (this.indexBuffer = t.createIndexBuffer(this.indexArray)),
                  (this.indexBuffer2 = t.createIndexBuffer(this.indexArray2))),
                  this.programConfigurations.upload(t),
                  (this.uploaded = !0);
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.indexBuffer2.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy(),
                  this.segments2.destroy());
              }
              addFeature(t, e, n, r, i) {
                for (const o of Pl(e, 500)) {
                  let t = 0;
                  for (const a of o) t += a.length;
                  const e = this.segments.prepareSegment(
                      t,
                      this.layoutVertexArray,
                      this.indexArray
                    ),
                    n = e.vertexLength,
                    r = [],
                    i = [];
                  for (const a of o) {
                    if (0 === a.length) continue;
                    a !== o[0] && i.push(r.length / 2);
                    const t = this.segments2.prepareSegment(
                        a.length,
                        this.layoutVertexArray,
                        this.indexArray2
                      ),
                      e = t.vertexLength;
                    this.layoutVertexArray.emplaceBack(a[0].x, a[0].y),
                      this.indexArray2.emplaceBack(e + a.length - 1, e),
                      r.push(a[0].x),
                      r.push(a[0].y);
                    for (let n = 1; n < a.length; n++)
                      this.layoutVertexArray.emplaceBack(a[n].x, a[n].y),
                        this.indexArray2.emplaceBack(e + n - 1, e + n),
                        r.push(a[n].x),
                        r.push(a[n].y);
                    (t.vertexLength += a.length),
                      (t.primitiveLength += a.length);
                  }
                  const s = Ka(r, i);
                  for (let o = 0; o < s.length; o += 3)
                    this.indexArray.emplaceBack(
                      n + s[o],
                      n + s[o + 1],
                      n + s[o + 2]
                    );
                  (e.vertexLength += t), (e.primitiveLength += s.length / 3);
                }
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  t,
                  n,
                  i,
                  r
                );
              }
            }
            li("FillBucket", Il, { omit: ["layers", "patternFeatures"] });
            const Dl = new wo({
              "fill-sort-key": new _o(Nt.layout_fill["fill-sort-key"]),
            });
            var zl = {
              paint: new wo({
                "fill-antialias": new yo(Nt.paint_fill["fill-antialias"]),
                "fill-opacity": new _o(Nt.paint_fill["fill-opacity"]),
                "fill-color": new _o(Nt.paint_fill["fill-color"]),
                "fill-outline-color": new _o(
                  Nt.paint_fill["fill-outline-color"]
                ),
                "fill-translate": new yo(Nt.paint_fill["fill-translate"]),
                "fill-translate-anchor": new yo(
                  Nt.paint_fill["fill-translate-anchor"]
                ),
                "fill-pattern": new vo(Nt.paint_fill["fill-pattern"]),
              }),
              layout: Dl,
            };
            const Rl = Co([
                { name: "a_pos_normal_ed", components: 4, type: "Int16" },
              ]),
              Ll = Co([
                { name: "a_centroid_pos", components: 2, type: "Uint16" },
              ]),
              { members: Fl } = Rl;
            var Bl = Nl;
            function Nl(t, e, n, r, i) {
              (this.properties = {}),
                (this.extent = n),
                (this.type = 0),
                (this._pbf = t),
                (this._geometry = -1),
                (this._keys = r),
                (this._values = i),
                t.readFields(jl, this, e);
            }
            function jl(t, e, n) {
              1 == t
                ? (e.id = n.readVarint())
                : 2 == t
                ? (function (t, e) {
                    for (var n = t.readVarint() + t.pos; t.pos < n; ) {
                      var r = e._keys[t.readVarint()],
                        i = e._values[t.readVarint()];
                      e.properties[r] = i;
                    }
                  })(n, e)
                : 3 == t
                ? (e.type = n.readVarint())
                : 4 == t && (e._geometry = n.pos);
            }
            function Ul(t) {
              for (
                var e, n, r = 0, i = 0, o = t.length, s = o - 1;
                i < o;
                s = i++
              )
                r += ((n = t[s]).x - (e = t[i]).x) * (e.y + n.y);
              return r;
            }
            (Nl.types = ["Unknown", "Point", "LineString", "Polygon"]),
              (Nl.prototype.loadGeometry = function () {
                var t = this._pbf;
                t.pos = this._geometry;
                for (
                  var e,
                    n = t.readVarint() + t.pos,
                    r = 1,
                    i = 0,
                    s = 0,
                    a = 0,
                    l = [];
                  t.pos < n;

                ) {
                  if (i <= 0) {
                    var c = t.readVarint();
                    (r = 7 & c), (i = c >> 3);
                  }
                  if ((i--, 1 === r || 2 === r))
                    (s += t.readSVarint()),
                      (a += t.readSVarint()),
                      1 === r && (e && l.push(e), (e = [])),
                      e.push(new o(s, a));
                  else {
                    if (7 !== r) throw new Error("unknown command " + r);
                    e && e.push(e[0].clone());
                  }
                }
                return e && l.push(e), l;
              }),
              (Nl.prototype.bbox = function () {
                var t = this._pbf;
                t.pos = this._geometry;
                for (
                  var e = t.readVarint() + t.pos,
                    n = 1,
                    r = 0,
                    i = 0,
                    o = 0,
                    s = 1 / 0,
                    a = -1 / 0,
                    l = 1 / 0,
                    c = -1 / 0;
                  t.pos < e;

                ) {
                  if (r <= 0) {
                    var u = t.readVarint();
                    (n = 7 & u), (r = u >> 3);
                  }
                  if ((r--, 1 === n || 2 === n))
                    (i += t.readSVarint()) < s && (s = i),
                      i > a && (a = i),
                      (o += t.readSVarint()) < l && (l = o),
                      o > c && (c = o);
                  else if (7 !== n) throw new Error("unknown command " + n);
                }
                return [s, l, a, c];
              }),
              (Nl.prototype.toGeoJSON = function (t, e, n) {
                var r,
                  i,
                  o = this.extent * Math.pow(2, n),
                  s = this.extent * t,
                  a = this.extent * e,
                  l = this.loadGeometry(),
                  c = Nl.types[this.type];
                function u(t) {
                  for (var e = 0; e < t.length; e++) {
                    var n = t[e];
                    t[e] = [
                      (360 * (n.x + s)) / o - 180,
                      (360 / Math.PI) *
                        Math.atan(
                          Math.exp(
                            ((180 - (360 * (n.y + a)) / o) * Math.PI) / 180
                          )
                        ) -
                        90,
                    ];
                  }
                }
                switch (this.type) {
                  case 1:
                    var h = [];
                    for (r = 0; r < l.length; r++) h[r] = l[r][0];
                    u((l = h));
                    break;
                  case 2:
                    for (r = 0; r < l.length; r++) u(l[r]);
                    break;
                  case 3:
                    for (
                      l = (function (t) {
                        var e = t.length;
                        if (e <= 1) return [t];
                        for (var n, r, i = [], o = 0; o < e; o++) {
                          var s = Ul(t[o]);
                          0 !== s &&
                            (void 0 === r && (r = s < 0),
                            r === s < 0
                              ? (n && i.push(n), (n = [t[o]]))
                              : n.push(t[o]));
                        }
                        return n && i.push(n), i;
                      })(l),
                        r = 0;
                      r < l.length;
                      r++
                    )
                      for (i = 0; i < l[r].length; i++) u(l[r][i]);
                }
                1 === l.length ? (l = l[0]) : (c = "Multi" + c);
                var p = {
                  type: "Feature",
                  geometry: { type: c, coordinates: l },
                  properties: this.properties,
                };
                return "id" in this && (p.id = this.id), p;
              });
            var Zl = Vl;
            function Vl(t, e) {
              (this.version = 1),
                (this.name = null),
                (this.extent = 4096),
                (this.length = 0),
                (this._pbf = t),
                (this._keys = []),
                (this._values = []),
                (this._features = []),
                t.readFields(ql, this, e),
                (this.length = this._features.length);
            }
            function ql(t, e, n) {
              15 === t
                ? (e.version = n.readVarint())
                : 1 === t
                ? (e.name = n.readString())
                : 5 === t
                ? (e.extent = n.readVarint())
                : 2 === t
                ? e._features.push(n.pos)
                : 3 === t
                ? e._keys.push(n.readString())
                : 4 === t &&
                  e._values.push(
                    (function (t) {
                      for (
                        var e = null, n = t.readVarint() + t.pos;
                        t.pos < n;

                      ) {
                        var r = t.readVarint() >> 3;
                        e =
                          1 === r
                            ? t.readString()
                            : 2 === r
                            ? t.readFloat()
                            : 3 === r
                            ? t.readDouble()
                            : 4 === r
                            ? t.readVarint64()
                            : 5 === r
                            ? t.readVarint()
                            : 6 === r
                            ? t.readSVarint()
                            : 7 === r
                            ? t.readBoolean()
                            : null;
                      }
                      return e;
                    })(n)
                  );
            }
            function $l(t, e, n) {
              if (3 === t) {
                var r = new Zl(n, n.readVarint() + n.pos);
                r.length && (e[r.name] = r);
              }
            }
            Vl.prototype.feature = function (t) {
              if (t < 0 || t >= this._features.length)
                throw new Error("feature index out of bounds");
              this._pbf.pos = this._features[t];
              var e = this._pbf.readVarint() + this._pbf.pos;
              return new Bl(
                this._pbf,
                e,
                this.extent,
                this._keys,
                this._values
              );
            };
            var Gl = {
              VectorTile: function (t, e) {
                this.layers = t.readFields($l, {}, e);
              },
              VectorTileFeature: Bl,
              VectorTileLayer: Zl,
            };
            const Wl = Gl.VectorTileFeature.types,
              Hl = Math.pow(2, 13);
            function Xl(t, e, n, r, i, o, s, a) {
              t.emplaceBack(
                (e << 1) + s,
                (n << 1) + o,
                (Math.floor(r * Hl) << 1) + i,
                Math.round(a)
              );
            }
            class Kl {
              constructor() {
                (this.acc = new o(0, 0)), (this.polyCount = []);
              }
              startRing(t) {
                (this.currentPolyCount = { edges: 0, top: 0 }),
                  this.polyCount.push(this.currentPolyCount),
                  this.min ||
                    ((this.min = new o(t.x, t.y)),
                    (this.max = new o(t.x, t.y)));
              }
              append(t, e) {
                this.currentPolyCount.edges++, this.acc._add(t);
                let n = !!this.borders;
                const r = this.min,
                  i = this.max;
                t.x < r.x
                  ? ((r.x = t.x), (n = !0))
                  : t.x > i.x && ((i.x = t.x), (n = !0)),
                  t.y < r.y
                    ? ((r.y = t.y), (n = !0))
                    : t.y > i.y && ((i.y = t.y), (n = !0)),
                  ((0 === t.x || t.x === Vs) && t.x === e.x) !=
                    ((0 === t.y || t.y === Vs) && t.y === e.y) &&
                    this.processBorderOverlap(t, e),
                  n && this.checkBorderIntersection(t, e);
              }
              checkBorderIntersection(t, e) {
                e.x < 0 != t.x < 0 &&
                  this.addBorderIntersection(
                    0,
                    rn(e.y, t.y, (0 - e.x) / (t.x - e.x))
                  ),
                  e.x > Vs != t.x > Vs &&
                    this.addBorderIntersection(
                      1,
                      rn(e.y, t.y, (Vs - e.x) / (t.x - e.x))
                    ),
                  e.y < 0 != t.y < 0 &&
                    this.addBorderIntersection(
                      2,
                      rn(e.x, t.x, (0 - e.y) / (t.y - e.y))
                    ),
                  e.y > Vs != t.y > Vs &&
                    this.addBorderIntersection(
                      3,
                      rn(e.x, t.x, (Vs - e.y) / (t.y - e.y))
                    );
              }
              addBorderIntersection(t, e) {
                this.borders ||
                  (this.borders = [
                    [Number.MAX_VALUE, -Number.MAX_VALUE],
                    [Number.MAX_VALUE, -Number.MAX_VALUE],
                    [Number.MAX_VALUE, -Number.MAX_VALUE],
                    [Number.MAX_VALUE, -Number.MAX_VALUE],
                  ]);
                const n = this.borders[t];
                e < n[0] && (n[0] = e), e > n[1] && (n[1] = e);
              }
              processBorderOverlap(t, e) {
                if (t.x === e.x) {
                  if (t.y === e.y) return;
                  const n = 0 === t.x ? 0 : 1;
                  this.addBorderIntersection(n, e.y),
                    this.addBorderIntersection(n, t.y);
                } else {
                  const n = 0 === t.y ? 2 : 3;
                  this.addBorderIntersection(n, e.x),
                    this.addBorderIntersection(n, t.x);
                }
              }
              centroid() {
                const t = this.polyCount.reduce((t, e) => t + e.edges, 0);
                return 0 !== t ? this.acc.div(t)._round() : new o(0, 0);
              }
              span() {
                return new o(this.max.x - this.min.x, this.max.y - this.min.y);
              }
              intersectsCount() {
                return this.borders.reduce(
                  (t, e) => t + +(e[0] !== Number.MAX_VALUE),
                  0
                );
              }
            }
            class Yl {
              constructor(t) {
                (this.zoom = t.zoom),
                  (this.overscaling = t.overscaling),
                  (this.layers = t.layers),
                  (this.layerIds = this.layers.map((t) => t.id)),
                  (this.index = t.index),
                  (this.hasPattern = !1),
                  (this.layoutVertexArray = new Oo()),
                  (this.centroidVertexArray = new ls()),
                  (this.indexArray = new Zo()),
                  (this.programConfigurations = new Is(t.layers, t.zoom)),
                  (this.segments = new Zs()),
                  (this.stateDependentLayerIds = this.layers
                    .filter((t) => t.isStateDependent())
                    .map((t) => t.id)),
                  (this.enableTerrain = t.enableTerrain);
              }
              populate(t, e, n) {
                (this.features = []),
                  (this.hasPattern = Ol("fill-extrusion", this.layers, e)),
                  (this.featuresOnBorder = []),
                  (this.borders = [[], [], [], []]),
                  (this.borderDone = [!1, !1, !1, !1]),
                  (this.tileToMeter = (function (t) {
                    const e = Math.exp(Math.PI * (1 - (t.y / (1 << t.z)) * 2));
                    return (80150034 * e) / (e * e + 1) / Vs / (1 << t.z);
                  })(n));
                for (const {
                  feature: r,
                  id: i,
                  index: o,
                  sourceLayerIndex: s,
                } of t) {
                  const t = this.layers[0]._featureFilter.needGeometry,
                    a = Ws(r, t);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new ao(this.zoom),
                      a,
                      n
                    )
                  )
                    continue;
                  const l = {
                      id: i,
                      sourceLayerIndex: s,
                      index: o,
                      geometry: t ? a.geometry : Gs(r),
                      properties: r.properties,
                      type: r.type,
                      patterns: {},
                    },
                    c = this.layoutVertexArray.length;
                  this.hasPattern
                    ? this.features.push(
                        kl("fill-extrusion", this.layers, l, this.zoom, e)
                      )
                    : this.addFeature(l, l.geometry, o, n, {}),
                    e.featureIndex.insert(r, l.geometry, o, s, this.index, c);
                }
                this.sortBorders();
              }
              addFeatures(t, e, n) {
                for (const r of this.features) {
                  const { geometry: t } = r;
                  this.addFeature(r, t, r.index, e, n);
                }
                this.sortBorders();
              }
              update(t, e, n) {
                this.stateDependentLayers.length &&
                  this.programConfigurations.updatePaintArrays(
                    t,
                    e,
                    this.stateDependentLayers,
                    n
                  );
              }
              isEmpty() {
                return 0 === this.layoutVertexArray.length;
              }
              uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
              }
              upload(t) {
                this.uploaded ||
                  ((this.layoutVertexBuffer = t.createVertexBuffer(
                    this.layoutVertexArray,
                    Fl
                  )),
                  (this.indexBuffer = t.createIndexBuffer(this.indexArray))),
                  this.programConfigurations.upload(t),
                  (this.uploaded = !0);
              }
              uploadCentroid(t) {
                0 !== this.centroidVertexArray.length &&
                  (this.centroidVertexBuffer
                    ? this.needsCentroidUpdate &&
                      this.centroidVertexBuffer.updateData(
                        this.centroidVertexArray
                      )
                    : (this.centroidVertexBuffer = t.createVertexBuffer(
                        this.centroidVertexArray,
                        Ll.members,
                        !0
                      )),
                  (this.needsCentroidUpdate = !1));
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.centroidVertexBuffer &&
                    this.centroidVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy());
              }
              addFeature(t, e, n, r, i) {
                const o = this.enableTerrain ? new Kl() : null;
                for (const a of Pl(e, 500)) {
                  let e = 0,
                    n = this.segments.prepareSegment(
                      4,
                      this.layoutVertexArray,
                      this.indexArray
                    );
                  if (
                    0 === a.length ||
                    (s = a[0]).every((t) => t.x <= 0) ||
                    s.every((t) => t.x >= Vs) ||
                    s.every((t) => t.y <= 0) ||
                    s.every((t) => t.y >= Vs)
                  )
                    continue;
                  for (let t = 0; t < a.length; t++) {
                    const r = a[t];
                    if (0 === r.length) continue;
                    e += r.length;
                    let i = 0;
                    o && o.startRing(r[0]);
                    for (let t = 0; t < r.length; t++) {
                      const e = r[t];
                      if (t >= 1) {
                        const s = r[t - 1];
                        if (!Ql(e, s)) {
                          o && o.append(e, s),
                            n.vertexLength + 4 > Zs.MAX_VERTEX_ARRAY_LENGTH &&
                              (n = this.segments.prepareSegment(
                                4,
                                this.layoutVertexArray,
                                this.indexArray
                              ));
                          const t = e.sub(s)._perp(),
                            r = t.x / (Math.abs(t.x) + Math.abs(t.y)),
                            a = t.y > 0 ? 1 : 0,
                            l = s.dist(e);
                          i + l > 32768 && (i = 0),
                            Xl(this.layoutVertexArray, e.x, e.y, r, a, 0, 0, i),
                            Xl(this.layoutVertexArray, e.x, e.y, r, a, 0, 1, i),
                            (i += l),
                            Xl(this.layoutVertexArray, s.x, s.y, r, a, 0, 0, i),
                            Xl(this.layoutVertexArray, s.x, s.y, r, a, 0, 1, i);
                          const c = n.vertexLength;
                          this.indexArray.emplaceBack(c, c + 2, c + 1),
                            this.indexArray.emplaceBack(c + 1, c + 2, c + 3),
                            (n.vertexLength += 4),
                            (n.primitiveLength += 2);
                        }
                      }
                    }
                  }
                  if (
                    (n.vertexLength + e > Zs.MAX_VERTEX_ARRAY_LENGTH &&
                      (n = this.segments.prepareSegment(
                        e,
                        this.layoutVertexArray,
                        this.indexArray
                      )),
                    "Polygon" !== Wl[t.type])
                  )
                    continue;
                  const r = [],
                    i = [],
                    l = n.vertexLength;
                  for (let t = 0; t < a.length; t++) {
                    const e = a[t];
                    if (0 !== e.length) {
                      e !== a[0] && i.push(r.length / 2);
                      for (let t = 0; t < e.length; t++) {
                        const n = e[t];
                        Xl(this.layoutVertexArray, n.x, n.y, 0, 0, 1, 1, 0),
                          r.push(n.x),
                          r.push(n.y),
                          o && o.currentPolyCount.top++;
                      }
                    }
                  }
                  const c = Ka(r, i);
                  for (let t = 0; t < c.length; t += 3)
                    this.indexArray.emplaceBack(
                      l + c[t],
                      l + c[t + 2],
                      l + c[t + 1]
                    );
                  (n.primitiveLength += c.length / 3), (n.vertexLength += e);
                }
                var s;
                if (o && o.polyCount.length > 0) {
                  if (o.borders) {
                    o.vertexArrayOffset = this.centroidVertexArray.length;
                    const t = o.borders,
                      e = this.featuresOnBorder.push(o) - 1;
                    for (let n = 0; n < 4; n++)
                      t[n][0] !== Number.MAX_VALUE && this.borders[n].push(e);
                  }
                  this.encodeCentroid(o.borders ? void 0 : o.centroid(), o);
                }
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  t,
                  n,
                  i,
                  r
                );
              }
              sortBorders() {
                for (let t = 0; t < 4; t++)
                  this.borders[t].sort(
                    (e, n) =>
                      this.featuresOnBorder[e].borders[t][0] -
                      this.featuresOnBorder[n].borders[t][0]
                  );
              }
              encodeCentroid(t, e, n = !0) {
                let r, i;
                if (t)
                  if (0 !== t.y) {
                    const n = e.span()._mult(this.tileToMeter);
                    (r =
                      (Math.max(t.x, 1) << 3) +
                      Math.min(7, Math.round(n.x / 10))),
                      (i =
                        (Math.max(t.y, 1) << 3) +
                        Math.min(7, Math.round(n.y / 10)));
                  } else (r = Math.ceil(7 * (t.x + 450))), (i = 0);
                else (r = 0), (i = +n);
                let o = n
                  ? this.centroidVertexArray.length
                  : e.vertexArrayOffset;
                for (const s of e.polyCount) {
                  n &&
                    this.centroidVertexArray.resize(
                      this.centroidVertexArray.length + 4 * s.edges + s.top
                    );
                  for (let t = 0; t < 2 * s.edges; t++)
                    this.centroidVertexArray.emplace(o++, 0, i),
                      this.centroidVertexArray.emplace(o++, r, i);
                  for (let t = 0; t < s.top; t++)
                    this.centroidVertexArray.emplace(o++, r, i);
                }
              }
            }
            function Ql(t, e) {
              return (
                (t.x === e.x && (t.x < 0 || t.x > Vs)) ||
                (t.y === e.y && (t.y < 0 || t.y > Vs))
              );
            }
            li("FillExtrusionBucket", Yl, { omit: ["layers", "features"] }),
              li("PartMetadata", Kl);
            var Jl = {
              paint: new wo({
                "fill-extrusion-opacity": new yo(
                  Nt["paint_fill-extrusion"]["fill-extrusion-opacity"]
                ),
                "fill-extrusion-color": new _o(
                  Nt["paint_fill-extrusion"]["fill-extrusion-color"]
                ),
                "fill-extrusion-translate": new yo(
                  Nt["paint_fill-extrusion"]["fill-extrusion-translate"]
                ),
                "fill-extrusion-translate-anchor": new yo(
                  Nt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]
                ),
                "fill-extrusion-pattern": new vo(
                  Nt["paint_fill-extrusion"]["fill-extrusion-pattern"]
                ),
                "fill-extrusion-height": new _o(
                  Nt["paint_fill-extrusion"]["fill-extrusion-height"]
                ),
                "fill-extrusion-base": new _o(
                  Nt["paint_fill-extrusion"]["fill-extrusion-base"]
                ),
                "fill-extrusion-vertical-gradient": new yo(
                  Nt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]
                ),
              }),
            };
            function tc(t, e) {
              return t.x * e.x + t.y * e.y;
            }
            function ec(t, e) {
              if (1 === t.length) {
                let n = 0;
                const r = e[n++];
                let i;
                for (; !i || r.equals(i); )
                  if (((i = e[n++]), !i)) return 1 / 0;
                for (; n < e.length; n++) {
                  const o = e[n],
                    s = t[0],
                    a = i.sub(r),
                    l = o.sub(r),
                    c = s.sub(r),
                    u = tc(a, a),
                    h = tc(a, l),
                    p = tc(l, l),
                    d = tc(c, a),
                    f = tc(c, l),
                    m = u * p - h * h,
                    g = (p * d - h * f) / m,
                    y = (u * f - h * d) / m,
                    _ = r.z * (1 - g - y) + i.z * g + o.z * y;
                  if (isFinite(_)) return _;
                }
                return 1 / 0;
              }
              {
                let t = 1 / 0;
                for (const n of e) t = Math.min(t, n.z);
                return t;
              }
            }
            function nc(t) {
              const e = new o(t[0], t[1]);
              return (e.z = t[2]), e;
            }
            function rc(t, e, n, r, i, o, s, a) {
              const l = s * i.getElevationAt(t, e, !0, !0),
                c = 0 !== o[0],
                u = c
                  ? 0 === o[1]
                    ? s * (o[0] / 7 - 450)
                    : s *
                      (function (t, e, n) {
                        const r = Math.floor(e[0] / 8),
                          i = Math.floor(e[1] / 8),
                          o = 10 * (e[0] - 8 * r),
                          s = 10 * (e[1] - 8 * i),
                          a = t.getElevationAt(r, i, !0, !0),
                          l = t.getMeterToDEM(n),
                          c = Math.floor(0.5 * (o * l - 1)),
                          u = Math.floor(0.5 * (s * l - 1)),
                          h = t.tileCoordToPixel(r, i),
                          p = 2 * c + 1,
                          d = 2 * u + 1,
                          f = (function (t, e, n, r, i) {
                            return [
                              t.getElevationAtPixel(e, n, !0),
                              t.getElevationAtPixel(e + i, n, !0),
                              t.getElevationAtPixel(e, n + i, !0),
                              t.getElevationAtPixel(e + r, n + i, !0),
                            ];
                          })(t, h.x - c, h.y - u, p, d),
                          m = Math.abs(f[0] - f[1]),
                          g = Math.abs(f[2] - f[3]),
                          y = Math.abs(f[0] - f[2]) + Math.abs(f[1] - f[3]),
                          _ = Math.min(0.25, (0.5 * l * (m + g)) / p),
                          v = Math.min(0.25, (0.5 * l * y) / d);
                        return a + Math.max(_ * o, v * s);
                      })(i, o, a)
                  : l;
              return {
                base: l + (0 === n) ? -1 : n,
                top: c ? Math.max(u + r, l + n + 2) : l + r,
              };
            }
            const ic = Co(
                [
                  { name: "a_pos_normal", components: 2, type: "Int16" },
                  { name: "a_data", components: 4, type: "Uint8" },
                  { name: "a_linesofar", components: 1, type: "Float32" },
                ],
                4
              ),
              { members: oc } = ic,
              sc = Co([
                { name: "a_uv_x", components: 1, type: "Float32" },
                { name: "a_split_index", components: 1, type: "Float32" },
              ]),
              { members: ac } = sc,
              lc = Gl.VectorTileFeature.types,
              cc = Math.cos((Math.PI / 180) * 37.5);
            class uc {
              constructor(t) {
                (this.zoom = t.zoom),
                  (this.overscaling = t.overscaling),
                  (this.layers = t.layers),
                  (this.layerIds = this.layers.map((t) => t.id)),
                  (this.index = t.index),
                  (this.hasPattern = !1),
                  (this.patternFeatures = []),
                  (this.lineClipsArray = []),
                  (this.gradients = {}),
                  this.layers.forEach((t) => {
                    this.gradients[t.id] = {};
                  }),
                  (this.layoutVertexArray = new ko()),
                  (this.layoutVertexArray2 = new Io()),
                  (this.indexArray = new Zo()),
                  (this.programConfigurations = new Is(t.layers, t.zoom)),
                  (this.segments = new Zs()),
                  (this.maxLineLength = 0),
                  (this.stateDependentLayerIds = this.layers
                    .filter((t) => t.isStateDependent())
                    .map((t) => t.id));
              }
              populate(t, e, n) {
                this.hasPattern = Ol("line", this.layers, e);
                const r = this.layers[0].layout.get("line-sort-key"),
                  i = [];
                for (const {
                  feature: l,
                  id: c,
                  index: u,
                  sourceLayerIndex: h,
                } of t) {
                  const t = this.layers[0]._featureFilter.needGeometry,
                    e = Ws(l, t);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new ao(this.zoom),
                      e,
                      n
                    )
                  )
                    continue;
                  const o = r ? r.evaluate(e, {}, n) : void 0,
                    s = {
                      id: c,
                      properties: l.properties,
                      type: l.type,
                      sourceLayerIndex: h,
                      index: u,
                      geometry: t ? e.geometry : Gs(l),
                      patterns: {},
                      sortKey: o,
                    };
                  i.push(s);
                }
                r && i.sort((t, e) => t.sortKey - e.sortKey);
                const { lineAtlas: o, featureIndex: s } = e,
                  a = this.addConstantDashes(o);
                for (const l of i) {
                  const { geometry: r, index: i, sourceLayerIndex: c } = l;
                  if ((a && this.addFeatureDashes(l, o), this.hasPattern)) {
                    const t = kl("line", this.layers, l, this.zoom, e);
                    this.patternFeatures.push(t);
                  } else this.addFeature(l, r, i, n, o.positions);
                  s.insert(t[i].feature, r, i, c, this.index);
                }
              }
              addConstantDashes(t) {
                let e = !1;
                for (const n of this.layers) {
                  const r = n.paint.get("line-dasharray").value,
                    i = n.layout.get("line-cap").value;
                  if ("constant" !== r.kind || "constant" !== i.kind) e = !0;
                  else {
                    const e = i.value,
                      n = r.value;
                    if (!n) continue;
                    t.addDash(n.from, e),
                      t.addDash(n.to, e),
                      n.other && t.addDash(n.other, e);
                  }
                }
                return e;
              }
              addFeatureDashes(t, e) {
                const n = this.zoom;
                for (const r of this.layers) {
                  const i = r.paint.get("line-dasharray").value,
                    o = r.layout.get("line-cap").value;
                  if ("constant" === i.kind && "constant" === o.kind) continue;
                  let s, a, l, c, u, h;
                  if ("constant" === i.kind) {
                    const t = i.value;
                    if (!t) continue;
                    (s = t.other || t.to), (a = t.to), (l = t.from);
                  } else
                    (s = i.evaluate({ zoom: n - 1 }, t)),
                      (a = i.evaluate({ zoom: n }, t)),
                      (l = i.evaluate({ zoom: n + 1 }, t));
                  "constant" === o.kind
                    ? (c = u = h = o.value)
                    : ((c = o.evaluate({ zoom: n - 1 }, t)),
                      (u = o.evaluate({ zoom: n }, t)),
                      (h = o.evaluate({ zoom: n + 1 }, t))),
                    e.addDash(s, c),
                    e.addDash(a, u),
                    e.addDash(l, h);
                  const p = e.getKey(s, c),
                    d = e.getKey(a, u),
                    f = e.getKey(l, h);
                  t.patterns[r.id] = { min: p, mid: d, max: f };
                }
              }
              update(t, e, n) {
                this.stateDependentLayers.length &&
                  this.programConfigurations.updatePaintArrays(
                    t,
                    e,
                    this.stateDependentLayers,
                    n
                  );
              }
              addFeatures(t, e, n) {
                for (const r of this.patternFeatures)
                  this.addFeature(r, r.geometry, r.index, e, n);
              }
              isEmpty() {
                return 0 === this.layoutVertexArray.length;
              }
              uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
              }
              upload(t) {
                this.uploaded ||
                  (0 !== this.layoutVertexArray2.length &&
                    (this.layoutVertexBuffer2 = t.createVertexBuffer(
                      this.layoutVertexArray2,
                      ac
                    )),
                  (this.layoutVertexBuffer = t.createVertexBuffer(
                    this.layoutVertexArray,
                    oc
                  )),
                  (this.indexBuffer = t.createIndexBuffer(this.indexArray))),
                  this.programConfigurations.upload(t),
                  (this.uploaded = !0);
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy());
              }
              lineFeatureClips(t) {
                if (
                  t.properties &&
                  t.properties.hasOwnProperty("mapbox_clip_start") &&
                  t.properties.hasOwnProperty("mapbox_clip_end")
                )
                  return {
                    start: +t.properties.mapbox_clip_start,
                    end: +t.properties.mapbox_clip_end,
                  };
              }
              addFeature(t, e, n, r, i) {
                const o = this.layers[0].layout,
                  s = o.get("line-join").evaluate(t, {}),
                  a = o.get("line-cap").evaluate(t, {}),
                  l = o.get("line-miter-limit"),
                  c = o.get("line-round-limit");
                this.lineClips = this.lineFeatureClips(t);
                for (const u of e) this.addLine(u, t, s, a, l, c);
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  t,
                  n,
                  i,
                  r
                );
              }
              addLine(t, e, n, r, i, o) {
                if (
                  ((this.distance = 0),
                  (this.scaledDistance = 0),
                  (this.totalDistance = 0),
                  (this.lineSoFar = 0),
                  this.lineClips)
                ) {
                  this.lineClipsArray.push(this.lineClips);
                  for (let e = 0; e < t.length - 1; e++)
                    this.totalDistance += t[e].dist(t[e + 1]);
                  this.updateScaledDistance(),
                    (this.maxLineLength = Math.max(
                      this.maxLineLength,
                      this.totalDistance
                    ));
                }
                const s = "Polygon" === lc[e.type];
                let a = t.length;
                for (; a >= 2 && t[a - 1].equals(t[a - 2]); ) a--;
                let l = 0;
                for (; l < a - 1 && t[l].equals(t[l + 1]); ) l++;
                if (a < (s ? 3 : 2)) return;
                "bevel" === n && (i = 1.05);
                const c =
                    this.overscaling <= 16
                      ? 122880 / (512 * this.overscaling)
                      : 0,
                  u = this.segments.prepareSegment(
                    10 * a,
                    this.layoutVertexArray,
                    this.indexArray
                  );
                let h, p, d, f, m;
                (this.e1 = this.e2 = -1),
                  s && ((h = t[a - 2]), (m = t[l].sub(h)._unit()._perp()));
                for (let g = l; g < a; g++) {
                  if (
                    ((d = g === a - 1 ? (s ? t[l + 1] : void 0) : t[g + 1]),
                    d && t[g].equals(d))
                  )
                    continue;
                  m && (f = m),
                    h && (p = h),
                    (h = t[g]),
                    (m = d ? d.sub(h)._unit()._perp() : f),
                    (f = f || m);
                  let e = f.add(m);
                  (0 === e.x && 0 === e.y) || e._unit();
                  const y = f.x * m.x + f.y * m.y,
                    _ = e.x * m.x + e.y * m.y,
                    v = 0 !== _ ? 1 / _ : 1 / 0,
                    b = 2 * Math.sqrt(2 - 2 * _),
                    x = _ < cc && p && d,
                    w = f.x * m.y - f.y * m.x > 0;
                  if (x && g > l) {
                    const t = h.dist(p);
                    if (t > 2 * c) {
                      const e = h.sub(
                        h
                          .sub(p)
                          ._mult(c / t)
                          ._round()
                      );
                      this.updateDistance(p, e),
                        this.addCurrentVertex(e, f, 0, 0, u),
                        (p = e);
                    }
                  }
                  const S = p && d;
                  let E = S ? n : s ? "butt" : r;
                  if (
                    (S &&
                      "round" === E &&
                      (v < o ? (E = "miter") : v <= 2 && (E = "fakeround")),
                    "miter" === E && v > i && (E = "bevel"),
                    "bevel" === E &&
                      (v > 2 && (E = "flipbevel"), v < i && (E = "miter")),
                    p && this.updateDistance(p, h),
                    "miter" === E)
                  )
                    e._mult(v), this.addCurrentVertex(h, e, 0, 0, u);
                  else if ("flipbevel" === E) {
                    if (v > 100) e = m.mult(-1);
                    else {
                      const t = (v * f.add(m).mag()) / f.sub(m).mag();
                      e._perp()._mult(t * (w ? -1 : 1));
                    }
                    this.addCurrentVertex(h, e, 0, 0, u),
                      this.addCurrentVertex(h, e.mult(-1), 0, 0, u);
                  } else if ("bevel" === E || "fakeround" === E) {
                    const t = -Math.sqrt(v * v - 1),
                      e = w ? t : 0,
                      n = w ? 0 : t;
                    if (
                      (p && this.addCurrentVertex(h, f, e, n, u),
                      "fakeround" === E)
                    ) {
                      const t = Math.round((180 * b) / Math.PI / 20);
                      for (let e = 1; e < t; e++) {
                        let n = e / t;
                        if (0.5 !== n) {
                          const t = n - 0.5;
                          n +=
                            n *
                            t *
                            (n - 1) *
                            ((1.0904 +
                              y * (y * (3.55645 - 1.43519 * y) - 3.2452)) *
                              t *
                              t +
                              (0.848013 + y * (0.215638 * y - 1.06021)));
                        }
                        const r = m
                          .sub(f)
                          ._mult(n)
                          ._add(f)
                          ._unit()
                          ._mult(w ? -1 : 1);
                        this.addHalfVertex(h, r.x, r.y, !1, w, 0, u);
                      }
                    }
                    d && this.addCurrentVertex(h, m, -e, -n, u);
                  } else if ("butt" === E) this.addCurrentVertex(h, e, 0, 0, u);
                  else if ("square" === E) {
                    const t = p ? 1 : -1;
                    p || this.addCurrentVertex(h, e, t, t, u),
                      this.addCurrentVertex(h, e, 0, 0, u),
                      p && this.addCurrentVertex(h, e, t, t, u);
                  } else
                    "round" === E &&
                      (p &&
                        (this.addCurrentVertex(h, f, 0, 0, u),
                        this.addCurrentVertex(h, f, 1, 1, u, !0)),
                      d &&
                        (this.addCurrentVertex(h, m, -1, -1, u, !0),
                        this.addCurrentVertex(h, m, 0, 0, u)));
                  if (x && g < a - 1) {
                    const t = h.dist(d);
                    if (t > 2 * c) {
                      const e = h.add(
                        d
                          .sub(h)
                          ._mult(c / t)
                          ._round()
                      );
                      this.updateDistance(h, e),
                        this.addCurrentVertex(e, m, 0, 0, u),
                        (h = e);
                    }
                  }
                }
              }
              addCurrentVertex(t, e, n, r, i, o = !1) {
                const s = e.y * r - e.x,
                  a = -e.y - e.x * r;
                this.addHalfVertex(
                  t,
                  e.x + e.y * n,
                  e.y - e.x * n,
                  o,
                  !1,
                  n,
                  i
                ),
                  this.addHalfVertex(t, s, a, o, !0, -r, i);
              }
              addHalfVertex({ x: t, y: e }, n, r, i, o, s, a) {
                this.layoutVertexArray.emplaceBack(
                  (t << 1) + (i ? 1 : 0),
                  (e << 1) + (o ? 1 : 0),
                  Math.round(63 * n) + 128,
                  Math.round(63 * r) + 128,
                  1 + (0 === s ? 0 : s < 0 ? -1 : 1),
                  0,
                  this.lineSoFar
                ),
                  this.lineClips &&
                    this.layoutVertexArray2.emplaceBack(
                      this.scaledDistance,
                      this.lineClipsArray.length
                    );
                const l = a.vertexLength++;
                this.e1 >= 0 &&
                  this.e2 >= 0 &&
                  (this.indexArray.emplaceBack(this.e1, this.e2, l),
                  a.primitiveLength++),
                  o ? (this.e2 = l) : (this.e1 = l);
              }
              updateScaledDistance() {
                if (this.lineClips) {
                  const t =
                    this.totalDistance /
                    (this.lineClips.end - this.lineClips.start);
                  (this.scaledDistance = this.distance / this.totalDistance),
                    (this.lineSoFar = t * this.lineClips.start + this.distance);
                } else this.lineSoFar = this.distance;
              }
              updateDistance(t, e) {
                (this.distance += t.dist(e)), this.updateScaledDistance();
              }
            }
            li("LineBucket", uc, { omit: ["layers", "patternFeatures"] });
            const hc = new wo({
              "line-cap": new _o(Nt.layout_line["line-cap"]),
              "line-join": new _o(Nt.layout_line["line-join"]),
              "line-miter-limit": new yo(Nt.layout_line["line-miter-limit"]),
              "line-round-limit": new yo(Nt.layout_line["line-round-limit"]),
              "line-sort-key": new _o(Nt.layout_line["line-sort-key"]),
            });
            var pc = {
              paint: new wo({
                "line-opacity": new _o(Nt.paint_line["line-opacity"]),
                "line-color": new _o(Nt.paint_line["line-color"]),
                "line-translate": new yo(Nt.paint_line["line-translate"]),
                "line-translate-anchor": new yo(
                  Nt.paint_line["line-translate-anchor"]
                ),
                "line-width": new _o(Nt.paint_line["line-width"]),
                "line-gap-width": new _o(Nt.paint_line["line-gap-width"]),
                "line-offset": new _o(Nt.paint_line["line-offset"]),
                "line-blur": new _o(Nt.paint_line["line-blur"]),
                "line-dasharray": new vo(Nt.paint_line["line-dasharray"]),
                "line-pattern": new vo(Nt.paint_line["line-pattern"]),
                "line-gradient": new xo(Nt.paint_line["line-gradient"]),
              }),
              layout: hc,
            };
            const dc = new (class extends _o {
              possiblyEvaluate(t, e) {
                return (
                  (e = new ao(Math.floor(e.zoom), {
                    now: e.now,
                    fadeDuration: e.fadeDuration,
                    zoomHistory: e.zoomHistory,
                    transition: e.transition,
                  })),
                  super.possiblyEvaluate(t, e)
                );
              }
              evaluate(t, e, n, r) {
                return (
                  (e = b({}, e, { zoom: Math.floor(e.zoom) })),
                  super.evaluate(t, e, n, r)
                );
              }
            })(pc.paint.properties["line-width"].specification);
            function fc(t, e) {
              return e > 0 ? e + 2 * t : t;
            }
            dc.useIntegerZoom = !0;
            const mc = Co(
                [
                  { name: "a_pos_offset", components: 4, type: "Int16" },
                  { name: "a_data", components: 4, type: "Uint16" },
                  { name: "a_pixeloffset", components: 4, type: "Int16" },
                ],
                4
              ),
              gc = Co(
                [{ name: "a_projected_pos", components: 3, type: "Float32" }],
                4
              );
            Co([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
            const yc = Co([
                { name: "a_placed", components: 2, type: "Uint8" },
                { name: "a_shift", components: 2, type: "Float32" },
              ]),
              _c = Co([
                { name: "a_size_scale", components: 1, type: "Float32" },
                { name: "a_padding", components: 2, type: "Float32" },
              ]);
            Co([
              { type: "Int16", name: "anchorPointX" },
              { type: "Int16", name: "anchorPointY" },
              { type: "Float32", name: "x1" },
              { type: "Float32", name: "y1" },
              { type: "Float32", name: "x2" },
              { type: "Float32", name: "y2" },
              { type: "Int16", name: "padding" },
              { type: "Uint32", name: "featureIndex" },
              { type: "Uint16", name: "sourceLayerIndex" },
              { type: "Uint16", name: "bucketIndex" },
            ]);
            const vc = Co(
                [
                  { name: "a_pos", components: 2, type: "Int16" },
                  { name: "a_anchor_pos", components: 2, type: "Int16" },
                  { name: "a_extrude", components: 2, type: "Int16" },
                ],
                4
              ),
              bc = Co(
                [
                  { name: "a_pos_2f", components: 2, type: "Float32" },
                  { name: "a_radius", components: 1, type: "Float32" },
                  { name: "a_flags", components: 2, type: "Int16" },
                ],
                4
              );
            Co([{ name: "triangle", components: 3, type: "Uint16" }]),
              Co([
                { type: "Float32", name: "anchorX" },
                { type: "Float32", name: "anchorY" },
                { type: "Uint16", name: "glyphStartIndex" },
                { type: "Uint16", name: "numGlyphs" },
                { type: "Uint32", name: "vertexStartIndex" },
                { type: "Uint32", name: "lineStartIndex" },
                { type: "Uint32", name: "lineLength" },
                { type: "Uint16", name: "segment" },
                { type: "Uint16", name: "lowerSize" },
                { type: "Uint16", name: "upperSize" },
                { type: "Float32", name: "lineOffsetX" },
                { type: "Float32", name: "lineOffsetY" },
                { type: "Uint8", name: "writingMode" },
                { type: "Uint8", name: "placedOrientation" },
                { type: "Uint8", name: "hidden" },
                { type: "Uint32", name: "crossTileID" },
                { type: "Int16", name: "associatedIconIndex" },
                { type: "Uint8", name: "flipState" },
              ]),
              Co([
                { type: "Float32", name: "anchorX" },
                { type: "Float32", name: "anchorY" },
                { type: "Int16", name: "rightJustifiedTextSymbolIndex" },
                { type: "Int16", name: "centerJustifiedTextSymbolIndex" },
                { type: "Int16", name: "leftJustifiedTextSymbolIndex" },
                { type: "Int16", name: "verticalPlacedTextSymbolIndex" },
                { type: "Int16", name: "placedIconSymbolIndex" },
                { type: "Int16", name: "verticalPlacedIconSymbolIndex" },
                { type: "Uint16", name: "key" },
                { type: "Uint16", name: "textBoxStartIndex" },
                { type: "Uint16", name: "textBoxEndIndex" },
                { type: "Uint16", name: "verticalTextBoxStartIndex" },
                { type: "Uint16", name: "verticalTextBoxEndIndex" },
                { type: "Uint16", name: "iconBoxStartIndex" },
                { type: "Uint16", name: "iconBoxEndIndex" },
                { type: "Uint16", name: "verticalIconBoxStartIndex" },
                { type: "Uint16", name: "verticalIconBoxEndIndex" },
                { type: "Uint16", name: "featureIndex" },
                { type: "Uint16", name: "numHorizontalGlyphVertices" },
                { type: "Uint16", name: "numVerticalGlyphVertices" },
                { type: "Uint16", name: "numIconVertices" },
                { type: "Uint16", name: "numVerticalIconVertices" },
                { type: "Uint16", name: "useRuntimeCollisionCircles" },
                { type: "Uint32", name: "crossTileID" },
                { type: "Float32", components: 2, name: "textOffset" },
                { type: "Float32", name: "collisionCircleDiameter" },
              ]),
              Co([{ type: "Float32", name: "offsetX" }]),
              Co([
                { type: "Int16", name: "x" },
                { type: "Int16", name: "y" },
                { type: "Int16", name: "tileUnitDistanceFromAnchor" },
              ]);
            var xc = 24;
            const wc = 128;
            function Sc(t, e) {
              const { expression: n } = e;
              if ("constant" === n.kind)
                return {
                  kind: "constant",
                  layoutSize: n.evaluate(new ao(t + 1)),
                };
              if ("source" === n.kind) return { kind: "source" };
              {
                const { zoomStops: e, interpolationType: r } = n;
                let i = 0;
                for (; i < e.length && e[i] <= t; ) i++;
                i = Math.max(0, i - 1);
                let o = i;
                for (; o < e.length && e[o] < t + 1; ) o++;
                o = Math.min(e.length - 1, o);
                const s = e[i],
                  a = e[o];
                return "composite" === n.kind
                  ? {
                      kind: "composite",
                      minZoom: s,
                      maxZoom: a,
                      interpolationType: r,
                    }
                  : {
                      kind: "camera",
                      minZoom: s,
                      maxZoom: a,
                      minSize: n.evaluate(new ao(s)),
                      maxSize: n.evaluate(new ao(a)),
                      interpolationType: r,
                    };
              }
            }
            function Ec(
              t,
              { uSize: e, uSizeT: n },
              { lowerSize: r, upperSize: i }
            ) {
              return "source" === t.kind
                ? r / wc
                : "composite" === t.kind
                ? rn(r / wc, i / wc, n)
                : e;
            }
            function Tc(t, e) {
              let n = 0,
                r = 0;
              if ("constant" === t.kind) r = t.layoutSize;
              else if ("source" !== t.kind) {
                const { interpolationType: i, minZoom: o, maxZoom: s } = t,
                  a = i ? g(Sn.interpolationFactor(i, e, o, s), 0, 1) : 0;
                "camera" === t.kind
                  ? (r = rn(t.minSize, t.maxSize, a))
                  : (n = a);
              }
              return { uSizeT: n, uSize: r };
            }
            var Ac = Object.freeze({
              __proto__: null,
              getSizeData: Sc,
              evaluateSizeForFeature: Ec,
              evaluateSizeForZoom: Tc,
              SIZE_PACK_FACTOR: wc,
            });
            function Cc(t, e, n) {
              return (
                t.sections.forEach((t) => {
                  t.text = (function (t, e, n) {
                    const r = e.layout.get("text-transform").evaluate(n, {});
                    return (
                      "uppercase" === r
                        ? (t = t.toLocaleUpperCase())
                        : "lowercase" === r && (t = t.toLocaleLowerCase()),
                      so.applyArabicShaping && (t = so.applyArabicShaping(t)),
                      t
                    );
                  })(t.text, e, n);
                }),
                t
              );
            }
            const Pc = {
              "!": "\ufe15",
              "#": "\uff03",
              $: "\uff04",
              "%": "\uff05",
              "&": "\uff06",
              "(": "\ufe35",
              ")": "\ufe36",
              "*": "\uff0a",
              "+": "\uff0b",
              ",": "\ufe10",
              "-": "\ufe32",
              ".": "\u30fb",
              "/": "\uff0f",
              ":": "\ufe13",
              ";": "\ufe14",
              "<": "\ufe3f",
              "=": "\uff1d",
              ">": "\ufe40",
              "?": "\ufe16",
              "@": "\uff20",
              "[": "\ufe47",
              "\\": "\uff3c",
              "]": "\ufe48",
              "^": "\uff3e",
              _: "\ufe33",
              "`": "\uff40",
              "{": "\ufe37",
              "|": "\u2015",
              "}": "\ufe38",
              "~": "\uff5e",
              "\xa2": "\uffe0",
              "\xa3": "\uffe1",
              "\xa5": "\uffe5",
              "\xa6": "\uffe4",
              "\xac": "\uffe2",
              "\xaf": "\uffe3",
              "\u2013": "\ufe32",
              "\u2014": "\ufe31",
              "\u2018": "\ufe43",
              "\u2019": "\ufe44",
              "\u201c": "\ufe41",
              "\u201d": "\ufe42",
              "\u2026": "\ufe19",
              "\u2027": "\u30fb",
              "\u20a9": "\uffe6",
              "\u3001": "\ufe11",
              "\u3002": "\ufe12",
              "\u3008": "\ufe3f",
              "\u3009": "\ufe40",
              "\u300a": "\ufe3d",
              "\u300b": "\ufe3e",
              "\u300c": "\ufe41",
              "\u300d": "\ufe42",
              "\u300e": "\ufe43",
              "\u300f": "\ufe44",
              "\u3010": "\ufe3b",
              "\u3011": "\ufe3c",
              "\u3014": "\ufe39",
              "\u3015": "\ufe3a",
              "\u3016": "\ufe17",
              "\u3017": "\ufe18",
              "\uff01": "\ufe15",
              "\uff08": "\ufe35",
              "\uff09": "\ufe36",
              "\uff0c": "\ufe10",
              "\uff0d": "\ufe32",
              "\uff0e": "\u30fb",
              "\uff1a": "\ufe13",
              "\uff1b": "\ufe14",
              "\uff1c": "\ufe3f",
              "\uff1e": "\ufe40",
              "\uff1f": "\ufe16",
              "\uff3b": "\ufe47",
              "\uff3d": "\ufe48",
              "\uff3f": "\ufe33",
              "\uff5b": "\ufe37",
              "\uff5c": "\u2015",
              "\uff5d": "\ufe38",
              "\uff5f": "\ufe35",
              "\uff60": "\ufe36",
              "\uff61": "\ufe12",
              "\uff62": "\ufe41",
              "\uff63": "\ufe42",
            };
            function Mc(t) {
              return (
                "\ufe36" === t ||
                "\ufe48" === t ||
                "\ufe38" === t ||
                "\ufe44" === t ||
                "\ufe42" === t ||
                "\ufe3e" === t ||
                "\ufe3c" === t ||
                "\ufe3a" === t ||
                "\ufe18" === t ||
                "\ufe40" === t ||
                "\ufe10" === t ||
                "\ufe13" === t ||
                "\ufe14" === t ||
                "\uff40" === t ||
                "\uffe3" === t ||
                "\ufe11" === t ||
                "\ufe12" === t
              );
            }
            function Oc(t) {
              return (
                "\ufe35" === t ||
                "\ufe47" === t ||
                "\ufe37" === t ||
                "\ufe43" === t ||
                "\ufe41" === t ||
                "\ufe3d" === t ||
                "\ufe3b" === t ||
                "\ufe39" === t ||
                "\ufe17" === t ||
                "\ufe3f" === t
              );
            }
            var kc = function (t, e, n, r, i) {
                var o,
                  s,
                  a = 8 * i - r - 1,
                  l = (1 << a) - 1,
                  c = l >> 1,
                  u = -7,
                  h = n ? i - 1 : 0,
                  p = n ? -1 : 1,
                  d = t[e + h];
                for (
                  h += p, o = d & ((1 << -u) - 1), d >>= -u, u += a;
                  u > 0;
                  o = 256 * o + t[e + h], h += p, u -= 8
                );
                for (
                  s = o & ((1 << -u) - 1), o >>= -u, u += r;
                  u > 0;
                  s = 256 * s + t[e + h], h += p, u -= 8
                );
                if (0 === o) o = 1 - c;
                else {
                  if (o === l) return s ? NaN : (1 / 0) * (d ? -1 : 1);
                  (s += Math.pow(2, r)), (o -= c);
                }
                return (d ? -1 : 1) * s * Math.pow(2, o - r);
              },
              Ic = function (t, e, n, r, i, o) {
                var s,
                  a,
                  l,
                  c = 8 * o - i - 1,
                  u = (1 << c) - 1,
                  h = u >> 1,
                  p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                  d = r ? 0 : o - 1,
                  f = r ? 1 : -1,
                  m = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0;
                for (
                  e = Math.abs(e),
                    isNaN(e) || e === 1 / 0
                      ? ((a = isNaN(e) ? 1 : 0), (s = u))
                      : ((s = Math.floor(Math.log(e) / Math.LN2)),
                        e * (l = Math.pow(2, -s)) < 1 && (s--, (l *= 2)),
                        (e += s + h >= 1 ? p / l : p * Math.pow(2, 1 - h)) *
                          l >=
                          2 && (s++, (l /= 2)),
                        s + h >= u
                          ? ((a = 0), (s = u))
                          : s + h >= 1
                          ? ((a = (e * l - 1) * Math.pow(2, i)), (s += h))
                          : ((a = e * Math.pow(2, h - 1) * Math.pow(2, i)),
                            (s = 0)));
                  i >= 8;
                  t[n + d] = 255 & a, d += f, a /= 256, i -= 8
                );
                for (
                  s = (s << i) | a, c += i;
                  c > 0;
                  t[n + d] = 255 & s, d += f, s /= 256, c -= 8
                );
                t[n + d - f] |= 128 * m;
              },
              Dc = zc;
            function zc(t) {
              (this.buf =
                ArrayBuffer.isView && ArrayBuffer.isView(t)
                  ? t
                  : new Uint8Array(t || 0)),
                (this.pos = 0),
                (this.type = 0),
                (this.length = this.buf.length);
            }
            (zc.Varint = 0), (zc.Fixed64 = 1), (zc.Bytes = 2), (zc.Fixed32 = 5);
            var Rc = 4294967296,
              Lc = 1 / Rc,
              Fc =
                "undefined" == typeof TextDecoder
                  ? null
                  : new TextDecoder("utf8");
            function Bc(t) {
              return t.type === zc.Bytes ? t.readVarint() + t.pos : t.pos + 1;
            }
            function Nc(t, e, n) {
              return n
                ? 4294967296 * e + (t >>> 0)
                : 4294967296 * (e >>> 0) + (t >>> 0);
            }
            function jc(t, e, n) {
              var r =
                e <= 16383
                  ? 1
                  : e <= 2097151
                  ? 2
                  : e <= 268435455
                  ? 3
                  : Math.floor(Math.log(e) / (7 * Math.LN2));
              n.realloc(r);
              for (var i = n.pos - 1; i >= t; i--) n.buf[i + r] = n.buf[i];
            }
            function Uc(t, e) {
              for (var n = 0; n < t.length; n++) e.writeVarint(t[n]);
            }
            function Zc(t, e) {
              for (var n = 0; n < t.length; n++) e.writeSVarint(t[n]);
            }
            function Vc(t, e) {
              for (var n = 0; n < t.length; n++) e.writeFloat(t[n]);
            }
            function qc(t, e) {
              for (var n = 0; n < t.length; n++) e.writeDouble(t[n]);
            }
            function $c(t, e) {
              for (var n = 0; n < t.length; n++) e.writeBoolean(t[n]);
            }
            function Gc(t, e) {
              for (var n = 0; n < t.length; n++) e.writeFixed32(t[n]);
            }
            function Wc(t, e) {
              for (var n = 0; n < t.length; n++) e.writeSFixed32(t[n]);
            }
            function Hc(t, e) {
              for (var n = 0; n < t.length; n++) e.writeFixed64(t[n]);
            }
            function Xc(t, e) {
              for (var n = 0; n < t.length; n++) e.writeSFixed64(t[n]);
            }
            function Kc(t, e) {
              return (
                (t[e] | (t[e + 1] << 8) | (t[e + 2] << 16)) +
                16777216 * t[e + 3]
              );
            }
            function Yc(t, e, n) {
              (t[n] = e),
                (t[n + 1] = e >>> 8),
                (t[n + 2] = e >>> 16),
                (t[n + 3] = e >>> 24);
            }
            function Qc(t, e) {
              return (
                (t[e] | (t[e + 1] << 8) | (t[e + 2] << 16)) + (t[e + 3] << 24)
              );
            }
            function Jc(t, e, n) {
              (e.glyphs = []), 1 === t && n.readMessage(tu, e);
            }
            function tu(t, e, n) {
              if (3 === t) {
                const {
                  id: t,
                  bitmap: r,
                  width: i,
                  height: o,
                  left: s,
                  top: a,
                  advance: l,
                } = n.readMessage(eu, {});
                e.glyphs.push({
                  id: t,
                  bitmap: new Va({ width: i + 6, height: o + 6 }, r),
                  metrics: { width: i, height: o, left: s, top: a, advance: l },
                });
              } else 4 === t ? (e.ascender = n.readSVarint()) : 5 === t && (e.descender = n.readSVarint());
            }
            function eu(t, e, n) {
              1 === t
                ? (e.id = n.readVarint())
                : 2 === t
                ? (e.bitmap = n.readBytes())
                : 3 === t
                ? (e.width = n.readVarint())
                : 4 === t
                ? (e.height = n.readVarint())
                : 5 === t
                ? (e.left = n.readSVarint())
                : 6 === t
                ? (e.top = n.readSVarint())
                : 7 === t && (e.advance = n.readVarint());
            }
            function nu(t) {
              let e = 0,
                n = 0;
              for (const s of t) (e += s.w * s.h), (n = Math.max(n, s.w));
              t.sort((t, e) => e.h - t.h);
              const r = [
                {
                  x: 0,
                  y: 0,
                  w: Math.max(Math.ceil(Math.sqrt(e / 0.95)), n),
                  h: 1 / 0,
                },
              ];
              let i = 0,
                o = 0;
              for (const s of t)
                for (let t = r.length - 1; t >= 0; t--) {
                  const e = r[t];
                  if (!(s.w > e.w || s.h > e.h)) {
                    if (
                      ((s.x = e.x),
                      (s.y = e.y),
                      (o = Math.max(o, s.y + s.h)),
                      (i = Math.max(i, s.x + s.w)),
                      s.w === e.w && s.h === e.h)
                    ) {
                      const e = r.pop();
                      t < r.length && (r[t] = e);
                    } else
                      s.h === e.h
                        ? ((e.x += s.w), (e.w -= s.w))
                        : s.w === e.w
                        ? ((e.y += s.h), (e.h -= s.h))
                        : (r.push({
                            x: e.x + s.w,
                            y: e.y,
                            w: e.w - s.w,
                            h: s.h,
                          }),
                          (e.y += s.h),
                          (e.h -= s.h));
                    break;
                  }
                }
              return { w: i, h: o, fill: e / (i * o) || 0 };
            }
            zc.prototype = {
              destroy: function () {
                this.buf = null;
              },
              readFields: function (t, e, n) {
                for (n = n || this.length; this.pos < n; ) {
                  var r = this.readVarint(),
                    i = r >> 3,
                    o = this.pos;
                  (this.type = 7 & r),
                    t(i, e, this),
                    this.pos === o && this.skip(r);
                }
                return e;
              },
              readMessage: function (t, e) {
                return this.readFields(t, e, this.readVarint() + this.pos);
              },
              readFixed32: function () {
                var t = Kc(this.buf, this.pos);
                return (this.pos += 4), t;
              },
              readSFixed32: function () {
                var t = Qc(this.buf, this.pos);
                return (this.pos += 4), t;
              },
              readFixed64: function () {
                var t =
                  Kc(this.buf, this.pos) + Kc(this.buf, this.pos + 4) * Rc;
                return (this.pos += 8), t;
              },
              readSFixed64: function () {
                var t =
                  Kc(this.buf, this.pos) + Qc(this.buf, this.pos + 4) * Rc;
                return (this.pos += 8), t;
              },
              readFloat: function () {
                var t = kc(this.buf, this.pos, !0, 23, 4);
                return (this.pos += 4), t;
              },
              readDouble: function () {
                var t = kc(this.buf, this.pos, !0, 52, 8);
                return (this.pos += 8), t;
              },
              readVarint: function (t) {
                var e,
                  n,
                  r = this.buf;
                return (
                  (e = 127 & (n = r[this.pos++])),
                  n < 128
                    ? e
                    : ((e |= (127 & (n = r[this.pos++])) << 7),
                      n < 128
                        ? e
                        : ((e |= (127 & (n = r[this.pos++])) << 14),
                          n < 128
                            ? e
                            : ((e |= (127 & (n = r[this.pos++])) << 21),
                              n < 128
                                ? e
                                : (function (t, e, n) {
                                    var r,
                                      i,
                                      o = n.buf;
                                    if (
                                      ((r = (112 & (i = o[n.pos++])) >> 4),
                                      i < 128)
                                    )
                                      return Nc(t, r, e);
                                    if (
                                      ((r |= (127 & (i = o[n.pos++])) << 3),
                                      i < 128)
                                    )
                                      return Nc(t, r, e);
                                    if (
                                      ((r |= (127 & (i = o[n.pos++])) << 10),
                                      i < 128)
                                    )
                                      return Nc(t, r, e);
                                    if (
                                      ((r |= (127 & (i = o[n.pos++])) << 17),
                                      i < 128)
                                    )
                                      return Nc(t, r, e);
                                    if (
                                      ((r |= (127 & (i = o[n.pos++])) << 24),
                                      i < 128)
                                    )
                                      return Nc(t, r, e);
                                    if (
                                      ((r |= (1 & (i = o[n.pos++])) << 31),
                                      i < 128)
                                    )
                                      return Nc(t, r, e);
                                    throw new Error(
                                      "Expected varint not more than 10 bytes"
                                    );
                                  })(
                                    (e |= (15 & (n = r[this.pos])) << 28),
                                    t,
                                    this
                                  ))))
                );
              },
              readVarint64: function () {
                return this.readVarint(!0);
              },
              readSVarint: function () {
                var t = this.readVarint();
                return t % 2 == 1 ? (t + 1) / -2 : t / 2;
              },
              readBoolean: function () {
                return Boolean(this.readVarint());
              },
              readString: function () {
                var t = this.readVarint() + this.pos,
                  e = this.pos;
                return (
                  (this.pos = t),
                  t - e >= 12 && Fc
                    ? (function (t, e, n) {
                        return Fc.decode(t.subarray(e, n));
                      })(this.buf, e, t)
                    : (function (t, e, n) {
                        for (var r = "", i = e; i < n; ) {
                          var o,
                            s,
                            a,
                            l = t[i],
                            c = null,
                            u = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
                          if (i + u > n) break;
                          1 === u
                            ? l < 128 && (c = l)
                            : 2 === u
                            ? 128 == (192 & (o = t[i + 1])) &&
                              (c = ((31 & l) << 6) | (63 & o)) <= 127 &&
                              (c = null)
                            : 3 === u
                            ? ((s = t[i + 2]),
                              128 == (192 & (o = t[i + 1])) &&
                                128 == (192 & s) &&
                                ((c =
                                  ((15 & l) << 12) |
                                  ((63 & o) << 6) |
                                  (63 & s)) <= 2047 ||
                                  (c >= 55296 && c <= 57343)) &&
                                (c = null))
                            : 4 === u &&
                              ((s = t[i + 2]),
                              (a = t[i + 3]),
                              128 == (192 & (o = t[i + 1])) &&
                                128 == (192 & s) &&
                                128 == (192 & a) &&
                                ((c =
                                  ((15 & l) << 18) |
                                  ((63 & o) << 12) |
                                  ((63 & s) << 6) |
                                  (63 & a)) <= 65535 ||
                                  c >= 1114112) &&
                                (c = null)),
                            null === c
                              ? ((c = 65533), (u = 1))
                              : c > 65535 &&
                                ((c -= 65536),
                                (r += String.fromCharCode(
                                  ((c >>> 10) & 1023) | 55296
                                )),
                                (c = 56320 | (1023 & c))),
                            (r += String.fromCharCode(c)),
                            (i += u);
                        }
                        return r;
                      })(this.buf, e, t)
                );
              },
              readBytes: function () {
                var t = this.readVarint() + this.pos,
                  e = this.buf.subarray(this.pos, t);
                return (this.pos = t), e;
              },
              readPackedVarint: function (t, e) {
                if (this.type !== zc.Bytes) return t.push(this.readVarint(e));
                var n = Bc(this);
                for (t = t || []; this.pos < n; ) t.push(this.readVarint(e));
                return t;
              },
              readPackedSVarint: function (t) {
                if (this.type !== zc.Bytes) return t.push(this.readSVarint());
                var e = Bc(this);
                for (t = t || []; this.pos < e; ) t.push(this.readSVarint());
                return t;
              },
              readPackedBoolean: function (t) {
                if (this.type !== zc.Bytes) return t.push(this.readBoolean());
                var e = Bc(this);
                for (t = t || []; this.pos < e; ) t.push(this.readBoolean());
                return t;
              },
              readPackedFloat: function (t) {
                if (this.type !== zc.Bytes) return t.push(this.readFloat());
                var e = Bc(this);
                for (t = t || []; this.pos < e; ) t.push(this.readFloat());
                return t;
              },
              readPackedDouble: function (t) {
                if (this.type !== zc.Bytes) return t.push(this.readDouble());
                var e = Bc(this);
                for (t = t || []; this.pos < e; ) t.push(this.readDouble());
                return t;
              },
              readPackedFixed32: function (t) {
                if (this.type !== zc.Bytes) return t.push(this.readFixed32());
                var e = Bc(this);
                for (t = t || []; this.pos < e; ) t.push(this.readFixed32());
                return t;
              },
              readPackedSFixed32: function (t) {
                if (this.type !== zc.Bytes) return t.push(this.readSFixed32());
                var e = Bc(this);
                for (t = t || []; this.pos < e; ) t.push(this.readSFixed32());
                return t;
              },
              readPackedFixed64: function (t) {
                if (this.type !== zc.Bytes) return t.push(this.readFixed64());
                var e = Bc(this);
                for (t = t || []; this.pos < e; ) t.push(this.readFixed64());
                return t;
              },
              readPackedSFixed64: function (t) {
                if (this.type !== zc.Bytes) return t.push(this.readSFixed64());
                var e = Bc(this);
                for (t = t || []; this.pos < e; ) t.push(this.readSFixed64());
                return t;
              },
              skip: function (t) {
                var e = 7 & t;
                if (e === zc.Varint) for (; this.buf[this.pos++] > 127; );
                else if (e === zc.Bytes)
                  this.pos = this.readVarint() + this.pos;
                else if (e === zc.Fixed32) this.pos += 4;
                else {
                  if (e !== zc.Fixed64)
                    throw new Error("Unimplemented type: " + e);
                  this.pos += 8;
                }
              },
              writeTag: function (t, e) {
                this.writeVarint((t << 3) | e);
              },
              realloc: function (t) {
                for (var e = this.length || 16; e < this.pos + t; ) e *= 2;
                if (e !== this.length) {
                  var n = new Uint8Array(e);
                  n.set(this.buf), (this.buf = n), (this.length = e);
                }
              },
              finish: function () {
                return (
                  (this.length = this.pos),
                  (this.pos = 0),
                  this.buf.subarray(0, this.length)
                );
              },
              writeFixed32: function (t) {
                this.realloc(4), Yc(this.buf, t, this.pos), (this.pos += 4);
              },
              writeSFixed32: function (t) {
                this.realloc(4), Yc(this.buf, t, this.pos), (this.pos += 4);
              },
              writeFixed64: function (t) {
                this.realloc(8),
                  Yc(this.buf, -1 & t, this.pos),
                  Yc(this.buf, Math.floor(t * Lc), this.pos + 4),
                  (this.pos += 8);
              },
              writeSFixed64: function (t) {
                this.realloc(8),
                  Yc(this.buf, -1 & t, this.pos),
                  Yc(this.buf, Math.floor(t * Lc), this.pos + 4),
                  (this.pos += 8);
              },
              writeVarint: function (t) {
                (t = +t || 0) > 268435455 || t < 0
                  ? (function (t, e) {
                      var n, r;
                      if (
                        (t >= 0
                          ? ((n = t % 4294967296 | 0),
                            (r = (t / 4294967296) | 0))
                          : ((r = ~(-t / 4294967296)),
                            4294967295 ^ (n = ~(-t % 4294967296))
                              ? (n = (n + 1) | 0)
                              : ((n = 0), (r = (r + 1) | 0))),
                        t >= 0x10000000000000000 || t < -0x10000000000000000)
                      )
                        throw new Error(
                          "Given varint doesn't fit into 10 bytes"
                        );
                      e.realloc(10),
                        (function (t, e, n) {
                          (n.buf[n.pos++] = (127 & t) | 128),
                            (t >>>= 7),
                            (n.buf[n.pos++] = (127 & t) | 128),
                            (t >>>= 7),
                            (n.buf[n.pos++] = (127 & t) | 128),
                            (t >>>= 7),
                            (n.buf[n.pos++] = (127 & t) | 128),
                            (n.buf[n.pos] = 127 & (t >>>= 7));
                        })(n, 0, e),
                        (function (t, e) {
                          var n = (7 & t) << 4;
                          (e.buf[e.pos++] |= n | ((t >>>= 3) ? 128 : 0)),
                            t &&
                              ((e.buf[e.pos++] =
                                (127 & t) | ((t >>>= 7) ? 128 : 0)),
                              t &&
                                ((e.buf[e.pos++] =
                                  (127 & t) | ((t >>>= 7) ? 128 : 0)),
                                t &&
                                  ((e.buf[e.pos++] =
                                    (127 & t) | ((t >>>= 7) ? 128 : 0)),
                                  t &&
                                    ((e.buf[e.pos++] =
                                      (127 & t) | ((t >>>= 7) ? 128 : 0)),
                                    t && (e.buf[e.pos++] = 127 & t)))));
                        })(r, e);
                    })(t, this)
                  : (this.realloc(4),
                    (this.buf[this.pos++] = (127 & t) | (t > 127 ? 128 : 0)),
                    t <= 127 ||
                      ((this.buf[this.pos++] =
                        (127 & (t >>>= 7)) | (t > 127 ? 128 : 0)),
                      t <= 127 ||
                        ((this.buf[this.pos++] =
                          (127 & (t >>>= 7)) | (t > 127 ? 128 : 0)),
                        t <= 127 || (this.buf[this.pos++] = (t >>> 7) & 127))));
              },
              writeSVarint: function (t) {
                this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);
              },
              writeBoolean: function (t) {
                this.writeVarint(Boolean(t));
              },
              writeString: function (t) {
                (t = String(t)), this.realloc(4 * t.length), this.pos++;
                var e = this.pos;
                this.pos = (function (t, e, n) {
                  for (var r, i, o = 0; o < e.length; o++) {
                    if ((r = e.charCodeAt(o)) > 55295 && r < 57344) {
                      if (!i) {
                        r > 56319 || o + 1 === e.length
                          ? ((t[n++] = 239), (t[n++] = 191), (t[n++] = 189))
                          : (i = r);
                        continue;
                      }
                      if (r < 56320) {
                        (t[n++] = 239), (t[n++] = 191), (t[n++] = 189), (i = r);
                        continue;
                      }
                      (r = ((i - 55296) << 10) | (r - 56320) | 65536),
                        (i = null);
                    } else
                      i &&
                        ((t[n++] = 239),
                        (t[n++] = 191),
                        (t[n++] = 189),
                        (i = null));
                    r < 128
                      ? (t[n++] = r)
                      : (r < 2048
                          ? (t[n++] = (r >> 6) | 192)
                          : (r < 65536
                              ? (t[n++] = (r >> 12) | 224)
                              : ((t[n++] = (r >> 18) | 240),
                                (t[n++] = ((r >> 12) & 63) | 128)),
                            (t[n++] = ((r >> 6) & 63) | 128)),
                        (t[n++] = (63 & r) | 128));
                  }
                  return n;
                })(this.buf, t, this.pos);
                var n = this.pos - e;
                n >= 128 && jc(e, n, this),
                  (this.pos = e - 1),
                  this.writeVarint(n),
                  (this.pos += n);
              },
              writeFloat: function (t) {
                this.realloc(4),
                  Ic(this.buf, t, this.pos, !0, 23, 4),
                  (this.pos += 4);
              },
              writeDouble: function (t) {
                this.realloc(8),
                  Ic(this.buf, t, this.pos, !0, 52, 8),
                  (this.pos += 8);
              },
              writeBytes: function (t) {
                var e = t.length;
                this.writeVarint(e), this.realloc(e);
                for (var n = 0; n < e; n++) this.buf[this.pos++] = t[n];
              },
              writeRawMessage: function (t, e) {
                this.pos++;
                var n = this.pos;
                t(e, this);
                var r = this.pos - n;
                r >= 128 && jc(n, r, this),
                  (this.pos = n - 1),
                  this.writeVarint(r),
                  (this.pos += r);
              },
              writeMessage: function (t, e, n) {
                this.writeTag(t, zc.Bytes), this.writeRawMessage(e, n);
              },
              writePackedVarint: function (t, e) {
                e.length && this.writeMessage(t, Uc, e);
              },
              writePackedSVarint: function (t, e) {
                e.length && this.writeMessage(t, Zc, e);
              },
              writePackedBoolean: function (t, e) {
                e.length && this.writeMessage(t, $c, e);
              },
              writePackedFloat: function (t, e) {
                e.length && this.writeMessage(t, Vc, e);
              },
              writePackedDouble: function (t, e) {
                e.length && this.writeMessage(t, qc, e);
              },
              writePackedFixed32: function (t, e) {
                e.length && this.writeMessage(t, Gc, e);
              },
              writePackedSFixed32: function (t, e) {
                e.length && this.writeMessage(t, Wc, e);
              },
              writePackedFixed64: function (t, e) {
                e.length && this.writeMessage(t, Hc, e);
              },
              writePackedSFixed64: function (t, e) {
                e.length && this.writeMessage(t, Xc, e);
              },
              writeBytesField: function (t, e) {
                this.writeTag(t, zc.Bytes), this.writeBytes(e);
              },
              writeFixed32Field: function (t, e) {
                this.writeTag(t, zc.Fixed32), this.writeFixed32(e);
              },
              writeSFixed32Field: function (t, e) {
                this.writeTag(t, zc.Fixed32), this.writeSFixed32(e);
              },
              writeFixed64Field: function (t, e) {
                this.writeTag(t, zc.Fixed64), this.writeFixed64(e);
              },
              writeSFixed64Field: function (t, e) {
                this.writeTag(t, zc.Fixed64), this.writeSFixed64(e);
              },
              writeVarintField: function (t, e) {
                this.writeTag(t, zc.Varint), this.writeVarint(e);
              },
              writeSVarintField: function (t, e) {
                this.writeTag(t, zc.Varint), this.writeSVarint(e);
              },
              writeStringField: function (t, e) {
                this.writeTag(t, zc.Bytes), this.writeString(e);
              },
              writeFloatField: function (t, e) {
                this.writeTag(t, zc.Fixed32), this.writeFloat(e);
              },
              writeDoubleField: function (t, e) {
                this.writeTag(t, zc.Fixed64), this.writeDouble(e);
              },
              writeBooleanField: function (t, e) {
                this.writeVarintField(t, Boolean(e));
              },
            };
            class ru {
              constructor(
                t,
                {
                  pixelRatio: e,
                  version: n,
                  stretchX: r,
                  stretchY: i,
                  content: o,
                }
              ) {
                (this.paddedRect = t),
                  (this.pixelRatio = e),
                  (this.stretchX = r),
                  (this.stretchY = i),
                  (this.content = o),
                  (this.version = n);
              }
              get tl() {
                return [this.paddedRect.x + 1, this.paddedRect.y + 1];
              }
              get br() {
                return [
                  this.paddedRect.x + this.paddedRect.w - 1,
                  this.paddedRect.y + this.paddedRect.h - 1,
                ];
              }
              get displaySize() {
                return [
                  (this.paddedRect.w - 2) / this.pixelRatio,
                  (this.paddedRect.h - 2) / this.pixelRatio,
                ];
              }
            }
            class iu {
              constructor(t, e) {
                const n = {},
                  r = {};
                this.haveRenderCallbacks = [];
                const i = [];
                this.addImages(t, n, i), this.addImages(e, r, i);
                const { w: o, h: s } = nu(i),
                  a = new qa({ width: o || 1, height: s || 1 });
                for (const l in t) {
                  const e = t[l],
                    r = n[l].paddedRect;
                  qa.copy(
                    e.data,
                    a,
                    { x: 0, y: 0 },
                    { x: r.x + 1, y: r.y + 1 },
                    e.data
                  );
                }
                for (const l in e) {
                  const t = e[l],
                    n = r[l].paddedRect,
                    i = n.x + 1,
                    o = n.y + 1,
                    s = t.data.width,
                    c = t.data.height;
                  qa.copy(t.data, a, { x: 0, y: 0 }, { x: i, y: o }, t.data),
                    qa.copy(
                      t.data,
                      a,
                      { x: 0, y: c - 1 },
                      { x: i, y: o - 1 },
                      { width: s, height: 1 }
                    ),
                    qa.copy(
                      t.data,
                      a,
                      { x: 0, y: 0 },
                      { x: i, y: o + c },
                      { width: s, height: 1 }
                    ),
                    qa.copy(
                      t.data,
                      a,
                      { x: s - 1, y: 0 },
                      { x: i - 1, y: o },
                      { width: 1, height: c }
                    ),
                    qa.copy(
                      t.data,
                      a,
                      { x: 0, y: 0 },
                      { x: i + s, y: o },
                      { width: 1, height: c }
                    );
                }
                (this.image = a),
                  (this.iconPositions = n),
                  (this.patternPositions = r);
              }
              addImages(t, e, n) {
                for (const r in t) {
                  const i = t[r],
                    o = {
                      x: 0,
                      y: 0,
                      w: i.data.width + 2,
                      h: i.data.height + 2,
                    };
                  n.push(o),
                    (e[r] = new ru(o, i)),
                    i.hasRenderCallback && this.haveRenderCallbacks.push(r);
                }
              }
              patchUpdatedImages(t, e) {
                t.dispatchRenderCallbacks(this.haveRenderCallbacks);
                for (const n in t.updatedImages)
                  this.patchUpdatedImage(
                    this.iconPositions[n],
                    t.getImage(n),
                    e
                  ),
                    this.patchUpdatedImage(
                      this.patternPositions[n],
                      t.getImage(n),
                      e
                    );
              }
              patchUpdatedImage(t, e, n) {
                if (!t || !e) return;
                if (t.version === e.version) return;
                t.version = e.version;
                const [r, i] = t.tl;
                n.update(e.data, void 0, { x: r, y: i });
              }
            }
            li("ImagePosition", ru), li("ImageAtlas", iu);
            const ou = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
            class su {
              constructor() {
                (this.scale = 1),
                  (this.fontStack = ""),
                  (this.imageName = null);
              }
              static forText(t, e) {
                const n = new su();
                return (n.scale = t || 1), (n.fontStack = e), n;
              }
              static forImage(t) {
                const e = new su();
                return (e.imageName = t), e;
              }
            }
            class au {
              constructor() {
                (this.text = ""),
                  (this.sectionIndex = []),
                  (this.sections = []),
                  (this.imageSectionID = null);
              }
              static fromFeature(t, e) {
                const n = new au();
                for (let r = 0; r < t.sections.length; r++) {
                  const i = t.sections[r];
                  i.image ? n.addImageSection(i) : n.addTextSection(i, e);
                }
                return n;
              }
              length() {
                return this.text.length;
              }
              getSection(t) {
                return this.sections[this.sectionIndex[t]];
              }
              getSections() {
                return this.sections;
              }
              getSectionIndex(t) {
                return this.sectionIndex[t];
              }
              getCharCode(t) {
                return this.text.charCodeAt(t);
              }
              verticalizePunctuation(t) {
                this.text = (function (t, e) {
                  let n = "";
                  for (let r = 0; r < t.length; r++) {
                    const i = t.charCodeAt(r + 1) || null,
                      o = t.charCodeAt(r - 1) || null;
                    n +=
                      (!e &&
                        ((i && $i(i) && !Pc[t[r + 1]]) ||
                          (o && $i(o) && !Pc[t[r - 1]]))) ||
                      !Pc[t[r]]
                        ? t[r]
                        : Pc[t[r]];
                  }
                  return n;
                })(this.text, t);
              }
              trim() {
                let t = 0;
                for (
                  let n = 0;
                  n < this.text.length && cu[this.text.charCodeAt(n)];
                  n++
                )
                  t++;
                let e = this.text.length;
                for (
                  let n = this.text.length - 1;
                  n >= 0 && n >= t && cu[this.text.charCodeAt(n)];
                  n--
                )
                  e--;
                (this.text = this.text.substring(t, e)),
                  (this.sectionIndex = this.sectionIndex.slice(t, e));
              }
              substring(t, e) {
                const n = new au();
                return (
                  (n.text = this.text.substring(t, e)),
                  (n.sectionIndex = this.sectionIndex.slice(t, e)),
                  (n.sections = this.sections),
                  n
                );
              }
              toString() {
                return this.text;
              }
              getMaxScale() {
                return this.sectionIndex.reduce(
                  (t, e) => Math.max(t, this.sections[e].scale),
                  0
                );
              }
              addTextSection(t, e) {
                (this.text += t.text),
                  this.sections.push(su.forText(t.scale, t.fontStack || e));
                const n = this.sections.length - 1;
                for (let r = 0; r < t.text.length; ++r)
                  this.sectionIndex.push(n);
              }
              addImageSection(t) {
                const e = t.image ? t.image.name : "";
                if (0 === e.length)
                  return void I(
                    "Can't add FormattedSection with an empty image."
                  );
                const n = this.getNextImageSectionCharCode();
                n
                  ? ((this.text += String.fromCharCode(n)),
                    this.sections.push(su.forImage(e)),
                    this.sectionIndex.push(this.sections.length - 1))
                  : I("Reached maximum number of images 6401");
              }
              getNextImageSectionCharCode() {
                return this.imageSectionID
                  ? this.imageSectionID >= 63743
                    ? null
                    : ++this.imageSectionID
                  : ((this.imageSectionID = 57344), this.imageSectionID);
              }
            }
            function lu(t, e, n, r, i, o, s, a, l, c, u, h, p, d, f, m) {
              const g = au.fromFeature(t, i);
              let y;
              h === ou.vertical && g.verticalizePunctuation(p);
              const {
                processBidirectionalText: _,
                processStyledBidirectionalText: v,
              } = so;
              if (_ && 1 === g.sections.length) {
                y = [];
                const t = _(g.toString(), gu(g, c, o, e, r, d, f));
                for (const e of t) {
                  const t = new au();
                  (t.text = e), (t.sections = g.sections);
                  for (let n = 0; n < e.length; n++) t.sectionIndex.push(0);
                  y.push(t);
                }
              } else if (v) {
                y = [];
                const t = v(g.text, g.sectionIndex, gu(g, c, o, e, r, d, f));
                for (const e of t) {
                  const t = new au();
                  (t.text = e[0]),
                    (t.sectionIndex = e[1]),
                    (t.sections = g.sections),
                    y.push(t);
                }
              } else
                y = (function (t, e) {
                  const n = [],
                    r = t.text;
                  let i = 0;
                  for (const o of e) n.push(t.substring(i, o)), (i = o);
                  return i < r.length && n.push(t.substring(i, r.length)), n;
                })(g, gu(g, c, o, e, r, d, f));
              const b = [],
                x = {
                  positionedLines: b,
                  text: g.toString(),
                  top: u[1],
                  bottom: u[1],
                  left: u[0],
                  right: u[0],
                  writingMode: h,
                  iconsInText: !1,
                  verticalizable: !1,
                  hasBaseline: !1,
                };
              return (
                (function (t, e, n, r, i, o, s, a, l, c, u, h) {
                  let p = 0,
                    d = 0,
                    f = 0;
                  const m = "right" === a ? 1 : "left" === a ? 0 : 0.5;
                  let g = !1;
                  for (const w of i) {
                    const t = w.getSections();
                    for (const n of t) {
                      if (n.imageName) continue;
                      const t = e[n.fontStack];
                      if (
                        t &&
                        ((g = void 0 !== t.ascender && void 0 !== t.descender),
                        !g)
                      )
                        break;
                    }
                    if (!g) break;
                  }
                  let y = 0;
                  for (const w of i) {
                    w.trim();
                    const i = w.getMaxScale(),
                      s = (i - 1) * xc,
                      a = { positionedGlyphs: [], lineOffset: 0 };
                    t.positionedLines[y] = a;
                    const v = a.positionedGlyphs;
                    let b = 0;
                    if (!w.length()) {
                      (d += o), ++y;
                      continue;
                    }
                    let x = 0,
                      S = 0;
                    for (let o = 0; o < w.length(); o++) {
                      const s = w.getSection(o),
                        a = w.getSectionIndex(o),
                        f = w.getCharCode(o);
                      let m = s.scale,
                        y = null,
                        E = null,
                        T = null,
                        A = xc,
                        C = 0;
                      const P = !(
                        l === ou.horizontal ||
                        (!u && !qi(f)) ||
                        (u &&
                          (cu[f] ||
                            ((_ = f),
                            fi(_) || mi(_) || gi(_) || Ri(_) || Ni(_))))
                      );
                      if (s.imageName) {
                        const e = r[s.imageName];
                        if (!e) continue;
                        (T = s.imageName),
                          (t.iconsInText = t.iconsInText || !0),
                          (E = e.paddedRect);
                        const n = e.displaySize;
                        (m = (m * xc) / h),
                          (y = {
                            width: n[0],
                            height: n[1],
                            left: 1,
                            top: -3,
                            advance: P ? n[1] : n[0],
                            localGlyph: !1,
                          }),
                          (C = g ? -y.height * m : i * xc - 17 - n[1] * m),
                          (A = y.advance);
                        const o = (P ? n[0] : n[1]) * m - xc * i;
                        o > 0 && o > b && (b = o);
                      } else {
                        const t = n[s.fontStack];
                        if (!t) continue;
                        t[f] && (E = t[f]);
                        const r = e[s.fontStack];
                        if (!r) continue;
                        const o = r.glyphs[f];
                        if (!o) continue;
                        if (((y = o.metrics), (A = 8203 !== f ? xc : 0), g)) {
                          const t =
                              void 0 !== r.ascender ? Math.abs(r.ascender) : 0,
                            e =
                              void 0 !== r.descender
                                ? Math.abs(r.descender)
                                : 0,
                            n = (t + e) * m;
                          x < n && ((x = n), (S = ((t - e) / 2) * m)),
                            (C = -t * m);
                        } else C = (i - m) * xc - 17;
                      }
                      P
                        ? ((t.verticalizable = !0),
                          v.push({
                            glyph: f,
                            imageName: T,
                            x: p,
                            y: d + C,
                            vertical: P,
                            scale: m,
                            localGlyph: y.localGlyph,
                            fontStack: s.fontStack,
                            sectionIndex: a,
                            metrics: y,
                            rect: E,
                          }),
                          (p += A * m + c))
                        : (v.push({
                            glyph: f,
                            imageName: T,
                            x: p,
                            y: d + C,
                            vertical: P,
                            scale: m,
                            localGlyph: y.localGlyph,
                            fontStack: s.fontStack,
                            sectionIndex: a,
                            metrics: y,
                            rect: E,
                          }),
                          (p += y.advance * m + c));
                    }
                    0 !== v.length &&
                      ((f = Math.max(p - c, f)),
                      g ? _u(v, m, b, S, (o * i) / 2) : _u(v, m, b, 0, o / 2)),
                      (p = 0);
                    const E = o * i + b;
                    (a.lineOffset = Math.max(b, s)), (d += E), ++y;
                  }
                  var _;
                  const v = d,
                    { horizontalAlign: b, verticalAlign: x } = yu(s);
                  (function (t, e, n, r, i, o) {
                    const s = (e - n) * i,
                      a = -o * r;
                    for (const l of t)
                      for (const t of l.positionedGlyphs)
                        (t.x += s), (t.y += a);
                  })(t.positionedLines, m, b, x, f, v),
                    (t.top += -x * v),
                    (t.bottom = t.top + v),
                    (t.left += -b * f),
                    (t.right = t.left + f),
                    (t.hasBaseline = g);
                })(x, e, n, r, y, s, a, l, h, c, p, m),
                !(function (t) {
                  for (const e of t)
                    if (0 !== e.positionedGlyphs.length) return !1;
                  return !0;
                })(b) && x
              );
            }
            const cu = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 },
              uu = {
                10: !0,
                32: !0,
                38: !0,
                40: !0,
                41: !0,
                43: !0,
                45: !0,
                47: !0,
                173: !0,
                183: !0,
                8203: !0,
                8208: !0,
                8211: !0,
                8231: !0,
              };
            function hu(t, e, n, r, i, o) {
              if (e.imageName) {
                const t = r[e.imageName];
                return t ? (t.displaySize[0] * e.scale * xc) / o + i : 0;
              }
              {
                const r = n[e.fontStack],
                  o = r && r.glyphs[t];
                return o ? o.metrics.advance * e.scale + i : 0;
              }
            }
            function pu(t, e, n, r) {
              const i = Math.pow(t - e, 2);
              return r ? (t < e ? i / 2 : 2 * i) : i + Math.abs(n) * n;
            }
            function du(t, e, n) {
              let r = 0;
              return (
                10 === t && (r -= 1e4),
                n && (r += 150),
                (40 !== t && 65288 !== t) || (r += 50),
                (41 !== e && 65289 !== e) || (r += 50),
                r
              );
            }
            function fu(t, e, n, r, i, o) {
              let s = null,
                a = pu(e, n, i, o);
              for (const l of r) {
                const t = pu(e - l.x, n, i, o) + l.badness;
                t <= a && ((s = l), (a = t));
              }
              return { index: t, x: e, priorBreak: s, badness: a };
            }
            function mu(t) {
              return t ? mu(t.priorBreak).concat(t.index) : [];
            }
            function gu(t, e, n, r, i, o, s) {
              if ("point" !== o) return [];
              if (!t) return [];
              const a = [],
                l = (function (t, e, n, r, i, o) {
                  let s = 0;
                  for (let a = 0; a < t.length(); a++) {
                    const n = t.getSection(a);
                    s += hu(t.getCharCode(a), n, r, i, e, o);
                  }
                  return s / Math.max(1, Math.ceil(s / n));
                })(t, e, n, r, i, s),
                c = t.text.indexOf("\u200b") >= 0;
              let u = 0;
              for (let p = 0; p < t.length(); p++) {
                const n = t.getSection(p),
                  o = t.getCharCode(p);
                if (
                  (cu[o] || (u += hu(o, n, r, i, e, s)), p < t.length() - 1)
                ) {
                  const e = !(
                    (h = o) < 11904 ||
                    !(
                      Ei(h) ||
                      Si(h) ||
                      Fi(h) ||
                      zi(h) ||
                      Pi(h) ||
                      yi(h) ||
                      Ti(h) ||
                      bi(h) ||
                      Mi(h) ||
                      Oi(h) ||
                      Ci(h) ||
                      ji(h) ||
                      xi(h) ||
                      vi(h) ||
                      _i(h) ||
                      Ai(h) ||
                      wi(h) ||
                      Li(h) ||
                      Ii(h) ||
                      ki(h)
                    )
                  );
                  (uu[o] || e || n.imageName) &&
                    a.push(
                      fu(
                        p + 1,
                        u,
                        l,
                        a,
                        du(o, t.getCharCode(p + 1), e && c),
                        !1
                      )
                    );
                }
              }
              var h;
              return mu(fu(t.length(), u, l, a, 0, !0));
            }
            function yu(t) {
              let e = 0.5,
                n = 0.5;
              switch (t) {
                case "right":
                case "top-right":
                case "bottom-right":
                  e = 1;
                  break;
                case "left":
                case "top-left":
                case "bottom-left":
                  e = 0;
              }
              switch (t) {
                case "bottom":
                case "bottom-right":
                case "bottom-left":
                  n = 1;
                  break;
                case "top":
                case "top-right":
                case "top-left":
                  n = 0;
              }
              return { horizontalAlign: e, verticalAlign: n };
            }
            function _u(t, e, n, r, i) {
              if (!(e || n || r || i)) return;
              const o = t.length - 1,
                s = t[o],
                a = (s.x + s.metrics.advance * s.scale) * e;
              for (let l = 0; l <= o; l++) (t[l].x -= a), (t[l].y += n + r + i);
            }
            function vu(t, e, n) {
              const { horizontalAlign: r, verticalAlign: i } = yu(n),
                o = e[0] - t.displaySize[0] * r,
                s = e[1] - t.displaySize[1] * i;
              return {
                image: t,
                top: s,
                bottom: s + t.displaySize[1],
                left: o,
                right: o + t.displaySize[0],
              };
            }
            function bu(t, e, n, r, i, o) {
              const s = t.image;
              let a;
              if (s.content) {
                const t = s.content,
                  e = s.pixelRatio || 1;
                a = [
                  t[0] / e,
                  t[1] / e,
                  s.displaySize[0] - t[2] / e,
                  s.displaySize[1] - t[3] / e,
                ];
              }
              const l = e.left * o,
                c = e.right * o;
              let u, h, p, d;
              "width" === n || "both" === n
                ? ((d = i[0] + l - r[3]), (h = i[0] + c + r[1]))
                : ((d = i[0] + (l + c - s.displaySize[0]) / 2),
                  (h = d + s.displaySize[0]));
              const f = e.top * o,
                m = e.bottom * o;
              return (
                "height" === n || "both" === n
                  ? ((u = i[1] + f - r[0]), (p = i[1] + m + r[2]))
                  : ((u = i[1] + (f + m - s.displaySize[1]) / 2),
                    (p = u + s.displaySize[1])),
                {
                  image: s,
                  top: u,
                  right: h,
                  bottom: p,
                  left: d,
                  collisionPadding: a,
                }
              );
            }
            class xu extends o {
              constructor(t, e, n, r) {
                super(t, e),
                  (this.angle = n),
                  void 0 !== r && (this.segment = r);
              }
              clone() {
                return new xu(this.x, this.y, this.angle, this.segment);
              }
            }
            function wu(t, e, n, r, i) {
              if (void 0 === e.segment) return !0;
              let o = e,
                s = e.segment + 1,
                a = 0;
              for (; a > -n / 2; ) {
                if ((s--, s < 0)) return !1;
                (a -= t[s].dist(o)), (o = t[s]);
              }
              (a += t[s].dist(t[s + 1])), s++;
              const l = [];
              let c = 0;
              for (; a < n / 2; ) {
                const e = t[s],
                  n = t[s + 1];
                if (!n) return !1;
                let o = t[s - 1].angleTo(e) - e.angleTo(n);
                for (
                  o = Math.abs(((o + 3 * Math.PI) % (2 * Math.PI)) - Math.PI),
                    l.push({ distance: a, angleDelta: o }),
                    c += o;
                  a - l[0].distance > r;

                )
                  c -= l.shift().angleDelta;
                if (c > i) return !1;
                s++, (a += e.dist(n));
              }
              return !0;
            }
            function Su(t) {
              let e = 0;
              for (let n = 0; n < t.length - 1; n++) e += t[n].dist(t[n + 1]);
              return e;
            }
            function Eu(t, e, n) {
              return t ? 0.6 * e * n : 0;
            }
            function Tu(t, e) {
              return Math.max(
                t ? t.right - t.left : 0,
                e ? e.right - e.left : 0
              );
            }
            function Au(t, e, n, r, i, o) {
              const s = Eu(n, i, o),
                a = Tu(n, r) * o;
              let l = 0;
              const c = Su(t) / 2;
              for (let u = 0; u < t.length - 1; u++) {
                const n = t[u],
                  r = t[u + 1],
                  i = n.dist(r);
                if (l + i > c) {
                  const o = (c - l) / i,
                    h = rn(n.x, r.x, o),
                    p = rn(n.y, r.y, o),
                    d = new xu(h, p, r.angleTo(n), u);
                  return !s || wu(t, d, a, s, e) ? d : void 0;
                }
                l += i;
              }
            }
            function Cu(t, e, n, r, i, o, s, a, l) {
              const c = Eu(r, o, s),
                u = Tu(r, i),
                h = u * s,
                p =
                  0 === t[0].x || t[0].x === l || 0 === t[0].y || t[0].y === l;
              return (
                e - h < e / 4 && (e = h + e / 4),
                Pu(
                  t,
                  p ? ((e / 2) * a) % e : ((u / 2 + 2 * o) * s * a) % e,
                  e,
                  c,
                  n,
                  h,
                  p,
                  !1,
                  l
                )
              );
            }
            function Pu(t, e, n, r, i, o, s, a, l) {
              const c = o / 2,
                u = Su(t);
              let h = 0,
                p = e - n,
                d = [];
              for (let f = 0; f < t.length - 1; f++) {
                const e = t[f],
                  s = t[f + 1],
                  a = e.dist(s),
                  m = s.angleTo(e);
                for (; p + n < h + a; ) {
                  p += n;
                  const g = (p - h) / a,
                    y = rn(e.x, s.x, g),
                    _ = rn(e.y, s.y, g);
                  if (
                    y >= 0 &&
                    y < l &&
                    _ >= 0 &&
                    _ < l &&
                    p - c >= 0 &&
                    p + c <= u
                  ) {
                    const e = new xu(y, _, m, f);
                    e._round(), (r && !wu(t, e, o, r, i)) || d.push(e);
                  }
                }
                h += a;
              }
              return (
                a || d.length || s || (d = Pu(t, h / 2, n, r, i, o, s, !0, l)),
                d
              );
            }
            function Mu(t, e, n, r, i) {
              const s = [];
              for (let a = 0; a < t.length; a++) {
                const l = t[a];
                let c;
                for (let t = 0; t < l.length - 1; t++) {
                  let a = l[t],
                    u = l[t + 1];
                  (a.x < e && u.x < e) ||
                    (a.x < e
                      ? (a = new o(
                          e,
                          a.y + ((e - a.x) / (u.x - a.x)) * (u.y - a.y)
                        )._round())
                      : u.x < e &&
                        (u = new o(
                          e,
                          a.y + ((e - a.x) / (u.x - a.x)) * (u.y - a.y)
                        )._round()),
                    (a.y < n && u.y < n) ||
                      (a.y < n
                        ? (a = new o(
                            a.x + ((n - a.y) / (u.y - a.y)) * (u.x - a.x),
                            n
                          )._round())
                        : u.y < n &&
                          (u = new o(
                            a.x + ((n - a.y) / (u.y - a.y)) * (u.x - a.x),
                            n
                          )._round()),
                      (a.x >= r && u.x >= r) ||
                        (a.x >= r
                          ? (a = new o(
                              r,
                              a.y + ((r - a.x) / (u.x - a.x)) * (u.y - a.y)
                            )._round())
                          : u.x >= r &&
                            (u = new o(
                              r,
                              a.y + ((r - a.x) / (u.x - a.x)) * (u.y - a.y)
                            )._round()),
                        (a.y >= i && u.y >= i) ||
                          (a.y >= i
                            ? (a = new o(
                                a.x + ((i - a.y) / (u.y - a.y)) * (u.x - a.x),
                                i
                              )._round())
                            : u.y >= i &&
                              (u = new o(
                                a.x + ((i - a.y) / (u.y - a.y)) * (u.x - a.x),
                                i
                              )._round()),
                          (c && a.equals(c[c.length - 1])) ||
                            ((c = [a]), s.push(c)),
                          c.push(u)))));
                }
              }
              return s;
            }
            li("Anchor", xu);
            var Ou = Du,
              ku = Du,
              Iu = 1e20;
            function Du(t, e, n, r, i, o) {
              (this.fontSize = t || 24),
                (this.buffer = void 0 === e ? 3 : e),
                (this.cutoff = r || 0.25),
                (this.fontFamily = i || "sans-serif"),
                (this.fontWeight = o || "normal"),
                (this.radius = n || 8);
              var s = (this.size = this.fontSize + 2 * this.buffer),
                a = s + 2 * this.buffer;
              (this.canvas = document.createElement("canvas")),
                (this.canvas.width = this.canvas.height = s),
                (this.ctx = this.canvas.getContext("2d")),
                (this.ctx.font =
                  this.fontWeight +
                  " " +
                  this.fontSize +
                  "px " +
                  this.fontFamily),
                (this.ctx.textAlign = "left"),
                (this.ctx.fillStyle = "black"),
                (this.gridOuter = new Float64Array(a * a)),
                (this.gridInner = new Float64Array(a * a)),
                (this.f = new Float64Array(a)),
                (this.z = new Float64Array(a + 1)),
                (this.v = new Uint16Array(a)),
                (this.useMetrics =
                  void 0 !== this.ctx.measureText("A").actualBoundingBoxLeft),
                (this.middle = Math.round(
                  (s / 2) *
                    (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1)
                ));
            }
            function zu(t, e, n, r, i, o) {
              for (var s = 0; s < e; s++) Ru(t, s, e, n, r, i, o);
              for (var a = 0; a < n; a++) Ru(t, a * e, 1, e, r, i, o);
            }
            function Ru(t, e, n, r, i, o, s) {
              var a, l, c, u;
              for (o[0] = 0, s[0] = -Iu, s[1] = Iu, a = 0; a < r; a++)
                i[a] = t[e + a * n];
              for (a = 1, l = 0, c = 0; a < r; a++) {
                do {
                  c = (i[a] - i[(u = o[l])] + a * a - u * u) / (a - u) / 2;
                } while (c <= s[l] && --l > -1);
                (o[++l] = a), (s[l] = c), (s[l + 1] = Iu);
              }
              for (a = 0, l = 0; a < r; a++) {
                for (; s[l + 1] < a; ) l++;
                t[e + a * n] = i[(u = o[l])] + (a - u) * (a - u);
              }
            }
            (Du.prototype._draw = function (t, e) {
              var n,
                r,
                i,
                o,
                s,
                a,
                l,
                c,
                u,
                h = this.ctx.measureText(t),
                p = h.width,
                d = 2 * this.buffer;
              e && this.useMetrics
                ? ((s = Math.floor(h.actualBoundingBoxAscent)),
                  (c = this.buffer + Math.ceil(h.actualBoundingBoxAscent)),
                  (a = this.buffer),
                  (l = this.buffer),
                  (n =
                    (r = Math.min(
                      this.size,
                      Math.ceil(
                        h.actualBoundingBoxRight - h.actualBoundingBoxLeft
                      )
                    )) + d),
                  (i =
                    (o = Math.min(
                      this.size - a,
                      Math.ceil(
                        h.actualBoundingBoxAscent + h.actualBoundingBoxDescent
                      )
                    )) + d),
                  (this.ctx.textBaseline = "alphabetic"))
                : ((n = r = this.size),
                  (i = o = this.size),
                  (s = (19 * this.fontSize) / 24),
                  (a = l = 0),
                  (c = this.middle),
                  (this.ctx.textBaseline = "middle")),
                r &&
                  o &&
                  (this.ctx.clearRect(l, a, r, o),
                  this.ctx.fillText(t, this.buffer, c),
                  (u = this.ctx.getImageData(l, a, r, o)));
              var f = new Uint8ClampedArray(n * i);
              return (
                (function (t, e, n, r, i, o, s) {
                  o.fill(Iu, 0, e * n), s.fill(0, 0, e * n);
                  for (var a = (e - r) / 2, l = 0; l < i; l++)
                    for (var c = 0; c < r; c++) {
                      var u = (l + a) * e + c + a,
                        h = t.data[4 * (l * r + c) + 3] / 255;
                      if (1 === h) (o[u] = 0), (s[u] = Iu);
                      else if (0 === h) (o[u] = Iu), (s[u] = 0);
                      else {
                        var p = Math.max(0, 0.5 - h),
                          d = Math.max(0, h - 0.5);
                        (o[u] = p * p), (s[u] = d * d);
                      }
                    }
                })(u, n, i, r, o, this.gridOuter, this.gridInner),
                zu(this.gridOuter, n, i, this.f, this.v, this.z),
                zu(this.gridInner, n, i, this.f, this.v, this.z),
                (function (t, e, n, r, i, o, s) {
                  for (var a = 0; a < e * n; a++) {
                    var l = Math.sqrt(r[a]) - Math.sqrt(i[a]);
                    t[a] = Math.round(255 - 255 * (l / o + s));
                  }
                })(
                  f,
                  n,
                  i,
                  this.gridOuter,
                  this.gridInner,
                  this.radius,
                  this.cutoff
                ),
                {
                  data: f,
                  metrics: {
                    width: r,
                    height: o,
                    sdfWidth: n,
                    sdfHeight: i,
                    top: s,
                    left: 0,
                    advance: p,
                  },
                }
              );
            }),
              (Du.prototype.draw = function (t) {
                return this._draw(t, !1).data;
              }),
              (Du.prototype.drawWithMetrics = function (t) {
                return this._draw(t, !0);
              }),
              (Ou.default = ku);
            const Lu = { none: 0, ideographs: 1, all: 2 };
            class Fu {
              constructor(t, e, n) {
                (this.requestManager = t),
                  (this.localGlyphMode = e),
                  (this.localFontFamily = n),
                  (this.entries = {}),
                  (this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} });
              }
              setURL(t) {
                this.url = t;
              }
              getGlyphs(t, e) {
                const n = [];
                for (const r in t)
                  for (const e of t[r]) n.push({ stack: r, id: e });
                _(
                  n,
                  ({ stack: t, id: e }, n) => {
                    let r = this.entries[t];
                    r ||
                      (r = this.entries[t] =
                        {
                          glyphs: {},
                          requests: {},
                          ranges: {},
                          ascender: void 0,
                          descender: void 0,
                        });
                    let i = r.glyphs[e];
                    if (void 0 !== i)
                      return void n(null, { stack: t, id: e, glyph: i });
                    if (((i = this._tinySDF(r, t, e)), i))
                      return (
                        (r.glyphs[e] = i),
                        void n(null, { stack: t, id: e, glyph: i })
                      );
                    const o = Math.floor(e / 256);
                    if (256 * o > 65535)
                      return void n(new Error("glyphs > 65535 not supported"));
                    if (r.ranges[o])
                      return void n(null, { stack: t, id: e, glyph: i });
                    let s = r.requests[o];
                    s ||
                      ((s = r.requests[o] = []),
                      Fu.loadGlyphRange(
                        t,
                        o,
                        this.url,
                        this.requestManager,
                        (t, e) => {
                          if (e) {
                            (r.ascender = e.ascender),
                              (r.descender = e.descender);
                            for (const t in e.glyphs)
                              this._doesCharSupportLocalGlyph(+t) ||
                                (r.glyphs[+t] = e.glyphs[+t]);
                            r.ranges[o] = !0;
                          }
                          for (const n of s) n(t, e);
                          delete r.requests[o];
                        }
                      )),
                      s.push((r, i) => {
                        r
                          ? n(r)
                          : i &&
                            n(null, {
                              stack: t,
                              id: e,
                              glyph: i.glyphs[e] || null,
                            });
                      });
                  },
                  (t, n) => {
                    if (t) e(t);
                    else if (n) {
                      const t = {};
                      for (const { stack: e, id: r, glyph: i } of n)
                        void 0 === t[e] && (t[e] = {}),
                          void 0 === t[e].glyphs && (t[e].glyphs = {}),
                          (t[e].glyphs[r] = i && {
                            id: i.id,
                            bitmap: i.bitmap.clone(),
                            metrics: i.metrics,
                          }),
                          (t[e].ascender = this.entries[e].ascender),
                          (t[e].descender = this.entries[e].descender);
                      e(null, t);
                    }
                  }
                );
              }
              _doesCharSupportLocalGlyph(t) {
                return (
                  this.localGlyphMode !== Lu.none &&
                  (this.localGlyphMode === Lu.all
                    ? !!this.localFontFamily
                    : (!!this.localFontFamily &&
                        (Oi(t) || Di(t) || xi(t) || wi(t))) ||
                      bi(t))
                );
              }
              _tinySDF(t, e, n) {
                const r = this.localFontFamily;
                if (!r) return;
                if (!this._doesCharSupportLocalGlyph(n)) return;
                let i = t.tinySDF;
                if (!i) {
                  let n = "400";
                  /bold/i.test(e)
                    ? (n = "900")
                    : /medium/i.test(e)
                    ? (n = "500")
                    : /light/i.test(e) && (n = "200"),
                    (i = t.tinySDF = new Fu.TinySDF(48, 6, 16, 0.25, r, n));
                }
                if (this.localGlyphs[i.fontWeight][n])
                  return this.localGlyphs[i.fontWeight][n];
                const { data: o, metrics: s } = i.drawWithMetrics(
                    String.fromCharCode(n)
                  ),
                  {
                    sdfWidth: a,
                    sdfHeight: l,
                    width: c,
                    height: u,
                    left: h,
                    top: p,
                    advance: d,
                  } = s;
                return (this.localGlyphs[i.fontWeight][n] = {
                  id: n,
                  bitmap: new Va({ width: a, height: l }, o),
                  metrics: {
                    width: c / 2,
                    height: u / 2,
                    left: h / 2,
                    top: p / 2 - 27,
                    advance: d / 2,
                    localGlyph: !0,
                  },
                });
              }
            }
            function Bu(t, e, n, r) {
              const i = [],
                s = t.image,
                a = s.pixelRatio,
                l = s.paddedRect.w - 2,
                c = s.paddedRect.h - 2,
                u = t.right - t.left,
                h = t.bottom - t.top,
                p = s.stretchX || [[0, l]],
                d = s.stretchY || [[0, c]],
                f = (t, e) => t + e[1] - e[0],
                m = p.reduce(f, 0),
                g = d.reduce(f, 0),
                y = l - m,
                _ = c - g;
              let v = 0,
                b = m,
                x = 0,
                w = g,
                S = 0,
                E = y,
                T = 0,
                A = _;
              if (s.content && r) {
                const t = s.content;
                (v = Nu(p, 0, t[0])),
                  (x = Nu(d, 0, t[1])),
                  (b = Nu(p, t[0], t[2])),
                  (w = Nu(d, t[1], t[3])),
                  (S = t[0] - v),
                  (T = t[1] - x),
                  (E = t[2] - t[0] - b),
                  (A = t[3] - t[1] - w);
              }
              const C = (r, i, l, c) => {
                const p = Uu(r.stretch - v, b, u, t.left),
                  d = Zu(r.fixed - S, E, r.stretch, m),
                  f = Uu(i.stretch - x, w, h, t.top),
                  y = Zu(i.fixed - T, A, i.stretch, g),
                  _ = Uu(l.stretch - v, b, u, t.left),
                  C = Zu(l.fixed - S, E, l.stretch, m),
                  P = Uu(c.stretch - x, w, h, t.top),
                  M = Zu(c.fixed - T, A, c.stretch, g),
                  O = new o(p, f),
                  k = new o(_, f),
                  I = new o(_, P),
                  D = new o(p, P),
                  z = new o(d / a, y / a),
                  R = new o(C / a, M / a),
                  L = (e * Math.PI) / 180;
                if (L) {
                  const t = Math.sin(L),
                    e = Math.cos(L),
                    n = [e, -t, t, e];
                  O._matMult(n), k._matMult(n), D._matMult(n), I._matMult(n);
                }
                const F = r.stretch + r.fixed,
                  B = i.stretch + i.fixed;
                return {
                  tl: O,
                  tr: k,
                  bl: D,
                  br: I,
                  tex: {
                    x: s.paddedRect.x + 1 + F,
                    y: s.paddedRect.y + 1 + B,
                    w: l.stretch + l.fixed - F,
                    h: c.stretch + c.fixed - B,
                  },
                  writingMode: void 0,
                  glyphOffset: [0, 0],
                  sectionIndex: 0,
                  pixelOffsetTL: z,
                  pixelOffsetBR: R,
                  minFontScaleX: E / a / u,
                  minFontScaleY: A / a / h,
                  isSDF: n,
                };
              };
              if (r && (s.stretchX || s.stretchY)) {
                const t = ju(p, y, m),
                  e = ju(d, _, g);
                for (let n = 0; n < t.length - 1; n++) {
                  const r = t[n],
                    o = t[n + 1];
                  for (let t = 0; t < e.length - 1; t++)
                    i.push(C(r, e[t], o, e[t + 1]));
                }
              } else i.push(C({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l + 1 }, { fixed: 0, stretch: c + 1 }));
              return i;
            }
            function Nu(t, e, n) {
              let r = 0;
              for (const i of t)
                r +=
                  Math.max(e, Math.min(n, i[1])) -
                  Math.max(e, Math.min(n, i[0]));
              return r;
            }
            function ju(t, e, n) {
              const r = [{ fixed: -1, stretch: 0 }];
              for (const [i, o] of t) {
                const t = r[r.length - 1];
                r.push({ fixed: i - t.stretch, stretch: t.stretch }),
                  r.push({
                    fixed: i - t.stretch,
                    stretch: t.stretch + (o - i),
                  });
              }
              return r.push({ fixed: e + 1, stretch: n }), r;
            }
            function Uu(t, e, n, r) {
              return (t / e) * n + r;
            }
            function Zu(t, e, n, r) {
              return t - (e * n) / r;
            }
            function Vu(t, e, n, r) {
              const i = e + t.positionedLines[r].lineOffset;
              return 0 === r
                ? n + i / 2
                : n + (i + (e + t.positionedLines[r - 1].lineOffset)) / 2;
            }
            (Fu.loadGlyphRange = function (t, e, n, r, i) {
              const o = 256 * e,
                s = o + 255,
                a = r.transformRequest(
                  r
                    .normalizeGlyphsURL(n)
                    .replace("{fontstack}", t)
                    .replace("{range}", `${o}-${s}`),
                  wt.Glyphs
                );
              At(a, (t, e) => {
                if (t) i(t);
                else if (e) {
                  const t = {},
                    n = (function (t) {
                      return new Dc(t).readFields(Jc, {});
                    })(e);
                  for (const e of n.glyphs) t[e.id] = e;
                  i(null, {
                    glyphs: t,
                    ascender: n.ascender,
                    descender: n.descender,
                  });
                }
              });
            }),
              (Fu.TinySDF = Ou);
            class qu {
              constructor(t = [], e = $u) {
                if (
                  ((this.data = t),
                  (this.length = this.data.length),
                  (this.compare = e),
                  this.length > 0)
                )
                  for (let n = (this.length >> 1) - 1; n >= 0; n--)
                    this._down(n);
              }
              push(t) {
                this.data.push(t), this.length++, this._up(this.length - 1);
              }
              pop() {
                if (0 === this.length) return;
                const t = this.data[0],
                  e = this.data.pop();
                return (
                  this.length--,
                  this.length > 0 && ((this.data[0] = e), this._down(0)),
                  t
                );
              }
              peek() {
                return this.data[0];
              }
              _up(t) {
                const { data: e, compare: n } = this,
                  r = e[t];
                for (; t > 0; ) {
                  const i = (t - 1) >> 1,
                    o = e[i];
                  if (n(r, o) >= 0) break;
                  (e[t] = o), (t = i);
                }
                e[t] = r;
              }
              _down(t) {
                const { data: e, compare: n } = this,
                  r = this.length >> 1,
                  i = e[t];
                for (; t < r; ) {
                  let r = 1 + (t << 1),
                    o = e[r];
                  const s = r + 1;
                  if (
                    (s < this.length && n(e[s], o) < 0 && ((r = s), (o = e[s])),
                    n(o, i) >= 0)
                  )
                    break;
                  (e[t] = o), (t = r);
                }
                e[t] = i;
              }
            }
            function $u(t, e) {
              return t < e ? -1 : t > e ? 1 : 0;
            }
            function Gu(t, e = 1, n = !1) {
              let r = 1 / 0,
                i = 1 / 0,
                s = -1 / 0,
                a = -1 / 0;
              const l = t[0];
              for (let o = 0; o < l.length; o++) {
                const t = l[o];
                (!o || t.x < r) && (r = t.x),
                  (!o || t.y < i) && (i = t.y),
                  (!o || t.x > s) && (s = t.x),
                  (!o || t.y > a) && (a = t.y);
              }
              const c = Math.min(s - r, a - i);
              let u = c / 2;
              const h = new qu([], Wu);
              if (0 === c) return new o(r, i);
              for (let o = r; o < s; o += c)
                for (let e = i; e < a; e += c)
                  h.push(new Hu(o + u, e + u, u, t));
              let p = (function (t) {
                  let e = 0,
                    n = 0,
                    r = 0;
                  const i = t[0];
                  for (let o = 0, s = i.length, a = s - 1; o < s; a = o++) {
                    const t = i[o],
                      s = i[a],
                      l = t.x * s.y - s.x * t.y;
                    (n += (t.x + s.x) * l),
                      (r += (t.y + s.y) * l),
                      (e += 3 * l);
                  }
                  return new Hu(n / e, r / e, 0, t);
                })(t),
                d = h.length;
              for (; h.length; ) {
                const r = h.pop();
                (r.d > p.d || !p.d) &&
                  ((p = r),
                  n &&
                    console.log(
                      "found best %d after %d probes",
                      Math.round(1e4 * r.d) / 1e4,
                      d
                    )),
                  r.max - p.d <= e ||
                    ((u = r.h / 2),
                    h.push(new Hu(r.p.x - u, r.p.y - u, u, t)),
                    h.push(new Hu(r.p.x + u, r.p.y - u, u, t)),
                    h.push(new Hu(r.p.x - u, r.p.y + u, u, t)),
                    h.push(new Hu(r.p.x + u, r.p.y + u, u, t)),
                    (d += 4));
              }
              return (
                n &&
                  (console.log(`num probes: ${d}`),
                  console.log(`best distance: ${p.d}`)),
                p.p
              );
            }
            function Wu(t, e) {
              return e.max - t.max;
            }
            function Hu(t, e, n, r) {
              (this.p = new o(t, e)),
                (this.h = n),
                (this.d = (function (t, e) {
                  let n = !1,
                    r = 1 / 0;
                  for (let i = 0; i < e.length; i++) {
                    const o = e[i];
                    for (let e = 0, i = o.length, s = i - 1; e < i; s = e++) {
                      const i = o[e],
                        a = o[s];
                      i.y > t.y != a.y > t.y &&
                        t.x < ((a.x - i.x) * (t.y - i.y)) / (a.y - i.y) + i.x &&
                        (n = !n),
                        (r = Math.min(r, ra(t, i, a)));
                    }
                  }
                  return (n ? 1 : -1) * Math.sqrt(r);
                })(this.p, r)),
                (this.max = this.d + this.h * Math.SQRT2);
            }
            const Xu = Number.POSITIVE_INFINITY,
              Ku = Math.sqrt(2);
            function Yu(t, e) {
              return e[1] !== Xu
                ? (function (t, e, n) {
                    let r = 0,
                      i = 0;
                    switch (((e = Math.abs(e)), (n = Math.abs(n)), t)) {
                      case "top-right":
                      case "top-left":
                      case "top":
                        i = n - 7;
                        break;
                      case "bottom-right":
                      case "bottom-left":
                      case "bottom":
                        i = 7 - n;
                    }
                    switch (t) {
                      case "top-right":
                      case "bottom-right":
                      case "right":
                        r = -e;
                        break;
                      case "top-left":
                      case "bottom-left":
                      case "left":
                        r = e;
                    }
                    return [r, i];
                  })(t, e[0], e[1])
                : (function (t, e) {
                    let n = 0,
                      r = 0;
                    e < 0 && (e = 0);
                    const i = e / Ku;
                    switch (t) {
                      case "top-right":
                      case "top-left":
                        r = i - 7;
                        break;
                      case "bottom-right":
                      case "bottom-left":
                        r = 7 - i;
                        break;
                      case "bottom":
                        r = 7 - e;
                        break;
                      case "top":
                        r = e - 7;
                    }
                    switch (t) {
                      case "top-right":
                      case "bottom-right":
                        n = -i;
                        break;
                      case "top-left":
                      case "bottom-left":
                        n = i;
                        break;
                      case "left":
                        n = e;
                        break;
                      case "right":
                        n = -e;
                    }
                    return [n, r];
                  })(t, e[0]);
            }
            function Qu(t, e, n, r, i, o, s, a) {
              t.createArrays(),
                (t.tilePixelRatio = Vs / (512 * t.overscaling)),
                (t.compareText = {}),
                (t.iconsNeedLinear = !1);
              const l = t.layers[0].layout,
                c = t.layers[0]._unevaluatedLayout._values,
                u = {};
              if ("composite" === t.textSizeData.kind) {
                const { minZoom: e, maxZoom: n } = t.textSizeData;
                u.compositeTextSizes = [
                  c["text-size"].possiblyEvaluate(new ao(e), s),
                  c["text-size"].possiblyEvaluate(new ao(n), s),
                ];
              }
              if ("composite" === t.iconSizeData.kind) {
                const { minZoom: e, maxZoom: n } = t.iconSizeData;
                u.compositeIconSizes = [
                  c["icon-size"].possiblyEvaluate(new ao(e), s),
                  c["icon-size"].possiblyEvaluate(new ao(n), s),
                ];
              }
              (u.layoutTextSize = c["text-size"].possiblyEvaluate(
                new ao(a + 1),
                s
              )),
                (u.layoutIconSize = c["icon-size"].possiblyEvaluate(
                  new ao(a + 1),
                  s
                )),
                (u.textMaxSize = c["text-size"].possiblyEvaluate(
                  new ao(18),
                  s
                ));
              const h =
                  "map" === l.get("text-rotation-alignment") &&
                  "point" !== l.get("symbol-placement"),
                p = l.get("text-size");
              for (const d of t.features) {
                const o = l.get("text-font").evaluate(d, {}, s).join(","),
                  a = p.evaluate(d, {}, s),
                  c = u.layoutTextSize.evaluate(d, {}, s),
                  f =
                    (u.layoutIconSize.evaluate(d, {}, s),
                    { horizontal: {}, vertical: void 0 }),
                  m = d.text;
                let g,
                  y = [0, 0];
                if (m) {
                  const r = m.toString(),
                    u = l.get("text-letter-spacing").evaluate(d, {}, s) * xc,
                    p = l.get("text-line-height").evaluate(d, {}, s) * xc,
                    g = Zi(r) ? u : 0,
                    _ = l.get("text-anchor").evaluate(d, {}, s),
                    v = l.get("text-variable-anchor");
                  if (!v) {
                    const t = l.get("text-radial-offset").evaluate(d, {}, s);
                    y = t
                      ? Yu(_, [t * xc, Xu])
                      : l
                          .get("text-offset")
                          .evaluate(d, {}, s)
                          .map((t) => t * xc);
                  }
                  let b = h
                    ? "center"
                    : l.get("text-justify").evaluate(d, {}, s);
                  const x = l.get("symbol-placement"),
                    w = "point" === x,
                    S =
                      "point" === x
                        ? l.get("text-max-width").evaluate(d, {}, s) * xc
                        : 0,
                    E = (s) => {
                      t.allowVerticalPlacement &&
                        Ui(r) &&
                        (f.vertical = lu(
                          m,
                          e,
                          n,
                          i,
                          o,
                          S,
                          p,
                          _,
                          s,
                          g,
                          y,
                          ou.vertical,
                          !0,
                          x,
                          c,
                          a
                        ));
                    };
                  if (!h && v) {
                    const t = "auto" === b ? v.map((t) => Ju(t)) : [b];
                    let r = !1;
                    for (let s = 0; s < t.length; s++) {
                      const l = t[s];
                      if (!f.horizontal[l])
                        if (r) f.horizontal[l] = f.horizontal[0];
                        else {
                          const t = lu(
                            m,
                            e,
                            n,
                            i,
                            o,
                            S,
                            p,
                            "center",
                            l,
                            g,
                            y,
                            ou.horizontal,
                            !1,
                            x,
                            c,
                            a
                          );
                          t &&
                            ((f.horizontal[l] = t),
                            (r = 1 === t.positionedLines.length));
                        }
                    }
                    E("left");
                  } else {
                    if (
                      ("auto" === b && (b = Ju(_)),
                      w ||
                        l.get("text-writing-mode").indexOf("horizontal") >= 0 ||
                        !Ui(r))
                    ) {
                      const t = lu(
                        m,
                        e,
                        n,
                        i,
                        o,
                        S,
                        p,
                        _,
                        b,
                        g,
                        y,
                        ou.horizontal,
                        !1,
                        x,
                        c,
                        a
                      );
                      t && (f.horizontal[b] = t);
                    }
                    E("point" === x ? "left" : b);
                  }
                }
                let _ = !1;
                if (d.icon && d.icon.name) {
                  const e = r[d.icon.name];
                  e &&
                    ((g = vu(
                      i[d.icon.name],
                      l.get("icon-offset").evaluate(d, {}, s),
                      l.get("icon-anchor").evaluate(d, {}, s)
                    )),
                    (_ = e.sdf),
                    void 0 === t.sdfIcons
                      ? (t.sdfIcons = e.sdf)
                      : t.sdfIcons !== e.sdf &&
                        I(
                          "Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"
                        ),
                    (e.pixelRatio !== t.pixelRatio ||
                      0 !== l.get("icon-rotate").constantOr(1)) &&
                      (t.iconsNeedLinear = !0));
                }
                const v = rh(f.horizontal) || f.vertical;
                t.iconsInText || (t.iconsInText = !!v && v.iconsInText),
                  (v || g) && th(t, d, f, g, r, u, c, 0, y, _, s);
              }
              o && t.generateCollisionDebugBuffers(a, t.collisionBoxArray);
            }
            function Ju(t) {
              switch (t) {
                case "right":
                case "top-right":
                case "bottom-right":
                  return "right";
                case "left":
                case "top-left":
                case "bottom-left":
                  return "left";
              }
              return "center";
            }
            function th(t, e, n, r, i, o, s, a, l, c, u) {
              let p = o.textMaxSize.evaluate(e, {}, u);
              void 0 === p && (p = s);
              const d = t.layers[0].layout,
                f = d.get("icon-offset").evaluate(e, {}, u),
                m = rh(n.horizontal) || n.vertical,
                g = s / 24,
                y = (t.tilePixelRatio * p) / 24,
                _ = t.tilePixelRatio * d.get("symbol-spacing"),
                v = d.get("text-padding") * t.tilePixelRatio,
                b = d.get("icon-padding") * t.tilePixelRatio,
                x = h(d.get("text-max-angle")),
                w =
                  "map" === d.get("text-rotation-alignment") &&
                  "point" !== d.get("symbol-placement"),
                S =
                  "map" === d.get("icon-rotation-alignment") &&
                  "point" !== d.get("symbol-placement"),
                E = d.get("symbol-placement"),
                T = _ / 2,
                A = d.get("icon-text-fit");
              let C;
              r &&
                "none" !== A &&
                (t.allowVerticalPlacement &&
                  n.vertical &&
                  (C = bu(
                    r,
                    n.vertical,
                    A,
                    d.get("icon-text-fit-padding"),
                    f,
                    g
                  )),
                m && (r = bu(r, m, A, d.get("icon-text-fit-padding"), f, g)));
              const P = (a, h) => {
                h.x < 0 ||
                  h.x >= Vs ||
                  h.y < 0 ||
                  h.y >= Vs ||
                  (function (
                    t,
                    e,
                    n,
                    r,
                    i,
                    o,
                    s,
                    a,
                    l,
                    c,
                    u,
                    h,
                    p,
                    d,
                    f,
                    m,
                    g,
                    y,
                    _,
                    v,
                    b,
                    x,
                    w,
                    S
                  ) {
                    const E = t.addToLineVertexArray(e, n);
                    let T,
                      A,
                      C,
                      P,
                      M,
                      O,
                      k,
                      D = 0,
                      z = 0,
                      R = 0,
                      L = 0,
                      F = -1,
                      B = -1;
                    const N = {};
                    let j = ds(""),
                      U = 0,
                      Z = 0;
                    if (
                      (void 0 ===
                      a._unevaluatedLayout.getValue("text-radial-offset")
                        ? ([U, Z] = a.layout
                            .get("text-offset")
                            .evaluate(v, {}, w)
                            .map((t) => t * xc))
                        : ((U =
                            a.layout
                              .get("text-radial-offset")
                              .evaluate(v, {}, w) * xc),
                          (Z = Xu)),
                      t.allowVerticalPlacement && r.vertical)
                    ) {
                      const t = r.vertical;
                      if (d) (O = oh(t)), s && (k = oh(s));
                      else {
                        const n =
                          a.layout.get("text-rotate").evaluate(v, {}, w) + 90;
                        (C = ih(l, e, c, u, h, t, p, n, f)),
                          s && (P = ih(l, e, c, u, h, s, g, n));
                      }
                    }
                    if (i) {
                      const n = a.layout.get("icon-rotate").evaluate(v, {}, w),
                        r = "none" !== a.layout.get("icon-text-fit"),
                        o = Bu(i, n, x, r),
                        p = s ? Bu(s, n, x, r) : void 0;
                      (A = ih(l, e, c, u, h, i, g, n)), (D = 4 * o.length);
                      const d = t.iconSizeData;
                      let f = null;
                      "source" === d.kind
                        ? ((f = [
                            wc * a.layout.get("icon-size").evaluate(v, {}, w),
                          ]),
                          f[0] > eh &&
                            I(
                              `${t.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`
                            ))
                        : "composite" === d.kind &&
                          ((f = [
                            wc * b.compositeIconSizes[0].evaluate(v, {}, w),
                            wc * b.compositeIconSizes[1].evaluate(v, {}, w),
                          ]),
                          (f[0] > eh || f[1] > eh) &&
                            I(
                              `${t.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`
                            )),
                        t.addSymbols(
                          t.icon,
                          o,
                          f,
                          _,
                          y,
                          v,
                          !1,
                          e,
                          E.lineStartIndex,
                          E.lineLength,
                          -1,
                          w
                        ),
                        (F = t.icon.placedSymbolArray.length - 1),
                        p &&
                          ((z = 4 * p.length),
                          t.addSymbols(
                            t.icon,
                            p,
                            f,
                            _,
                            y,
                            v,
                            ou.vertical,
                            e,
                            E.lineStartIndex,
                            E.lineLength,
                            -1,
                            w
                          ),
                          (B = t.icon.placedSymbolArray.length - 1));
                    }
                    for (const I in r.horizontal) {
                      const n = r.horizontal[I];
                      T ||
                        ((j = ds(n.text)),
                        d
                          ? (M = oh(n))
                          : (T = ih(
                              l,
                              e,
                              c,
                              u,
                              h,
                              n,
                              p,
                              a.layout.get("text-rotate").evaluate(v, {}, w),
                              f
                            )));
                      const i = 1 === n.positionedLines.length;
                      if (
                        ((R += nh(
                          t,
                          e,
                          n,
                          o,
                          a,
                          d,
                          v,
                          f,
                          E,
                          r.vertical ? ou.horizontal : ou.horizontalOnly,
                          i ? Object.keys(r.horizontal) : [I],
                          N,
                          F,
                          b,
                          w
                        )),
                        i)
                      )
                        break;
                    }
                    r.vertical &&
                      (L += nh(
                        t,
                        e,
                        r.vertical,
                        o,
                        a,
                        d,
                        v,
                        f,
                        E,
                        ou.vertical,
                        ["vertical"],
                        N,
                        B,
                        b,
                        w
                      ));
                    let V = -1;
                    const q = (t, e) => (t ? Math.max(t, e) : e);
                    (V = q(M, V)), (V = q(O, V)), (V = q(k, V));
                    const $ = V > -1 ? 1 : 0;
                    $ && (V *= S / xc),
                      t.glyphOffsetArray.length >= fh.MAX_GLYPHS &&
                        I(
                          "Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"
                        ),
                      void 0 !== v.sortKey &&
                        t.addToSortKeyRanges(
                          t.symbolInstances.length,
                          v.sortKey
                        ),
                      t.symbolInstances.emplaceBack(
                        e.x,
                        e.y,
                        N.right >= 0 ? N.right : -1,
                        N.center >= 0 ? N.center : -1,
                        N.left >= 0 ? N.left : -1,
                        N.vertical >= 0 ? N.vertical : -1,
                        F,
                        B,
                        j,
                        void 0 !== T ? T : t.collisionBoxArray.length,
                        void 0 !== T ? T + 1 : t.collisionBoxArray.length,
                        void 0 !== C ? C : t.collisionBoxArray.length,
                        void 0 !== C ? C + 1 : t.collisionBoxArray.length,
                        void 0 !== A ? A : t.collisionBoxArray.length,
                        void 0 !== A ? A + 1 : t.collisionBoxArray.length,
                        P || t.collisionBoxArray.length,
                        P ? P + 1 : t.collisionBoxArray.length,
                        c,
                        R,
                        L,
                        D,
                        z,
                        $,
                        0,
                        U,
                        Z,
                        V
                      );
                  })(
                    t,
                    h,
                    a,
                    n,
                    r,
                    i,
                    C,
                    t.layers[0],
                    t.collisionBoxArray,
                    e.index,
                    e.sourceLayerIndex,
                    t.index,
                    v,
                    w,
                    l,
                    0,
                    b,
                    S,
                    f,
                    e,
                    o,
                    c,
                    u,
                    s
                  );
              };
              if ("line" === E)
                for (const h of Mu(e.geometry, 0, 0, Vs, Vs)) {
                  const e = Cu(
                    h,
                    _,
                    x,
                    n.vertical || m,
                    r,
                    24,
                    y,
                    t.overscaling,
                    Vs
                  );
                  for (const n of e) {
                    const e = m;
                    (e && sh(t, e.text, T, n)) || P(h, n);
                  }
                }
              else if ("line-center" === E) {
                for (const h of e.geometry)
                  if (h.length > 1) {
                    const t = Au(h, x, n.vertical || m, r, 24, y);
                    t && P(h, t);
                  }
              } else if ("Polygon" === e.type)
                for (const h of Pl(e.geometry, 0)) {
                  const t = Gu(h, 16);
                  P(h[0], new xu(t.x, t.y, 0));
                }
              else if ("LineString" === e.type)
                for (const h of e.geometry) P(h, new xu(h[0].x, h[0].y, 0));
              else if ("Point" === e.type)
                for (const h of e.geometry)
                  for (const t of h) P([t], new xu(t.x, t.y, 0));
            }
            const eh = 32640;
            function nh(t, e, n, r, i, s, a, l, c, u, h, p, d, f, m) {
              const g = (function (t, e, n, r, i, s, a, l) {
                  const c = [];
                  if (0 === e.positionedLines.length) return c;
                  const u =
                      (r.layout.get("text-rotate").evaluate(s, {}) * Math.PI) /
                      180,
                    h = (function (t) {
                      const e = t[0],
                        n = t[1],
                        r = e * n;
                      return r > 0
                        ? [e, -n]
                        : r < 0
                        ? [-e, n]
                        : 0 === e
                        ? [n, e]
                        : [n, -e];
                    })(n);
                  let p = Math.abs(e.top - e.bottom);
                  for (const o of e.positionedLines) p -= o.lineOffset;
                  const d = e.positionedLines.length,
                    f = p / d;
                  let m = e.top - n[1];
                  for (let g = 0; g < d; ++g) {
                    const t = e.positionedLines[g];
                    m = Vu(e, f, m, g);
                    for (const r of t.positionedGlyphs) {
                      if (!r.rect) continue;
                      const t = r.rect || {};
                      let s = 4,
                        p = !0,
                        d = 1,
                        f = 0;
                      const g = (i || l) && r.vertical,
                        y = (r.metrics.advance * r.scale) / 2,
                        _ = r.metrics,
                        v = r.rect;
                      if (null === v) continue;
                      if (
                        (l &&
                          e.verticalizable &&
                          (f = r.imageName
                            ? y - (r.metrics.width * r.scale) / 2
                            : 0),
                        r.imageName)
                      ) {
                        const t = a[r.imageName];
                        if (!t) continue;
                        (p = t.sdf), (d = t.pixelRatio), (s = 1 / d);
                      }
                      const b = i ? [r.x + y, r.y] : [0, 0];
                      let x = [0, 0],
                        w = [0, 0],
                        S = !1;
                      i ||
                        (g
                          ? ((w = [r.x + y + h[0], r.y + h[1] - f]), (S = !0))
                          : (x = [r.x + y + n[0], r.y + n[1] - f]));
                      const E = (v.w * r.scale) / (d * (r.localGlyph ? 2 : 1)),
                        T = (v.h * r.scale) / (d * (r.localGlyph ? 2 : 1));
                      let A, C, P, M;
                      if (g) {
                        const t = r.y - m,
                          e = new o(-y, y - t),
                          n = -Math.PI / 2,
                          i = new o(...w);
                        (A = new o(-y + x[0], x[1])),
                          A._rotateAround(n, e)._add(i),
                          (A.x += -t + y),
                          (A.y -= (_.left - s) * r.scale);
                        const a = r.imageName
                            ? _.advance * r.scale
                            : xc * r.scale,
                          l = String.fromCharCode(r.glyph);
                        Mc(l)
                          ? (A.x += (1 - s) * r.scale)
                          : Oc(l)
                          ? (A.x += a - _.height * r.scale + (-s - 1) * r.scale)
                          : (A.x +=
                              r.imageName ||
                              (_.width + 2 * s === v.w &&
                                _.height + 2 * s === v.h)
                                ? (a - T) / 2
                                : (a - (_.height + 2 * s) * r.scale) / 2),
                          (C = new o(A.x, A.y - E)),
                          (P = new o(A.x + T, A.y)),
                          (M = new o(A.x + T, A.y - E));
                      } else {
                        const t = (_.left - s) * r.scale - y + x[0],
                          e = (-_.top - s) * r.scale + x[1],
                          n = t + E,
                          i = e + T;
                        (A = new o(t, e)),
                          (C = new o(n, e)),
                          (P = new o(t, i)),
                          (M = new o(n, i));
                      }
                      if (u) {
                        let t;
                        (t = i
                          ? new o(0, 0)
                          : S
                          ? new o(h[0], h[1])
                          : new o(n[0], n[1])),
                          A._rotateAround(u, t),
                          C._rotateAround(u, t),
                          P._rotateAround(u, t),
                          M._rotateAround(u, t);
                      }
                      const O = new o(0, 0),
                        k = new o(0, 0);
                      c.push({
                        tl: A,
                        tr: C,
                        bl: P,
                        br: M,
                        tex: t,
                        writingMode: e.writingMode,
                        glyphOffset: b,
                        sectionIndex: r.sectionIndex,
                        isSDF: p,
                        pixelOffsetTL: O,
                        pixelOffsetBR: k,
                        minFontScaleX: 0,
                        minFontScaleY: 0,
                      });
                    }
                  }
                  return c;
                })(0, n, l, i, s, a, r, t.allowVerticalPlacement),
                y = t.textSizeData;
              let _ = null;
              "source" === y.kind
                ? ((_ = [wc * i.layout.get("text-size").evaluate(a, {}, m)]),
                  _[0] > eh &&
                    I(
                      `${t.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`
                    ))
                : "composite" === y.kind &&
                  ((_ = [
                    wc * f.compositeTextSizes[0].evaluate(a, {}, m),
                    wc * f.compositeTextSizes[1].evaluate(a, {}, m),
                  ]),
                  (_[0] > eh || _[1] > eh) &&
                    I(
                      `${t.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`
                    )),
                t.addSymbols(
                  t.text,
                  g,
                  _,
                  l,
                  s,
                  a,
                  u,
                  e,
                  c.lineStartIndex,
                  c.lineLength,
                  d,
                  m
                );
              for (const o of h) p[o] = t.text.placedSymbolArray.length - 1;
              return 4 * g.length;
            }
            function rh(t) {
              for (const e in t) return t[e];
              return null;
            }
            function ih(t, e, n, r, i, s, a, l, c) {
              let u = s.top,
                p = s.bottom,
                d = s.left,
                f = s.right;
              const m = s.collisionPadding;
              if (
                (m && ((d -= m[0]), (u -= m[1]), (f += m[2]), (p += m[3])), l)
              ) {
                const t = new o(d, u),
                  e = new o(f, u),
                  n = new o(d, p),
                  r = new o(f, p),
                  i = h(l);
                let s = new o(0, 0);
                c && (s = new o(c[0], c[1])),
                  t._rotateAround(i, s),
                  e._rotateAround(i, s),
                  n._rotateAround(i, s),
                  r._rotateAround(i, s),
                  (d = Math.min(t.x, e.x, n.x, r.x)),
                  (f = Math.max(t.x, e.x, n.x, r.x)),
                  (u = Math.min(t.y, e.y, n.y, r.y)),
                  (p = Math.max(t.y, e.y, n.y, r.y));
              }
              return (
                t.emplaceBack(e.x, e.y, d, u, f, p, a, n, r, i), t.length - 1
              );
            }
            function oh(t) {
              t.collisionPadding &&
                ((t.top -= t.collisionPadding[1]),
                (t.bottom += t.collisionPadding[3]));
              const e = t.bottom - t.top;
              return e > 0 ? Math.max(10, e) : null;
            }
            function sh(t, e, n, r) {
              const i = t.compareText;
              if (e in i) {
                const t = i[e];
                for (let e = t.length - 1; e >= 0; e--)
                  if (r.dist(t[e]) < n) return !0;
              } else i[e] = [];
              return i[e].push(r), !1;
            }
            const ah = Gl.VectorTileFeature.types,
              lh = [
                {
                  name: "a_fade_opacity",
                  components: 1,
                  type: "Uint8",
                  offset: 0,
                },
              ];
            function ch(t, e, n, r, i, o, s, a, l, c, u, h, p) {
              const d = a ? Math.min(eh, Math.round(a[0])) : 0,
                f = a ? Math.min(eh, Math.round(a[1])) : 0;
              t.emplaceBack(
                e,
                n,
                Math.round(32 * r),
                Math.round(32 * i),
                o,
                s,
                (d << 1) + (l ? 1 : 0),
                f,
                16 * c,
                16 * u,
                256 * h,
                256 * p
              );
            }
            function uh(t, e, n) {
              t.emplaceBack(e.x, e.y, n),
                t.emplaceBack(e.x, e.y, n),
                t.emplaceBack(e.x, e.y, n),
                t.emplaceBack(e.x, e.y, n);
            }
            function hh(t) {
              for (const e of t.sections) if (Hi(e.text)) return !0;
              return !1;
            }
            class ph {
              constructor(t) {
                (this.layoutVertexArray = new Ro()),
                  (this.indexArray = new Zo()),
                  (this.programConfigurations = t),
                  (this.segments = new Zs()),
                  (this.dynamicLayoutVertexArray = new Lo()),
                  (this.opacityVertexArray = new Fo()),
                  (this.placedSymbolArray = new ts());
              }
              isEmpty() {
                return (
                  0 === this.layoutVertexArray.length &&
                  0 === this.indexArray.length &&
                  0 === this.dynamicLayoutVertexArray.length &&
                  0 === this.opacityVertexArray.length
                );
              }
              upload(t, e, n, r) {
                this.isEmpty() ||
                  (n &&
                    ((this.layoutVertexBuffer = t.createVertexBuffer(
                      this.layoutVertexArray,
                      mc.members
                    )),
                    (this.indexBuffer = t.createIndexBuffer(
                      this.indexArray,
                      e
                    )),
                    (this.dynamicLayoutVertexBuffer = t.createVertexBuffer(
                      this.dynamicLayoutVertexArray,
                      gc.members,
                      !0
                    )),
                    (this.opacityVertexBuffer = t.createVertexBuffer(
                      this.opacityVertexArray,
                      lh,
                      !0
                    )),
                    (this.opacityVertexBuffer.itemSize = 1)),
                  (n || r) && this.programConfigurations.upload(t));
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy(),
                  this.dynamicLayoutVertexBuffer.destroy(),
                  this.opacityVertexBuffer.destroy());
              }
            }
            li("SymbolBuffers", ph);
            class dh {
              constructor(t, e, n) {
                (this.layoutVertexArray = new t()),
                  (this.layoutAttributes = e),
                  (this.indexArray = new n()),
                  (this.segments = new Zs()),
                  (this.collisionVertexArray = new Uo()),
                  (this.collisionVertexArrayExt = new Lo());
              }
              upload(t) {
                (this.layoutVertexBuffer = t.createVertexBuffer(
                  this.layoutVertexArray,
                  this.layoutAttributes
                )),
                  (this.indexBuffer = t.createIndexBuffer(this.indexArray)),
                  (this.collisionVertexBuffer = t.createVertexBuffer(
                    this.collisionVertexArray,
                    yc.members,
                    !0
                  )),
                  (this.collisionVertexBufferExt = t.createVertexBuffer(
                    this.collisionVertexArrayExt,
                    _c.members,
                    !0
                  ));
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.segments.destroy(),
                  this.collisionVertexBuffer.destroy(),
                  this.collisionVertexBufferExt.destroy());
              }
            }
            li("CollisionBuffers", dh);
            class fh {
              constructor(t) {
                (this.collisionBoxArray = t.collisionBoxArray),
                  (this.zoom = t.zoom),
                  (this.overscaling = t.overscaling),
                  (this.layers = t.layers),
                  (this.layerIds = this.layers.map((t) => t.id)),
                  (this.index = t.index),
                  (this.pixelRatio = t.pixelRatio),
                  (this.sourceLayerIndex = t.sourceLayerIndex),
                  (this.hasPattern = !1),
                  (this.hasRTLText = !1),
                  (this.sortKeyRanges = []),
                  (this.collisionCircleArray = []),
                  (this.placementInvProjMatrix = ga([])),
                  (this.placementViewportMatrix = ga([]));
                const e = this.layers[0]._unevaluatedLayout._values;
                (this.textSizeData = Sc(this.zoom, e["text-size"])),
                  (this.iconSizeData = Sc(this.zoom, e["icon-size"]));
                const n = this.layers[0].layout,
                  r = n.get("symbol-sort-key"),
                  i = n.get("symbol-z-order");
                (this.canOverlap =
                  n.get("text-allow-overlap") ||
                  n.get("icon-allow-overlap") ||
                  n.get("text-ignore-placement") ||
                  n.get("icon-ignore-placement")),
                  (this.sortFeaturesByKey =
                    "viewport-y" !== i && void 0 !== r.constantOr(1)),
                  (this.sortFeaturesByY =
                    ("viewport-y" === i ||
                      ("auto" === i && !this.sortFeaturesByKey)) &&
                    this.canOverlap),
                  (this.writingModes = n
                    .get("text-writing-mode")
                    .map((t) => ou[t])),
                  (this.stateDependentLayerIds = this.layers
                    .filter((t) => t.isStateDependent())
                    .map((t) => t.id)),
                  (this.sourceID = t.sourceID);
              }
              createArrays() {
                (this.text = new ph(
                  new Is(this.layers, this.zoom, (t) => /^text/.test(t))
                )),
                  (this.icon = new ph(
                    new Is(this.layers, this.zoom, (t) => /^icon/.test(t))
                  )),
                  (this.glyphOffsetArray = new rs()),
                  (this.lineVertexArray = new is()),
                  (this.symbolInstances = new ns());
              }
              calculateGlyphDependencies(t, e, n, r, i) {
                for (let o = 0; o < t.length; o++)
                  if (((e[t.charCodeAt(o)] = !0), r && i)) {
                    const n = Pc[t.charAt(o)];
                    n && (e[n.charCodeAt(0)] = !0);
                  }
              }
              populate(t, e, n) {
                const r = this.layers[0],
                  i = r.layout,
                  o = i.get("text-font"),
                  s = i.get("text-field"),
                  a = i.get("icon-image"),
                  l =
                    ("constant" !== s.value.kind ||
                      (s.value.value instanceof fe &&
                        !s.value.value.isEmpty()) ||
                      s.value.value.toString().length > 0) &&
                    ("constant" !== o.value.kind || o.value.value.length > 0),
                  c =
                    "constant" !== a.value.kind ||
                    !!a.value.value ||
                    Object.keys(a.parameters).length > 0,
                  u = i.get("symbol-sort-key");
                if (((this.features = []), !l && !c)) return;
                const h = e.iconDependencies,
                  p = e.glyphDependencies,
                  d = e.availableImages,
                  f = new ao(this.zoom);
                for (const {
                  feature: m,
                  id: g,
                  index: y,
                  sourceLayerIndex: _,
                } of t) {
                  const t = r._featureFilter.needGeometry,
                    e = Ws(m, t);
                  if (!r._featureFilter.filter(f, e, n)) continue;
                  let s, a;
                  if ((t || (e.geometry = Gs(m)), l)) {
                    const t = r.getValueAndResolveTokens("text-field", e, n, d),
                      i = fe.factory(t);
                    hh(i) && (this.hasRTLText = !0),
                      (!this.hasRTLText ||
                        "unavailable" === io() ||
                        (this.hasRTLText && so.isParsed())) &&
                        (s = Cc(i, r, e));
                  }
                  if (c) {
                    const t = r.getValueAndResolveTokens("icon-image", e, n, d);
                    a = t instanceof me ? t : me.fromString(t);
                  }
                  if (!s && !a) continue;
                  const v = this.sortFeaturesByKey
                    ? u.evaluate(e, {}, n)
                    : void 0;
                  if (
                    (this.features.push({
                      id: g,
                      text: s,
                      icon: a,
                      index: y,
                      sourceLayerIndex: _,
                      geometry: e.geometry,
                      properties: m.properties,
                      type: ah[m.type],
                      sortKey: v,
                    }),
                    a && (h[a.name] = !0),
                    s)
                  ) {
                    const t = o.evaluate(e, {}, n).join(","),
                      r =
                        "map" === i.get("text-rotation-alignment") &&
                        "point" !== i.get("symbol-placement");
                    this.allowVerticalPlacement =
                      this.writingModes &&
                      this.writingModes.indexOf(ou.vertical) >= 0;
                    for (const e of s.sections)
                      if (e.image) h[e.image.name] = !0;
                      else {
                        const n = Ui(s.toString()),
                          i = e.fontStack || t,
                          o = (p[i] = p[i] || {});
                        this.calculateGlyphDependencies(
                          e.text,
                          o,
                          r,
                          this.allowVerticalPlacement,
                          n
                        );
                      }
                  }
                }
                "line" === i.get("symbol-placement") &&
                  (this.features = (function (t) {
                    const e = {},
                      n = {},
                      r = [];
                    let i = 0;
                    function o(e) {
                      r.push(t[e]), i++;
                    }
                    function s(t, e, i) {
                      const o = n[t];
                      return (
                        delete n[t],
                        (n[e] = o),
                        r[o].geometry[0].pop(),
                        (r[o].geometry[0] = r[o].geometry[0].concat(i[0])),
                        o
                      );
                    }
                    function a(t, n, i) {
                      const o = e[n];
                      return (
                        delete e[n],
                        (e[t] = o),
                        r[o].geometry[0].shift(),
                        (r[o].geometry[0] = i[0].concat(r[o].geometry[0])),
                        o
                      );
                    }
                    function l(t, e, n) {
                      const r = n ? e[0][e[0].length - 1] : e[0][0];
                      return `${t}:${r.x}:${r.y}`;
                    }
                    for (let c = 0; c < t.length; c++) {
                      const u = t[c],
                        h = u.geometry,
                        p = u.text ? u.text.toString() : null;
                      if (!p) {
                        o(c);
                        continue;
                      }
                      const d = l(p, h),
                        f = l(p, h, !0);
                      if (d in n && f in e && n[d] !== e[f]) {
                        const t = a(d, f, h),
                          i = s(d, f, r[t].geometry);
                        delete e[d],
                          delete n[f],
                          (n[l(p, r[i].geometry, !0)] = i),
                          (r[t].geometry = null);
                      } else
                        d in n
                          ? s(d, f, h)
                          : f in e
                          ? a(d, f, h)
                          : (o(c), (e[d] = i - 1), (n[f] = i - 1));
                    }
                    return r.filter((t) => t.geometry);
                  })(this.features)),
                  this.sortFeaturesByKey &&
                    this.features.sort((t, e) => t.sortKey - e.sortKey);
              }
              update(t, e, n) {
                this.stateDependentLayers.length &&
                  (this.text.programConfigurations.updatePaintArrays(
                    t,
                    e,
                    this.layers,
                    n
                  ),
                  this.icon.programConfigurations.updatePaintArrays(
                    t,
                    e,
                    this.layers,
                    n
                  ));
              }
              isEmpty() {
                return 0 === this.symbolInstances.length && !this.hasRTLText;
              }
              uploadPending() {
                return (
                  !this.uploaded ||
                  this.text.programConfigurations.needsUpload ||
                  this.icon.programConfigurations.needsUpload
                );
              }
              upload(t) {
                !this.uploaded &&
                  this.hasDebugData() &&
                  (this.textCollisionBox.upload(t),
                  this.iconCollisionBox.upload(t)),
                  this.text.upload(
                    t,
                    this.sortFeaturesByY,
                    !this.uploaded,
                    this.text.programConfigurations.needsUpload
                  ),
                  this.icon.upload(
                    t,
                    this.sortFeaturesByY,
                    !this.uploaded,
                    this.icon.programConfigurations.needsUpload
                  ),
                  (this.uploaded = !0);
              }
              destroyDebugData() {
                this.textCollisionBox.destroy(),
                  this.iconCollisionBox.destroy();
              }
              destroy() {
                this.text.destroy(),
                  this.icon.destroy(),
                  this.hasDebugData() && this.destroyDebugData();
              }
              addToLineVertexArray(t, e) {
                const n = this.lineVertexArray.length;
                if (void 0 !== t.segment) {
                  let n = t.dist(e[t.segment + 1]),
                    r = t.dist(e[t.segment]);
                  const i = {};
                  for (let o = t.segment + 1; o < e.length; o++)
                    (i[o] = {
                      x: e[o].x,
                      y: e[o].y,
                      tileUnitDistanceFromAnchor: n,
                    }),
                      o < e.length - 1 && (n += e[o + 1].dist(e[o]));
                  for (let o = t.segment || 0; o >= 0; o--)
                    (i[o] = {
                      x: e[o].x,
                      y: e[o].y,
                      tileUnitDistanceFromAnchor: r,
                    }),
                      o > 0 && (r += e[o - 1].dist(e[o]));
                  for (let t = 0; t < e.length; t++) {
                    const e = i[t];
                    this.lineVertexArray.emplaceBack(
                      e.x,
                      e.y,
                      e.tileUnitDistanceFromAnchor
                    );
                  }
                }
                return {
                  lineStartIndex: n,
                  lineLength: this.lineVertexArray.length - n,
                };
              }
              addSymbols(t, e, n, r, i, o, s, a, l, c, u, h) {
                const p = t.indexArray,
                  d = t.layoutVertexArray,
                  f = t.segments.prepareSegment(
                    4 * e.length,
                    d,
                    p,
                    this.canOverlap ? o.sortKey : void 0
                  ),
                  m = this.glyphOffsetArray.length,
                  g = f.vertexLength,
                  y =
                    this.allowVerticalPlacement && s === ou.vertical
                      ? Math.PI / 2
                      : 0,
                  _ = o.text && o.text.sections;
                for (let v = 0; v < e.length; v++) {
                  const {
                      tl: r,
                      tr: i,
                      bl: s,
                      br: l,
                      tex: c,
                      pixelOffsetTL: u,
                      pixelOffsetBR: m,
                      minFontScaleX: g,
                      minFontScaleY: b,
                      glyphOffset: x,
                      isSDF: w,
                      sectionIndex: S,
                    } = e[v],
                    E = f.vertexLength,
                    T = x[1];
                  ch(d, a.x, a.y, r.x, T + r.y, c.x, c.y, n, w, u.x, u.y, g, b),
                    ch(
                      d,
                      a.x,
                      a.y,
                      i.x,
                      T + i.y,
                      c.x + c.w,
                      c.y,
                      n,
                      w,
                      m.x,
                      u.y,
                      g,
                      b
                    ),
                    ch(
                      d,
                      a.x,
                      a.y,
                      s.x,
                      T + s.y,
                      c.x,
                      c.y + c.h,
                      n,
                      w,
                      u.x,
                      m.y,
                      g,
                      b
                    ),
                    ch(
                      d,
                      a.x,
                      a.y,
                      l.x,
                      T + l.y,
                      c.x + c.w,
                      c.y + c.h,
                      n,
                      w,
                      m.x,
                      m.y,
                      g,
                      b
                    ),
                    uh(t.dynamicLayoutVertexArray, a, y),
                    p.emplaceBack(E, E + 1, E + 2),
                    p.emplaceBack(E + 1, E + 2, E + 3),
                    (f.vertexLength += 4),
                    (f.primitiveLength += 2),
                    this.glyphOffsetArray.emplaceBack(x[0]),
                    (v !== e.length - 1 && S === e[v + 1].sectionIndex) ||
                      t.programConfigurations.populatePaintArrays(
                        d.length,
                        o,
                        o.index,
                        {},
                        h,
                        _ && _[S]
                      );
                }
                t.placedSymbolArray.emplaceBack(
                  a.x,
                  a.y,
                  m,
                  this.glyphOffsetArray.length - m,
                  g,
                  l,
                  c,
                  a.segment,
                  n ? n[0] : 0,
                  n ? n[1] : 0,
                  r[0],
                  r[1],
                  s,
                  0,
                  !1,
                  0,
                  u,
                  0
                );
              }
              _commitLayoutVertex(t, e, n, r, i) {
                t.emplaceBack(e.x, e.y, n, r, Math.round(i.x), Math.round(i.y));
              }
              _addCollisionDebugVertices(t, e, n, r, i) {
                const s = n.segments.prepareSegment(
                    4,
                    n.layoutVertexArray,
                    n.indexArray
                  ),
                  a = s.vertexLength,
                  l = i.anchorX,
                  c = i.anchorY;
                for (let o = 0; o < 4; o++)
                  n.collisionVertexArray.emplaceBack(0, 0, 0, 0);
                n.collisionVertexArrayExt.emplaceBack(
                  e,
                  -t.padding,
                  -t.padding
                ),
                  n.collisionVertexArrayExt.emplaceBack(
                    e,
                    t.padding,
                    -t.padding
                  ),
                  n.collisionVertexArrayExt.emplaceBack(
                    e,
                    t.padding,
                    t.padding
                  ),
                  n.collisionVertexArrayExt.emplaceBack(
                    e,
                    -t.padding,
                    t.padding
                  ),
                  this._commitLayoutVertex(
                    n.layoutVertexArray,
                    r,
                    l,
                    c,
                    new o(t.x1, t.y1)
                  ),
                  this._commitLayoutVertex(
                    n.layoutVertexArray,
                    r,
                    l,
                    c,
                    new o(t.x2, t.y1)
                  ),
                  this._commitLayoutVertex(
                    n.layoutVertexArray,
                    r,
                    l,
                    c,
                    new o(t.x2, t.y2)
                  ),
                  this._commitLayoutVertex(
                    n.layoutVertexArray,
                    r,
                    l,
                    c,
                    new o(t.x1, t.y2)
                  ),
                  (s.vertexLength += 4);
                const u = n.indexArray;
                u.emplaceBack(a, a + 1),
                  u.emplaceBack(a + 1, a + 2),
                  u.emplaceBack(a + 2, a + 3),
                  u.emplaceBack(a + 3, a),
                  (s.primitiveLength += 4);
              }
              _addTextDebugCollisionBoxes(t, e, n, r, i, o) {
                for (let s = r; s < i; s++) {
                  const r = n.get(s),
                    i = this.getSymbolInstanceTextSize(t, o, e, s);
                  this._addCollisionDebugVertices(
                    r,
                    i,
                    this.textCollisionBox,
                    r.anchorPoint,
                    o
                  );
                }
              }
              _addIconDebugCollisionBoxes(t, e, n, r, i, o) {
                for (let s = r; s < i; s++) {
                  const r = n.get(s),
                    i = this.getSymbolInstanceIconSize(t, e, s);
                  this._addCollisionDebugVertices(
                    r,
                    i,
                    this.iconCollisionBox,
                    r.anchorPoint,
                    o
                  );
                }
              }
              generateCollisionDebugBuffers(t, e) {
                this.hasDebugData() && this.destroyDebugData(),
                  (this.textCollisionBox = new dh(No, vc.members, Ho)),
                  (this.iconCollisionBox = new dh(No, vc.members, Ho));
                const n = Tc(this.iconSizeData, t),
                  r = Tc(this.textSizeData, t);
                for (let i = 0; i < this.symbolInstances.length; i++) {
                  const o = this.symbolInstances.get(i);
                  this._addTextDebugCollisionBoxes(
                    r,
                    t,
                    e,
                    o.textBoxStartIndex,
                    o.textBoxEndIndex,
                    o
                  ),
                    this._addTextDebugCollisionBoxes(
                      r,
                      t,
                      e,
                      o.verticalTextBoxStartIndex,
                      o.verticalTextBoxEndIndex,
                      o
                    ),
                    this._addIconDebugCollisionBoxes(
                      n,
                      t,
                      e,
                      o.iconBoxStartIndex,
                      o.iconBoxEndIndex,
                      o
                    ),
                    this._addIconDebugCollisionBoxes(
                      n,
                      t,
                      e,
                      o.verticalIconBoxStartIndex,
                      o.verticalIconBoxEndIndex,
                      o
                    );
                }
              }
              getSymbolInstanceTextSize(t, e, n, r) {
                const i = this.text.placedSymbolArray.get(
                    e.rightJustifiedTextSymbolIndex >= 0
                      ? e.rightJustifiedTextSymbolIndex
                      : e.centerJustifiedTextSymbolIndex >= 0
                      ? e.centerJustifiedTextSymbolIndex
                      : e.leftJustifiedTextSymbolIndex >= 0
                      ? e.leftJustifiedTextSymbolIndex
                      : e.verticalPlacedTextSymbolIndex >= 0
                      ? e.verticalPlacedTextSymbolIndex
                      : r
                  ),
                  o = Ec(this.textSizeData, t, i) / xc;
                return this.tilePixelRatio * o;
              }
              getSymbolInstanceIconSize(t, e, n) {
                const r = this.icon.placedSymbolArray.get(n),
                  i = Ec(this.iconSizeData, t, r);
                return this.tilePixelRatio * i;
              }
              _commitDebugCollisionVertexUpdate(t, e, n) {
                t.emplaceBack(e, -n, -n),
                  t.emplaceBack(e, n, -n),
                  t.emplaceBack(e, n, n),
                  t.emplaceBack(e, -n, n);
              }
              _updateTextDebugCollisionBoxes(t, e, n, r, i, o) {
                for (let s = r; s < i; s++) {
                  const r = n.get(s),
                    i = this.getSymbolInstanceTextSize(t, o, e, s);
                  this._commitDebugCollisionVertexUpdate(
                    this.textCollisionBox.collisionVertexArrayExt,
                    i,
                    r.padding
                  );
                }
              }
              _updateIconDebugCollisionBoxes(t, e, n, r, i) {
                for (let o = r; o < i; o++) {
                  const r = n.get(o),
                    i = this.getSymbolInstanceIconSize(t, e, o);
                  this._commitDebugCollisionVertexUpdate(
                    this.iconCollisionBox.collisionVertexArrayExt,
                    i,
                    r.padding
                  );
                }
              }
              updateCollisionDebugBuffers(t, e) {
                if (!this.hasDebugData()) return;
                this.hasTextCollisionBoxData() &&
                  this.textCollisionBox.collisionVertexArrayExt.clear(),
                  this.hasIconCollisionBoxData() &&
                    this.iconCollisionBox.collisionVertexArrayExt.clear();
                const n = Tc(this.iconSizeData, t),
                  r = Tc(this.textSizeData, t);
                for (let i = 0; i < this.symbolInstances.length; i++) {
                  const o = this.symbolInstances.get(i);
                  this._updateTextDebugCollisionBoxes(
                    r,
                    t,
                    e,
                    o.textBoxStartIndex,
                    o.textBoxEndIndex,
                    o
                  ),
                    this._updateTextDebugCollisionBoxes(
                      r,
                      t,
                      e,
                      o.verticalTextBoxStartIndex,
                      o.verticalTextBoxEndIndex,
                      o
                    ),
                    this._updateIconDebugCollisionBoxes(
                      n,
                      t,
                      e,
                      o.iconBoxStartIndex,
                      o.iconBoxEndIndex
                    ),
                    this._updateIconDebugCollisionBoxes(
                      n,
                      t,
                      e,
                      o.verticalIconBoxStartIndex,
                      o.verticalIconBoxEndIndex
                    );
                }
                this.hasTextCollisionBoxData() &&
                  this.textCollisionBox.collisionVertexBufferExt &&
                  this.textCollisionBox.collisionVertexBufferExt.updateData(
                    this.textCollisionBox.collisionVertexArrayExt
                  ),
                  this.hasIconCollisionBoxData() &&
                    this.iconCollisionBox.collisionVertexBufferExt &&
                    this.iconCollisionBox.collisionVertexBufferExt.updateData(
                      this.iconCollisionBox.collisionVertexArrayExt
                    );
              }
              _deserializeCollisionBoxesForSymbol(t, e, n, r, i, o, s, a, l) {
                const c = {};
                for (let u = e; u < n; u++) {
                  const e = t.get(u);
                  (c.textBox = {
                    x1: e.x1,
                    y1: e.y1,
                    x2: e.x2,
                    y2: e.y2,
                    padding: e.padding,
                    anchorPointX: e.anchorPointX,
                    anchorPointY: e.anchorPointY,
                  }),
                    (c.textFeatureIndex = e.featureIndex);
                  break;
                }
                for (let u = r; u < i; u++) {
                  const e = t.get(u);
                  (c.verticalTextBox = {
                    x1: e.x1,
                    y1: e.y1,
                    x2: e.x2,
                    y2: e.y2,
                    padding: e.padding,
                    anchorPointX: e.anchorPointX,
                    anchorPointY: e.anchorPointY,
                  }),
                    (c.verticalTextFeatureIndex = e.featureIndex);
                  break;
                }
                for (let u = o; u < s; u++) {
                  const e = t.get(u);
                  (c.iconBox = {
                    x1: e.x1,
                    y1: e.y1,
                    x2: e.x2,
                    y2: e.y2,
                    padding: e.padding,
                    anchorPointX: e.anchorPointX,
                    anchorPointY: e.anchorPointY,
                  }),
                    (c.iconFeatureIndex = e.featureIndex);
                  break;
                }
                for (let u = a; u < l; u++) {
                  const e = t.get(u);
                  (c.verticalIconBox = {
                    x1: e.x1,
                    y1: e.y1,
                    x2: e.x2,
                    y2: e.y2,
                    padding: e.padding,
                    anchorPointX: e.anchorPointX,
                    anchorPointY: e.anchorPointY,
                  }),
                    (c.verticalIconFeatureIndex = e.featureIndex);
                  break;
                }
                return c;
              }
              deserializeCollisionBoxes(t) {
                this.collisionArrays = [];
                for (let e = 0; e < this.symbolInstances.length; e++) {
                  const n = this.symbolInstances.get(e);
                  this.collisionArrays.push(
                    this._deserializeCollisionBoxesForSymbol(
                      t,
                      n.textBoxStartIndex,
                      n.textBoxEndIndex,
                      n.verticalTextBoxStartIndex,
                      n.verticalTextBoxEndIndex,
                      n.iconBoxStartIndex,
                      n.iconBoxEndIndex,
                      n.verticalIconBoxStartIndex,
                      n.verticalIconBoxEndIndex
                    )
                  );
                }
              }
              hasTextData() {
                return this.text.segments.get().length > 0;
              }
              hasIconData() {
                return this.icon.segments.get().length > 0;
              }
              hasDebugData() {
                return this.textCollisionBox && this.iconCollisionBox;
              }
              hasTextCollisionBoxData() {
                return (
                  this.hasDebugData() &&
                  this.textCollisionBox.segments.get().length > 0
                );
              }
              hasIconCollisionBoxData() {
                return (
                  this.hasDebugData() &&
                  this.iconCollisionBox.segments.get().length > 0
                );
              }
              addIndicesForPlacedSymbol(t, e) {
                const n = t.placedSymbolArray.get(e),
                  r = n.vertexStartIndex + 4 * n.numGlyphs;
                for (let i = n.vertexStartIndex; i < r; i += 4)
                  t.indexArray.emplaceBack(i, i + 1, i + 2),
                    t.indexArray.emplaceBack(i + 1, i + 2, i + 3);
              }
              getSortedSymbolIndexes(t) {
                if (
                  this.sortedAngle === t &&
                  void 0 !== this.symbolInstanceIndexes
                )
                  return this.symbolInstanceIndexes;
                const e = Math.sin(t),
                  n = Math.cos(t),
                  r = [],
                  i = [],
                  o = [];
                for (let s = 0; s < this.symbolInstances.length; ++s) {
                  o.push(s);
                  const t = this.symbolInstances.get(s);
                  r.push(0 | Math.round(e * t.anchorX + n * t.anchorY)),
                    i.push(t.featureIndex);
                }
                return o.sort((t, e) => r[t] - r[e] || i[e] - i[t]), o;
              }
              addToSortKeyRanges(t, e) {
                const n = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                n && n.sortKey === e
                  ? (n.symbolInstanceEnd = t + 1)
                  : this.sortKeyRanges.push({
                      sortKey: e,
                      symbolInstanceStart: t,
                      symbolInstanceEnd: t + 1,
                    });
              }
              sortFeatures(t) {
                if (
                  this.sortFeaturesByY &&
                  this.sortedAngle !== t &&
                  !(
                    this.text.segments.get().length > 1 ||
                    this.icon.segments.get().length > 1
                  )
                ) {
                  (this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t)),
                    (this.sortedAngle = t),
                    this.text.indexArray.clear(),
                    this.icon.indexArray.clear(),
                    (this.featureSortOrder = []);
                  for (const t of this.symbolInstanceIndexes) {
                    const e = this.symbolInstances.get(t);
                    this.featureSortOrder.push(e.featureIndex),
                      [
                        e.rightJustifiedTextSymbolIndex,
                        e.centerJustifiedTextSymbolIndex,
                        e.leftJustifiedTextSymbolIndex,
                      ].forEach((t, e, n) => {
                        t >= 0 &&
                          n.indexOf(t) === e &&
                          this.addIndicesForPlacedSymbol(this.text, t);
                      }),
                      e.verticalPlacedTextSymbolIndex >= 0 &&
                        this.addIndicesForPlacedSymbol(
                          this.text,
                          e.verticalPlacedTextSymbolIndex
                        ),
                      e.placedIconSymbolIndex >= 0 &&
                        this.addIndicesForPlacedSymbol(
                          this.icon,
                          e.placedIconSymbolIndex
                        ),
                      e.verticalPlacedIconSymbolIndex >= 0 &&
                        this.addIndicesForPlacedSymbol(
                          this.icon,
                          e.verticalPlacedIconSymbolIndex
                        );
                  }
                  this.text.indexBuffer &&
                    this.text.indexBuffer.updateData(this.text.indexArray),
                    this.icon.indexBuffer &&
                      this.icon.indexBuffer.updateData(this.icon.indexArray);
                }
              }
            }
            li("SymbolBucket", fh, {
              omit: ["layers", "collisionBoxArray", "features", "compareText"],
            }),
              (fh.MAX_GLYPHS = 65535),
              (fh.addDynamicAttributes = uh);
            const mh = new wo({
              "symbol-placement": new yo(Nt.layout_symbol["symbol-placement"]),
              "symbol-spacing": new yo(Nt.layout_symbol["symbol-spacing"]),
              "symbol-avoid-edges": new yo(
                Nt.layout_symbol["symbol-avoid-edges"]
              ),
              "symbol-sort-key": new _o(Nt.layout_symbol["symbol-sort-key"]),
              "symbol-z-order": new yo(Nt.layout_symbol["symbol-z-order"]),
              "icon-allow-overlap": new yo(
                Nt.layout_symbol["icon-allow-overlap"]
              ),
              "icon-ignore-placement": new yo(
                Nt.layout_symbol["icon-ignore-placement"]
              ),
              "icon-optional": new yo(Nt.layout_symbol["icon-optional"]),
              "icon-rotation-alignment": new yo(
                Nt.layout_symbol["icon-rotation-alignment"]
              ),
              "icon-size": new _o(Nt.layout_symbol["icon-size"]),
              "icon-text-fit": new yo(Nt.layout_symbol["icon-text-fit"]),
              "icon-text-fit-padding": new yo(
                Nt.layout_symbol["icon-text-fit-padding"]
              ),
              "icon-image": new _o(Nt.layout_symbol["icon-image"]),
              "icon-rotate": new _o(Nt.layout_symbol["icon-rotate"]),
              "icon-padding": new yo(Nt.layout_symbol["icon-padding"]),
              "icon-keep-upright": new yo(
                Nt.layout_symbol["icon-keep-upright"]
              ),
              "icon-offset": new _o(Nt.layout_symbol["icon-offset"]),
              "icon-anchor": new _o(Nt.layout_symbol["icon-anchor"]),
              "icon-pitch-alignment": new yo(
                Nt.layout_symbol["icon-pitch-alignment"]
              ),
              "text-pitch-alignment": new yo(
                Nt.layout_symbol["text-pitch-alignment"]
              ),
              "text-rotation-alignment": new yo(
                Nt.layout_symbol["text-rotation-alignment"]
              ),
              "text-field": new _o(Nt.layout_symbol["text-field"]),
              "text-font": new _o(Nt.layout_symbol["text-font"]),
              "text-size": new _o(Nt.layout_symbol["text-size"]),
              "text-max-width": new _o(Nt.layout_symbol["text-max-width"]),
              "text-line-height": new _o(Nt.layout_symbol["text-line-height"]),
              "text-letter-spacing": new _o(
                Nt.layout_symbol["text-letter-spacing"]
              ),
              "text-justify": new _o(Nt.layout_symbol["text-justify"]),
              "text-radial-offset": new _o(
                Nt.layout_symbol["text-radial-offset"]
              ),
              "text-variable-anchor": new yo(
                Nt.layout_symbol["text-variable-anchor"]
              ),
              "text-anchor": new _o(Nt.layout_symbol["text-anchor"]),
              "text-max-angle": new yo(Nt.layout_symbol["text-max-angle"]),
              "text-writing-mode": new yo(
                Nt.layout_symbol["text-writing-mode"]
              ),
              "text-rotate": new _o(Nt.layout_symbol["text-rotate"]),
              "text-padding": new yo(Nt.layout_symbol["text-padding"]),
              "text-keep-upright": new yo(
                Nt.layout_symbol["text-keep-upright"]
              ),
              "text-transform": new _o(Nt.layout_symbol["text-transform"]),
              "text-offset": new _o(Nt.layout_symbol["text-offset"]),
              "text-allow-overlap": new yo(
                Nt.layout_symbol["text-allow-overlap"]
              ),
              "text-ignore-placement": new yo(
                Nt.layout_symbol["text-ignore-placement"]
              ),
              "text-optional": new yo(Nt.layout_symbol["text-optional"]),
            });
            var gh = {
              paint: new wo({
                "icon-opacity": new _o(Nt.paint_symbol["icon-opacity"]),
                "icon-color": new _o(Nt.paint_symbol["icon-color"]),
                "icon-halo-color": new _o(Nt.paint_symbol["icon-halo-color"]),
                "icon-halo-width": new _o(Nt.paint_symbol["icon-halo-width"]),
                "icon-halo-blur": new _o(Nt.paint_symbol["icon-halo-blur"]),
                "icon-translate": new yo(Nt.paint_symbol["icon-translate"]),
                "icon-translate-anchor": new yo(
                  Nt.paint_symbol["icon-translate-anchor"]
                ),
                "text-opacity": new _o(Nt.paint_symbol["text-opacity"]),
                "text-color": new _o(Nt.paint_symbol["text-color"], {
                  runtimeType: Yt,
                  getOverride: (t) => t.textColor,
                  hasOverride: (t) => !!t.textColor,
                }),
                "text-halo-color": new _o(Nt.paint_symbol["text-halo-color"]),
                "text-halo-width": new _o(Nt.paint_symbol["text-halo-width"]),
                "text-halo-blur": new _o(Nt.paint_symbol["text-halo-blur"]),
                "text-translate": new yo(Nt.paint_symbol["text-translate"]),
                "text-translate-anchor": new yo(
                  Nt.paint_symbol["text-translate-anchor"]
                ),
              }),
              layout: mh,
            };
            class yh {
              constructor(t) {
                (this.type = t.property.overrides
                  ? t.property.overrides.runtimeType
                  : Wt),
                  (this.defaultValue = t);
              }
              evaluate(t) {
                if (t.formattedSection) {
                  const e = this.defaultValue.property.overrides;
                  if (e && e.hasOverride(t.formattedSection))
                    return e.getOverride(t.formattedSection);
                }
                return t.feature && t.featureState
                  ? this.defaultValue.evaluate(t.feature, t.featureState)
                  : this.defaultValue.property.specification.default;
              }
              eachChild(t) {
                this.defaultValue.isConstant() ||
                  t(this.defaultValue.value._styleExpression.expression);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                return null;
              }
            }
            li("FormatSectionOverride", yh, { omit: ["defaultValue"] });
            class _h extends Ns {
              constructor(t) {
                super(t, gh);
              }
              recalculate(t, e) {
                super.recalculate(t, e),
                  "auto" === this.layout.get("icon-rotation-alignment") &&
                    (this.layout._values["icon-rotation-alignment"] =
                      "point" !== this.layout.get("symbol-placement")
                        ? "map"
                        : "viewport"),
                  "auto" === this.layout.get("text-rotation-alignment") &&
                    (this.layout._values["text-rotation-alignment"] =
                      "point" !== this.layout.get("symbol-placement")
                        ? "map"
                        : "viewport"),
                  "auto" === this.layout.get("text-pitch-alignment") &&
                    (this.layout._values["text-pitch-alignment"] =
                      this.layout.get("text-rotation-alignment")),
                  "auto" === this.layout.get("icon-pitch-alignment") &&
                    (this.layout._values["icon-pitch-alignment"] =
                      this.layout.get("icon-rotation-alignment"));
                const n = this.layout.get("text-writing-mode");
                if (n) {
                  const t = [];
                  for (const e of n) t.indexOf(e) < 0 && t.push(e);
                  this.layout._values["text-writing-mode"] = t;
                } else this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
                this._setPaintOverrides();
              }
              getValueAndResolveTokens(t, e, n, r) {
                const i = this.layout.get(t).evaluate(e, {}, n, r),
                  o = this._unevaluatedLayout._values[t];
                return o.isDataDriven() || ur(o.value) || !i
                  ? i
                  : (function (t, e) {
                      return e.replace(/{([^{}]+)}/g, (e, n) =>
                        n in t ? String(t[n]) : ""
                      );
                    })(e.properties, i);
              }
              createBucket(t) {
                return new fh(t);
              }
              queryRadius() {
                return 0;
              }
              queryIntersectsFeature() {
                return !1;
              }
              _setPaintOverrides() {
                for (const t of gh.paint.overridableProperties) {
                  if (!_h.hasPaintOverride(this.layout, t)) continue;
                  const e = this.paint.get(t),
                    n = new yh(e),
                    r = new cr(n, e.property.specification);
                  let i = null;
                  (i =
                    "constant" === e.value.kind || "source" === e.value.kind
                      ? new pr("source", r)
                      : new dr(
                          "composite",
                          r,
                          e.value.zoomStops,
                          e.value._interpolationType
                        )),
                    (this.paint._values[t] = new mo(
                      e.property,
                      i,
                      e.parameters
                    ));
                }
              }
              _handleOverridablePaintPropertyUpdate(t, e, n) {
                return (
                  !(!this.layout || e.isDataDriven() || n.isDataDriven()) &&
                  _h.hasPaintOverride(this.layout, t)
                );
              }
              static hasPaintOverride(t, e) {
                const n = t.get("text-field"),
                  r = gh.paint.properties[e];
                let i = !1;
                const o = (t) => {
                  for (const e of t)
                    if (r.overrides && r.overrides.hasOverride(e))
                      return void (i = !0);
                };
                if ("constant" === n.value.kind && n.value.value instanceof fe)
                  o(n.value.value.sections);
                else if ("source" === n.value.kind) {
                  const t = (e) => {
                      i ||
                        (e instanceof be && _e(e.value) === ee
                          ? o(e.value.sections)
                          : e instanceof Ee
                          ? o(e.sections)
                          : e.eachChild(t));
                    },
                    e = n.value;
                  e._styleExpression && t(e._styleExpression.expression);
                }
                return i;
              }
              getProgramConfiguration(t) {
                return new ks(this, t);
              }
            }
            var vh = {
                paint: new wo({
                  "background-color": new yo(
                    Nt.paint_background["background-color"]
                  ),
                  "background-pattern": new bo(
                    Nt.paint_background["background-pattern"]
                  ),
                  "background-opacity": new yo(
                    Nt.paint_background["background-opacity"]
                  ),
                }),
              },
              bh = {
                paint: new wo({
                  "raster-opacity": new yo(Nt.paint_raster["raster-opacity"]),
                  "raster-hue-rotate": new yo(
                    Nt.paint_raster["raster-hue-rotate"]
                  ),
                  "raster-brightness-min": new yo(
                    Nt.paint_raster["raster-brightness-min"]
                  ),
                  "raster-brightness-max": new yo(
                    Nt.paint_raster["raster-brightness-max"]
                  ),
                  "raster-saturation": new yo(
                    Nt.paint_raster["raster-saturation"]
                  ),
                  "raster-contrast": new yo(Nt.paint_raster["raster-contrast"]),
                  "raster-resampling": new yo(
                    Nt.paint_raster["raster-resampling"]
                  ),
                  "raster-fade-duration": new yo(
                    Nt.paint_raster["raster-fade-duration"]
                  ),
                }),
              };
            class xh extends Ns {
              constructor(t) {
                super(t, {}), (this.implementation = t);
              }
              is3D() {
                return "3d" === this.implementation.renderingMode;
              }
              hasOffscreenPass() {
                return void 0 !== this.implementation.prerender;
              }
              recalculate() {}
              updateTransitions() {}
              hasTransition() {}
              serialize() {}
              onAdd(t) {
                this.implementation.onAdd &&
                  this.implementation.onAdd(t, t.painter.context.gl);
              }
              onRemove(t) {
                this.implementation.onRemove &&
                  this.implementation.onRemove(t, t.painter.context.gl);
              }
            }
            var wh = {
              paint: new wo({
                "sky-type": new yo(Nt.paint_sky["sky-type"]),
                "sky-atmosphere-sun": new yo(
                  Nt.paint_sky["sky-atmosphere-sun"]
                ),
                "sky-atmosphere-sun-intensity": new yo(
                  Nt.paint_sky["sky-atmosphere-sun-intensity"]
                ),
                "sky-gradient-center": new yo(
                  Nt.paint_sky["sky-gradient-center"]
                ),
                "sky-gradient-radius": new yo(
                  Nt.paint_sky["sky-gradient-radius"]
                ),
                "sky-gradient": new xo(Nt.paint_sky["sky-gradient"]),
                "sky-atmosphere-halo-color": new yo(
                  Nt.paint_sky["sky-atmosphere-halo-color"]
                ),
                "sky-atmosphere-color": new yo(
                  Nt.paint_sky["sky-atmosphere-color"]
                ),
                "sky-opacity": new yo(Nt.paint_sky["sky-opacity"]),
              }),
            };
            function Sh(t, e, n) {
              const r = xa(0, 0, 1),
                i = Da(Ia());
              return (
                (function (t, e, n) {
                  n *= 0.5;
                  var r = e[0],
                    i = e[1],
                    o = e[2],
                    s = e[3],
                    a = Math.sin(n),
                    l = Math.cos(n);
                  (t[0] = r * l - o * a),
                    (t[1] = i * l + s * a),
                    (t[2] = o * l + r * a),
                    (t[3] = s * l - i * a);
                })(i, i, n ? -h(t) + Math.PI : h(t)),
                za(i, i, -h(e)),
                Aa(r, r, i),
                Ta(r, r)
              );
            }
            const Eh = {
                circle: class extends Ns {
                  constructor(t) {
                    super(t, da);
                  }
                  createBucket(t) {
                    return new Xs(t);
                  }
                  queryRadius(t) {
                    const e = t;
                    return (
                      la("circle-radius", this, e) +
                      la("circle-stroke-width", this, e) +
                      ca(this.paint.get("circle-translate"))
                    );
                  }
                  queryIntersectsFeature(t, e, n, r, i, o, s, a) {
                    const l =
                      "map" === this.paint.get("circle-pitch-alignment");
                    if (l && t.queryGeometry.isAboveHorizon) return !1;
                    const c = ha(
                        this.paint.get("circle-translate"),
                        this.paint.get("circle-translate-anchor"),
                        o.angle,
                        t.pixelToTileUnitsFactor
                      ),
                      u =
                        this.paint.get("circle-radius").evaluate(e, n) +
                        this.paint.get("circle-stroke-width").evaluate(e, n),
                      h = l ? u * t.pixelToTileUnitsFactor : u;
                    for (const p of r)
                      for (const e of p) {
                        const n = e.add(c),
                          r =
                            a && o.elevation
                              ? o.elevation.exaggeration() *
                                a.getElevationAt(n.x, n.y, !0)
                              : 0,
                          i = l ? n : Ra(n, r, s),
                          u = l
                            ? t.tilespaceRays.map((t) => Ba(t, r))
                            : t.queryGeometry.screenGeometry;
                        let p = h;
                        const d = ka([], [e.x, e.y, r, 1], s);
                        if (
                          ("viewport" ===
                            this.paint.get("circle-pitch-scale") &&
                          "map" === this.paint.get("circle-pitch-alignment")
                            ? (p *= d[3] / o.cameraToCenterDistance)
                            : "map" === this.paint.get("circle-pitch-scale") &&
                              "viewport" ===
                                this.paint.get("circle-pitch-alignment") &&
                              (p *= o.cameraToCenterDistance / d[3]),
                          Ys(u, i, p))
                        )
                          return !0;
                      }
                    return !1;
                  }
                  getProgramIds() {
                    return ["circle"];
                  }
                  getProgramConfiguration(t) {
                    return new ks(this, t);
                  }
                },
                heatmap: class extends Ns {
                  createBucket(t) {
                    return new Na(t);
                  }
                  constructor(t) {
                    super(t, $a), this._updateColorRamp();
                  }
                  _handleSpecialPaintPropertyUpdate(t) {
                    "heatmap-color" === t && this._updateColorRamp();
                  }
                  _updateColorRamp() {
                    (this.colorRamp = Ga({
                      expression:
                        this._transitionablePaint._values["heatmap-color"].value
                          .expression,
                      evaluationKey: "heatmapDensity",
                      image: this.colorRamp,
                    })),
                      (this.colorRampTexture = null);
                  }
                  resize() {
                    this.heatmapFbo &&
                      (this.heatmapFbo.destroy(), (this.heatmapFbo = null));
                  }
                  queryRadius() {
                    return 0;
                  }
                  queryIntersectsFeature() {
                    return !1;
                  }
                  hasOffscreenPass() {
                    return (
                      0 !== this.paint.get("heatmap-opacity") &&
                      "none" !== this.visibility
                    );
                  }
                  getProgramIds() {
                    return ["heatmap", "heatmapTexture"];
                  }
                  getProgramConfiguration(t) {
                    return new ks(this, t);
                  }
                },
                hillshade: class extends Ns {
                  constructor(t) {
                    super(t, Wa);
                  }
                  hasOffscreenPass() {
                    return (
                      0 !== this.paint.get("hillshade-exaggeration") &&
                      "none" !== this.visibility
                    );
                  }
                  getProgramIds() {
                    return ["hillshade", "hillshadePrepare"];
                  }
                  getProgramConfiguration(t) {
                    return new ks(this, t);
                  }
                },
                fill: class extends Ns {
                  constructor(t) {
                    super(t, zl);
                  }
                  getProgramIds() {
                    const t = this.paint.get("fill-pattern"),
                      e = t && t.constantOr(1),
                      n = [e ? "fillPattern" : "fill"];
                    return (
                      this.paint.get("fill-antialias") &&
                        n.push(
                          e && !this.getPaintProperty("fill-outline-color")
                            ? "fillOutlinePattern"
                            : "fillOutline"
                        ),
                      n
                    );
                  }
                  getProgramConfiguration(t) {
                    return new ks(this, t);
                  }
                  recalculate(t, e) {
                    super.recalculate(t, e);
                    const n = this.paint._values["fill-outline-color"];
                    "constant" === n.value.kind &&
                      void 0 === n.value.value &&
                      (this.paint._values["fill-outline-color"] =
                        this.paint._values["fill-color"]);
                  }
                  createBucket(t) {
                    return new Il(t);
                  }
                  queryRadius() {
                    return ca(this.paint.get("fill-translate"));
                  }
                  queryIntersectsFeature(t, e, n, r, i, o) {
                    return (
                      !t.queryGeometry.isAboveHorizon &&
                      Qs(
                        ua(
                          t.tilespaceGeometry,
                          this.paint.get("fill-translate"),
                          this.paint.get("fill-translate-anchor"),
                          o.angle,
                          t.pixelToTileUnitsFactor
                        ),
                        r
                      )
                    );
                  }
                  isTileClipped() {
                    return !0;
                  }
                },
                "fill-extrusion": class extends Ns {
                  constructor(t) {
                    super(t, Jl);
                  }
                  createBucket(t) {
                    return new Yl(t);
                  }
                  queryRadius() {
                    return ca(this.paint.get("fill-extrusion-translate"));
                  }
                  is3D() {
                    return !0;
                  }
                  getProgramIds() {
                    return [
                      this.paint.get("fill-extrusion-pattern").constantOr(1)
                        ? "fillExtrusionPattern"
                        : "fillExtrusion",
                    ];
                  }
                  getProgramConfiguration(t) {
                    return new ks(this, t);
                  }
                  queryIntersectsFeature(t, e, n, r, i, s, a, l, c) {
                    const u = ha(
                        this.paint.get("fill-extrusion-translate"),
                        this.paint.get("fill-extrusion-translate-anchor"),
                        s.angle,
                        t.pixelToTileUnitsFactor
                      ),
                      h = this.paint
                        .get("fill-extrusion-height")
                        .evaluate(e, n),
                      p = this.paint.get("fill-extrusion-base").evaluate(e, n),
                      d = [0, 0],
                      f = l && s.elevation,
                      m = s.elevation ? s.elevation.exaggeration() : 1;
                    if (f) {
                      const e = t.tile.getBucket(this).centroidVertexArray,
                        n = c + 1;
                      if (n < e.length) {
                        const t = e.get(n);
                        (d[0] = t.a_centroid_pos0), (d[1] = t.a_centroid_pos1);
                      }
                    }
                    if (0 === d[0] && 1 === d[1]) return !1;
                    const g = (function (t, e, n, r, i, s, a, l, c) {
                        return s
                          ? (function (t, e, n, r, i, o, s, a, l) {
                              const c = [],
                                u = [],
                                h = [0, 0, 0, 1];
                              for (const p of t) {
                                const t = [],
                                  d = [];
                                for (const c of p) {
                                  const u = c.x + r.x,
                                    p = c.y + r.y,
                                    f = rc(u, p, e, n, o, s, a, l);
                                  (h[0] = u),
                                    (h[1] = p),
                                    (h[2] = f.base),
                                    (h[3] = 1),
                                    ka(h, h, i),
                                    (h[3] = Math.max(h[3], 1e-5));
                                  const m = nc([
                                    h[0] / h[3],
                                    h[1] / h[3],
                                    h[2] / h[3],
                                  ]);
                                  (h[0] = u),
                                    (h[1] = p),
                                    (h[2] = f.top),
                                    (h[3] = 1),
                                    ka(h, h, i),
                                    (h[3] = Math.max(h[3], 1e-5));
                                  const g = nc([
                                    h[0] / h[3],
                                    h[1] / h[3],
                                    h[2] / h[3],
                                  ]);
                                  t.push(m), d.push(g);
                                }
                                c.push(t), u.push(d);
                              }
                              return [c, u];
                            })(t, e, n, r, i, s, a, l, c)
                          : (function (t, e, n, r, i) {
                              const s = [],
                                a = [],
                                l = i[8] * e,
                                c = i[9] * e,
                                u = i[10] * e,
                                h = i[11] * e,
                                p = i[8] * n,
                                d = i[9] * n,
                                f = i[10] * n,
                                m = i[11] * n;
                              for (const g of t) {
                                const t = [],
                                  e = [];
                                for (const n of g) {
                                  const s = n.x + r.x,
                                    a = n.y + r.y,
                                    g = i[0] * s + i[4] * a + i[12],
                                    y = i[1] * s + i[5] * a + i[13],
                                    _ = i[2] * s + i[6] * a + i[14],
                                    v = i[3] * s + i[7] * a + i[15],
                                    b = g + l,
                                    x = y + c,
                                    w = _ + u,
                                    S = Math.max(v + h, 1e-5),
                                    E = g + p,
                                    T = y + d,
                                    A = _ + f,
                                    C = Math.max(v + m, 1e-5),
                                    P = new o(b / S, x / S);
                                  (P.z = w / S), t.push(P);
                                  const M = new o(E / C, T / C);
                                  (M.z = A / C), e.push(M);
                                }
                                s.push(t), a.push(e);
                              }
                              return [s, a];
                            })(t, e, n, r, i);
                      })(r, p, h, u, a, f ? l : null, d, m, s.center.lat),
                      y = t.queryGeometry;
                    return (function (t, e, n) {
                      let r = 1 / 0;
                      Qs(n, e) && (r = ec(n, e[0]));
                      for (let i = 0; i < e.length; i++) {
                        const o = e[i],
                          s = t[i];
                        for (let t = 0; t < o.length - 1; t++) {
                          const e = o[t],
                            i = [e, o[t + 1], s[t + 1], s[t], e];
                          Ks(n, i) && (r = Math.min(r, ec(n, i)));
                        }
                      }
                      return r !== 1 / 0 && r;
                    })(
                      g[0],
                      g[1],
                      y.isPointQuery() ? y.screenBounds : y.screenGeometry
                    );
                  }
                },
                line: class extends Ns {
                  constructor(t) {
                    super(t, pc), (this.gradientVersion = 0);
                  }
                  _handleSpecialPaintPropertyUpdate(t) {
                    if ("line-gradient" === t) {
                      const t =
                        this._transitionablePaint._values["line-gradient"].value
                          .expression;
                      (this.stepInterpolant =
                        t._styleExpression &&
                        t._styleExpression.expression instanceof nn),
                        (this.gradientVersion = (this.gradientVersion + 1) % l);
                    }
                  }
                  gradientExpression() {
                    return this._transitionablePaint._values["line-gradient"]
                      .value.expression;
                  }
                  recalculate(t, e) {
                    super.recalculate(t, e),
                      (this.paint._values["line-floorwidth"] =
                        dc.possiblyEvaluate(
                          this._transitioningPaint._values["line-width"].value,
                          t
                        ));
                  }
                  createBucket(t) {
                    return new uc(t);
                  }
                  getProgramIds() {
                    const t = this.paint.get("line-dasharray"),
                      e = this.paint.get("line-pattern").constantOr(1),
                      n = this.paint.get("line-gradient");
                    return [
                      e
                        ? "linePattern"
                        : t
                        ? "lineSDF"
                        : n
                        ? "lineGradient"
                        : "line",
                    ];
                  }
                  getProgramConfiguration(t) {
                    return new ks(this, t);
                  }
                  queryRadius(t) {
                    const e = t,
                      n = fc(
                        la("line-width", this, e),
                        la("line-gap-width", this, e)
                      ),
                      r = la("line-offset", this, e);
                    return (
                      n / 2 + Math.abs(r) + ca(this.paint.get("line-translate"))
                    );
                  }
                  queryIntersectsFeature(t, e, n, r, i, s) {
                    if (t.queryGeometry.isAboveHorizon) return !1;
                    const a = ua(
                        t.tilespaceGeometry,
                        this.paint.get("line-translate"),
                        this.paint.get("line-translate-anchor"),
                        s.angle,
                        t.pixelToTileUnitsFactor
                      ),
                      l =
                        (t.pixelToTileUnitsFactor / 2) *
                        fc(
                          this.paint.get("line-width").evaluate(e, n),
                          this.paint.get("line-gap-width").evaluate(e, n)
                        ),
                      c = this.paint.get("line-offset").evaluate(e, n);
                    return (
                      c &&
                        (r = (function (t, e) {
                          const n = [],
                            r = new o(0, 0);
                          for (let i = 0; i < t.length; i++) {
                            const o = t[i],
                              s = [];
                            for (let t = 0; t < o.length; t++) {
                              const n = o[t - 1],
                                i = o[t],
                                a = o[t + 1],
                                l = 0 === t ? r : i.sub(n)._unit()._perp(),
                                c =
                                  t === o.length - 1
                                    ? r
                                    : a.sub(i)._unit()._perp(),
                                u = l._add(c)._unit();
                              u._mult(1 / (u.x * c.x + u.y * c.y)),
                                s.push(u._mult(e)._add(i));
                            }
                            n.push(s);
                          }
                          return n;
                        })(r, c * t.pixelToTileUnitsFactor)),
                      (function (t, e, n) {
                        for (let r = 0; r < e.length; r++) {
                          const i = e[r];
                          if (t.length >= 3)
                            for (let e = 0; e < i.length; e++)
                              if (oa(t, i[e])) return !0;
                          if (Js(t, i, n)) return !0;
                        }
                        return !1;
                      })(a, r, l)
                    );
                  }
                  isTileClipped() {
                    return !0;
                  }
                },
                symbol: _h,
                background: class extends Ns {
                  constructor(t) {
                    super(t, vh);
                  }
                  getProgramIds() {
                    return [
                      this.paint.get("background-pattern")
                        ? "backgroundPattern"
                        : "background",
                    ];
                  }
                },
                raster: class extends Ns {
                  constructor(t) {
                    super(t, bh);
                  }
                  getProgramIds() {
                    return ["raster"];
                  }
                },
                sky: class extends Ns {
                  constructor(t) {
                    super(t, wh), this._updateColorRamp();
                  }
                  _handleSpecialPaintPropertyUpdate(t) {
                    "sky-gradient" === t
                      ? this._updateColorRamp()
                      : ("sky-atmosphere-sun" !== t &&
                          "sky-atmosphere-halo-color" !== t &&
                          "sky-atmosphere-color" !== t &&
                          "sky-atmosphere-sun-intensity" !== t) ||
                        (this._skyboxInvalidated = !0);
                  }
                  _updateColorRamp() {
                    (this.colorRamp = Ga({
                      expression:
                        this._transitionablePaint._values["sky-gradient"].value
                          .expression,
                      evaluationKey: "skyRadialProgress",
                    })),
                      this.colorRampTexture &&
                        (this.colorRampTexture.destroy(),
                        (this.colorRampTexture = null));
                  }
                  needsSkyboxCapture(t) {
                    if (
                      this._skyboxInvalidated ||
                      !this.skyboxTexture ||
                      !this.skyboxGeometry
                    )
                      return !0;
                    if (!this.paint.get("sky-atmosphere-sun")) {
                      const e = t.style.light.properties.get("position");
                      return (
                        this._lightPosition.azimuthal !== e.azimuthal ||
                        this._lightPosition.polar !== e.polar
                      );
                    }
                  }
                  getCenter(t, e) {
                    const n = this.paint.get("sky-type");
                    if ("atmosphere" === n) {
                      const n = this.paint.get("sky-atmosphere-sun"),
                        r = !n,
                        i = t.style.light,
                        o = i.properties.get("position");
                      return (
                        r &&
                          "viewport" === i.properties.get("anchor") &&
                          I(
                            "The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."
                          ),
                        r
                          ? Sh(o.azimuthal, 90 - o.polar, e)
                          : Sh(n[0], 90 - n[1], e)
                      );
                    }
                    if ("gradient" === n) {
                      const t = this.paint.get("sky-gradient-center");
                      return Sh(t[0], 90 - t[1], e);
                    }
                  }
                  is3D() {
                    return !1;
                  }
                  isSky() {
                    return !0;
                  }
                  markSkyboxValid(t) {
                    (this._skyboxInvalidated = !1),
                      (this._lightPosition =
                        t.style.light.properties.get("position"));
                  }
                  hasOffscreenPass() {
                    return !0;
                  }
                  getProgramIds() {
                    const t = this.paint.get("sky-type");
                    return "atmosphere" === t
                      ? ["skyboxCapture", "skybox"]
                      : "gradient" === t
                      ? ["skyboxGradient"]
                      : null;
                  }
                },
              },
              {
                HTMLImageElement: Th,
                HTMLCanvasElement: Ah,
                HTMLVideoElement: Ch,
                ImageData: Ph,
                ImageBitmap: Mh,
              } = a;
            class Oh {
              constructor(t, e, n, r) {
                (this.context = t),
                  (this.format = n),
                  (this.texture = t.gl.createTexture()),
                  this.update(e, r);
              }
              update(t, e, n) {
                const { width: r, height: i } = t,
                  o = !(
                    (this.size && this.size[0] === r && this.size[1] === i) ||
                    n
                  ),
                  { context: s } = this,
                  { gl: a } = s;
                if (
                  ((this.useMipmap = Boolean(e && e.useMipmap)),
                  a.bindTexture(a.TEXTURE_2D, this.texture),
                  s.pixelStoreUnpackFlipY.set(!1),
                  s.pixelStoreUnpack.set(1),
                  s.pixelStoreUnpackPremultiplyAlpha.set(
                    this.format === a.RGBA && (!e || !1 !== e.premultiply)
                  ),
                  o)
                )
                  (this.size = [r, i]),
                    t instanceof Th ||
                    t instanceof Ah ||
                    t instanceof Ch ||
                    t instanceof Ph ||
                    (Mh && t instanceof Mh)
                      ? a.texImage2D(
                          a.TEXTURE_2D,
                          0,
                          this.format,
                          this.format,
                          a.UNSIGNED_BYTE,
                          t
                        )
                      : a.texImage2D(
                          a.TEXTURE_2D,
                          0,
                          this.format,
                          r,
                          i,
                          0,
                          this.format,
                          a.UNSIGNED_BYTE,
                          t.data
                        );
                else {
                  const { x: e, y: o } = n || { x: 0, y: 0 };
                  t instanceof Th ||
                  t instanceof Ah ||
                  t instanceof Ch ||
                  t instanceof Ph ||
                  (Mh && t instanceof Mh)
                    ? a.texSubImage2D(
                        a.TEXTURE_2D,
                        0,
                        e,
                        o,
                        a.RGBA,
                        a.UNSIGNED_BYTE,
                        t
                      )
                    : a.texSubImage2D(
                        a.TEXTURE_2D,
                        0,
                        e,
                        o,
                        r,
                        i,
                        a.RGBA,
                        a.UNSIGNED_BYTE,
                        t.data
                      );
                }
                this.useMipmap &&
                  this.isSizePowerOfTwo() &&
                  a.generateMipmap(a.TEXTURE_2D);
              }
              bind(t, e, n) {
                const { context: r } = this,
                  { gl: i } = r;
                i.bindTexture(i.TEXTURE_2D, this.texture),
                  n !== i.LINEAR_MIPMAP_NEAREST ||
                    this.isSizePowerOfTwo() ||
                    (n = i.LINEAR),
                  t !== this.filter &&
                    (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, t),
                    i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, n || t),
                    (this.filter = t)),
                  e !== this.wrap &&
                    (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, e),
                    i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, e),
                    (this.wrap = e));
              }
              isSizePowerOfTwo() {
                return (
                  this.size[0] === this.size[1] &&
                  (Math.log(this.size[0]) / Math.LN2) % 1 == 0
                );
              }
              destroy() {
                const { gl: t } = this.context;
                t.deleteTexture(this.texture), (this.texture = null);
              }
            }
            class kh {
              constructor(t, e) {
                t &&
                  (e
                    ? this.setSouthWest(t).setNorthEast(e)
                    : 4 === t.length
                    ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]])
                    : this.setSouthWest(t[0]).setNorthEast(t[1]));
              }
              setNorthEast(t) {
                return (
                  (this._ne =
                    t instanceof Dh ? new Dh(t.lng, t.lat) : Dh.convert(t)),
                  this
                );
              }
              setSouthWest(t) {
                return (
                  (this._sw =
                    t instanceof Dh ? new Dh(t.lng, t.lat) : Dh.convert(t)),
                  this
                );
              }
              extend(t) {
                const e = this._sw,
                  n = this._ne;
                let r, i;
                if (t instanceof Dh) (r = t), (i = t);
                else {
                  if (!(t instanceof kh))
                    return Array.isArray(t)
                      ? 4 === t.length || t.every(Array.isArray)
                        ? this.extend(kh.convert(t))
                        : this.extend(Dh.convert(t))
                      : this;
                  if (((r = t._sw), (i = t._ne), !r || !i)) return this;
                }
                return (
                  e || n
                    ? ((e.lng = Math.min(r.lng, e.lng)),
                      (e.lat = Math.min(r.lat, e.lat)),
                      (n.lng = Math.max(i.lng, n.lng)),
                      (n.lat = Math.max(i.lat, n.lat)))
                    : ((this._sw = new Dh(r.lng, r.lat)),
                      (this._ne = new Dh(i.lng, i.lat))),
                  this
                );
              }
              getCenter() {
                return new Dh(
                  (this._sw.lng + this._ne.lng) / 2,
                  (this._sw.lat + this._ne.lat) / 2
                );
              }
              getSouthWest() {
                return this._sw;
              }
              getNorthEast() {
                return this._ne;
              }
              getNorthWest() {
                return new Dh(this.getWest(), this.getNorth());
              }
              getSouthEast() {
                return new Dh(this.getEast(), this.getSouth());
              }
              getWest() {
                return this._sw.lng;
              }
              getSouth() {
                return this._sw.lat;
              }
              getEast() {
                return this._ne.lng;
              }
              getNorth() {
                return this._ne.lat;
              }
              toArray() {
                return [this._sw.toArray(), this._ne.toArray()];
              }
              toString() {
                return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
              }
              isEmpty() {
                return !(this._sw && this._ne);
              }
              contains(t) {
                const { lng: e, lat: n } = Dh.convert(t);
                let r = this._sw.lng <= e && e <= this._ne.lng;
                return (
                  this._sw.lng > this._ne.lng &&
                    (r = this._sw.lng >= e && e >= this._ne.lng),
                  this._sw.lat <= n && n <= this._ne.lat && r
                );
              }
              static convert(t) {
                return !t || t instanceof kh ? t : new kh(t);
              }
            }
            const Ih = 6371008.8;
            class Dh {
              constructor(t, e) {
                if (isNaN(t) || isNaN(e))
                  throw new Error(`Invalid LngLat object: (${t}, ${e})`);
                if (
                  ((this.lng = +t),
                  (this.lat = +e),
                  this.lat > 90 || this.lat < -90)
                )
                  throw new Error(
                    "Invalid LngLat latitude value: must be between -90 and 90"
                  );
              }
              wrap() {
                return new Dh(y(this.lng, -180, 180), this.lat);
              }
              toArray() {
                return [this.lng, this.lat];
              }
              toString() {
                return `LngLat(${this.lng}, ${this.lat})`;
              }
              distanceTo(t) {
                const e = Math.PI / 180,
                  n = this.lat * e,
                  r = t.lat * e,
                  i =
                    Math.sin(n) * Math.sin(r) +
                    Math.cos(n) *
                      Math.cos(r) *
                      Math.cos((t.lng - this.lng) * e);
                return Ih * Math.acos(Math.min(i, 1));
              }
              toBounds(t = 0) {
                const e = (360 * t) / 40075017,
                  n = e / Math.cos((Math.PI / 180) * this.lat);
                return new kh(
                  new Dh(this.lng - n, this.lat - e),
                  new Dh(this.lng + n, this.lat + e)
                );
              }
              static convert(t) {
                if (t instanceof Dh) return t;
                if (Array.isArray(t) && (2 === t.length || 3 === t.length))
                  return new Dh(Number(t[0]), Number(t[1]));
                if (!Array.isArray(t) && "object" == typeof t && null !== t)
                  return new Dh(
                    Number("lng" in t ? t.lng : t.lon),
                    Number(t.lat)
                  );
                throw new Error(
                  "`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]"
                );
              }
            }
            const zh = 2 * Math.PI * Ih;
            function Rh(t) {
              return zh * Math.cos((t * Math.PI) / 180);
            }
            function Lh(t) {
              return (180 + t) / 360;
            }
            function Fh(t) {
              return (
                (180 -
                  (180 / Math.PI) *
                    Math.log(Math.tan(Math.PI / 4 + (t * Math.PI) / 360))) /
                360
              );
            }
            function Bh(t, e) {
              return t / Rh(e);
            }
            function Nh(t) {
              return (
                (360 / Math.PI) *
                  Math.atan(Math.exp(((180 - 360 * t) * Math.PI) / 180)) -
                90
              );
            }
            function jh(t, e) {
              return t * Rh(Nh(e));
            }
            class Uh {
              constructor(t, e, n = 0) {
                (this.x = +t), (this.y = +e), (this.z = +n);
              }
              static fromLngLat(t, e = 0) {
                const n = Dh.convert(t);
                return new Uh(Lh(n.lng), Fh(n.lat), Bh(e, n.lat));
              }
              toLngLat() {
                return new Dh(360 * this.x - 180, Nh(this.y));
              }
              toAltitude() {
                return jh(this.z, this.y);
              }
              meterInMercatorCoordinateUnits() {
                return (
                  (1 / zh) *
                  ((t = Nh(this.y)), 1 / Math.cos((t * Math.PI) / 180))
                );
                var t;
              }
            }
            class Zh {
              constructor(t, e) {
                (this.width = t),
                  (this.height = e),
                  (this.nextRow = 0),
                  (this.image = new Va({ width: t, height: e })),
                  (this.positions = {}),
                  (this.uploaded = !1);
              }
              getDash(t, e) {
                const n = this.getKey(t, e);
                return this.positions[n];
              }
              trim() {
                const t = this.width,
                  e = (this.height = E(this.nextRow));
                this.image.resize({ width: t, height: e });
              }
              getKey(t, e) {
                return t.join(",") + e;
              }
              getDashRanges(t, e, n) {
                const r = [];
                let i = t.length % 2 == 1 ? -t[t.length - 1] * n : 0,
                  o = t[0] * n,
                  s = !0;
                r.push({
                  left: i,
                  right: o,
                  isDash: s,
                  zeroLength: 0 === t[0],
                });
                let a = t[0];
                for (let l = 1; l < t.length; l++) {
                  s = !s;
                  const e = t[l];
                  (i = a * n),
                    (a += e),
                    (o = a * n),
                    r.push({
                      left: i,
                      right: o,
                      isDash: s,
                      zeroLength: 0 === e,
                    });
                }
                return r;
              }
              addRoundDash(t, e, n) {
                const r = e / 2;
                for (let i = -n; i <= n; i++) {
                  const e = this.width * (this.nextRow + n + i);
                  let o = 0,
                    s = t[o];
                  for (let a = 0; a < this.width; a++) {
                    a / s.right > 1 && (s = t[++o]);
                    const l = Math.abs(a - s.left),
                      c = Math.abs(a - s.right),
                      u = Math.min(l, c);
                    let h;
                    const p = (i / n) * (r + 1);
                    if (s.isDash) {
                      const t = r - Math.abs(p);
                      h = Math.sqrt(u * u + t * t);
                    } else h = r - Math.sqrt(u * u + p * p);
                    this.image.data[e + a] = Math.max(
                      0,
                      Math.min(255, h + 128)
                    );
                  }
                }
              }
              addRegularDash(t, e) {
                for (let a = t.length - 1; a >= 0; --a) {
                  const e = t[a],
                    n = t[a + 1];
                  e.zeroLength
                    ? t.splice(a, 1)
                    : n &&
                      n.isDash === e.isDash &&
                      ((n.left = e.left), t.splice(a, 1));
                }
                const n = t[0],
                  r = t[t.length - 1];
                n.isDash === r.isDash &&
                  ((n.left = r.left - this.width),
                  (r.right = n.right + this.width));
                const i = this.width * this.nextRow;
                let o = 0,
                  s = t[o];
                for (let a = 0; a < this.width; a++) {
                  a / s.right > 1 && (s = t[++o]);
                  const n = Math.abs(a - s.left),
                    r = Math.abs(a - s.right),
                    l = Math.min(n, r);
                  this.image.data[i + a] = Math.max(
                    0,
                    Math.min(255, (s.isDash ? l : -l) + e + 128)
                  );
                }
              }
              addDash(t, e) {
                const n = this.getKey(t, e);
                if (this.positions[n]) return this.positions[n];
                const r = "round" === e,
                  i = r ? 7 : 0,
                  o = 2 * i + 1;
                if (this.nextRow + o > this.height)
                  return I("LineAtlas out of space"), null;
                0 === t.length && t.push(1);
                let s = 0;
                for (let c = 0; c < t.length; c++)
                  t[c] < 0 &&
                    (I(
                      "Negative value is found in line dasharray, replacing values with 0"
                    ),
                    (t[c] = 0)),
                    (s += t[c]);
                if (0 !== s) {
                  const n = this.width / s,
                    o = this.getDashRanges(t, this.width, n);
                  r
                    ? this.addRoundDash(o, n, i)
                    : this.addRegularDash(o, "square" === e ? 0.5 * n : 0);
                }
                const a = this.nextRow + i;
                this.nextRow += o;
                const l = { tl: [a, i], br: [s, 0] };
                return (this.positions[n] = l), l;
              }
            }
            li("LineAtlas", Zh);
            class Vh {
              constructor(t) {
                (this._callback = t),
                  (this._triggered = !1),
                  "undefined" != typeof MessageChannel &&
                    ((this._channel = new MessageChannel()),
                    (this._channel.port2.onmessage = () => {
                      (this._triggered = !1), this._callback();
                    }));
              }
              trigger() {
                this._triggered ||
                  ((this._triggered = !0),
                  this._channel
                    ? this._channel.port1.postMessage(!0)
                    : setTimeout(() => {
                        (this._triggered = !1), this._callback();
                      }, 0));
              }
              remove() {
                delete this._channel, (this._callback = () => {});
              }
            }
            const qh = a.performance;
            function $h(t) {
              const e = t ? t.url.toString() : void 0;
              return qh.getEntriesByName(e);
            }
            class Gh {
              constructor() {
                (this.tasks = {}),
                  (this.taskQueue = []),
                  A(["process"], this),
                  (this.invoker = new Vh(this.process)),
                  (this.nextId = 0);
              }
              add(t, e) {
                const n = this.nextId++,
                  r = (function ({ type: t, isSymbolTile: e, zoom: n }) {
                    return (
                      (n = n || 0),
                      "message" === t
                        ? 0
                        : "maybePrepare" !== t || e
                        ? "parseTile" !== t || e
                          ? "parseTile" === t && e
                            ? 300 - n
                            : "maybePrepare" === t && e
                            ? 400 - n
                            : 500
                          : 200 - n
                        : 100 - n
                    );
                  })(e);
                if (0 === r) {
                  R();
                  try {
                    t();
                  } finally {
                  }
                  return { cancel: () => {} };
                }
                return (
                  (this.tasks[n] = { fn: t, metadata: e, priority: r, id: n }),
                  this.taskQueue.push(n),
                  this.invoker.trigger(),
                  {
                    cancel: () => {
                      delete this.tasks[n];
                    },
                  }
                );
              }
              process() {
                R();
                try {
                  if (
                    ((this.taskQueue = this.taskQueue.filter(
                      (t) => !!this.tasks[t]
                    )),
                    !this.taskQueue.length)
                  )
                    return;
                  const t = this.pick();
                  if (null === t) return;
                  const e = this.tasks[t];
                  if (
                    (delete this.tasks[t],
                    this.taskQueue.length && this.invoker.trigger(),
                    !e)
                  )
                    return;
                  e.fn();
                } finally {
                }
              }
              pick() {
                let t = null,
                  e = 1 / 0;
                for (let r = 0; r < this.taskQueue.length; r++) {
                  const n = this.tasks[this.taskQueue[r]];
                  n.priority < e && ((e = n.priority), (t = r));
                }
                if (null === t) return null;
                const n = this.taskQueue[t];
                return this.taskQueue.splice(t, 1), n;
              }
              remove() {
                this.invoker.remove();
              }
            }
            function Wh(t, e, n) {
              var r = (2 * Math.PI * 6378137) / 256 / Math.pow(2, n);
              return [
                t * r - (2 * Math.PI * 6378137) / 2,
                e * r - (2 * Math.PI * 6378137) / 2,
              ];
            }
            class Hh {
              constructor(t, e, n) {
                (this.z = t),
                  (this.x = e),
                  (this.y = n),
                  (this.key = Yh(0, t, t, e, n));
              }
              equals(t) {
                return this.z === t.z && this.x === t.x && this.y === t.y;
              }
              url(t, e) {
                const n =
                  ((i = this.y),
                  (o = this.z),
                  (s = Wh(
                    256 * (r = this.x),
                    256 * (i = Math.pow(2, o) - i - 1),
                    o
                  )),
                  (a = Wh(256 * (r + 1), 256 * (i + 1), o)),
                  s[0] + "," + s[1] + "," + a[0] + "," + a[1]);
                var r, i, o, s, a;
                const l = (function (t, e, n) {
                  let r,
                    i = "";
                  for (let o = t; o > 0; o--)
                    (r = 1 << (o - 1)),
                      (i += (e & r ? 1 : 0) + (n & r ? 2 : 0));
                  return i;
                })(this.z, this.x, this.y);
                return t[(this.x + this.y) % t.length]
                  .replace(
                    "{prefix}",
                    (this.x % 16).toString(16) + (this.y % 16).toString(16)
                  )
                  .replace("{z}", String(this.z))
                  .replace("{x}", String(this.x))
                  .replace(
                    "{y}",
                    String(
                      "tms" === e ? Math.pow(2, this.z) - this.y - 1 : this.y
                    )
                  )
                  .replace("{quadkey}", l)
                  .replace("{bbox-epsg-3857}", n);
              }
              getTilePoint(t) {
                const e = Math.pow(2, this.z);
                return new o((t.x * e - this.x) * Vs, (t.y * e - this.y) * Vs);
              }
              getTileVec3(t) {
                const e = Math.pow(2, this.z);
                return xa(
                  (t.x * e - this.x) * Vs,
                  (t.y * e - this.y) * Vs,
                  jh(t.z, t.y)
                );
              }
              toString() {
                return `${this.z}/${this.x}/${this.y}`;
              }
            }
            class Xh {
              constructor(t, e) {
                (this.wrap = t),
                  (this.canonical = e),
                  (this.key = Yh(t, e.z, e.z, e.x, e.y));
              }
            }
            class Kh {
              constructor(t, e, n, r, i) {
                (this.overscaledZ = t),
                  (this.wrap = e),
                  (this.canonical = new Hh(n, +r, +i)),
                  (this.key =
                    0 === e && t === n
                      ? this.canonical.key
                      : Yh(e, t, n, r, i));
              }
              equals(t) {
                return (
                  this.overscaledZ === t.overscaledZ &&
                  this.wrap === t.wrap &&
                  this.canonical.equals(t.canonical)
                );
              }
              scaledTo(t) {
                const e = this.canonical.z - t;
                return t > this.canonical.z
                  ? new Kh(
                      t,
                      this.wrap,
                      this.canonical.z,
                      this.canonical.x,
                      this.canonical.y
                    )
                  : new Kh(
                      t,
                      this.wrap,
                      t,
                      this.canonical.x >> e,
                      this.canonical.y >> e
                    );
              }
              calculateScaledKey(t, e = !0) {
                if (this.overscaledZ === t && e) return this.key;
                if (t > this.canonical.z)
                  return Yh(
                    this.wrap * +e,
                    t,
                    this.canonical.z,
                    this.canonical.x,
                    this.canonical.y
                  );
                {
                  const n = this.canonical.z - t;
                  return Yh(
                    this.wrap * +e,
                    t,
                    t,
                    this.canonical.x >> n,
                    this.canonical.y >> n
                  );
                }
              }
              isChildOf(t) {
                if (t.wrap !== this.wrap) return !1;
                const e = this.canonical.z - t.canonical.z;
                return (
                  0 === t.overscaledZ ||
                  (t.overscaledZ < this.overscaledZ &&
                    t.canonical.x === this.canonical.x >> e &&
                    t.canonical.y === this.canonical.y >> e)
                );
              }
              children(t) {
                if (this.overscaledZ >= t)
                  return [
                    new Kh(
                      this.overscaledZ + 1,
                      this.wrap,
                      this.canonical.z,
                      this.canonical.x,
                      this.canonical.y
                    ),
                  ];
                const e = this.canonical.z + 1,
                  n = 2 * this.canonical.x,
                  r = 2 * this.canonical.y;
                return [
                  new Kh(e, this.wrap, e, n, r),
                  new Kh(e, this.wrap, e, n + 1, r),
                  new Kh(e, this.wrap, e, n, r + 1),
                  new Kh(e, this.wrap, e, n + 1, r + 1),
                ];
              }
              isLessThan(t) {
                return (
                  this.wrap < t.wrap ||
                  (!(this.wrap > t.wrap) &&
                    (this.overscaledZ < t.overscaledZ ||
                      (!(this.overscaledZ > t.overscaledZ) &&
                        (this.canonical.x < t.canonical.x ||
                          (!(this.canonical.x > t.canonical.x) &&
                            this.canonical.y < t.canonical.y)))))
                );
              }
              wrapped() {
                return new Kh(
                  this.overscaledZ,
                  0,
                  this.canonical.z,
                  this.canonical.x,
                  this.canonical.y
                );
              }
              unwrapTo(t) {
                return new Kh(
                  this.overscaledZ,
                  t,
                  this.canonical.z,
                  this.canonical.x,
                  this.canonical.y
                );
              }
              overscaleFactor() {
                return Math.pow(2, this.overscaledZ - this.canonical.z);
              }
              toUnwrapped() {
                return new Xh(this.wrap, this.canonical);
              }
              toString() {
                return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
              }
              getTilePoint(t) {
                return this.canonical.getTilePoint(
                  new Uh(t.x - this.wrap, t.y)
                );
              }
              getTileVec3(t) {
                return this.canonical.getTileVec3(
                  new Uh(t.x - this.wrap, t.y, t.z)
                );
              }
            }
            function Yh(t, e, n, r, i) {
              const o = 1 << Math.min(n, 22);
              let s = o * (i % o) + (r % o);
              return (
                t &&
                  n < 22 &&
                  (s +=
                    o *
                    o *
                    ((t < 0 ? -2 * t - 1 : 2 * t) % (1 << (2 * (22 - n))))),
                16 * (32 * s + n) + (e - n)
              );
            }
            li("CanonicalTileID", Hh),
              li("OverscaledTileID", Kh, { omit: ["projMatrix"] });
            class Qh {
              constructor(t) {
                (this._stringToNumber = {}), (this._numberToString = []);
                for (let e = 0; e < t.length; e++) {
                  const n = t[e];
                  (this._stringToNumber[n] = e), (this._numberToString[e] = n);
                }
              }
              encode(t) {
                return this._stringToNumber[t];
              }
              decode(t) {
                return this._numberToString[t];
              }
            }
            class Jh {
              constructor(t, e, n, r, i) {
                (this.type = "Feature"),
                  (this._vectorTileFeature = t),
                  (t._z = e),
                  (t._x = n),
                  (t._y = r),
                  (this.properties = t.properties),
                  (this.id = i);
              }
              get geometry() {
                return (
                  void 0 === this._geometry &&
                    (this._geometry = this._vectorTileFeature.toGeoJSON(
                      this._vectorTileFeature._x,
                      this._vectorTileFeature._y,
                      this._vectorTileFeature._z
                    ).geometry),
                  this._geometry
                );
              }
              set geometry(t) {
                this._geometry = t;
              }
              toJSON() {
                const t = { geometry: this.geometry };
                for (const e in this)
                  "_geometry" !== e &&
                    "_vectorTileFeature" !== e &&
                    (t[e] = this[e]);
                return t;
              }
            }
            var tp = Co([{ name: "a_pos", type: "Int16", components: 2 }]);
            class ep {
              constructor(t, e, n) {
                (this.tileID = t),
                  (this.uid = w()),
                  (this.uses = 0),
                  (this.tileSize = e),
                  (this.tileZoom = n),
                  (this.buckets = {}),
                  (this.expirationTime = null),
                  (this.queryPadding = 0),
                  (this.hasSymbolBuckets = !1),
                  (this.hasRTLText = !1),
                  (this.dependencies = {}),
                  (this.expiredRequestCount = 0),
                  (this.state = "loading");
              }
              registerFadeDuration(t) {
                const e = t + this.timeAdded;
                e < V.now() ||
                  (this.fadeEndTime && e < this.fadeEndTime) ||
                  (this.fadeEndTime = e);
              }
              wasRequested() {
                return (
                  "errored" === this.state ||
                  "loaded" === this.state ||
                  "reloading" === this.state
                );
              }
              loadVectorData(t, e, n) {
                if (
                  (this.hasData() && this.unloadVectorData(),
                  (this.state = "loaded"),
                  t)
                ) {
                  t.featureIndex &&
                    ((this.latestFeatureIndex = t.featureIndex),
                    t.rawTileData
                      ? ((this.latestRawTileData = t.rawTileData),
                        (this.latestFeatureIndex.rawTileData = t.rawTileData))
                      : this.latestRawTileData &&
                        (this.latestFeatureIndex.rawTileData =
                          this.latestRawTileData)),
                    (this.collisionBoxArray = t.collisionBoxArray),
                    (this.buckets = (function (t, e) {
                      const n = {};
                      if (!e) return n;
                      for (const r of t) {
                        const t = r.layerIds
                          .map((t) => e.getLayer(t))
                          .filter(Boolean);
                        if (0 !== t.length) {
                          (r.layers = t),
                            r.stateDependentLayerIds &&
                              (r.stateDependentLayers =
                                r.stateDependentLayerIds.map(
                                  (e) => t.filter((t) => t.id === e)[0]
                                ));
                          for (const e of t) n[e.id] = r;
                        }
                      }
                      return n;
                    })(t.buckets, e.style)),
                    (this.hasSymbolBuckets = !1);
                  for (const t in this.buckets) {
                    const e = this.buckets[t];
                    if (e instanceof fh) {
                      if (((this.hasSymbolBuckets = !0), !n)) break;
                      e.justReloaded = !0;
                    }
                  }
                  if (((this.hasRTLText = !1), this.hasSymbolBuckets))
                    for (const t in this.buckets) {
                      const e = this.buckets[t];
                      if (e instanceof fh && e.hasRTLText) {
                        (this.hasRTLText = !0),
                          so.isLoading() ||
                            so.isLoaded() ||
                            "deferred" !== io() ||
                            oo();
                        break;
                      }
                    }
                  this.queryPadding = 0;
                  for (const t in this.buckets) {
                    const n = this.buckets[t];
                    this.queryPadding = Math.max(
                      this.queryPadding,
                      e.style.getLayer(t).queryRadius(n)
                    );
                  }
                  t.imageAtlas && (this.imageAtlas = t.imageAtlas),
                    t.glyphAtlasImage &&
                      (this.glyphAtlasImage = t.glyphAtlasImage),
                    t.lineAtlas && (this.lineAtlas = t.lineAtlas);
                } else this.collisionBoxArray = new Qo();
              }
              unloadVectorData() {
                for (const t in this.buckets) this.buckets[t].destroy();
                (this.buckets = {}),
                  this.imageAtlas && (this.imageAtlas = null),
                  this.lineAtlas && (this.lineAtlas = null),
                  this.imageAtlasTexture && this.imageAtlasTexture.destroy(),
                  this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(),
                  this.lineAtlasTexture && this.lineAtlasTexture.destroy(),
                  (this.latestFeatureIndex = null),
                  (this.state = "unloaded");
              }
              getBucket(t) {
                return this.buckets[t.id];
              }
              upload(t) {
                for (const n in this.buckets) {
                  const e = this.buckets[n];
                  e.uploadPending() && e.upload(t);
                }
                const e = t.gl;
                this.imageAtlas &&
                  !this.imageAtlas.uploaded &&
                  ((this.imageAtlasTexture = new Oh(
                    t,
                    this.imageAtlas.image,
                    e.RGBA
                  )),
                  (this.imageAtlas.uploaded = !0)),
                  this.glyphAtlasImage &&
                    ((this.glyphAtlasTexture = new Oh(
                      t,
                      this.glyphAtlasImage,
                      e.ALPHA
                    )),
                    (this.glyphAtlasImage = null)),
                  this.lineAtlas &&
                    !this.lineAtlas.uploaded &&
                    ((this.lineAtlasTexture = new Oh(
                      t,
                      this.lineAtlas.image,
                      e.ALPHA
                    )),
                    (this.lineAtlas.uploaded = !0));
              }
              prepare(t) {
                this.imageAtlas &&
                  this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture);
              }
              queryRenderedFeatures(t, e, n, r, i, o, s, a) {
                return this.latestFeatureIndex &&
                  this.latestFeatureIndex.rawTileData
                  ? this.latestFeatureIndex.query(
                      {
                        tileResult: r,
                        pixelPosMatrix: s,
                        transform: o,
                        params: i,
                      },
                      t,
                      e,
                      n
                    )
                  : {};
              }
              querySourceFeatures(t, e) {
                const n = this.latestFeatureIndex;
                if (!n || !n.rawTileData) return;
                const r = n.loadVTLayers(),
                  i = e ? e.sourceLayer : "",
                  o = r._geojsonTileLayer || r[i];
                if (!o) return;
                const s = Tr(e && e.filter),
                  { z: a, x: l, y: c } = this.tileID.canonical,
                  u = { z: a, x: l, y: c };
                for (let h = 0; h < o.length; h++) {
                  const e = o.feature(h);
                  if (s.needGeometry) {
                    const t = Ws(e, !0);
                    if (
                      !s.filter(
                        new ao(this.tileID.overscaledZ),
                        t,
                        this.tileID.canonical
                      )
                    )
                      continue;
                  } else if (!s.filter(new ao(this.tileID.overscaledZ), e))
                    continue;
                  const r = n.getId(e, i),
                    p = new Jh(e, a, l, c, r);
                  (p.tile = u), t.push(p);
                }
              }
              hasData() {
                return (
                  "loaded" === this.state ||
                  "reloading" === this.state ||
                  "expired" === this.state
                );
              }
              patternsLoaded() {
                return (
                  this.imageAtlas &&
                  !!Object.keys(this.imageAtlas.patternPositions).length
                );
              }
              setExpiryData(t) {
                const e = this.expirationTime;
                if (t.cacheControl) {
                  const e = L(t.cacheControl);
                  e["max-age"] &&
                    (this.expirationTime = Date.now() + 1e3 * e["max-age"]);
                } else t.expires && (this.expirationTime = new Date(t.expires).getTime());
                if (this.expirationTime) {
                  const t = Date.now();
                  let n = !1;
                  if (this.expirationTime > t) n = !1;
                  else if (e)
                    if (this.expirationTime < e) n = !0;
                    else {
                      const r = this.expirationTime - e;
                      r
                        ? (this.expirationTime = t + Math.max(r, 3e4))
                        : (n = !0);
                    }
                  else n = !0;
                  n
                    ? (this.expiredRequestCount++, (this.state = "expired"))
                    : (this.expiredRequestCount = 0);
                }
              }
              getExpiryTimeout() {
                if (this.expirationTime)
                  return this.expiredRequestCount
                    ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31))
                    : Math.min(
                        this.expirationTime - new Date().getTime(),
                        Math.pow(2, 31) - 1
                      );
              }
              setFeatureState(t, e) {
                if (
                  !this.latestFeatureIndex ||
                  !this.latestFeatureIndex.rawTileData ||
                  0 === Object.keys(t).length
                )
                  return;
                const n = this.latestFeatureIndex.loadVTLayers();
                for (const r in this.buckets) {
                  if (!e.style.hasLayer(r)) continue;
                  const i = this.buckets[r],
                    o = i.layers[0].sourceLayer || "_geojsonTileLayer",
                    s = n[o],
                    a = t[o];
                  if (!s || !a || 0 === Object.keys(a).length) continue;
                  i.update(
                    a,
                    s,
                    (this.imageAtlas && this.imageAtlas.patternPositions) || {}
                  );
                  const l = e && e.style && e.style.getLayer(r);
                  l &&
                    (this.queryPadding = Math.max(
                      this.queryPadding,
                      l.queryRadius(i)
                    ));
                }
              }
              holdingForFade() {
                return void 0 !== this.symbolFadeHoldUntil;
              }
              symbolFadeFinished() {
                return (
                  !this.symbolFadeHoldUntil ||
                  this.symbolFadeHoldUntil < V.now()
                );
              }
              clearFadeHold() {
                this.symbolFadeHoldUntil = void 0;
              }
              setHoldDuration(t) {
                this.symbolFadeHoldUntil = V.now() + t;
              }
              setDependencies(t, e) {
                const n = {};
                for (const r of e) n[r] = !0;
                this.dependencies[t] = n;
              }
              hasDependency(t, e) {
                for (const n of t) {
                  const t = this.dependencies[n];
                  if (t) for (const n of e) if (t[n]) return !0;
                }
                return !1;
              }
              clearQueryDebugViz() {}
            }
            class np {
              constructor() {
                (this.state = {}),
                  (this.stateChanges = {}),
                  (this.deletedStates = {});
              }
              updateState(t, e, n) {
                const r = String(e);
                if (
                  ((this.stateChanges[t] = this.stateChanges[t] || {}),
                  (this.stateChanges[t][r] = this.stateChanges[t][r] || {}),
                  b(this.stateChanges[t][r], n),
                  null === this.deletedStates[t])
                ) {
                  this.deletedStates[t] = {};
                  for (const e in this.state[t])
                    e !== r && (this.deletedStates[t][e] = null);
                } else if (
                  this.deletedStates[t] &&
                  null === this.deletedStates[t][r]
                ) {
                  this.deletedStates[t][r] = {};
                  for (const e in this.state[t][r])
                    n[e] || (this.deletedStates[t][r][e] = null);
                } else
                  for (const i in n)
                    this.deletedStates[t] &&
                      this.deletedStates[t][r] &&
                      null === this.deletedStates[t][r][i] &&
                      delete this.deletedStates[t][r][i];
              }
              removeFeatureState(t, e, n) {
                if (null === this.deletedStates[t]) return;
                const r = String(e);
                if (
                  ((this.deletedStates[t] = this.deletedStates[t] || {}),
                  n && void 0 !== e)
                )
                  null !== this.deletedStates[t][r] &&
                    ((this.deletedStates[t][r] =
                      this.deletedStates[t][r] || {}),
                    (this.deletedStates[t][r][n] = null));
                else if (void 0 !== e)
                  if (this.stateChanges[t] && this.stateChanges[t][r])
                    for (n in ((this.deletedStates[t][r] = {}),
                    this.stateChanges[t][r]))
                      this.deletedStates[t][r][n] = null;
                  else this.deletedStates[t][r] = null;
                else this.deletedStates[t] = null;
              }
              getState(t, e) {
                const n = String(e),
                  r = b(
                    {},
                    (this.state[t] || {})[n],
                    (this.stateChanges[t] || {})[n]
                  );
                if (null === this.deletedStates[t]) return {};
                if (this.deletedStates[t]) {
                  const n = this.deletedStates[t][e];
                  if (null === n) return {};
                  for (const t in n) delete r[t];
                }
                return r;
              }
              initializeTileState(t, e) {
                t.setFeatureState(this.state, e);
              }
              coalesceChanges(t, e) {
                const n = {};
                for (const r in this.stateChanges) {
                  this.state[r] = this.state[r] || {};
                  const t = {};
                  for (const e in this.stateChanges[r])
                    this.state[r][e] || (this.state[r][e] = {}),
                      b(this.state[r][e], this.stateChanges[r][e]),
                      (t[e] = this.state[r][e]);
                  n[r] = t;
                }
                for (const r in this.deletedStates) {
                  this.state[r] = this.state[r] || {};
                  const t = {};
                  if (null === this.deletedStates[r])
                    for (const e in this.state[r])
                      (t[e] = {}), (this.state[r][e] = {});
                  else
                    for (const e in this.deletedStates[r]) {
                      if (null === this.deletedStates[r][e])
                        this.state[r][e] = {};
                      else
                        for (const t of Object.keys(this.deletedStates[r][e]))
                          delete this.state[r][e][t];
                      t[e] = this.state[r][e];
                    }
                  (n[r] = n[r] || {}), b(n[r], t);
                }
                if (
                  ((this.stateChanges = {}),
                  (this.deletedStates = {}),
                  0 !== Object.keys(n).length)
                )
                  for (const r in t) t[r].setFeatureState(n, e);
              }
            }
            class rp {
              constructor(t) {
                (this.size = t),
                  (this.minimums = []),
                  (this.maximums = []),
                  (this.leaves = []);
              }
              getElevation(t, e) {
                const n = this.toIdx(t, e);
                return { min: this.minimums[n], max: this.maximums[n] };
              }
              isLeaf(t, e) {
                return this.leaves[this.toIdx(t, e)];
              }
              toIdx(t, e) {
                return e * this.size + t;
              }
            }
            function ip(t, e, n, r) {
              let i = 0,
                o = Number.MAX_VALUE;
              for (let s = 0; s < 3; s++)
                if (Math.abs(r[s]) < 1e-15) {
                  if (n[s] < t[s] || n[s] > e[s]) return null;
                } else {
                  const a = 1 / r[s];
                  let l = (t[s] - n[s]) * a,
                    c = (e[s] - n[s]) * a;
                  if (l > c) {
                    const t = l;
                    (l = c), (c = t);
                  }
                  if ((l > i && (i = l), c < o && (o = c), i > o)) return null;
                }
              return i;
            }
            function op(t, e, n, r, i, o, s, a, l, c, u) {
              const h = r - t,
                p = i - e,
                d = o - n,
                f = s - t,
                m = a - e,
                g = l - n,
                y = u[1] * g - u[2] * m,
                _ = u[2] * f - u[0] * g,
                v = u[0] * m - u[1] * f,
                b = h * y + p * _ + d * v;
              if (Math.abs(b) < 1e-15) return null;
              const x = 1 / b,
                w = c[0] - t,
                S = c[1] - e,
                E = c[2] - n,
                T = (w * y + S * _ + E * v) * x;
              if (T < 0 || T > 1) return null;
              const A = S * d - E * p,
                C = E * h - w * d,
                P = w * p - S * h,
                M = (u[0] * A + u[1] * C + u[2] * P) * x;
              return M < 0 || T + M > 1 ? null : (f * A + m * C + g * P) * x;
            }
            function sp(t, e, n) {
              return (t - e) / (n - e);
            }
            function ap(t, e, n, r, i, o, s, a, l) {
              const c = 1 << n,
                u = o - r,
                h = s - i,
                p = ((t + 1) / c) * u + r,
                d = ((e + 0) / c) * h + i,
                f = ((e + 1) / c) * h + i;
              (a[0] = ((t + 0) / c) * u + r),
                (a[1] = d),
                (l[0] = p),
                (l[1] = f);
            }
            class lp {
              constructor(t) {
                if (
                  ((this.maximums = []),
                  (this.minimums = []),
                  (this.leaves = []),
                  (this.childOffsets = []),
                  (this.nodeCount = 0),
                  (this.dem = t),
                  (this._siblingOffset = [
                    [0, 0],
                    [1, 0],
                    [0, 1],
                    [1, 1],
                  ]),
                  !this.dem)
                )
                  return;
                const e = (function (t) {
                    const e = Math.ceil(Math.log2(t.dim / 8)),
                      n = [];
                    let r = Math.ceil(Math.pow(2, e));
                    const i = 1 / r,
                      o = (t, e, n, r, i) => {
                        const o = r ? 1 : 0,
                          s = (t + 1) * n - o,
                          a = e * n,
                          l = (e + 1) * n - o;
                        (i[0] = t * n), (i[1] = a), (i[2] = s), (i[3] = l);
                      };
                    let s = new rp(r);
                    const a = [];
                    for (let l = 0; l < r * r; l++) {
                      o(l % r, Math.floor(l / r), i, !1, a);
                      const e = up(a[0], a[1], t),
                        n = up(a[2], a[1], t),
                        c = up(a[2], a[3], t),
                        u = up(a[0], a[3], t);
                      s.minimums.push(Math.min(e, n, c, u)),
                        s.maximums.push(Math.max(e, n, c, u)),
                        s.leaves.push(1);
                    }
                    for (n.push(s), r /= 2; r >= 1; r /= 2) {
                      const t = n[n.length - 1];
                      s = new rp(r);
                      for (let e = 0; e < r * r; e++) {
                        o(e % r, Math.floor(e / r), 2, !0, a);
                        const n = t.getElevation(a[0], a[1]),
                          i = t.getElevation(a[2], a[1]),
                          l = t.getElevation(a[2], a[3]),
                          c = t.getElevation(a[0], a[3]),
                          u = t.isLeaf(a[0], a[1]),
                          h = t.isLeaf(a[2], a[1]),
                          p = t.isLeaf(a[2], a[3]),
                          d = t.isLeaf(a[0], a[3]),
                          f = Math.min(n.min, i.min, l.min, c.min),
                          m = Math.max(n.max, i.max, l.max, c.max),
                          g = u && h && p && d;
                        s.maximums.push(m),
                          s.minimums.push(f),
                          s.leaves.push(m - f <= 5 && g ? 1 : 0);
                      }
                      n.push(s);
                    }
                    return n;
                  })(this.dem),
                  n = e.length - 1,
                  r = e[n];
                this._addNode(r.minimums[0], r.maximums[0], r.leaves[0]),
                  this._construct(e, 0, 0, n, 0);
              }
              raycastRoot(t, e, n, r, i, o, s = 1) {
                return ip([t, e, -100], [n, r, this.maximums[0] * s], i, o);
              }
              raycast(t, e, n, r, i, o, s = 1) {
                if (!this.nodeCount) return null;
                const a = this.raycastRoot(t, e, n, r, i, o, s);
                if (null == a) return null;
                const l = [],
                  c = [],
                  u = [],
                  h = [],
                  p = [{ idx: 0, t: a, nodex: 0, nodey: 0, depth: 0 }];
                for (; p.length > 0; ) {
                  const {
                    idx: a,
                    t: d,
                    nodex: f,
                    nodey: m,
                    depth: g,
                  } = p.pop();
                  if (this.leaves[a]) {
                    ap(f, m, g, t, e, n, r, u, h);
                    const a = 1 << g,
                      l = (f + 0) / a,
                      c = (f + 1) / a,
                      p = (m + 0) / a,
                      y = (m + 1) / a,
                      _ = up(l, p, this.dem) * s,
                      v = up(c, p, this.dem) * s,
                      b = up(c, y, this.dem) * s,
                      x = up(l, y, this.dem) * s,
                      w = op(u[0], u[1], _, h[0], u[1], v, h[0], h[1], b, i, o),
                      S = op(h[0], h[1], b, u[0], h[1], x, u[0], u[1], _, i, o),
                      E = Math.min(
                        null !== w ? w : Number.MAX_VALUE,
                        null !== S ? S : Number.MAX_VALUE
                      );
                    if (E !== Number.MAX_VALUE) return E;
                    {
                      const t = Ea([], i, o, d);
                      if (
                        cp(
                          _,
                          v,
                          x,
                          b,
                          sp(t[0], u[0], h[0]),
                          sp(t[1], u[1], h[1])
                        ) >= t[2]
                      )
                        return d;
                    }
                    continue;
                  }
                  let y = 0;
                  for (let p = 0; p < this._siblingOffset.length; p++) {
                    ap(
                      (f << 1) + this._siblingOffset[p][0],
                      (m << 1) + this._siblingOffset[p][1],
                      g + 1,
                      t,
                      e,
                      n,
                      r,
                      u,
                      h
                    ),
                      (u[2] = -100),
                      (h[2] = this.maximums[this.childOffsets[a] + p] * s);
                    const d = ip(u, h, i, o);
                    if (null != d) {
                      const t = d;
                      l[p] = t;
                      let e = !1;
                      for (let n = 0; n < y && !e; n++)
                        t >= l[c[n]] && (c.splice(n, 0, p), (e = !0));
                      e || (c[y] = p), y++;
                    }
                  }
                  for (let t = 0; t < y; t++) {
                    const e = c[t];
                    p.push({
                      idx: this.childOffsets[a] + e,
                      t: l[e],
                      nodex: (f << 1) + this._siblingOffset[e][0],
                      nodey: (m << 1) + this._siblingOffset[e][1],
                      depth: g + 1,
                    });
                  }
                }
                return null;
              }
              _addNode(t, e, n) {
                return (
                  this.minimums.push(t),
                  this.maximums.push(e),
                  this.leaves.push(n),
                  this.childOffsets.push(0),
                  this.nodeCount++
                );
              }
              _construct(t, e, n, r, i) {
                if (1 === t[r].isLeaf(e, n)) return;
                this.childOffsets[i] || (this.childOffsets[i] = this.nodeCount);
                const o = r - 1,
                  s = t[o];
                let a,
                  l = 0;
                for (let c = 0; c < this._siblingOffset.length; c++) {
                  const t = 2 * e + this._siblingOffset[c][0],
                    r = 2 * n + this._siblingOffset[c][1],
                    i = s.getElevation(t, r),
                    o = s.isLeaf(t, r),
                    u = this._addNode(i.min, i.max, o);
                  o && (l |= 1 << c), a || (a = u);
                }
                for (let c = 0; c < this._siblingOffset.length; c++)
                  l & (1 << c) ||
                    this._construct(
                      t,
                      2 * e + this._siblingOffset[c][0],
                      2 * n + this._siblingOffset[c][1],
                      o,
                      a + c
                    );
              }
            }
            function cp(t, e, n, r, i, o) {
              return rn(rn(t, n, o), rn(e, r, o), i);
            }
            function up(t, e, n) {
              const r = n.dim,
                i = g(t * r - 0.5, 0, r - 1),
                o = g(e * r - 0.5, 0, r - 1),
                s = Math.floor(i),
                a = Math.floor(o),
                l = Math.min(s + 1, r - 1),
                c = Math.min(a + 1, r - 1);
              return cp(
                n.get(s, a),
                n.get(l, a),
                n.get(s, c),
                n.get(l, c),
                i - s,
                o - a
              );
            }
            const hp = {
              mapbox: [6553.6, 25.6, 0.1, 1e4],
              terrarium: [256, 1, 1 / 256, 32768],
            };
            class pp {
              get tree() {
                return this._tree || this._buildQuadTree(), this._tree;
              }
              constructor(t, e, n, r = !1, i = !1) {
                if (((this.uid = t), e.height !== e.width))
                  throw new RangeError("DEM tiles must be square");
                if (n && "mapbox" !== n && "terrarium" !== n)
                  return I(
                    `"${n}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`
                  );
                this.stride = e.height;
                const o = (this.dim = e.height - 2);
                if (
                  ((this.data = new Uint32Array(e.data.buffer)),
                  (this.encoding = n || "mapbox"),
                  (this.borderReady = r),
                  !r)
                ) {
                  for (let t = 0; t < o; t++)
                    (this.data[this._idx(-1, t)] = this.data[this._idx(0, t)]),
                      (this.data[this._idx(o, t)] =
                        this.data[this._idx(o - 1, t)]),
                      (this.data[this._idx(t, -1)] =
                        this.data[this._idx(t, 0)]),
                      (this.data[this._idx(t, o)] =
                        this.data[this._idx(t, o - 1)]);
                  (this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)]),
                    (this.data[this._idx(o, -1)] =
                      this.data[this._idx(o - 1, 0)]),
                    (this.data[this._idx(-1, o)] =
                      this.data[this._idx(0, o - 1)]),
                    (this.data[this._idx(o, o)] =
                      this.data[this._idx(o - 1, o - 1)]),
                    i && this._buildQuadTree();
                }
              }
              _buildQuadTree() {
                this._tree = new lp(this);
              }
              get(t, e, n = !1) {
                const r = new Uint8Array(this.data.buffer);
                n && ((t = g(t, -1, this.dim)), (e = g(e, -1, this.dim)));
                const i = 4 * this._idx(t, e);
                return (
                  "terrarium" === this.encoding
                    ? this._unpackTerrarium
                    : this._unpackMapbox
                )(r[i], r[i + 1], r[i + 2]);
              }
              static getUnpackVector(t) {
                return hp[t];
              }
              get unpackVector() {
                return hp[this.encoding];
              }
              _idx(t, e) {
                if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1)
                  throw new RangeError(
                    "out of range source coordinates for DEM data"
                  );
                return (e + 1) * this.stride + (t + 1);
              }
              _unpackMapbox(t, e, n) {
                return (256 * t * 256 + 256 * e + n) / 10 - 1e4;
              }
              _unpackTerrarium(t, e, n) {
                return 256 * t + e + n / 256 - 32768;
              }
              static pack(t, e) {
                const n = [0, 0, 0, 0],
                  r = pp.getUnpackVector(e);
                let i = Math.floor((t + r[3]) / r[2]);
                return (
                  (n[2] = i % 256),
                  (i = Math.floor(i / 256)),
                  (n[1] = i % 256),
                  (i = Math.floor(i / 256)),
                  (n[0] = i),
                  n
                );
              }
              getPixels() {
                return new qa(
                  { width: this.stride, height: this.stride },
                  new Uint8Array(this.data.buffer)
                );
              }
              backfillBorder(t, e, n) {
                if (this.dim !== t.dim)
                  throw new Error("dem dimension mismatch");
                let r = e * this.dim,
                  i = e * this.dim + this.dim,
                  o = n * this.dim,
                  s = n * this.dim + this.dim;
                switch (e) {
                  case -1:
                    r = i - 1;
                    break;
                  case 1:
                    i = r + 1;
                }
                switch (n) {
                  case -1:
                    o = s - 1;
                    break;
                  case 1:
                    s = o + 1;
                }
                const a = -e * this.dim,
                  l = -n * this.dim;
                for (let c = o; c < s; c++)
                  for (let e = r; e < i; e++)
                    this.data[this._idx(e, c)] =
                      t.data[this._idx(e + a, c + l)];
              }
              onDeserialize() {
                this._tree && (this._tree.dem = this);
              }
            }
            li("DEMData", pp), li("DemMinMaxQuadTree", lp, { omit: ["dem"] });
            class dp {
              constructor(t, e) {
                (this.max = t), (this.onRemove = e), this.reset();
              }
              reset() {
                for (const t in this.data)
                  for (const e of this.data[t])
                    e.timeout && clearTimeout(e.timeout),
                      this.onRemove(e.value);
                return (this.data = {}), (this.order = []), this;
              }
              add(t, e, n) {
                const r = t.wrapped().key;
                void 0 === this.data[r] && (this.data[r] = []);
                const i = { value: e, timeout: void 0 };
                if (
                  (void 0 !== n &&
                    (i.timeout = setTimeout(() => {
                      this.remove(t, i);
                    }, n)),
                  this.data[r].push(i),
                  this.order.push(r),
                  this.order.length > this.max)
                ) {
                  const t = this._getAndRemoveByKey(this.order[0]);
                  t && this.onRemove(t);
                }
                return this;
              }
              has(t) {
                return t.wrapped().key in this.data;
              }
              getAndRemove(t) {
                return this.has(t)
                  ? this._getAndRemoveByKey(t.wrapped().key)
                  : null;
              }
              _getAndRemoveByKey(t) {
                const e = this.data[t].shift();
                return (
                  e.timeout && clearTimeout(e.timeout),
                  0 === this.data[t].length && delete this.data[t],
                  this.order.splice(this.order.indexOf(t), 1),
                  e.value
                );
              }
              getByKey(t) {
                const e = this.data[t];
                return e ? e[0].value : null;
              }
              get(t) {
                return this.has(t) ? this.data[t.wrapped().key][0].value : null;
              }
              remove(t, e) {
                if (!this.has(t)) return this;
                const n = t.wrapped().key,
                  r = void 0 === e ? 0 : this.data[n].indexOf(e),
                  i = this.data[n][r];
                return (
                  this.data[n].splice(r, 1),
                  i.timeout && clearTimeout(i.timeout),
                  0 === this.data[n].length && delete this.data[n],
                  this.onRemove(i.value),
                  this.order.splice(this.order.indexOf(n), 1),
                  this
                );
              }
              setMaxSize(t) {
                for (this.max = t; this.order.length > this.max; ) {
                  const t = this._getAndRemoveByKey(this.order[0]);
                  t && this.onRemove(t);
                }
                return this;
              }
              filter(t) {
                const e = [];
                for (const n in this.data)
                  for (const r of this.data[n]) t(r.value) || e.push(r);
                for (const n of e) this.remove(n.value.tileID, n);
              }
            }
            class fp {
              constructor(t, e, n) {
                (this.func = t), (this.mask = e), (this.range = n);
              }
            }
            (fp.ReadOnly = !1),
              (fp.ReadWrite = !0),
              (fp.disabled = new fp(519, fp.ReadOnly, [0, 1]));
            const mp = 7680;
            class gp {
              constructor(t, e, n, r, i, o) {
                (this.test = t),
                  (this.ref = e),
                  (this.mask = n),
                  (this.fail = r),
                  (this.depthFail = i),
                  (this.pass = o);
              }
            }
            gp.disabled = new gp({ func: 519, mask: 0 }, 0, 0, mp, mp, mp);
            class yp {
              constructor(t, e, n) {
                (this.blendFunction = t),
                  (this.blendColor = e),
                  (this.mask = n);
              }
            }
            (yp.Replace = [1, 0]),
              (yp.disabled = new yp(yp.Replace, he.transparent, [
                !1,
                !1,
                !1,
                !1,
              ])),
              (yp.unblended = new yp(yp.Replace, he.transparent, [
                !0,
                !0,
                !0,
                !0,
              ])),
              (yp.alphaBlended = new yp([1, 771], he.transparent, [
                !0,
                !0,
                !0,
                !0,
              ]));
            const _p = 1029,
              vp = 2305;
            class bp {
              constructor(t, e, n) {
                (this.enable = t), (this.mode = e), (this.frontFace = n);
              }
            }
            (bp.disabled = new bp(!1, _p, vp)),
              (bp.backCCW = new bp(!0, _p, vp)),
              (bp.backCW = new bp(!0, _p, 2304)),
              (bp.frontCW = new bp(!0, 1028, 2304)),
              (bp.frontCCW = new bp(!0, 1028, vp));
            class xp extends Bt {
              constructor(t, e, n) {
                super(),
                  (this.id = t),
                  (this._onlySymbols = n),
                  e.on("data", (t) => {
                    "source" === t.dataType &&
                      "metadata" === t.sourceDataType &&
                      (this._sourceLoaded = !0),
                      this._sourceLoaded &&
                        !this._paused &&
                        "source" === t.dataType &&
                        "content" === t.sourceDataType &&
                        (this.reload(),
                        this.transform && this.update(this.transform));
                  }),
                  e.on("error", () => {
                    this._sourceErrored = !0;
                  }),
                  (this._source = e),
                  (this._tiles = {}),
                  (this._cache = new dp(0, this._unloadTile.bind(this))),
                  (this._timers = {}),
                  (this._cacheTimers = {}),
                  (this._maxTileCacheSize = null),
                  (this._loadedParentTiles = {}),
                  (this._coveredTiles = {}),
                  (this._state = new np());
              }
              onAdd(t) {
                (this.map = t),
                  (this._maxTileCacheSize = t ? t._maxTileCacheSize : null);
              }
              loaded() {
                if (this._sourceErrored) return !0;
                if (!this._sourceLoaded) return !1;
                if (!this._source.loaded()) return !1;
                for (const t in this._tiles) {
                  const e = this._tiles[t];
                  if ("loaded" !== e.state && "errored" !== e.state) return !1;
                }
                return !0;
              }
              getSource() {
                return this._source;
              }
              pause() {
                this._paused = !0;
              }
              resume() {
                if (!this._paused) return;
                const t = this._shouldReloadOnResume;
                (this._paused = !1),
                  (this._shouldReloadOnResume = !1),
                  t && this.reload(),
                  this.transform && this.update(this.transform);
              }
              _loadTile(t, e) {
                return (
                  (t.isSymbolTile = this._onlySymbols),
                  this._source.loadTile(t, e)
                );
              }
              _unloadTile(t) {
                if (this._source.unloadTile)
                  return this._source.unloadTile(t, () => {});
              }
              _abortTile(t) {
                if (this._source.abortTile)
                  return this._source.abortTile(t, () => {});
              }
              serialize() {
                return this._source.serialize();
              }
              prepare(t) {
                this._source.prepare && this._source.prepare(),
                  this._state.coalesceChanges(
                    this._tiles,
                    this.map ? this.map.painter : null
                  );
                for (const e in this._tiles) {
                  const n = this._tiles[e];
                  n.upload(t), n.prepare(this.map.style.imageManager);
                }
              }
              getIds() {
                return v(this._tiles)
                  .map((t) => t.tileID)
                  .sort(wp)
                  .map((t) => t.key);
              }
              getRenderableIds(t) {
                const e = [];
                for (const n in this._tiles)
                  this._isIdRenderable(+n, t) && e.push(this._tiles[n]);
                return t
                  ? e
                      .sort((t, e) => {
                        const n = t.tileID,
                          r = e.tileID,
                          i = new o(n.canonical.x, n.canonical.y)._rotate(
                            this.transform.angle
                          ),
                          s = new o(r.canonical.x, r.canonical.y)._rotate(
                            this.transform.angle
                          );
                        return (
                          n.overscaledZ - r.overscaledZ ||
                          s.y - i.y ||
                          s.x - i.x
                        );
                      })
                      .map((t) => t.tileID.key)
                  : e
                      .map((t) => t.tileID)
                      .sort(wp)
                      .map((t) => t.key);
              }
              hasRenderableParent(t) {
                const e = this.findLoadedParent(t, 0);
                return !!e && this._isIdRenderable(e.tileID.key);
              }
              _isIdRenderable(t, e) {
                return (
                  this._tiles[t] &&
                  this._tiles[t].hasData() &&
                  !this._coveredTiles[t] &&
                  (e || !this._tiles[t].holdingForFade())
                );
              }
              reload() {
                if (this._paused) this._shouldReloadOnResume = !0;
                else {
                  this._cache.reset();
                  for (const t in this._tiles)
                    "errored" !== this._tiles[t].state &&
                      this._reloadTile(+t, "reloading");
                }
              }
              _reloadTile(t, e) {
                const n = this._tiles[t];
                n &&
                  ("loading" !== n.state && (n.state = e),
                  this._loadTile(n, this._tileLoaded.bind(this, n, t, e)));
              }
              _tileLoaded(t, e, n, r) {
                if (r)
                  return (
                    (t.state = "errored"),
                    void (404 !== r.status
                      ? this._source.fire(new Ft(r, { tile: t }))
                      : this.update(this.transform))
                  );
                (t.timeAdded = V.now()),
                  "expired" === n && (t.refreshedUponExpiration = !0),
                  this._setTileReloadTimer(e, t),
                  "raster-dem" === this.getSource().type &&
                    t.dem &&
                    this._backfillDEM(t),
                  this._state.initializeTileState(
                    t,
                    this.map ? this.map.painter : null
                  ),
                  this._source.fire(
                    new Lt("data", {
                      dataType: "source",
                      tile: t,
                      coord: t.tileID,
                      sourceCacheId: this.id,
                    })
                  );
              }
              _backfillDEM(t) {
                const e = this.getRenderableIds();
                for (let r = 0; r < e.length; r++) {
                  const i = e[r];
                  if (t.neighboringTiles && t.neighboringTiles[i]) {
                    const e = this.getTileByID(i);
                    n(t, e), n(e, t);
                  }
                }
                function n(t, e) {
                  if (!t.dem || t.dem.borderReady) return;
                  (t.needsHillshadePrepare = !0),
                    (t.needsDEMTextureUpload = !0);
                  let n = e.tileID.canonical.x - t.tileID.canonical.x;
                  const r = e.tileID.canonical.y - t.tileID.canonical.y,
                    i = Math.pow(2, t.tileID.canonical.z),
                    o = e.tileID.key;
                  (0 === n && 0 === r) ||
                    Math.abs(r) > 1 ||
                    (Math.abs(n) > 1 &&
                      (1 === Math.abs(n + i)
                        ? (n += i)
                        : 1 === Math.abs(n - i) && (n -= i)),
                    e.dem &&
                      t.dem &&
                      (t.dem.backfillBorder(e.dem, n, r),
                      t.neighboringTiles &&
                        t.neighboringTiles[o] &&
                        (t.neighboringTiles[o].backfilled = !0)));
                }
              }
              getTile(t) {
                return this.getTileByID(t.key);
              }
              getTileByID(t) {
                return this._tiles[t];
              }
              _retainLoadedChildren(t, e, n, r) {
                for (const i in this._tiles) {
                  let o = this._tiles[i];
                  if (
                    r[i] ||
                    !o.hasData() ||
                    o.tileID.overscaledZ <= e ||
                    o.tileID.overscaledZ > n
                  )
                    continue;
                  let s = o.tileID;
                  for (; o && o.tileID.overscaledZ > e + 1; ) {
                    const t = o.tileID.scaledTo(o.tileID.overscaledZ - 1);
                    (o = this._tiles[t.key]), o && o.hasData() && (s = t);
                  }
                  let a = s;
                  for (; a.overscaledZ > e; )
                    if (((a = a.scaledTo(a.overscaledZ - 1)), t[a.key])) {
                      r[s.key] = s;
                      break;
                    }
                }
              }
              findLoadedParent(t, e) {
                if (t.key in this._loadedParentTiles) {
                  const n = this._loadedParentTiles[t.key];
                  return n && n.tileID.overscaledZ >= e ? n : null;
                }
                for (let n = t.overscaledZ - 1; n >= e; n--) {
                  const e = t.scaledTo(n),
                    r = this._getLoadedTile(e);
                  if (r) return r;
                }
              }
              _getLoadedTile(t) {
                const e = this._tiles[t.key];
                return e && e.hasData()
                  ? e
                  : this._cache.getByKey(
                      this._source.reparseOverscaled
                        ? t.wrapped().key
                        : t.canonical.key
                    );
              }
              updateCacheSize(t, e) {
                e = e || this._source.tileSize;
                const n = Math.ceil(t.width / e) + 1,
                  r = Math.ceil(t.height / e) + 1,
                  i = Math.floor(n * r * 5),
                  o =
                    "number" == typeof this._maxTileCacheSize
                      ? Math.min(this._maxTileCacheSize, i)
                      : i;
                this._cache.setMaxSize(o);
              }
              handleWrapJump(t) {
                const e = Math.round(
                  (t - (void 0 === this._prevLng ? t : this._prevLng)) / 360
                );
                if (((this._prevLng = t), e)) {
                  const t = {};
                  for (const n in this._tiles) {
                    const r = this._tiles[n];
                    (r.tileID = r.tileID.unwrapTo(r.tileID.wrap + e)),
                      (t[r.tileID.key] = r);
                  }
                  this._tiles = t;
                  for (const e in this._timers)
                    clearTimeout(this._timers[e]), delete this._timers[e];
                  for (const e in this._tiles)
                    this._setTileReloadTimer(+e, this._tiles[e]);
                }
              }
              update(t, e, n) {
                if (
                  ((this.transform = t),
                  !this._sourceLoaded ||
                    this._paused ||
                    this.transform.freezeTileCoverage)
                )
                  return;
                if (this.usedForTerrain && !n) return;
                let r;
                this.updateCacheSize(t, e),
                  this.handleWrapJump(this.transform.center.lng),
                  (this._coveredTiles = {}),
                  this.used || this.usedForTerrain
                    ? this._source.tileID
                      ? (r = t
                          .getVisibleUnwrappedCoordinates(this._source.tileID)
                          .map(
                            (t) =>
                              new Kh(
                                t.canonical.z,
                                t.wrap,
                                t.canonical.z,
                                t.canonical.x,
                                t.canonical.y
                              )
                          ))
                      : ((r = t.coveringTiles({
                          tileSize: e || this._source.tileSize,
                          minzoom: this._source.minzoom,
                          maxzoom: this._source.maxzoom,
                          roundZoom: this._source.roundZoom && !n,
                          reparseOverscaled: this._source.reparseOverscaled,
                          isTerrainDEM: this.usedForTerrain,
                        })),
                        this._source.hasTile &&
                          (r = r.filter((t) => this._source.hasTile(t))))
                    : (r = []);
                const i = this._updateRetainedTiles(r);
                if (Sp(this._source.type) && 0 !== r.length) {
                  const t = {},
                    e = {},
                    n = Object.keys(i);
                  for (const r of n) {
                    const n = i[r],
                      o = this._tiles[r];
                    if (!o || (o.fadeEndTime && o.fadeEndTime <= V.now()))
                      continue;
                    const s = this.findLoadedParent(
                      n,
                      Math.max(
                        n.overscaledZ - xp.maxOverzooming,
                        this._source.minzoom
                      )
                    );
                    s &&
                      (this._addTile(s.tileID), (t[s.tileID.key] = s.tileID)),
                      (e[r] = n);
                  }
                  const o = r[r.length - 1].overscaledZ;
                  for (const r in this._tiles) {
                    const t = this._tiles[r];
                    if (i[r] || !t.hasData()) continue;
                    let n = t.tileID;
                    for (; n.overscaledZ > o; ) {
                      n = n.scaledTo(n.overscaledZ - 1);
                      const o = this._tiles[n.key];
                      if (o && o.hasData() && e[n.key]) {
                        i[r] = t.tileID;
                        break;
                      }
                    }
                  }
                  for (const r in t)
                    i[r] || ((this._coveredTiles[r] = !0), (i[r] = t[r]));
                }
                for (const s in i) this._tiles[s].clearFadeHold();
                const o = (function (t, e) {
                  const n = [];
                  for (const r in t) r in e || n.push(r);
                  return n;
                })(this._tiles, i);
                for (const s of o) {
                  const t = this._tiles[s];
                  t.hasSymbolBuckets && !t.holdingForFade()
                    ? t.setHoldDuration(this.map._fadeDuration)
                    : (t.hasSymbolBuckets && !t.symbolFadeFinished()) ||
                      this._removeTile(+s);
                }
                this._updateLoadedParentTileCache(),
                  this._onlySymbols &&
                    this._source.afterUpdate &&
                    this._source.afterUpdate();
              }
              releaseSymbolFadeTiles() {
                for (const t in this._tiles)
                  this._tiles[t].holdingForFade() && this._removeTile(+t);
              }
              _updateRetainedTiles(t) {
                const e = {};
                if (0 === t.length) return e;
                const n = {},
                  r = t[t.length - 1].overscaledZ,
                  i = t[0].overscaledZ,
                  o = Math.max(i - xp.maxOverzooming, this._source.minzoom),
                  s = Math.max(i + xp.maxUnderzooming, this._source.minzoom),
                  a = {};
                for (const l of t) {
                  const t = this._addTile(l);
                  (e[l.key] = l),
                    t.hasData() || (r < this._source.maxzoom && (a[l.key] = l));
                }
                this._retainLoadedChildren(a, r, s, e);
                for (const l of t) {
                  let t = this._tiles[l.key];
                  if (t.hasData()) continue;
                  if (l.canonical.z >= this._source.maxzoom) {
                    const t = l.children(this._source.maxzoom)[0],
                      n = this.getTile(t);
                    if (n && n.hasData()) {
                      e[t.key] = t;
                      continue;
                    }
                  } else {
                    const t = l.children(this._source.maxzoom);
                    if (
                      e[t[0].key] &&
                      e[t[1].key] &&
                      e[t[2].key] &&
                      e[t[3].key]
                    )
                      continue;
                  }
                  let r = t.wasRequested();
                  for (let i = l.overscaledZ - 1; i >= o; --i) {
                    const o = l.scaledTo(i);
                    if (n[o.key]) break;
                    if (
                      ((n[o.key] = !0),
                      (t = this.getTile(o)),
                      !t && r && (t = this._addTile(o)),
                      t &&
                        ((e[o.key] = o), (r = t.wasRequested()), t.hasData()))
                    )
                      break;
                  }
                }
                return e;
              }
              _updateLoadedParentTileCache() {
                this._loadedParentTiles = {};
                for (const t in this._tiles) {
                  const e = [];
                  let n,
                    r = this._tiles[t].tileID;
                  for (; r.overscaledZ > 0; ) {
                    if (r.key in this._loadedParentTiles) {
                      n = this._loadedParentTiles[r.key];
                      break;
                    }
                    e.push(r.key);
                    const t = r.scaledTo(r.overscaledZ - 1);
                    if (((n = this._getLoadedTile(t)), n)) break;
                    r = t;
                  }
                  for (const t of e) this._loadedParentTiles[t] = n;
                }
              }
              _addTile(t) {
                let e = this._tiles[t.key];
                if (e) return e;
                (e = this._cache.getAndRemove(t)),
                  e &&
                    (this._setTileReloadTimer(t.key, e),
                    (e.tileID = t),
                    this._state.initializeTileState(
                      e,
                      this.map ? this.map.painter : null
                    ),
                    this._cacheTimers[t.key] &&
                      (clearTimeout(this._cacheTimers[t.key]),
                      delete this._cacheTimers[t.key],
                      this._setTileReloadTimer(t.key, e)));
                const n = Boolean(e);
                return (
                  n ||
                    ((e = new ep(
                      t,
                      this._source.tileSize * t.overscaleFactor(),
                      this.transform.tileZoom
                    )),
                    this._loadTile(
                      e,
                      this._tileLoaded.bind(this, e, t.key, e.state)
                    )),
                  e
                    ? (e.uses++,
                      (this._tiles[t.key] = e),
                      n ||
                        this._source.fire(
                          new Lt("dataloading", {
                            tile: e,
                            coord: e.tileID,
                            dataType: "source",
                          })
                        ),
                      e)
                    : null
                );
              }
              _setTileReloadTimer(t, e) {
                t in this._timers &&
                  (clearTimeout(this._timers[t]), delete this._timers[t]);
                const n = e.getExpiryTimeout();
                n &&
                  (this._timers[t] = setTimeout(() => {
                    this._reloadTile(t, "expired"), delete this._timers[t];
                  }, n));
              }
              _removeTile(t) {
                const e = this._tiles[t];
                e &&
                  (e.uses--,
                  delete this._tiles[t],
                  this._timers[t] &&
                    (clearTimeout(this._timers[t]), delete this._timers[t]),
                  e.uses > 0 ||
                    (e.hasData() && "reloading" !== e.state
                      ? this._cache.add(e.tileID, e, e.getExpiryTimeout())
                      : ((e.aborted = !0),
                        this._abortTile(e),
                        this._unloadTile(e))));
              }
              clearTiles() {
                (this._shouldReloadOnResume = !1), (this._paused = !1);
                for (const t in this._tiles) this._removeTile(+t);
                this._cache.reset();
              }
              tilesIn(t, e, n) {
                const r = [],
                  i = this.transform;
                if (!i) return r;
                for (const o in this._tiles) {
                  const s = this._tiles[o];
                  if ((n && s.clearQueryDebugViz(), s.holdingForFade()))
                    continue;
                  const a = t.containsTile(s, i, e);
                  a && r.push(a);
                }
                return r;
              }
              getVisibleCoordinates(t) {
                const e = this.getRenderableIds(t).map(
                  (t) => this._tiles[t].tileID
                );
                for (const n of e)
                  n.projMatrix = this.transform.calculateProjMatrix(
                    n.toUnwrapped()
                  );
                return e;
              }
              hasTransition() {
                if (this._source.hasTransition()) return !0;
                if (Sp(this._source.type))
                  for (const t in this._tiles) {
                    const e = this._tiles[t];
                    if (void 0 !== e.fadeEndTime && e.fadeEndTime >= V.now())
                      return !0;
                  }
                return !1;
              }
              setFeatureState(t, e, n) {
                this._state.updateState((t = t || "_geojsonTileLayer"), e, n);
              }
              removeFeatureState(t, e, n) {
                this._state.removeFeatureState(
                  (t = t || "_geojsonTileLayer"),
                  e,
                  n
                );
              }
              getFeatureState(t, e) {
                return this._state.getState((t = t || "_geojsonTileLayer"), e);
              }
              setDependencies(t, e, n) {
                const r = this._tiles[t];
                r && r.setDependencies(e, n);
              }
              reloadTilesForDependencies(t, e) {
                for (const n in this._tiles)
                  this._tiles[n].hasDependency(t, e) &&
                    this._reloadTile(+n, "reloading");
                this._cache.filter((n) => !n.hasDependency(t, e));
              }
            }
            function wp(t, e) {
              const n = Math.abs(2 * t.wrap) - +(t.wrap < 0),
                r = Math.abs(2 * e.wrap) - +(e.wrap < 0);
              return (
                t.overscaledZ - e.overscaledZ ||
                r - n ||
                e.canonical.y - t.canonical.y ||
                e.canonical.x - t.canonical.x
              );
            }
            function Sp(t) {
              return "raster" === t || "image" === t || "video" === t;
            }
            (xp.maxOverzooming = 10), (xp.maxUnderzooming = 3);
            class Ep {
              constructor(t, e, n) {
                (this._demTile = t),
                  (this._dem = this._demTile.dem),
                  (this._scale = e),
                  (this._offset = n);
              }
              static create(t, e, n) {
                const r = n || t.findDEMTileFor(e);
                if (!r || !r.dem) return;
                const i = r.dem,
                  o = r.tileID,
                  s = 1 << (e.canonical.z - o.canonical.z);
                return new Ep(r, r.tileSize / Vs / s, [
                  (e.canonical.x / s - o.canonical.x) * i.dim,
                  (e.canonical.y / s - o.canonical.y) * i.dim,
                ]);
              }
              tileCoordToPixel(t, e) {
                const n = e * this._scale + this._offset[1],
                  r = Math.floor(t * this._scale + this._offset[0]),
                  i = Math.floor(n);
                return new o(r, i);
              }
              getElevationAt(t, e, n, r) {
                const i = t * this._scale + this._offset[0],
                  o = e * this._scale + this._offset[1],
                  s = Math.floor(i),
                  a = Math.floor(o),
                  l = this._dem;
                return (
                  (r = !!r),
                  n
                    ? rn(
                        rn(l.get(s, a, r), l.get(s, a + 1, r), o - a),
                        rn(l.get(s + 1, a, r), l.get(s + 1, a + 1, r), o - a),
                        i - s
                      )
                    : l.get(s, a, r)
                );
              }
              getElevationAtPixel(t, e, n) {
                return this._dem.get(t, e, !!n);
              }
              getMeterToDEM(t) {
                return (
                  (1 << this._demTile.tileID.canonical.z) *
                  Bh(1, t) *
                  this._dem.stride
                );
              }
            }
            class Tp {
              constructor(t, e) {
                (this.tileID = t),
                  (this.x = t.canonical.x),
                  (this.y = t.canonical.y),
                  (this.z = t.canonical.z),
                  (this.grid = new ri(Vs, 16, 0)),
                  (this.featureIndexArray = new ss()),
                  (this.promoteId = e);
              }
              insert(t, e, n, r, i, o = 0) {
                const s = this.featureIndexArray.length;
                this.featureIndexArray.emplaceBack(n, r, i, o);
                const a = this.grid;
                for (let l = 0; l < e.length; l++) {
                  const t = e[l],
                    n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                  for (let e = 0; e < t.length; e++) {
                    const r = t[e];
                    (n[0] = Math.min(n[0], r.x)),
                      (n[1] = Math.min(n[1], r.y)),
                      (n[2] = Math.max(n[2], r.x)),
                      (n[3] = Math.max(n[3], r.y));
                  }
                  n[0] < Vs &&
                    n[1] < Vs &&
                    n[2] >= 0 &&
                    n[3] >= 0 &&
                    a.insert(s, n[0], n[1], n[2], n[3]);
                }
              }
              loadVTLayers() {
                return (
                  this.vtLayers ||
                    ((this.vtLayers = new Gl.VectorTile(
                      new Dc(this.rawTileData)
                    ).layers),
                    (this.sourceLayerCoder = new Qh(
                      this.vtLayers
                        ? Object.keys(this.vtLayers).sort()
                        : ["_geojsonTileLayer"]
                    ))),
                  this.vtLayers
                );
              }
              query(t, e, n, r) {
                this.loadVTLayers();
                const i = t.params || {},
                  o = Tr(i.filter),
                  s = t.tileResult,
                  a = t.transform,
                  l = s.bufferedTilespaceBounds,
                  c = this.grid.query(
                    l.min.x,
                    l.min.y,
                    l.max.x,
                    l.max.y,
                    (t, e, n, r) => sa(s.bufferedTilespaceGeometry, t, e, n, r)
                  );
                c.sort(Cp);
                let u = null;
                a.elevation &&
                  c.length > 0 &&
                  (u = Ep.create(a.elevation, this.tileID));
                const h = {};
                let p;
                for (let d = 0; d < c.length; d++) {
                  const a = c[d];
                  if (a === p) continue;
                  p = a;
                  const l = this.featureIndexArray.get(a);
                  let f = null;
                  this.loadMatchingFeature(
                    h,
                    l,
                    o,
                    i.layers,
                    i.availableImages,
                    e,
                    n,
                    r,
                    (e, n, r, i = 0) => (
                      f || (f = Gs(e)),
                      n.queryIntersectsFeature(
                        s,
                        e,
                        r,
                        f,
                        this.z,
                        t.transform,
                        t.pixelPosMatrix,
                        u,
                        i
                      )
                    )
                  );
                }
                return h;
              }
              loadMatchingFeature(t, e, n, r, i, o, s, a, l) {
                const {
                    featureIndex: c,
                    bucketIndex: u,
                    sourceLayerIndex: h,
                    layoutVertexArrayOffset: p,
                  } = e,
                  d = this.bucketLayerIDs[u];
                if (
                  r &&
                  !(function (t, e) {
                    for (let n = 0; n < t.length; n++)
                      if (e.indexOf(t[n]) >= 0) return !0;
                    return !1;
                  })(r, d)
                )
                  return;
                const f = this.sourceLayerCoder.decode(h),
                  m = this.vtLayers[f].feature(c);
                if (n.needGeometry) {
                  const t = Ws(m, !0);
                  if (
                    !n.filter(
                      new ao(this.tileID.overscaledZ),
                      t,
                      this.tileID.canonical
                    )
                  )
                    return;
                } else if (!n.filter(new ao(this.tileID.overscaledZ), m)) return;
                const g = this.getId(m, f);
                for (let y = 0; y < d.length; y++) {
                  const e = d[y];
                  if (r && r.indexOf(e) < 0) continue;
                  const n = o[e];
                  if (!n) continue;
                  let u = {};
                  void 0 !== g &&
                    a &&
                    (u = a.getState(n.sourceLayer || "_geojsonTileLayer", g));
                  const h = b({}, s[e]);
                  (h.paint = Ap(h.paint, n.paint, m, u, i)),
                    (h.layout = Ap(h.layout, n.layout, m, u, i));
                  const f = !l || l(m, n, u, p);
                  if (!f) continue;
                  const _ = new Jh(m, this.z, this.x, this.y, g);
                  _.layer = h;
                  let v = t[e];
                  void 0 === v && (v = t[e] = []),
                    v.push({ featureIndex: c, feature: _, intersectionZ: f });
                }
              }
              lookupSymbolFeatures(t, e, n, r, i, o, s, a) {
                const l = {};
                this.loadVTLayers();
                const c = Tr(i);
                for (const u of t)
                  this.loadMatchingFeature(
                    l,
                    {
                      bucketIndex: n,
                      sourceLayerIndex: r,
                      featureIndex: u,
                      layoutVertexArrayOffset: 0,
                    },
                    c,
                    o,
                    s,
                    a,
                    e
                  );
                return l;
              }
              hasLayer(t) {
                for (const e of this.bucketLayerIDs)
                  for (const n of e) if (t === n) return !0;
                return !1;
              }
              getId(t, e) {
                let n = t.id;
                return (
                  this.promoteId &&
                    ((n =
                      t.properties[
                        "string" == typeof this.promoteId
                          ? this.promoteId
                          : this.promoteId[e]
                      ]),
                    "boolean" == typeof n && (n = Number(n))),
                  n
                );
              }
            }
            function Ap(t, e, n, r, i) {
              return P(t, (t, o) => {
                const s = e instanceof go ? e.get(o) : null;
                return s && s.evaluate ? s.evaluate(n, r, i) : s;
              });
            }
            function Cp(t, e) {
              return e - t;
            }
            li("FeatureIndex", Tp, {
              omit: ["rawTileData", "sourceLayerCoder"],
            });
            class Pp {
              constructor(t) {
                const e = {},
                  n = [];
                for (const s in t) {
                  const r = t[s],
                    i = (e[s] = {});
                  for (const t in r.glyphs) {
                    const e = r.glyphs[+t];
                    if (!e || 0 === e.bitmap.width || 0 === e.bitmap.height)
                      continue;
                    const o = e.metrics.localGlyph ? 2 : 1,
                      s = {
                        x: 0,
                        y: 0,
                        w: e.bitmap.width + 2 * o,
                        h: e.bitmap.height + 2 * o,
                      };
                    n.push(s), (i[t] = s);
                  }
                }
                const { w: r, h: i } = nu(n),
                  o = new Va({ width: r || 1, height: i || 1 });
                for (const s in t) {
                  const n = t[s];
                  for (const t in n.glyphs) {
                    const r = n.glyphs[+t];
                    if (!r || 0 === r.bitmap.width || 0 === r.bitmap.height)
                      continue;
                    const i = e[s][t],
                      a = r.metrics.localGlyph ? 2 : 1;
                    Va.copy(
                      r.bitmap,
                      o,
                      { x: 0, y: 0 },
                      { x: i.x + a, y: i.y + a },
                      r.bitmap
                    );
                  }
                }
                (this.image = o), (this.positions = e);
              }
            }
            li("GlyphAtlas", Pp);
            class Mp {
              constructor(t) {
                (this.tileID = new Kh(
                  t.tileID.overscaledZ,
                  t.tileID.wrap,
                  t.tileID.canonical.z,
                  t.tileID.canonical.x,
                  t.tileID.canonical.y
                )),
                  (this.tileZoom = t.tileZoom),
                  (this.uid = t.uid),
                  (this.zoom = t.zoom),
                  (this.pixelRatio = t.pixelRatio),
                  (this.tileSize = t.tileSize),
                  (this.source = t.source),
                  (this.overscaling = this.tileID.overscaleFactor()),
                  (this.showCollisionBoxes = t.showCollisionBoxes),
                  (this.collectResourceTiming = !!t.collectResourceTiming),
                  (this.returnDependencies = !!t.returnDependencies),
                  (this.promoteId = t.promoteId),
                  (this.enableTerrain = !!t.enableTerrain),
                  (this.isSymbolTile = t.isSymbolTile);
              }
              parse(t, e, n, r, i) {
                (this.status = "parsing"),
                  (this.data = t),
                  (this.collisionBoxArray = new Qo());
                const o = new Qh(Object.keys(t.layers).sort()),
                  s = new Tp(this.tileID, this.promoteId);
                s.bucketLayerIDs = [];
                const a = {},
                  l = new Zh(256, 256),
                  c = {
                    featureIndex: s,
                    iconDependencies: {},
                    patternDependencies: {},
                    glyphDependencies: {},
                    lineAtlas: l,
                    availableImages: n,
                  },
                  u = e.familiesBySource[this.source];
                for (const v in u) {
                  const e = t.layers[v];
                  if (!e) continue;
                  let r = !1,
                    i = !1;
                  for (const t of u[v])
                    "symbol" === t[0].type ? (r = !0) : (i = !0);
                  if (!0 === this.isSymbolTile && !r) continue;
                  if (!1 === this.isSymbolTile && !i) continue;
                  1 === e.version &&
                    I(
                      `Vector tile source "${this.source}" layer "${v}" does not use vector tile spec v2 and therefore may have some rendering errors.`
                    );
                  const l = o.encode(v),
                    h = [];
                  for (let t = 0; t < e.length; t++) {
                    const n = e.feature(t),
                      r = s.getId(n, v);
                    h.push({
                      feature: n,
                      id: r,
                      index: t,
                      sourceLayerIndex: l,
                    });
                  }
                  for (const t of u[v]) {
                    const e = t[0];
                    (void 0 !== this.isSymbolTile &&
                      ("symbol" === e.type) !== this.isSymbolTile) ||
                      (e.minzoom && this.zoom < Math.floor(e.minzoom)) ||
                      (e.maxzoom && this.zoom >= e.maxzoom) ||
                      ("none" !== e.visibility &&
                        (Op(t, this.zoom, n),
                        (a[e.id] = e.createBucket({
                          index: s.bucketLayerIDs.length,
                          layers: t,
                          zoom: this.zoom,
                          pixelRatio: this.pixelRatio,
                          overscaling: this.overscaling,
                          collisionBoxArray: this.collisionBoxArray,
                          sourceLayerIndex: l,
                          sourceID: this.source,
                          enableTerrain: this.enableTerrain,
                        })).populate(h, c, this.tileID.canonical),
                        s.bucketLayerIDs.push(t.map((t) => t.id))));
                  }
                }
                let h, p, d, f;
                l.trim();
                const m = {
                    type: "maybePrepare",
                    isSymbolTile: this.isSymbolTile,
                    zoom: this.zoom,
                  },
                  g = P(c.glyphDependencies, (t) => Object.keys(t).map(Number));
                Object.keys(g).length
                  ? r.send(
                      "getGlyphs",
                      { uid: this.uid, stacks: g },
                      (t, e) => {
                        h || ((h = t), (p = e), b.call(this));
                      },
                      void 0,
                      !1,
                      m
                    )
                  : (p = {});
                const y = Object.keys(c.iconDependencies);
                y.length
                  ? r.send(
                      "getImages",
                      {
                        icons: y,
                        source: this.source,
                        tileID: this.tileID,
                        type: "icons",
                      },
                      (t, e) => {
                        h || ((h = t), (d = e), b.call(this));
                      },
                      void 0,
                      !1,
                      m
                    )
                  : (d = {});
                const _ = Object.keys(c.patternDependencies);
                function b() {
                  if (h) return i(h);
                  if (p && d && f) {
                    const t = new Pp(p),
                      e = new iu(d, f);
                    for (const r in a) {
                      const i = a[r];
                      i instanceof fh
                        ? (Op(i.layers, this.zoom, n),
                          Qu(
                            i,
                            p,
                            t.positions,
                            d,
                            e.iconPositions,
                            this.showCollisionBoxes,
                            this.tileID.canonical,
                            this.tileZoom
                          ))
                        : i.hasPattern &&
                          (i instanceof uc ||
                            i instanceof Il ||
                            i instanceof Yl) &&
                          (Op(i.layers, this.zoom, n),
                          i.addFeatures(
                            c,
                            this.tileID.canonical,
                            e.patternPositions
                          ));
                    }
                    (this.status = "done"),
                      i(null, {
                        buckets: v(a).filter((t) => !t.isEmpty()),
                        featureIndex: s,
                        collisionBoxArray: this.collisionBoxArray,
                        glyphAtlasImage: t.image,
                        lineAtlas: l,
                        imageAtlas: e,
                        glyphMap: this.returnDependencies ? p : null,
                        iconMap: this.returnDependencies ? d : null,
                        glyphPositions: this.returnDependencies
                          ? t.positions
                          : null,
                      });
                  }
                }
                _.length
                  ? r.send(
                      "getImages",
                      {
                        icons: _,
                        source: this.source,
                        tileID: this.tileID,
                        type: "patterns",
                      },
                      (t, e) => {
                        h || ((h = t), (f = e), b.call(this));
                      },
                      void 0,
                      !1,
                      m
                    )
                  : (f = {}),
                  b.call(this);
              }
            }
            function Op(t, e, n) {
              const r = new ao(e);
              for (const i of t) i.recalculate(r, n);
            }
            class kp {
              constructor(t) {
                (this.entries = {}), (this.scheduler = t);
              }
              request(t, e, n, r) {
                const i = (this.entries[t] = this.entries[t] || {
                  callbacks: [],
                });
                if (i.result) {
                  const [t, n] = i.result;
                  return (
                    this.scheduler
                      ? this.scheduler.add(() => {
                          r(t, n);
                        }, e)
                      : r(t, n),
                    () => {}
                  );
                }
                return (
                  i.callbacks.push(r),
                  i.cancel ||
                    (i.cancel = n((n, r) => {
                      i.result = [n, r];
                      for (const t of i.callbacks)
                        this.scheduler
                          ? this.scheduler.add(() => {
                              t(n, r);
                            }, e)
                          : t(n, r);
                      setTimeout(() => delete this.entries[t], 3e3);
                    })),
                  () => {
                    i.result ||
                      ((i.callbacks = i.callbacks.filter((t) => t !== r)),
                      i.callbacks.length ||
                        (i.cancel(), delete this.entries[t]));
                  }
                );
              }
            }
            function Ip(t, e, n) {
              const r = JSON.stringify(t.request);
              return (
                t.data &&
                  (this.deduped.entries[r] = { result: [null, t.data] }),
                this.deduped.request(
                  r,
                  {
                    type: "parseTile",
                    isSymbolTile: t.isSymbolTile,
                    zoom: t.tileZoom,
                  },
                  (e) => {
                    const r = At(t.request, (t, r, i, o) => {
                      t
                        ? e(t)
                        : r &&
                          e(null, {
                            vectorTile: n
                              ? void 0
                              : new Gl.VectorTile(new Dc(r)),
                            rawData: r,
                            cacheControl: i,
                            expires: o,
                          });
                    });
                    return () => {
                      r.cancel(), e();
                    };
                  },
                  e
                )
              );
            }
            (t.ARRAY_TYPE = fa),
              (t.AUTH_ERR_MSG = J),
              (t.Actor = class {
                constructor(t, e, n) {
                  (this.target = t),
                    (this.parent = e),
                    (this.mapId = n),
                    (this.callbacks = {}),
                    (this.cancelCallbacks = {}),
                    A(["receive"], this),
                    this.target.addEventListener("message", this.receive, !1),
                    (this.globalScope = R() ? t : a),
                    (this.scheduler = new Gh());
                }
                send(t, e, n, r, i = !1, o) {
                  const s = Math.round(1e18 * Math.random())
                    .toString(36)
                    .substring(0, 10);
                  n && ((n.metadata = o), (this.callbacks[s] = n));
                  const a = U(this.globalScope) ? void 0 : [];
                  return (
                    this.target.postMessage(
                      {
                        id: s,
                        type: t,
                        hasCallback: !!n,
                        targetMapId: r,
                        mustQueue: i,
                        sourceMapId: this.mapId,
                        data: hi(e, a),
                      },
                      a
                    ),
                    {
                      cancel: () => {
                        n && delete this.callbacks[s],
                          this.target.postMessage({
                            id: s,
                            type: "<cancel>",
                            targetMapId: r,
                            sourceMapId: this.mapId,
                          });
                      },
                    }
                  );
                }
                receive(t) {
                  const e = t.data,
                    n = e.id;
                  if (n && (!e.targetMapId || this.mapId === e.targetMapId))
                    if ("<cancel>" === e.type) {
                      const t = this.cancelCallbacks[n];
                      delete this.cancelCallbacks[n], t && t.cancel();
                    } else if (e.mustQueue || R()) {
                      const t = this.callbacks[n];
                      this.cancelCallbacks[n] = this.scheduler.add(
                        () => this.processTask(n, e),
                        (t && t.metadata) || { type: "message" }
                      );
                    } else this.processTask(n, e);
                }
                processTask(t, e) {
                  if ("<response>" === e.type) {
                    const n = this.callbacks[t];
                    delete this.callbacks[t],
                      n && (e.error ? n(pi(e.error)) : n(null, pi(e.data)));
                  } else {
                    const n = U(this.globalScope) ? void 0 : [],
                      r = e.hasCallback
                        ? (e, r) => {
                            delete this.cancelCallbacks[t],
                              this.target.postMessage(
                                {
                                  id: t,
                                  type: "<response>",
                                  sourceMapId: this.mapId,
                                  error: e ? hi(e) : null,
                                  data: hi(r, n),
                                },
                                n
                              );
                          }
                        : (t) => {},
                      i = pi(e.data);
                    if (this.parent[e.type])
                      this.parent[e.type](e.sourceMapId, i, r);
                    else if (this.parent.getWorkerSource) {
                      const t = e.type.split(".");
                      this.parent
                        .getWorkerSource(e.sourceMapId, t[0], i.source)
                        [t[1]](i, r);
                    } else r(new Error(`Could not find function ${e.type}`));
                  }
                }
                remove() {
                  this.scheduler.remove(),
                    this.target.removeEventListener(
                      "message",
                      this.receive,
                      !1
                    );
                }
              }),
              (t.CanonicalTileID = Hh),
              (t.Color = he),
              (t.ColorMode = yp),
              (t.CullFaceMode = bp),
              (t.DEMData = pp),
              (t.DataConstantProperty = yo),
              (t.DedupedRequest = kp),
              (t.DepthMode = fp),
              (t.EXTENT = Vs),
              (t.Elevation = class {
                getAtPointOrZero(t, e = 0) {
                  return this.getAtPoint(t, e) || 0;
                }
                getAtPoint(t, e, n = !0) {
                  null == e && (e = null);
                  const r = this._source();
                  if (!r) return e;
                  if (t.y < 0 || t.y > 1) return e;
                  const i = r.getSource().maxzoom,
                    o = 1 << i,
                    s = Math.floor(t.x),
                    a = t.x - s,
                    l = new Kh(i, s, i, Math.floor(a * o), Math.floor(t.y * o)),
                    c = this.findDEMTileFor(l);
                  if (!c || !c.dem) return e;
                  const u = c.dem,
                    h = 1 << c.tileID.canonical.z,
                    p = (a * h - c.tileID.canonical.x) * u.dim,
                    d = (t.y * h - c.tileID.canonical.y) * u.dim,
                    f = Math.floor(p),
                    m = Math.floor(d);
                  return (
                    (n ? this.exaggeration() : 1) *
                    rn(
                      rn(u.get(f, m), u.get(f, m + 1), d - m),
                      rn(u.get(f + 1, m), u.get(f + 1, m + 1), d - m),
                      p - f
                    )
                  );
                }
                getAtTileOffset(t, e, n) {
                  const r = 1 << t.canonical.z;
                  return this.getAtPointOrZero(
                    new Uh(
                      t.wrap + (t.canonical.x + e / Vs) / r,
                      (t.canonical.y + n / Vs) / r
                    )
                  );
                }
                getForTilePoints(t, e, n, r) {
                  const i = Ep.create(this, t, r);
                  return (
                    !!i &&
                    (e.forEach((t) => {
                      t[2] =
                        this.exaggeration() * i.getElevationAt(t[0], t[1], n);
                    }),
                    !0)
                  );
                }
                getMinMaxForTile(t) {
                  const e = this.findDEMTileFor(t);
                  if (!e || !e.dem) return null;
                  const n = e.dem.tree,
                    r = e.tileID,
                    i = 1 << (t.canonical.z - r.canonical.z);
                  let o = t.canonical.x / i - r.canonical.x,
                    s = t.canonical.y / i - r.canonical.y,
                    a = 0;
                  for (
                    let l = 0;
                    l < t.canonical.z - r.canonical.z && !n.leaves[a];
                    l++
                  ) {
                    (o *= 2), (s *= 2);
                    const t = 2 * Math.floor(s) + Math.floor(o);
                    (a = n.childOffsets[a] + t), (o %= 1), (s %= 1);
                  }
                  return {
                    min: this.exaggeration() * n.minimums[a],
                    max: this.exaggeration() * n.maximums[a],
                  };
                }
                getMinElevationBelowMSL() {
                  throw new Error("Pure virtual method called.");
                }
                raycast(t, e, n) {
                  throw new Error("Pure virtual method called.");
                }
                pointCoordinate(t) {
                  throw new Error("Pure virtual method called.");
                }
                _source() {
                  throw new Error("Pure virtual method called.");
                }
                exaggeration() {
                  throw new Error("Pure virtual method called.");
                }
                findDEMTileFor(t) {
                  throw new Error("Pure virtual method called.");
                }
                get visibleDemTiles() {
                  throw new Error("Getter must be implemented in subclass.");
                }
              }),
              (t.ErrorEvent = Ft),
              (t.EvaluationParameters = ao),
              (t.Event = Lt),
              (t.Evented = Bt),
              (t.GlyphManager = Fu),
              (t.ImagePosition = ru),
              (t.LineAtlas = Zh),
              (t.LngLat = Dh),
              (t.LngLatBounds = kh),
              (t.LocalGlyphMode = Lu),
              (t.MAX_SAFE_INTEGER = l),
              (t.MercatorCoordinate = Uh),
              (t.ONE_EM = xc),
              (t.OverscaledTileID = Kh),
              (t.Properties = wo),
              (t.RGBAImage = qa),
              (t.RequestManager = class {
                constructor(t, e, n) {
                  (this._transformRequestFn = t),
                    (this._customAccessToken = e),
                    (this._silenceAuthErrors = !!n),
                    this._createSkuToken();
                }
                _createSkuToken() {
                  const t = (function () {
                    let t = "";
                    for (let e = 0; e < 10; e++)
                      t +=
                        "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[
                          Math.floor(62 * Math.random())
                        ];
                    return {
                      token: ["1", Q, t].join(""),
                      tokenExpiresAt: Date.now() + 432e5,
                    };
                  })();
                  (this._skuToken = t.token),
                    (this._skuTokenExpiresAt = t.tokenExpiresAt);
                }
                _isSkuTokenExpired() {
                  return Date.now() > this._skuTokenExpiresAt;
                }
                transformRequest(t, e) {
                  return (
                    (this._transformRequestFn &&
                      this._transformRequestFn(t, e)) || { url: t }
                  );
                }
                normalizeStyleURL(t, e) {
                  if (!tt(t)) return t;
                  const n = rt(t);
                  return (
                    (n.path = `/styles/v1${n.path}`),
                    this._makeAPIURL(n, this._customAccessToken || e)
                  );
                }
                normalizeGlyphsURL(t, e) {
                  if (!tt(t)) return t;
                  const n = rt(t);
                  return (
                    (n.path = `/fonts/v1${n.path}`),
                    this._makeAPIURL(n, this._customAccessToken || e)
                  );
                }
                normalizeSourceURL(t, e) {
                  if (!tt(t)) return t;
                  const n = rt(t);
                  return (
                    (n.path = `/v4/${n.authority}.json`),
                    n.params.push("secure"),
                    this._makeAPIURL(n, this._customAccessToken || e)
                  );
                }
                normalizeSpriteURL(t, e, n, r) {
                  const i = rt(t);
                  return tt(t)
                    ? ((i.path = `/styles/v1${i.path}/sprite${e}${n}`),
                      this._makeAPIURL(i, this._customAccessToken || r))
                    : ((i.path += `${e}${n}`), it(i));
                }
                normalizeTileURL(t, e, n) {
                  if (
                    (this._isSkuTokenExpired() && this._createSkuToken(),
                    t && !tt(t))
                  )
                    return t;
                  const r = rt(t);
                  (r.path = r.path.replace(
                    /(\.(png|jpg)\d*)(?=$)/,
                    `${
                      e || (n && "raster" !== r.authority && 512 === n)
                        ? "@2x"
                        : ""
                    }${G.supported ? ".webp" : "$1"}`
                  )),
                    "raster" === r.authority
                      ? (r.path = `/${$.RASTER_URL_PREFIX}${r.path}`)
                      : ((r.path = r.path.replace(/^.+\/v4\//, "/")),
                        (r.path = `/${$.TILE_URL_VERSION}${r.path}`));
                  const i =
                    this._customAccessToken ||
                    (function (t) {
                      for (const e of t) {
                        const t = e.match(/^access_token=(.*)$/);
                        if (t) return t[1];
                      }
                      return null;
                    })(r.params) ||
                    $.ACCESS_TOKEN;
                  return (
                    $.REQUIRE_ACCESS_TOKEN &&
                      i &&
                      this._skuToken &&
                      r.params.push(`sku=${this._skuToken}`),
                    this._makeAPIURL(r, i)
                  );
                }
                canonicalizeTileURL(t, e) {
                  const n = rt(t);
                  if (
                    !n.path.match(/^(\/v4\/|\/raster\/v1\/)/) ||
                    !n.path.match(/\.[\w]+$/)
                  )
                    return t;
                  let r = "mapbox://";
                  n.path.match(/^\/raster\/v1\//)
                    ? (r += `raster/${n.path.replace(
                        `/${$.RASTER_URL_PREFIX}/`,
                        ""
                      )}`)
                    : (r += `tiles/${n.path.replace(
                        `/${$.TILE_URL_VERSION}/`,
                        ""
                      )}`);
                  let i = n.params;
                  return (
                    e && (i = i.filter((t) => !t.match(/^access_token=/))),
                    i.length && (r += `?${i.join("&")}`),
                    r
                  );
                }
                canonicalizeTileset(t, e) {
                  const n = !!e && tt(e),
                    r = [];
                  for (const i of t.tiles || [])
                    et(i) ? r.push(this.canonicalizeTileURL(i, n)) : r.push(i);
                  return r;
                }
                _makeAPIURL(t, e) {
                  const n =
                      "See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes",
                    r = rt($.API_URL);
                  if (
                    ((t.protocol = r.protocol),
                    (t.authority = r.authority),
                    "http" === t.protocol)
                  ) {
                    const e = t.params.indexOf("secure");
                    e >= 0 && t.params.splice(e, 1);
                  }
                  if (
                    ("/" !== r.path && (t.path = `${r.path}${t.path}`),
                    !$.REQUIRE_ACCESS_TOKEN)
                  )
                    return it(t);
                  if (((e = e || $.ACCESS_TOKEN), !this._silenceAuthErrors)) {
                    if (!e)
                      throw new Error(
                        `An API access token is required to use Mapbox GL. ${n}`
                      );
                    if ("s" === e[0])
                      throw new Error(
                        `Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${n}`
                      );
                  }
                  return (
                    (t.params = t.params.filter(
                      (t) => -1 === t.indexOf("access_token")
                    )),
                    t.params.push(`access_token=${e || ""}`),
                    it(t)
                  );
                }
              }),
              (t.ResourceType = wt),
              (t.SegmentVector = Zs),
              (t.SourceCache = xp),
              (t.StencilMode = gp),
              (t.StructArrayLayout1ui2 = Xo),
              (t.StructArrayLayout2f1f2i16 = jo),
              (t.StructArrayLayout2i4 = Mo),
              (t.StructArrayLayout2ui4 = Ho),
              (t.StructArrayLayout3f12 = Lo),
              (t.StructArrayLayout3ui6 = Zo),
              (t.StructArrayLayout4i8 = Oo),
              (t.Texture = Oh),
              (t.Tile = ep),
              (t.Transitionable = uo),
              (t.Uniform1f = bs),
              (t.Uniform1i = class extends vs {
                constructor(t, e) {
                  super(t, e), (this.current = 0);
                }
                set(t) {
                  this.current !== t &&
                    ((this.current = t), this.gl.uniform1i(this.location, t));
                }
              }),
              (t.Uniform2f = class extends vs {
                constructor(t, e) {
                  super(t, e), (this.current = [0, 0]);
                }
                set(t) {
                  (t[0] === this.current[0] && t[1] === this.current[1]) ||
                    ((this.current = t),
                    this.gl.uniform2f(this.location, t[0], t[1]));
                }
              }),
              (t.Uniform3f = class extends vs {
                constructor(t, e) {
                  super(t, e), (this.current = [0, 0, 0]);
                }
                set(t) {
                  (t[0] === this.current[0] &&
                    t[1] === this.current[1] &&
                    t[2] === this.current[2]) ||
                    ((this.current = t),
                    this.gl.uniform3f(this.location, t[0], t[1], t[2]));
                }
              }),
              (t.Uniform4f = xs),
              (t.UniformColor = ws),
              (t.UniformMatrix3f = class extends vs {
                constructor(t, e) {
                  super(t, e), (this.current = Es);
                }
                set(t) {
                  for (let e = 0; e < 9; e++)
                    if (t[e] !== this.current[e]) {
                      (this.current = t),
                        this.gl.uniformMatrix3fv(this.location, !1, t);
                      break;
                    }
                }
              }),
              (t.UniformMatrix4f = class extends vs {
                constructor(t, e) {
                  super(t, e), (this.current = Ss);
                }
                set(t) {
                  if (t[12] !== this.current[12] || t[0] !== this.current[0])
                    return (
                      (this.current = t),
                      void this.gl.uniformMatrix4fv(this.location, !1, t)
                    );
                  for (let e = 1; e < 16; e++)
                    if (t[e] !== this.current[e]) {
                      (this.current = t),
                        this.gl.uniformMatrix4fv(this.location, !1, t);
                      break;
                    }
                }
              }),
              (t.UnwrappedTileID = Xh),
              (t.ValidationError = jt),
              (t.VectorTileWorkerSource = class extends Bt {
                constructor(t, e, n, r, i) {
                  super(),
                    (this.actor = t),
                    (this.layerIndex = e),
                    (this.availableImages = n),
                    (this.loadVectorData = i || Ip),
                    (this.loading = {}),
                    (this.loaded = {}),
                    (this.deduped = new kp(t.scheduler)),
                    (this.isSpriteLoaded = r),
                    (this.scheduler = t.scheduler);
                }
                loadTile(t, e) {
                  const n = t.uid,
                    r = t && t.request,
                    i = r && r.collectResourceTiming,
                    o = (this.loading[n] = new Mp(t));
                  o.abort = this.loadVectorData(t, (s, a) => {
                    const l = !this.loading[n];
                    if ((delete this.loading[n], l || s || !a))
                      return (
                        (o.status = "done"), l || (this.loaded[n] = o), e(s)
                      );
                    const c = a.rawData,
                      u = {};
                    a.expires && (u.expires = a.expires),
                      a.cacheControl && (u.cacheControl = a.cacheControl),
                      (o.vectorTile =
                        a.vectorTile || new Gl.VectorTile(new Dc(c)));
                    const h = () => {
                      o.parse(
                        o.vectorTile,
                        this.layerIndex,
                        this.availableImages,
                        this.actor,
                        (t, n) => {
                          if (t || !n) return e(t);
                          const o = {};
                          if (i) {
                            const t = $h(r);
                            t.length > 0 &&
                              (o.resourceTiming = JSON.parse(
                                JSON.stringify(t)
                              ));
                          }
                          e(null, b({ rawTileData: c.slice(0) }, n, u, o));
                        }
                      );
                    };
                    this.isSpriteLoaded
                      ? h()
                      : this.once("isSpriteLoaded", () => {
                          this.scheduler
                            ? this.scheduler.add(h, {
                                type: "parseTile",
                                isSymbolTile: t.isSymbolTile,
                                zoom: t.tileZoom,
                              })
                            : h();
                        }),
                      (this.loaded = this.loaded || {}),
                      (this.loaded[n] = o);
                  });
                }
                reloadTile(t, e) {
                  const n = this.loaded,
                    r = t.uid,
                    i = this;
                  if (n && n[r]) {
                    const o = n[r];
                    (o.showCollisionBoxes = t.showCollisionBoxes),
                      (o.enableTerrain = !!t.enableTerrain);
                    const s = (t, n) => {
                      const r = o.reloadCallback;
                      r &&
                        (delete o.reloadCallback,
                        o.parse(
                          o.vectorTile,
                          i.layerIndex,
                          this.availableImages,
                          i.actor,
                          r
                        )),
                        e(t, n);
                    };
                    "parsing" === o.status
                      ? (o.reloadCallback = s)
                      : "done" === o.status &&
                        (o.vectorTile
                          ? o.parse(
                              o.vectorTile,
                              this.layerIndex,
                              this.availableImages,
                              this.actor,
                              s
                            )
                          : s());
                  }
                }
                abortTile(t, e) {
                  const n = t.uid,
                    r = this.loading[n];
                  r && (r.abort && r.abort(), delete this.loading[n]), e();
                }
                removeTile(t, e) {
                  const n = this.loaded,
                    r = t.uid;
                  n && n[r] && delete n[r], e();
                }
              }),
              (t.WritingMode = ou),
              (t.ZoomHistory = di),
              (t.add = function (t, e, n) {
                return (
                  (t[0] = e[0] + n[0]),
                  (t[1] = e[1] + n[1]),
                  (t[2] = e[2] + n[2]),
                  t
                );
              }),
              (t.addDynamicAttributes = uh),
              (t.altitudeFromMercatorZ = jh),
              (t.asyncAll = _),
              (t.bezier = f),
              (t.bindAll = A),
              (t.bufferConvexPolygon = function (t, e) {
                const n = [];
                for (let r = 0; r < t.length; r++) {
                  const i = y(r - 1, -1, t.length - 1),
                    o = y(r + 1, -1, t.length - 1),
                    s = t[r],
                    a = t[o],
                    l = t[i].sub(s).unit(),
                    c = a.sub(s).unit(),
                    u = c.angleWithSep(l.x, l.y),
                    h = l
                      .add(c)
                      .unit()
                      .mult((-1 * e) / Math.sin(u / 2));
                  n.push(s.add(h));
                }
                return n;
              }),
              (t.cacheEntryPossiblyAdded = function (t) {
                xt++,
                  xt > _t &&
                    (t.getActor().send("enforceCacheSizeLimit", yt), (xt = 0));
              }),
              (t.clamp = g),
              (t.clearTileCache = function (t) {
                const e = a.caches.delete(ft);
                t && e.catch(t).then(() => t());
              }),
              (t.clipLine = Mu),
              (t.clone = function (t) {
                var e = new fa(3);
                return (e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), e;
              }),
              (t.clone$1 = function (t) {
                var e = new fa(16);
                return (
                  (e[0] = t[0]),
                  (e[1] = t[1]),
                  (e[2] = t[2]),
                  (e[3] = t[3]),
                  (e[4] = t[4]),
                  (e[5] = t[5]),
                  (e[6] = t[6]),
                  (e[7] = t[7]),
                  (e[8] = t[8]),
                  (e[9] = t[9]),
                  (e[10] = t[10]),
                  (e[11] = t[11]),
                  (e[12] = t[12]),
                  (e[13] = t[13]),
                  (e[14] = t[14]),
                  (e[15] = t[15]),
                  e
                );
              }),
              (t.clone$2 = O),
              (t.collisionCircleLayout = bc),
              (t.config = $),
              (t.conjugate = function (t, e) {
                return (
                  (t[0] = -e[0]),
                  (t[1] = -e[1]),
                  (t[2] = -e[2]),
                  (t[3] = e[3]),
                  t
                );
              }),
              (t.copy = function (t, e) {
                return (t[0] = e[0]), (t[1] = e[1]), (t[2] = e[2]), t;
              }),
              (t.create = va),
              (t.create$1 = function () {
                var t = new fa(16);
                return (
                  fa != Float32Array &&
                    ((t[1] = 0),
                    (t[2] = 0),
                    (t[3] = 0),
                    (t[4] = 0),
                    (t[6] = 0),
                    (t[7] = 0),
                    (t[8] = 0),
                    (t[9] = 0),
                    (t[11] = 0),
                    (t[12] = 0),
                    (t[13] = 0),
                    (t[14] = 0)),
                  (t[0] = 1),
                  (t[5] = 1),
                  (t[10] = 1),
                  (t[15] = 1),
                  t
                );
              }),
              (t.create$2 = ma),
              (t.createExpression = hr),
              (t.createFilter = Tr),
              (t.createLayout = Co),
              (t.createStyleLayer = function (t) {
                return "custom" === t.type ? new xh(t) : new Eh[t.type](t);
              }),
              (t.cross = function (t, e, n) {
                var r = e[0],
                  i = e[1],
                  o = e[2],
                  s = n[0],
                  a = n[1],
                  l = n[2];
                return (
                  (t[0] = i * l - o * a),
                  (t[1] = o * s - r * l),
                  (t[2] = r * a - i * s),
                  t
                );
              }),
              (t.degToRad = h),
              (t.div = function (t, e, n) {
                return (
                  (t[0] = e[0] / n[0]),
                  (t[1] = e[1] / n[1]),
                  (t[2] = e[2] / n[2]),
                  t
                );
              }),
              (t.dot = function (t, e) {
                return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
              }),
              (t.dot$1 = function (t, e) {
                return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3];
              }),
              (t.ease = m),
              (t.easeCubicInOut = d),
              (t.emitValidationErrors = ni),
              (t.endsWith = C),
              (t.enforceCacheSizeLimit = function (t) {
                vt(),
                  mt &&
                    mt.then((e) => {
                      e.keys().then((n) => {
                        for (let r = 0; r < n.length - t; r++) e.delete(n[r]);
                      });
                    });
              }),
              (t.evaluateSizeForFeature = Ec),
              (t.evaluateSizeForZoom = Tc),
              (t.evaluateVariableOffset = Yu),
              (t.evented = ro),
              (t.exactEquals = function (t, e) {
                return (
                  t[0] === e[0] &&
                  t[1] === e[1] &&
                  t[2] === e[2] &&
                  t[3] === e[3]
                );
              }),
              (t.exactEquals$1 = function (t, e) {
                return t[0] === e[0] && t[1] === e[1] && t[2] === e[2];
              }),
              (t.exported = V),
              (t.exported$1 = G),
              (t.extend = b),
              (t.filterObject = M),
              (t.fromMat4 = function (t, e) {
                return (
                  (t[0] = e[0]),
                  (t[1] = e[1]),
                  (t[2] = e[2]),
                  (t[3] = e[4]),
                  (t[4] = e[5]),
                  (t[5] = e[6]),
                  (t[6] = e[8]),
                  (t[7] = e[9]),
                  (t[8] = e[10]),
                  t
                );
              }),
              (t.fromQuat = function (t, e) {
                var n = e[0],
                  r = e[1],
                  i = e[2],
                  o = e[3],
                  s = n + n,
                  a = r + r,
                  l = i + i,
                  c = n * s,
                  u = r * s,
                  h = r * a,
                  p = i * s,
                  d = i * a,
                  f = i * l,
                  m = o * s,
                  g = o * a,
                  y = o * l;
                return (
                  (t[0] = 1 - h - f),
                  (t[1] = u + y),
                  (t[2] = p - g),
                  (t[3] = 0),
                  (t[4] = u - y),
                  (t[5] = 1 - c - f),
                  (t[6] = d + m),
                  (t[7] = 0),
                  (t[8] = p + g),
                  (t[9] = d - m),
                  (t[10] = 1 - c - h),
                  (t[11] = 0),
                  (t[12] = 0),
                  (t[13] = 0),
                  (t[14] = 0),
                  (t[15] = 1),
                  t
                );
              }),
              (t.fromRotation = function (t, e) {
                var n = Math.sin(e),
                  r = Math.cos(e);
                return (
                  (t[0] = r),
                  (t[1] = n),
                  (t[2] = 0),
                  (t[3] = -n),
                  (t[4] = r),
                  (t[5] = 0),
                  (t[6] = 0),
                  (t[7] = 0),
                  (t[8] = 1),
                  t
                );
              }),
              (t.fromScaling = function (t, e) {
                return (
                  (t[0] = e[0]),
                  (t[1] = 0),
                  (t[2] = 0),
                  (t[3] = 0),
                  (t[4] = 0),
                  (t[5] = e[1]),
                  (t[6] = 0),
                  (t[7] = 0),
                  (t[8] = 0),
                  (t[9] = 0),
                  (t[10] = e[2]),
                  (t[11] = 0),
                  (t[12] = 0),
                  (t[13] = 0),
                  (t[14] = 0),
                  (t[15] = 1),
                  t
                );
              }),
              (t.furthestTileCorner = function (t) {
                const e = Math.round(((t + 45 + 360) % 360) / 90) % 4;
                return p[e];
              }),
              (t.getAABBPointSquareDist = function (t, e, n) {
                let r = 0;
                for (let i = 0; i < 2; ++i) {
                  const o = n ? n[i] : 0;
                  t[i] > o && (r += (t[i] - o) * (t[i] - o)),
                    e[i] < o && (r += (o - e[i]) * (o - e[i]));
                }
                return r;
              }),
              (t.getAnchorAlignment = yu),
              (t.getAnchorJustification = Ju),
              (t.getBounds = function (t) {
                let e = 1 / 0,
                  n = 1 / 0,
                  r = -1 / 0,
                  i = -1 / 0;
                for (const o of t)
                  (e = Math.min(e, o.x)),
                    (n = Math.min(n, o.y)),
                    (r = Math.max(r, o.x)),
                    (i = Math.max(i, o.y));
                return { min: new o(e, n), max: new o(r, i) };
              }),
              (t.getImage = Dt),
              (t.getJSON = function (t, e) {
                return Tt(b(t, { type: "json" }), e);
              }),
              (t.getMapSessionAPI = pt),
              (t.getPerformanceMeasurement = $h),
              (t.getRTLTextPluginStatus = io),
              (t.getReferrer = Et),
              (t.getVideo = function (t, e) {
                const n = a.document.createElement("video");
                (n.muted = !0),
                  (n.onloadstart = function () {
                    e(null, n);
                  });
                for (let r = 0; r < t.length; r++) {
                  const e = a.document.createElement("source");
                  Mt(t[r]) || (n.crossOrigin = "Anonymous"),
                    (e.src = t[r]),
                    n.appendChild(e);
                }
                return { cancel: () => {} };
              }),
              (t.identity = ga),
              (t.identity$1 = Da),
              (t.invert = function (t, e) {
                var n = e[0],
                  r = e[1],
                  i = e[2],
                  o = e[3],
                  s = e[4],
                  a = e[5],
                  l = e[6],
                  c = e[7],
                  u = e[8],
                  h = e[9],
                  p = e[10],
                  d = e[11],
                  f = e[12],
                  m = e[13],
                  g = e[14],
                  y = e[15],
                  _ = n * a - r * s,
                  v = n * l - i * s,
                  b = n * c - o * s,
                  x = r * l - i * a,
                  w = r * c - o * a,
                  S = i * c - o * l,
                  E = u * m - h * f,
                  T = u * g - p * f,
                  A = u * y - d * f,
                  C = h * g - p * m,
                  P = h * y - d * m,
                  M = p * y - d * g,
                  O = _ * M - v * P + b * C + x * A - w * T + S * E;
                return O
                  ? ((t[0] = (a * M - l * P + c * C) * (O = 1 / O)),
                    (t[1] = (i * P - r * M - o * C) * O),
                    (t[2] = (m * S - g * w + y * x) * O),
                    (t[3] = (p * w - h * S - d * x) * O),
                    (t[4] = (l * A - s * M - c * T) * O),
                    (t[5] = (n * M - i * A + o * T) * O),
                    (t[6] = (g * b - f * S - y * v) * O),
                    (t[7] = (u * S - p * b + d * v) * O),
                    (t[8] = (s * P - a * A + c * E) * O),
                    (t[9] = (r * A - n * P - o * E) * O),
                    (t[10] = (f * w - m * b + y * _) * O),
                    (t[11] = (h * b - u * w - d * _) * O),
                    (t[12] = (a * T - s * C - l * E) * O),
                    (t[13] = (n * C - r * T + i * E) * O),
                    (t[14] = (m * v - f * x - g * _) * O),
                    (t[15] = (u * x - h * v + p * _) * O),
                    t)
                  : null;
              }),
              (t.isMapAuthenticated = function (t) {
                return dt.has(t);
              }),
              (t.isMapboxURL = tt),
              (t.latFromMercatorY = Nh),
              (t.len = Oa),
              (t.length = ba),
              (t.length$1 = function (t) {
                return Math.hypot(t[0], t[1], t[2], t[3]);
              }),
              (t.loadVectorTile = Ip),
              (t.makeRequest = Tt),
              (t.mercatorXfromLng = Lh),
              (t.mercatorYfromLat = Fh),
              (t.mercatorZfromAltitude = Bh),
              (t.mul = function (t, e, n) {
                return (
                  (t[0] = e[0] * n[0]),
                  (t[1] = e[1] * n[1]),
                  (t[2] = e[2] * n[2]),
                  (t[3] = e[3] * n[3]),
                  t
                );
              }),
              (t.mul$1 = _a),
              (t.mul$2 = Ma),
              (t.multiply = ya),
              (t.multiply$1 = Sa),
              (t.nextPowerOfTwo = E),
              (t.normalize = Ta),
              (t.normalize$1 = function (t, e) {
                var n = e[0],
                  r = e[1],
                  i = e[2],
                  o = e[3],
                  s = n * n + r * r + i * i + o * o;
                return (
                  s > 0 && (s = 1 / Math.sqrt(s)),
                  (t[0] = n * s),
                  (t[1] = r * s),
                  (t[2] = i * s),
                  (t[3] = o * s),
                  t
                );
              }),
              (t.number = rn),
              (t.ortho = function (t, e, n, r, i, o, s) {
                var a = 1 / (e - n),
                  l = 1 / (r - i),
                  c = 1 / (o - s);
                return (
                  (t[0] = -2 * a),
                  (t[1] = 0),
                  (t[2] = 0),
                  (t[3] = 0),
                  (t[4] = 0),
                  (t[5] = -2 * l),
                  (t[6] = 0),
                  (t[7] = 0),
                  (t[8] = 0),
                  (t[9] = 0),
                  (t[10] = 2 * c),
                  (t[11] = 0),
                  (t[12] = (e + n) * a),
                  (t[13] = (i + r) * l),
                  (t[14] = (s + o) * c),
                  (t[15] = 1),
                  t
                );
              }),
              (t.pbf = Dc),
              (t.perspective = function (t, e, n, r, i) {
                var o,
                  s = 1 / Math.tan(e / 2);
                return (
                  (t[0] = s / n),
                  (t[1] = 0),
                  (t[2] = 0),
                  (t[3] = 0),
                  (t[4] = 0),
                  (t[5] = s),
                  (t[6] = 0),
                  (t[7] = 0),
                  (t[8] = 0),
                  (t[9] = 0),
                  (t[11] = -1),
                  (t[12] = 0),
                  (t[13] = 0),
                  (t[15] = 0),
                  null != i && i !== 1 / 0
                    ? ((t[10] = (i + r) * (o = 1 / (r - i))),
                      (t[14] = 2 * i * r * o))
                    : ((t[10] = -1), (t[14] = -2 * r)),
                  t
                );
              }),
              (t.pick = function (t, e) {
                const n = {};
                for (let r = 0; r < e.length; r++) {
                  const i = e[r];
                  i in t && (n[i] = t[i]);
                }
                return n;
              }),
              (t.plugin = so),
              (t.pointGeometry = o),
              (t.polygonIntersectsBox = sa),
              (t.polygonIntersectsPolygon = Ks),
              (t.polygonizeBounds = function (t, e, n = 0, r = !0) {
                const i = new o(n, n),
                  s = t.sub(i),
                  a = e.add(i),
                  l = [s, new o(a.x, s.y), a, new o(s.x, a.y)];
                return r && l.push(s), l;
              }),
              (t.posAttributes = tp),
              (t.postMapLoadEvent = ut),
              (t.postTurnstileEvent = lt),
              (t.potpack = nu),
              (t.prevPowerOfTwo = function (t) {
                return t <= 1
                  ? 1
                  : Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
              }),
              (t.radToDeg = function (t) {
                return t * u;
              }),
              (t.refProperties = [
                "type",
                "source",
                "source-layer",
                "minzoom",
                "maxzoom",
                "filter",
                "layout",
              ]),
              (t.registerForPluginStateChange = function (t) {
                return (
                  t({ pluginStatus: Ji, pluginURL: to }),
                  ro.on("pluginStateChange", t),
                  t
                );
              }),
              (t.removeAuthState = function (t) {
                dt.delete(t);
              }),
              (t.renderColorRamp = Ga),
              (t.rotateX = function (t, e, n) {
                var r = Math.sin(n),
                  i = Math.cos(n),
                  o = e[4],
                  s = e[5],
                  a = e[6],
                  l = e[7],
                  c = e[8],
                  u = e[9],
                  h = e[10],
                  p = e[11];
                return (
                  e !== t &&
                    ((t[0] = e[0]),
                    (t[1] = e[1]),
                    (t[2] = e[2]),
                    (t[3] = e[3]),
                    (t[12] = e[12]),
                    (t[13] = e[13]),
                    (t[14] = e[14]),
                    (t[15] = e[15])),
                  (t[4] = o * i + c * r),
                  (t[5] = s * i + u * r),
                  (t[6] = a * i + h * r),
                  (t[7] = l * i + p * r),
                  (t[8] = c * i - o * r),
                  (t[9] = u * i - s * r),
                  (t[10] = h * i - a * r),
                  (t[11] = p * i - l * r),
                  t
                );
              }),
              (t.rotateX$1 = za),
              (t.rotateY = function (t, e, n) {
                var r = Math.sin(n),
                  i = Math.cos(n),
                  o = e[0],
                  s = e[1],
                  a = e[2],
                  l = e[3],
                  c = e[8],
                  u = e[9],
                  h = e[10],
                  p = e[11];
                return (
                  e !== t &&
                    ((t[4] = e[4]),
                    (t[5] = e[5]),
                    (t[6] = e[6]),
                    (t[7] = e[7]),
                    (t[12] = e[12]),
                    (t[13] = e[13]),
                    (t[14] = e[14]),
                    (t[15] = e[15])),
                  (t[0] = o * i - c * r),
                  (t[1] = s * i - u * r),
                  (t[2] = a * i - h * r),
                  (t[3] = l * i - p * r),
                  (t[8] = o * r + c * i),
                  (t[9] = s * r + u * i),
                  (t[10] = a * r + h * i),
                  (t[11] = l * r + p * i),
                  t
                );
              }),
              (t.rotateZ = function (t, e, n) {
                var r = Math.sin(n),
                  i = Math.cos(n),
                  o = e[0],
                  s = e[1],
                  a = e[2],
                  l = e[3],
                  c = e[4],
                  u = e[5],
                  h = e[6],
                  p = e[7];
                return (
                  e !== t &&
                    ((t[8] = e[8]),
                    (t[9] = e[9]),
                    (t[10] = e[10]),
                    (t[11] = e[11]),
                    (t[12] = e[12]),
                    (t[13] = e[13]),
                    (t[14] = e[14]),
                    (t[15] = e[15])),
                  (t[0] = o * i + c * r),
                  (t[1] = s * i + u * r),
                  (t[2] = a * i + h * r),
                  (t[3] = l * i + p * r),
                  (t[4] = c * i - o * r),
                  (t[5] = u * i - s * r),
                  (t[6] = h * i - a * r),
                  (t[7] = p * i - l * r),
                  t
                );
              }),
              (t.rotateZ$1 = function (t, e, n) {
                n *= 0.5;
                var r = e[0],
                  i = e[1],
                  o = e[2],
                  s = e[3],
                  a = Math.sin(n),
                  l = Math.cos(n);
                return (
                  (t[0] = r * l + i * a),
                  (t[1] = i * l - r * a),
                  (t[2] = o * l + s * a),
                  (t[3] = s * l - o * a),
                  t
                );
              }),
              (t.scale = function (t, e, n) {
                return (
                  (t[0] = e[0] * n), (t[1] = e[1] * n), (t[2] = e[2] * n), t
                );
              }),
              (t.scale$1 = function (t, e, n) {
                var r = n[0],
                  i = n[1],
                  o = n[2];
                return (
                  (t[0] = e[0] * r),
                  (t[1] = e[1] * r),
                  (t[2] = e[2] * r),
                  (t[3] = e[3] * r),
                  (t[4] = e[4] * i),
                  (t[5] = e[5] * i),
                  (t[6] = e[6] * i),
                  (t[7] = e[7] * i),
                  (t[8] = e[8] * o),
                  (t[9] = e[9] * o),
                  (t[10] = e[10] * o),
                  (t[11] = e[11] * o),
                  (t[12] = e[12]),
                  (t[13] = e[13]),
                  (t[14] = e[14]),
                  (t[15] = e[15]),
                  t
                );
              }),
              (t.scale$2 = function (t, e, n) {
                return (
                  (t[0] = e[0] * n),
                  (t[1] = e[1] * n),
                  (t[2] = e[2] * n),
                  (t[3] = e[3] * n),
                  t
                );
              }),
              (t.scaleAndAdd = Ea),
              (t.setCacheLimits = function (t, e) {
                (yt = t), (_t = e);
              }),
              (t.setRTLTextPlugin = function (t, e, n = !1) {
                if (Ji === Xi || Ji === Ki || Ji === Yi)
                  throw new Error(
                    "setRTLTextPlugin cannot be called multiple times."
                  );
                (to = V.resolveURL(t)), (Ji = Xi), (Qi = e), no(), n || oo();
              }),
              (t.smoothstep = function (t, e, n) {
                return (n = g((n - t) / (e - t), 0, 1)) * n * (3 - 2 * n);
              }),
              (t.spec = Nt),
              (t.storeAuthState = function (t, e) {
                e ? dt.add(t) : dt.delete(t);
              }),
              (t.sub = Pa),
              (t.subtract = wa),
              (t.symbolSize = Ac),
              (t.transformMat3 = function (t, e, n) {
                var r = e[0],
                  i = e[1],
                  o = e[2];
                return (
                  (t[0] = r * n[0] + i * n[3] + o * n[6]),
                  (t[1] = r * n[1] + i * n[4] + o * n[7]),
                  (t[2] = r * n[2] + i * n[5] + o * n[8]),
                  t
                );
              }),
              (t.transformMat4 = ka),
              (t.transformMat4$1 = function (t, e, n) {
                var r = e[0],
                  i = e[1],
                  o = e[2],
                  s = n[3] * r + n[7] * i + n[11] * o + n[15];
                return (
                  (t[0] =
                    (n[0] * r + n[4] * i + n[8] * o + n[12]) / (s = s || 1)),
                  (t[1] = (n[1] * r + n[5] * i + n[9] * o + n[13]) / s),
                  (t[2] = (n[2] * r + n[6] * i + n[10] * o + n[14]) / s),
                  t
                );
              }),
              (t.transformQuat = Aa),
              (t.translate = function (t, e, n) {
                var r,
                  i,
                  o,
                  s,
                  a,
                  l,
                  c,
                  u,
                  h,
                  p,
                  d,
                  f,
                  m = n[0],
                  g = n[1],
                  y = n[2];
                return (
                  e === t
                    ? ((t[12] = e[0] * m + e[4] * g + e[8] * y + e[12]),
                      (t[13] = e[1] * m + e[5] * g + e[9] * y + e[13]),
                      (t[14] = e[2] * m + e[6] * g + e[10] * y + e[14]),
                      (t[15] = e[3] * m + e[7] * g + e[11] * y + e[15]))
                    : ((i = e[1]),
                      (o = e[2]),
                      (s = e[3]),
                      (a = e[4]),
                      (l = e[5]),
                      (c = e[6]),
                      (u = e[7]),
                      (h = e[8]),
                      (p = e[9]),
                      (d = e[10]),
                      (f = e[11]),
                      (t[0] = r = e[0]),
                      (t[1] = i),
                      (t[2] = o),
                      (t[3] = s),
                      (t[4] = a),
                      (t[5] = l),
                      (t[6] = c),
                      (t[7] = u),
                      (t[8] = h),
                      (t[9] = p),
                      (t[10] = d),
                      (t[11] = f),
                      (t[12] = r * m + a * g + h * y + e[12]),
                      (t[13] = i * m + l * g + p * y + e[13]),
                      (t[14] = o * m + c * g + d * y + e[14]),
                      (t[15] = s * m + u * g + f * y + e[15])),
                  t
                );
              }),
              (t.triggerPluginCompletionEvent = eo),
              (t.uniqueId = w),
              (t.validateCustomStyleLayer = function (t) {
                const e = [],
                  n = t.id;
                return (
                  void 0 === n &&
                    e.push({
                      message: `layers.${n}: missing required property "id"`,
                    }),
                  void 0 === t.render &&
                    e.push({
                      message: `layers.${n}: missing required method "render"`,
                    }),
                  t.renderingMode &&
                    "2d" !== t.renderingMode &&
                    "3d" !== t.renderingMode &&
                    e.push({
                      message: `layers.${n}: property "renderingMode" must be either "2d" or "3d"`,
                    }),
                  e
                );
              }),
              (t.validateFog = Jr),
              (t.validateLight = Qr),
              (t.validateStyle = Yr),
              (t.values = v),
              (t.vectorTile = Gl),
              (t.version = e),
              (t.warnOnce = I),
              (t.window = a),
              (t.wrap = y);
          }),
          i(["./shared"], function (t) {
            function e(t) {
              const n = typeof t;
              if (
                "number" === n ||
                "boolean" === n ||
                "string" === n ||
                null == t
              )
                return JSON.stringify(t);
              if (Array.isArray(t)) {
                let n = "[";
                for (const r of t) n += `${e(r)},`;
                return `${n}]`;
              }
              const r = Object.keys(t).sort();
              let i = "{";
              for (let o = 0; o < r.length; o++)
                i += `${JSON.stringify(r[o])}:${e(t[r[o]])},`;
              return `${i}}`;
            }
            function n(n) {
              let r = "";
              for (const i of t.refProperties) r += `/${e(n[i])}`;
              return r;
            }
            class r {
              constructor(t) {
                (this.keyCache = {}), t && this.replace(t);
              }
              replace(t) {
                (this._layerConfigs = {}),
                  (this._layers = {}),
                  this.update(t, []);
              }
              update(e, r) {
                for (const n of e) {
                  this._layerConfigs[n.id] = n;
                  const e = (this._layers[n.id] = t.createStyleLayer(n));
                  (e._featureFilter = t.createFilter(e.filter)),
                    this.keyCache[n.id] && delete this.keyCache[n.id];
                }
                for (const t of r)
                  delete this.keyCache[t],
                    delete this._layerConfigs[t],
                    delete this._layers[t];
                this.familiesBySource = {};
                const i = (function (t, e) {
                  const r = {};
                  for (let o = 0; o < t.length; o++) {
                    const i = (e && e[t[o].id]) || n(t[o]);
                    e && (e[t[o].id] = i);
                    let s = r[i];
                    s || (s = r[i] = []), s.push(t[o]);
                  }
                  const i = [];
                  for (const n in r) i.push(r[n]);
                  return i;
                })(t.values(this._layerConfigs), this.keyCache);
                for (const t of i) {
                  const e = t.map((t) => this._layers[t.id]),
                    n = e[0];
                  if ("none" === n.visibility) continue;
                  const r = n.source || "";
                  let i = this.familiesBySource[r];
                  i || (i = this.familiesBySource[r] = {});
                  const o = n.sourceLayer || "_geojsonTileLayer";
                  let s = i[o];
                  s || (s = i[o] = []), s.push(e);
                }
              }
            }
            const { ImageBitmap: i } = t.window;
            class o {
              loadTile(e, n) {
                const {
                    uid: r,
                    encoding: o,
                    rawImageData: s,
                    padding: a,
                    buildQuadTree: l,
                  } = e,
                  c = i && s instanceof i ? this.getImageData(s, a) : s;
                n(null, new t.DEMData(r, c, o, a < 1, l));
              }
              getImageData(e, n) {
                (this.offscreenCanvas && this.offscreenCanvasContext) ||
                  ((this.offscreenCanvas = new OffscreenCanvas(
                    e.width,
                    e.height
                  )),
                  (this.offscreenCanvasContext =
                    this.offscreenCanvas.getContext("2d"))),
                  (this.offscreenCanvas.width = e.width),
                  (this.offscreenCanvas.height = e.height),
                  this.offscreenCanvasContext.drawImage(
                    e,
                    0,
                    0,
                    e.width,
                    e.height
                  );
                const r = this.offscreenCanvasContext.getImageData(
                  -n,
                  -n,
                  e.width + 2 * n,
                  e.height + 2 * n
                );
                return (
                  this.offscreenCanvasContext.clearRect(
                    0,
                    0,
                    this.offscreenCanvas.width,
                    this.offscreenCanvas.height
                  ),
                  new t.RGBAImage({ width: r.width, height: r.height }, r.data)
                );
              }
            }
            var s = function t(e, n) {
              var r,
                i = e && e.type;
              if ("FeatureCollection" === i)
                for (r = 0; r < e.features.length; r++) t(e.features[r], n);
              else if ("GeometryCollection" === i)
                for (r = 0; r < e.geometries.length; r++) t(e.geometries[r], n);
              else if ("Feature" === i) t(e.geometry, n);
              else if ("Polygon" === i) a(e.coordinates, n);
              else if ("MultiPolygon" === i)
                for (r = 0; r < e.coordinates.length; r++)
                  a(e.coordinates[r], n);
              return e;
            };
            function a(t, e) {
              if (0 !== t.length) {
                l(t[0], e);
                for (var n = 1; n < t.length; n++) l(t[n], !e);
              }
            }
            function l(t, e) {
              for (var n = 0, r = 0, i = t.length, o = i - 1; r < i; o = r++)
                n += (t[r][0] - t[o][0]) * (t[o][1] + t[r][1]);
              n >= 0 != !!e && t.reverse();
            }
            const c = t.vectorTile.VectorTileFeature.prototype.toGeoJSON;
            class u {
              constructor(e) {
                (this._feature = e),
                  (this.extent = t.EXTENT),
                  (this.type = e.type),
                  (this.properties = e.tags),
                  "id" in e && !isNaN(e.id) && (this.id = parseInt(e.id, 10));
              }
              loadGeometry() {
                if (1 === this._feature.type) {
                  const e = [];
                  for (const n of this._feature.geometry)
                    e.push([new t.pointGeometry(n[0], n[1])]);
                  return e;
                }
                {
                  const e = [];
                  for (const n of this._feature.geometry) {
                    const r = [];
                    for (const e of n) r.push(new t.pointGeometry(e[0], e[1]));
                    e.push(r);
                  }
                  return e;
                }
              }
              toGeoJSON(t, e, n) {
                return c.call(this, t, e, n);
              }
            }
            class h {
              constructor(e) {
                (this.layers = { _geojsonTileLayer: this }),
                  (this.name = "_geojsonTileLayer"),
                  (this.extent = t.EXTENT),
                  (this.length = e.length),
                  (this._features = e);
              }
              feature(t) {
                return new u(this._features[t]);
              }
            }
            var p = t.vectorTile.VectorTileFeature,
              d = f;
            function f(t, e) {
              (this.options = e || {}),
                (this.features = t),
                (this.length = t.length);
            }
            function m(t, e) {
              (this.id = "number" == typeof t.id ? t.id : void 0),
                (this.type = t.type),
                (this.rawGeometry = 1 === t.type ? [t.geometry] : t.geometry),
                (this.properties = t.tags),
                (this.extent = e || 4096);
            }
            (f.prototype.feature = function (t) {
              return new m(this.features[t], this.options.extent);
            }),
              (m.prototype.loadGeometry = function () {
                var e = this.rawGeometry;
                this.geometry = [];
                for (var n = 0; n < e.length; n++) {
                  for (var r = e[n], i = [], o = 0; o < r.length; o++)
                    i.push(new t.pointGeometry(r[o][0], r[o][1]));
                  this.geometry.push(i);
                }
                return this.geometry;
              }),
              (m.prototype.bbox = function () {
                this.geometry || this.loadGeometry();
                for (
                  var t = this.geometry,
                    e = 1 / 0,
                    n = -1 / 0,
                    r = 1 / 0,
                    i = -1 / 0,
                    o = 0;
                  o < t.length;
                  o++
                )
                  for (var s = t[o], a = 0; a < s.length; a++) {
                    var l = s[a];
                    (e = Math.min(e, l.x)),
                      (n = Math.max(n, l.x)),
                      (r = Math.min(r, l.y)),
                      (i = Math.max(i, l.y));
                  }
                return [e, r, n, i];
              }),
              (m.prototype.toGeoJSON = p.prototype.toGeoJSON);
            var g = _,
              y = d;
            function _(e) {
              var n = new t.pbf();
              return (
                (function (t, e) {
                  for (var n in t.layers) e.writeMessage(3, v, t.layers[n]);
                })(e, n),
                n.finish()
              );
            }
            function v(t, e) {
              var n;
              e.writeVarintField(15, t.version || 1),
                e.writeStringField(1, t.name || ""),
                e.writeVarintField(5, t.extent || 4096);
              var r = { keys: [], values: [], keycache: {}, valuecache: {} };
              for (n = 0; n < t.length; n++)
                (r.feature = t.feature(n)), e.writeMessage(2, b, r);
              var i = r.keys;
              for (n = 0; n < i.length; n++) e.writeStringField(3, i[n]);
              var o = r.values;
              for (n = 0; n < o.length; n++) e.writeMessage(4, T, o[n]);
            }
            function b(t, e) {
              var n = t.feature;
              void 0 !== n.id && e.writeVarintField(1, n.id),
                e.writeMessage(2, x, t),
                e.writeVarintField(3, n.type),
                e.writeMessage(4, E, n);
            }
            function x(t, e) {
              var n = t.feature,
                r = t.keys,
                i = t.values,
                o = t.keycache,
                s = t.valuecache;
              for (var a in n.properties) {
                var l = o[a];
                void 0 === l && (r.push(a), (o[a] = l = r.length - 1)),
                  e.writeVarint(l);
                var c = n.properties[a],
                  u = typeof c;
                "string" !== u &&
                  "boolean" !== u &&
                  "number" !== u &&
                  (c = JSON.stringify(c));
                var h = u + ":" + c,
                  p = s[h];
                void 0 === p && (i.push(c), (s[h] = p = i.length - 1)),
                  e.writeVarint(p);
              }
            }
            function w(t, e) {
              return (e << 3) + (7 & t);
            }
            function S(t) {
              return (t << 1) ^ (t >> 31);
            }
            function E(t, e) {
              for (
                var n = t.loadGeometry(),
                  r = t.type,
                  i = 0,
                  o = 0,
                  s = n.length,
                  a = 0;
                a < s;
                a++
              ) {
                var l = n[a],
                  c = 1;
                1 === r && (c = l.length), e.writeVarint(w(1, c));
                for (
                  var u = 3 === r ? l.length - 1 : l.length, h = 0;
                  h < u;
                  h++
                ) {
                  1 === h && 1 !== r && e.writeVarint(w(2, u - 1));
                  var p = l[h].x - i,
                    d = l[h].y - o;
                  e.writeVarint(S(p)), e.writeVarint(S(d)), (i += p), (o += d);
                }
                3 === r && e.writeVarint(w(7, 1));
              }
            }
            function T(t, e) {
              var n = typeof t;
              "string" === n
                ? e.writeStringField(1, t)
                : "boolean" === n
                ? e.writeBooleanField(7, t)
                : "number" === n &&
                  (t % 1 != 0
                    ? e.writeDoubleField(3, t)
                    : t < 0
                    ? e.writeSVarintField(6, t)
                    : e.writeVarintField(5, t));
            }
            function A(t, e, n, r, i, o) {
              if (i - r <= n) return;
              const s = (r + i) >> 1;
              C(t, e, s, r, i, o % 2),
                A(t, e, n, r, s - 1, o + 1),
                A(t, e, n, s + 1, i, o + 1);
            }
            function C(t, e, n, r, i, o) {
              for (; i > r; ) {
                if (i - r > 600) {
                  const s = i - r + 1,
                    a = n - r + 1,
                    l = Math.log(s),
                    c = 0.5 * Math.exp((2 * l) / 3),
                    u =
                      0.5 *
                      Math.sqrt((l * c * (s - c)) / s) *
                      (a - s / 2 < 0 ? -1 : 1);
                  C(
                    t,
                    e,
                    n,
                    Math.max(r, Math.floor(n - (a * c) / s + u)),
                    Math.min(i, Math.floor(n + ((s - a) * c) / s + u)),
                    o
                  );
                }
                const s = e[2 * n + o];
                let a = r,
                  l = i;
                for (
                  P(t, e, r, n), e[2 * i + o] > s && P(t, e, r, i);
                  a < l;

                ) {
                  for (P(t, e, a, l), a++, l--; e[2 * a + o] < s; ) a++;
                  for (; e[2 * l + o] > s; ) l--;
                }
                e[2 * r + o] === s ? P(t, e, r, l) : (l++, P(t, e, l, i)),
                  l <= n && (r = l + 1),
                  n <= l && (i = l - 1);
              }
            }
            function P(t, e, n, r) {
              M(t, n, r), M(e, 2 * n, 2 * r), M(e, 2 * n + 1, 2 * r + 1);
            }
            function M(t, e, n) {
              const r = t[e];
              (t[e] = t[n]), (t[n] = r);
            }
            function O(t, e, n, r) {
              const i = t - n,
                o = e - r;
              return i * i + o * o;
            }
            (g.fromVectorTileJs = _),
              (g.fromGeojsonVt = function (t, e) {
                e = e || {};
                var n = {};
                for (var r in t)
                  (n[r] = new d(t[r].features, e)),
                    (n[r].name = r),
                    (n[r].version = e.version),
                    (n[r].extent = e.extent);
                return _({ layers: n });
              }),
              (g.GeoJSONWrapper = y);
            const k = (t) => t[0],
              I = (t) => t[1];
            class D {
              constructor(t, e = k, n = I, r = 64, i = Float64Array) {
                (this.nodeSize = r), (this.points = t);
                const o = t.length < 65536 ? Uint16Array : Uint32Array,
                  s = (this.ids = new o(t.length)),
                  a = (this.coords = new i(2 * t.length));
                for (let l = 0; l < t.length; l++)
                  (s[l] = l), (a[2 * l] = e(t[l])), (a[2 * l + 1] = n(t[l]));
                A(s, a, r, 0, s.length - 1, 0);
              }
              range(t, e, n, r) {
                return (function (t, e, n, r, i, o, s) {
                  const a = [0, t.length - 1, 0],
                    l = [];
                  let c, u;
                  for (; a.length; ) {
                    const h = a.pop(),
                      p = a.pop(),
                      d = a.pop();
                    if (p - d <= s) {
                      for (let s = d; s <= p; s++)
                        (c = e[2 * s]),
                          (u = e[2 * s + 1]),
                          c >= n && c <= i && u >= r && u <= o && l.push(t[s]);
                      continue;
                    }
                    const f = Math.floor((d + p) / 2);
                    (c = e[2 * f]),
                      (u = e[2 * f + 1]),
                      c >= n && c <= i && u >= r && u <= o && l.push(t[f]);
                    const m = (h + 1) % 2;
                    (0 === h ? n <= c : r <= u) &&
                      (a.push(d), a.push(f - 1), a.push(m)),
                      (0 === h ? i >= c : o >= u) &&
                        (a.push(f + 1), a.push(p), a.push(m));
                  }
                  return l;
                })(this.ids, this.coords, t, e, n, r, this.nodeSize);
              }
              within(t, e, n) {
                return (function (t, e, n, r, i, o) {
                  const s = [0, t.length - 1, 0],
                    a = [],
                    l = i * i;
                  for (; s.length; ) {
                    const c = s.pop(),
                      u = s.pop(),
                      h = s.pop();
                    if (u - h <= o) {
                      for (let i = h; i <= u; i++)
                        O(e[2 * i], e[2 * i + 1], n, r) <= l && a.push(t[i]);
                      continue;
                    }
                    const p = Math.floor((h + u) / 2),
                      d = e[2 * p],
                      f = e[2 * p + 1];
                    O(d, f, n, r) <= l && a.push(t[p]);
                    const m = (c + 1) % 2;
                    (0 === c ? n - i <= d : r - i <= f) &&
                      (s.push(h), s.push(p - 1), s.push(m)),
                      (0 === c ? n + i >= d : r + i >= f) &&
                        (s.push(p + 1), s.push(u), s.push(m));
                  }
                  return a;
                })(this.ids, this.coords, t, e, n, this.nodeSize);
              }
            }
            const z = {
                minZoom: 0,
                maxZoom: 16,
                minPoints: 2,
                radius: 40,
                extent: 512,
                nodeSize: 64,
                log: !1,
                generateId: !1,
                reduce: null,
                map: (t) => t,
              },
              R =
                Math.fround ||
                ((L = new Float32Array(1)), (t) => ((L[0] = +t), L[0]));
            var L;
            class F {
              constructor(t) {
                (this.options = $(Object.create(z), t)),
                  (this.trees = new Array(this.options.maxZoom + 1));
              }
              load(t) {
                const {
                  log: e,
                  minZoom: n,
                  maxZoom: r,
                  nodeSize: i,
                } = this.options;
                e && console.time("total time");
                const o = `prepare ${t.length} points`;
                e && console.time(o), (this.points = t);
                let s = [];
                for (let a = 0; a < t.length; a++)
                  t[a].geometry && s.push(N(t[a], a));
                (this.trees[r + 1] = new D(s, G, W, i, Float32Array)),
                  e && console.timeEnd(o);
                for (let a = r; a >= n; a--) {
                  const t = +Date.now();
                  (s = this._cluster(s, a)),
                    (this.trees[a] = new D(s, G, W, i, Float32Array)),
                    e &&
                      console.log(
                        "z%d: %d clusters in %dms",
                        a,
                        s.length,
                        +Date.now() - t
                      );
                }
                return e && console.timeEnd("total time"), this;
              }
              getClusters(t, e) {
                let n = ((((t[0] + 180) % 360) + 360) % 360) - 180;
                const r = Math.max(-90, Math.min(90, t[1]));
                let i =
                  180 === t[2]
                    ? 180
                    : ((((t[2] + 180) % 360) + 360) % 360) - 180;
                const o = Math.max(-90, Math.min(90, t[3]));
                if (t[2] - t[0] >= 360) (n = -180), (i = 180);
                else if (n > i) {
                  const t = this.getClusters([n, r, 180, o], e),
                    s = this.getClusters([-180, r, i, o], e);
                  return t.concat(s);
                }
                const s = this.trees[this._limitZoom(e)],
                  a = s.range(Z(n), V(o), Z(i), V(r)),
                  l = [];
                for (const c of a) {
                  const t = s.points[c];
                  l.push(t.numPoints ? j(t) : this.points[t.index]);
                }
                return l;
              }
              getChildren(t) {
                const e = this._getOriginId(t),
                  n = this._getOriginZoom(t),
                  r = "No cluster with the specified id.",
                  i = this.trees[n];
                if (!i) throw new Error(r);
                const o = i.points[e];
                if (!o) throw new Error(r);
                const s =
                    this.options.radius /
                    (this.options.extent * Math.pow(2, n - 1)),
                  a = i.within(o.x, o.y, s),
                  l = [];
                for (const c of a) {
                  const e = i.points[c];
                  e.parentId === t &&
                    l.push(e.numPoints ? j(e) : this.points[e.index]);
                }
                if (0 === l.length) throw new Error(r);
                return l;
              }
              getLeaves(t, e, n) {
                const r = [];
                return (
                  this._appendLeaves(r, t, (e = e || 10), (n = n || 0), 0), r
                );
              }
              getTile(t, e, n) {
                const r = this.trees[this._limitZoom(t)],
                  i = Math.pow(2, t),
                  { extent: o, radius: s } = this.options,
                  a = s / o,
                  l = (n - a) / i,
                  c = (n + 1 + a) / i,
                  u = { features: [] };
                return (
                  this._addTileFeatures(
                    r.range((e - a) / i, l, (e + 1 + a) / i, c),
                    r.points,
                    e,
                    n,
                    i,
                    u
                  ),
                  0 === e &&
                    this._addTileFeatures(
                      r.range(1 - a / i, l, 1, c),
                      r.points,
                      i,
                      n,
                      i,
                      u
                    ),
                  e === i - 1 &&
                    this._addTileFeatures(
                      r.range(0, l, a / i, c),
                      r.points,
                      -1,
                      n,
                      i,
                      u
                    ),
                  u.features.length ? u : null
                );
              }
              getClusterExpansionZoom(t) {
                let e = this._getOriginZoom(t) - 1;
                for (; e <= this.options.maxZoom; ) {
                  const n = this.getChildren(t);
                  if ((e++, 1 !== n.length)) break;
                  t = n[0].properties.cluster_id;
                }
                return e;
              }
              _appendLeaves(t, e, n, r, i) {
                const o = this.getChildren(e);
                for (const s of o) {
                  const e = s.properties;
                  if (
                    (e && e.cluster
                      ? i + e.point_count <= r
                        ? (i += e.point_count)
                        : (i = this._appendLeaves(t, e.cluster_id, n, r, i))
                      : i < r
                      ? i++
                      : t.push(s),
                    t.length === n)
                  )
                    break;
                }
                return i;
              }
              _addTileFeatures(t, e, n, r, i, o) {
                for (const s of t) {
                  const t = e[s],
                    a = t.numPoints;
                  let l, c, u;
                  if (a) (l = U(t)), (c = t.x), (u = t.y);
                  else {
                    const e = this.points[t.index];
                    (l = e.properties),
                      (c = Z(e.geometry.coordinates[0])),
                      (u = V(e.geometry.coordinates[1]));
                  }
                  const h = {
                    type: 1,
                    geometry: [
                      [
                        Math.round(this.options.extent * (c * i - n)),
                        Math.round(this.options.extent * (u * i - r)),
                      ],
                    ],
                    tags: l,
                  };
                  let p;
                  a
                    ? (p = t.id)
                    : this.options.generateId
                    ? (p = t.index)
                    : this.points[t.index].id && (p = this.points[t.index].id),
                    void 0 !== p && (h.id = p),
                    o.features.push(h);
                }
              }
              _limitZoom(t) {
                return Math.max(
                  this.options.minZoom,
                  Math.min(+t, this.options.maxZoom + 1)
                );
              }
              _cluster(t, e) {
                const n = [],
                  {
                    radius: r,
                    extent: i,
                    reduce: o,
                    minPoints: s,
                  } = this.options,
                  a = r / (i * Math.pow(2, e));
                for (let l = 0; l < t.length; l++) {
                  const r = t[l];
                  if (r.zoom <= e) continue;
                  r.zoom = e;
                  const i = this.trees[e + 1],
                    c = i.within(r.x, r.y, a),
                    u = r.numPoints || 1;
                  let h = u;
                  for (const t of c) {
                    const n = i.points[t];
                    n.zoom > e && (h += n.numPoints || 1);
                  }
                  if (h >= s) {
                    let t = r.x * u,
                      s = r.y * u,
                      a = o && u > 1 ? this._map(r, !0) : null;
                    const p = (l << 5) + (e + 1) + this.points.length;
                    for (const n of c) {
                      const l = i.points[n];
                      if (l.zoom <= e) continue;
                      l.zoom = e;
                      const c = l.numPoints || 1;
                      (t += l.x * c),
                        (s += l.y * c),
                        (l.parentId = p),
                        o && (a || (a = this._map(r, !0)), o(a, this._map(l)));
                    }
                    (r.parentId = p), n.push(B(t / h, s / h, p, h, a));
                  } else if ((n.push(r), h > 1))
                    for (const t of c) {
                      const r = i.points[t];
                      r.zoom <= e || ((r.zoom = e), n.push(r));
                    }
                }
                return n;
              }
              _getOriginId(t) {
                return (t - this.points.length) >> 5;
              }
              _getOriginZoom(t) {
                return (t - this.points.length) % 32;
              }
              _map(t, e) {
                if (t.numPoints) return e ? $({}, t.properties) : t.properties;
                const n = this.points[t.index].properties,
                  r = this.options.map(n);
                return e && r === n ? $({}, r) : r;
              }
            }
            function B(t, e, n, r, i) {
              return {
                x: R(t),
                y: R(e),
                zoom: 1 / 0,
                id: n,
                parentId: -1,
                numPoints: r,
                properties: i,
              };
            }
            function N(t, e) {
              const [n, r] = t.geometry.coordinates;
              return {
                x: R(Z(n)),
                y: R(V(r)),
                zoom: 1 / 0,
                index: e,
                parentId: -1,
              };
            }
            function j(t) {
              return {
                type: "Feature",
                id: t.id,
                properties: U(t),
                geometry: {
                  type: "Point",
                  coordinates: [((e = t.x), 360 * (e - 0.5)), q(t.y)],
                },
              };
              var e;
            }
            function U(t) {
              const e = t.numPoints,
                n =
                  e >= 1e4
                    ? `${Math.round(e / 1e3)}k`
                    : e >= 1e3
                    ? Math.round(e / 100) / 10 + "k"
                    : e;
              return $($({}, t.properties), {
                cluster: !0,
                cluster_id: t.id,
                point_count: e,
                point_count_abbreviated: n,
              });
            }
            function Z(t) {
              return t / 360 + 0.5;
            }
            function V(t) {
              const e = Math.sin((t * Math.PI) / 180),
                n = 0.5 - (0.25 * Math.log((1 + e) / (1 - e))) / Math.PI;
              return n < 0 ? 0 : n > 1 ? 1 : n;
            }
            function q(t) {
              const e = ((180 - 360 * t) * Math.PI) / 180;
              return (360 * Math.atan(Math.exp(e))) / Math.PI - 90;
            }
            function $(t, e) {
              for (const n in e) t[n] = e[n];
              return t;
            }
            function G(t) {
              return t.x;
            }
            function W(t) {
              return t.y;
            }
            function H(t, e, n, r) {
              for (
                var i,
                  o = r,
                  s = (n - e) >> 1,
                  a = n - e,
                  l = t[e],
                  c = t[e + 1],
                  u = t[n],
                  h = t[n + 1],
                  p = e + 3;
                p < n;
                p += 3
              ) {
                var d = X(t[p], t[p + 1], l, c, u, h);
                if (d > o) (i = p), (o = d);
                else if (d === o) {
                  var f = Math.abs(p - s);
                  f < a && ((i = p), (a = f));
                }
              }
              o > r &&
                (i - e > 3 && H(t, e, i, r),
                (t[i + 2] = o),
                n - i > 3 && H(t, i, n, r));
            }
            function X(t, e, n, r, i, o) {
              var s = i - n,
                a = o - r;
              if (0 !== s || 0 !== a) {
                var l = ((t - n) * s + (e - r) * a) / (s * s + a * a);
                l > 1
                  ? ((n = i), (r = o))
                  : l > 0 && ((n += s * l), (r += a * l));
              }
              return (s = t - n) * s + (a = e - r) * a;
            }
            function K(t, e, n, r) {
              var i = {
                id: void 0 === t ? null : t,
                type: e,
                geometry: n,
                tags: r,
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -1 / 0,
                maxY: -1 / 0,
              };
              return (
                (function (t) {
                  var e = t.geometry,
                    n = t.type;
                  if ("Point" === n || "MultiPoint" === n || "LineString" === n)
                    Y(t, e);
                  else if ("Polygon" === n || "MultiLineString" === n)
                    for (var r = 0; r < e.length; r++) Y(t, e[r]);
                  else if ("MultiPolygon" === n)
                    for (r = 0; r < e.length; r++)
                      for (var i = 0; i < e[r].length; i++) Y(t, e[r][i]);
                })(i),
                i
              );
            }
            function Y(t, e) {
              for (var n = 0; n < e.length; n += 3)
                (t.minX = Math.min(t.minX, e[n])),
                  (t.minY = Math.min(t.minY, e[n + 1])),
                  (t.maxX = Math.max(t.maxX, e[n])),
                  (t.maxY = Math.max(t.maxY, e[n + 1]));
            }
            function Q(t, e, n, r) {
              if (e.geometry) {
                var i = e.geometry.coordinates,
                  o = e.geometry.type,
                  s = Math.pow(n.tolerance / ((1 << n.maxZoom) * n.extent), 2),
                  a = [],
                  l = e.id;
                if (
                  (n.promoteId
                    ? (l = e.properties[n.promoteId])
                    : n.generateId && (l = r || 0),
                  "Point" === o)
                )
                  J(i, a);
                else if ("MultiPoint" === o)
                  for (var c = 0; c < i.length; c++) J(i[c], a);
                else if ("LineString" === o) tt(i, a, s, !1);
                else if ("MultiLineString" === o) {
                  if (n.lineMetrics) {
                    for (c = 0; c < i.length; c++)
                      tt(i[c], (a = []), s, !1),
                        t.push(K(l, "LineString", a, e.properties));
                    return;
                  }
                  et(i, a, s, !1);
                } else if ("Polygon" === o) et(i, a, s, !0);
                else {
                  if ("MultiPolygon" !== o) {
                    if ("GeometryCollection" === o) {
                      for (c = 0; c < e.geometry.geometries.length; c++)
                        Q(
                          t,
                          {
                            id: l,
                            geometry: e.geometry.geometries[c],
                            properties: e.properties,
                          },
                          n,
                          r
                        );
                      return;
                    }
                    throw new Error(
                      "Input data is not a valid GeoJSON object."
                    );
                  }
                  for (c = 0; c < i.length; c++) {
                    var u = [];
                    et(i[c], u, s, !0), a.push(u);
                  }
                }
                t.push(K(l, o, a, e.properties));
              }
            }
            function J(t, e) {
              e.push(nt(t[0])), e.push(rt(t[1])), e.push(0);
            }
            function tt(t, e, n, r) {
              for (var i, o, s = 0, a = 0; a < t.length; a++) {
                var l = nt(t[a][0]),
                  c = rt(t[a][1]);
                e.push(l),
                  e.push(c),
                  e.push(0),
                  a > 0 &&
                    (s += r
                      ? (i * c - l * o) / 2
                      : Math.sqrt(Math.pow(l - i, 2) + Math.pow(c - o, 2))),
                  (i = l),
                  (o = c);
              }
              var u = e.length - 3;
              (e[2] = 1),
                H(e, 0, u, n),
                (e[u + 2] = 1),
                (e.size = Math.abs(s)),
                (e.start = 0),
                (e.end = e.size);
            }
            function et(t, e, n, r) {
              for (var i = 0; i < t.length; i++) {
                var o = [];
                tt(t[i], o, n, r), e.push(o);
              }
            }
            function nt(t) {
              return t / 360 + 0.5;
            }
            function rt(t) {
              var e = Math.sin((t * Math.PI) / 180),
                n = 0.5 - (0.25 * Math.log((1 + e) / (1 - e))) / Math.PI;
              return n < 0 ? 0 : n > 1 ? 1 : n;
            }
            function it(t, e, n, r, i, o, s, a) {
              if (((r /= e), o >= (n /= e) && s < r)) return t;
              if (s < n || o >= r) return null;
              for (var l = [], c = 0; c < t.length; c++) {
                var u = t[c],
                  h = u.geometry,
                  p = u.type,
                  d = 0 === i ? u.minX : u.minY,
                  f = 0 === i ? u.maxX : u.maxY;
                if (d >= n && f < r) l.push(u);
                else if (!(f < n || d >= r)) {
                  var m = [];
                  if ("Point" === p || "MultiPoint" === p) ot(h, m, n, r, i);
                  else if ("LineString" === p)
                    st(h, m, n, r, i, !1, a.lineMetrics);
                  else if ("MultiLineString" === p) lt(h, m, n, r, i, !1);
                  else if ("Polygon" === p) lt(h, m, n, r, i, !0);
                  else if ("MultiPolygon" === p)
                    for (var g = 0; g < h.length; g++) {
                      var y = [];
                      lt(h[g], y, n, r, i, !0), y.length && m.push(y);
                    }
                  if (m.length) {
                    if (a.lineMetrics && "LineString" === p) {
                      for (g = 0; g < m.length; g++)
                        l.push(K(u.id, p, m[g], u.tags));
                      continue;
                    }
                    ("LineString" !== p && "MultiLineString" !== p) ||
                      (1 === m.length
                        ? ((p = "LineString"), (m = m[0]))
                        : (p = "MultiLineString")),
                      ("Point" !== p && "MultiPoint" !== p) ||
                        (p = 3 === m.length ? "Point" : "MultiPoint"),
                      l.push(K(u.id, p, m, u.tags));
                  }
                }
              }
              return l.length ? l : null;
            }
            function ot(t, e, n, r, i) {
              for (var o = 0; o < t.length; o += 3) {
                var s = t[o + i];
                s >= n &&
                  s <= r &&
                  (e.push(t[o]), e.push(t[o + 1]), e.push(t[o + 2]));
              }
            }
            function st(t, e, n, r, i, o, s) {
              for (
                var a, l, c = at(t), u = 0 === i ? ut : ht, h = t.start, p = 0;
                p < t.length - 3;
                p += 3
              ) {
                var d = t[p],
                  f = t[p + 1],
                  m = t[p + 2],
                  g = t[p + 3],
                  y = t[p + 4],
                  _ = 0 === i ? d : f,
                  v = 0 === i ? g : y,
                  b = !1;
                s && (a = Math.sqrt(Math.pow(d - g, 2) + Math.pow(f - y, 2))),
                  _ < n
                    ? v > n &&
                      ((l = u(c, d, f, g, y, n)), s && (c.start = h + a * l))
                    : _ > r
                    ? v < r &&
                      ((l = u(c, d, f, g, y, r)), s && (c.start = h + a * l))
                    : ct(c, d, f, m),
                  v < n && _ >= n && ((l = u(c, d, f, g, y, n)), (b = !0)),
                  v > r && _ <= r && ((l = u(c, d, f, g, y, r)), (b = !0)),
                  !o && b && (s && (c.end = h + a * l), e.push(c), (c = at(t))),
                  s && (h += a);
              }
              var x = t.length - 3;
              (d = t[x]),
                (f = t[x + 1]),
                (m = t[x + 2]),
                (_ = 0 === i ? d : f) >= n && _ <= r && ct(c, d, f, m),
                (x = c.length - 3),
                o &&
                  x >= 3 &&
                  (c[x] !== c[0] || c[x + 1] !== c[1]) &&
                  ct(c, c[0], c[1], c[2]),
                c.length && e.push(c);
            }
            function at(t) {
              var e = [];
              return (e.size = t.size), (e.start = t.start), (e.end = t.end), e;
            }
            function lt(t, e, n, r, i, o) {
              for (var s = 0; s < t.length; s++) st(t[s], e, n, r, i, o, !1);
            }
            function ct(t, e, n, r) {
              t.push(e), t.push(n), t.push(r);
            }
            function ut(t, e, n, r, i, o) {
              var s = (o - e) / (r - e);
              return t.push(o), t.push(n + (i - n) * s), t.push(1), s;
            }
            function ht(t, e, n, r, i, o) {
              var s = (o - n) / (i - n);
              return t.push(e + (r - e) * s), t.push(o), t.push(1), s;
            }
            function pt(t, e) {
              for (var n = [], r = 0; r < t.length; r++) {
                var i,
                  o = t[r],
                  s = o.type;
                if ("Point" === s || "MultiPoint" === s || "LineString" === s)
                  i = dt(o.geometry, e);
                else if ("MultiLineString" === s || "Polygon" === s) {
                  i = [];
                  for (var a = 0; a < o.geometry.length; a++)
                    i.push(dt(o.geometry[a], e));
                } else if ("MultiPolygon" === s)
                  for (i = [], a = 0; a < o.geometry.length; a++) {
                    for (var l = [], c = 0; c < o.geometry[a].length; c++)
                      l.push(dt(o.geometry[a][c], e));
                    i.push(l);
                  }
                n.push(K(o.id, s, i, o.tags));
              }
              return n;
            }
            function dt(t, e) {
              var n = [];
              (n.size = t.size),
                void 0 !== t.start && ((n.start = t.start), (n.end = t.end));
              for (var r = 0; r < t.length; r += 3)
                n.push(t[r] + e, t[r + 1], t[r + 2]);
              return n;
            }
            function ft(t, e) {
              if (t.transformed) return t;
              var n,
                r,
                i,
                o = 1 << t.z,
                s = t.x,
                a = t.y;
              for (n = 0; n < t.features.length; n++) {
                var l = t.features[n],
                  c = l.geometry,
                  u = l.type;
                if (((l.geometry = []), 1 === u))
                  for (r = 0; r < c.length; r += 2)
                    l.geometry.push(mt(c[r], c[r + 1], e, o, s, a));
                else
                  for (r = 0; r < c.length; r++) {
                    var h = [];
                    for (i = 0; i < c[r].length; i += 2)
                      h.push(mt(c[r][i], c[r][i + 1], e, o, s, a));
                    l.geometry.push(h);
                  }
              }
              return (t.transformed = !0), t;
            }
            function mt(t, e, n, r, i, o) {
              return [Math.round(n * (t * r - i)), Math.round(n * (e * r - o))];
            }
            function gt(t, e, n, r, i) {
              for (
                var o =
                    e === i.maxZoom ? 0 : i.tolerance / ((1 << e) * i.extent),
                  s = {
                    features: [],
                    numPoints: 0,
                    numSimplified: 0,
                    numFeatures: 0,
                    source: null,
                    x: n,
                    y: r,
                    z: e,
                    transformed: !1,
                    minX: 2,
                    minY: 1,
                    maxX: -1,
                    maxY: 0,
                  },
                  a = 0;
                a < t.length;
                a++
              ) {
                s.numFeatures++, yt(s, t[a], o, i);
                var l = t[a].minX,
                  c = t[a].minY,
                  u = t[a].maxX,
                  h = t[a].maxY;
                l < s.minX && (s.minX = l),
                  c < s.minY && (s.minY = c),
                  u > s.maxX && (s.maxX = u),
                  h > s.maxY && (s.maxY = h);
              }
              return s;
            }
            function yt(t, e, n, r) {
              var i = e.geometry,
                o = e.type,
                s = [];
              if ("Point" === o || "MultiPoint" === o)
                for (var a = 0; a < i.length; a += 3)
                  s.push(i[a]),
                    s.push(i[a + 1]),
                    t.numPoints++,
                    t.numSimplified++;
              else if ("LineString" === o) _t(s, i, t, n, !1, !1);
              else if ("MultiLineString" === o || "Polygon" === o)
                for (a = 0; a < i.length; a++)
                  _t(s, i[a], t, n, "Polygon" === o, 0 === a);
              else if ("MultiPolygon" === o)
                for (var l = 0; l < i.length; l++) {
                  var c = i[l];
                  for (a = 0; a < c.length; a++) _t(s, c[a], t, n, !0, 0 === a);
                }
              if (s.length) {
                var u = e.tags || null;
                if ("LineString" === o && r.lineMetrics) {
                  for (var h in ((u = {}), e.tags)) u[h] = e.tags[h];
                  (u.mapbox_clip_start = i.start / i.size),
                    (u.mapbox_clip_end = i.end / i.size);
                }
                var p = {
                  geometry: s,
                  type:
                    "Polygon" === o || "MultiPolygon" === o
                      ? 3
                      : "LineString" === o || "MultiLineString" === o
                      ? 2
                      : 1,
                  tags: u,
                };
                null !== e.id && (p.id = e.id), t.features.push(p);
              }
            }
            function _t(t, e, n, r, i, o) {
              var s = r * r;
              if (r > 0 && e.size < (i ? s : r)) n.numPoints += e.length / 3;
              else {
                for (var a = [], l = 0; l < e.length; l += 3)
                  (0 === r || e[l + 2] > s) &&
                    (n.numSimplified++, a.push(e[l]), a.push(e[l + 1])),
                    n.numPoints++;
                i &&
                  (function (t, e) {
                    for (
                      var n = 0, r = 0, i = t.length, o = i - 2;
                      r < i;
                      o = r, r += 2
                    )
                      n += (t[r] - t[o]) * (t[r + 1] + t[o + 1]);
                    if (n > 0 === e)
                      for (r = 0, i = t.length; r < i / 2; r += 2) {
                        var s = t[r],
                          a = t[r + 1];
                        (t[r] = t[i - 2 - r]),
                          (t[r + 1] = t[i - 1 - r]),
                          (t[i - 2 - r] = s),
                          (t[i - 1 - r] = a);
                      }
                  })(a, o),
                  t.push(a);
              }
            }
            function vt(t, e) {
              var n = (e = this.options =
                (function (t, e) {
                  for (var n in e) t[n] = e[n];
                  return t;
                })(Object.create(this.options), e)).debug;
              if (
                (n && console.time("preprocess data"),
                e.maxZoom < 0 || e.maxZoom > 24)
              )
                throw new Error("maxZoom should be in the 0-24 range");
              if (e.promoteId && e.generateId)
                throw new Error(
                  "promoteId and generateId cannot be used together."
                );
              var r = (function (t, e) {
                var n = [];
                if ("FeatureCollection" === t.type)
                  for (var r = 0; r < t.features.length; r++)
                    Q(n, t.features[r], e, r);
                else Q(n, "Feature" === t.type ? t : { geometry: t }, e);
                return n;
              })(t, e);
              (this.tiles = {}),
                (this.tileCoords = []),
                n &&
                  (console.timeEnd("preprocess data"),
                  console.log(
                    "index: maxZoom: %d, maxPoints: %d",
                    e.indexMaxZoom,
                    e.indexMaxPoints
                  ),
                  console.time("generate tiles"),
                  (this.stats = {}),
                  (this.total = 0)),
                (r = (function (t, e) {
                  var n = e.buffer / e.extent,
                    r = t,
                    i = it(t, 1, -1 - n, n, 0, -1, 2, e),
                    o = it(t, 1, 1 - n, 2 + n, 0, -1, 2, e);
                  return (
                    (i || o) &&
                      ((r = it(t, 1, -n, 1 + n, 0, -1, 2, e) || []),
                      i && (r = pt(i, 1).concat(r)),
                      o && (r = r.concat(pt(o, -1)))),
                    r
                  );
                })(r, e)).length && this.splitTile(r, 0, 0, 0),
                n &&
                  (r.length &&
                    console.log(
                      "features: %d, points: %d",
                      this.tiles[0].numFeatures,
                      this.tiles[0].numPoints
                    ),
                  console.timeEnd("generate tiles"),
                  console.log(
                    "tiles generated:",
                    this.total,
                    JSON.stringify(this.stats)
                  ));
            }
            function bt(t, e, n) {
              return 32 * ((1 << t) * n + e) + t;
            }
            function xt(t, e) {
              const n = t.tileID.canonical;
              if (!this._geoJSONIndex) return e(null, null);
              const r = this._geoJSONIndex.getTile(n.z, n.x, n.y);
              if (!r) return e(null, null);
              const i = new h(r.features);
              let o = g(i);
              (0 === o.byteOffset && o.byteLength === o.buffer.byteLength) ||
                (o = new Uint8Array(o)),
                e(null, { vectorTile: i, rawData: o.buffer });
            }
            (vt.prototype.options = {
              maxZoom: 14,
              indexMaxZoom: 5,
              indexMaxPoints: 1e5,
              tolerance: 3,
              extent: 4096,
              buffer: 64,
              lineMetrics: !1,
              promoteId: null,
              generateId: !1,
              debug: 0,
            }),
              (vt.prototype.splitTile = function (t, e, n, r, i, o, s) {
                for (
                  var a = [t, e, n, r], l = this.options, c = l.debug;
                  a.length;

                ) {
                  (r = a.pop()), (n = a.pop()), (e = a.pop()), (t = a.pop());
                  var u = 1 << e,
                    h = bt(e, n, r),
                    p = this.tiles[h];
                  if (
                    !p &&
                    (c > 1 && console.time("creation"),
                    (p = this.tiles[h] = gt(t, e, n, r, l)),
                    this.tileCoords.push({ z: e, x: n, y: r }),
                    c)
                  ) {
                    c > 1 &&
                      (console.log(
                        "tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",
                        e,
                        n,
                        r,
                        p.numFeatures,
                        p.numPoints,
                        p.numSimplified
                      ),
                      console.timeEnd("creation"));
                    var d = "z" + e;
                    (this.stats[d] = (this.stats[d] || 0) + 1), this.total++;
                  }
                  if (((p.source = t), i)) {
                    if (e === l.maxZoom || e === i) continue;
                    var f = 1 << (i - e);
                    if (n !== Math.floor(o / f) || r !== Math.floor(s / f))
                      continue;
                  } else if (
                    e === l.indexMaxZoom ||
                    p.numPoints <= l.indexMaxPoints
                  )
                    continue;
                  if (((p.source = null), 0 !== t.length)) {
                    c > 1 && console.time("clipping");
                    var m,
                      g,
                      y,
                      _,
                      v,
                      b,
                      x = (0.5 * l.buffer) / l.extent,
                      w = 0.5 - x,
                      S = 0.5 + x,
                      E = 1 + x;
                    (m = g = y = _ = null),
                      (v = it(t, u, n - x, n + S, 0, p.minX, p.maxX, l)),
                      (b = it(t, u, n + w, n + E, 0, p.minX, p.maxX, l)),
                      (t = null),
                      v &&
                        ((m = it(v, u, r - x, r + S, 1, p.minY, p.maxY, l)),
                        (g = it(v, u, r + w, r + E, 1, p.minY, p.maxY, l)),
                        (v = null)),
                      b &&
                        ((y = it(b, u, r - x, r + S, 1, p.minY, p.maxY, l)),
                        (_ = it(b, u, r + w, r + E, 1, p.minY, p.maxY, l)),
                        (b = null)),
                      c > 1 && console.timeEnd("clipping"),
                      a.push(m || [], e + 1, 2 * n, 2 * r),
                      a.push(g || [], e + 1, 2 * n, 2 * r + 1),
                      a.push(y || [], e + 1, 2 * n + 1, 2 * r),
                      a.push(_ || [], e + 1, 2 * n + 1, 2 * r + 1);
                  }
                }
              }),
              (vt.prototype.getTile = function (t, e, n) {
                var r = this.options,
                  i = r.extent,
                  o = r.debug;
                if (t < 0 || t > 24) return null;
                var s = 1 << t,
                  a = bt(t, (e = ((e % s) + s) % s), n);
                if (this.tiles[a]) return ft(this.tiles[a], i);
                o > 1 && console.log("drilling down to z%d-%d-%d", t, e, n);
                for (var l, c = t, u = e, h = n; !l && c > 0; )
                  c--,
                    (u = Math.floor(u / 2)),
                    (h = Math.floor(h / 2)),
                    (l = this.tiles[bt(c, u, h)]);
                return l && l.source
                  ? (o > 1 &&
                      console.log("found parent tile z%d-%d-%d", c, u, h),
                    o > 1 && console.time("drilling down"),
                    this.splitTile(l.source, c, u, h, t, e, n),
                    o > 1 && console.timeEnd("drilling down"),
                    this.tiles[a] ? ft(this.tiles[a], i) : null)
                  : null;
              });
            class wt extends t.VectorTileWorkerSource {
              constructor(t, e, n, r, i) {
                super(t, e, n, r, xt), i && (this.loadGeoJSON = i);
              }
              loadData(e, n) {
                const r = e && e.request,
                  i = r && r.collectResourceTiming;
                this.loadGeoJSON(e, (o, a) => {
                  if (o || !a) return n(o);
                  if ("object" != typeof a)
                    return n(
                      new Error(
                        `Input data given to '${e.source}' is not a valid GeoJSON object.`
                      )
                    );
                  {
                    s(a, !0);
                    try {
                      if (e.filter) {
                        const n = t.createExpression(e.filter, {
                          type: "boolean",
                          "property-type": "data-driven",
                          overridable: !1,
                          transition: !1,
                        });
                        if ("error" === n.result)
                          throw new Error(
                            n.value
                              .map((t) => `${t.key}: ${t.message}`)
                              .join(", ")
                          );
                        const r = a.features.filter((t) =>
                          n.value.evaluate({ zoom: 0 }, t)
                        );
                        a = { type: "FeatureCollection", features: r };
                      }
                      this._geoJSONIndex = e.cluster
                        ? new F(
                            (function ({
                              superclusterOptions: e,
                              clusterProperties: n,
                            }) {
                              if (!n || !e) return e;
                              const r = {},
                                i = {},
                                o = { accumulated: null, zoom: 0 },
                                s = { properties: null },
                                a = Object.keys(n);
                              for (const l of a) {
                                const [e, o] = n[l],
                                  s = t.createExpression(o),
                                  a = t.createExpression(
                                    "string" == typeof e
                                      ? [e, ["accumulated"], ["get", l]]
                                      : e
                                  );
                                (r[l] = s.value), (i[l] = a.value);
                              }
                              return (
                                (e.map = (t) => {
                                  s.properties = t;
                                  const e = {};
                                  for (const n of a) e[n] = r[n].evaluate(o, s);
                                  return e;
                                }),
                                (e.reduce = (t, e) => {
                                  s.properties = e;
                                  for (const n of a)
                                    (o.accumulated = t[n]),
                                      (t[n] = i[n].evaluate(o, s));
                                }),
                                e
                              );
                            })(e)
                          ).load(a.features)
                        : (function (t, e) {
                            return new vt(t, e);
                          })(a, e.geojsonVtOptions);
                    } catch (o) {
                      return n(o);
                    }
                    this.loaded = {};
                    const l = {};
                    if (i) {
                      const n = t.getPerformanceMeasurement(r);
                      n &&
                        ((l.resourceTiming = {}),
                        (l.resourceTiming[e.source] = JSON.parse(
                          JSON.stringify(n)
                        )));
                    }
                    n(null, l);
                  }
                });
              }
              reloadTile(t, e) {
                const n = this.loaded;
                return n && n[t.uid]
                  ? super.reloadTile(t, e)
                  : this.loadTile(t, e);
              }
              loadGeoJSON(e, n) {
                if (e.request) t.getJSON(e.request, n);
                else {
                  if ("string" != typeof e.data)
                    return n(
                      new Error(
                        `Input data given to '${e.source}' is not a valid GeoJSON object.`
                      )
                    );
                  try {
                    return n(null, JSON.parse(e.data));
                  } catch (t) {
                    return n(
                      new Error(
                        `Input data given to '${e.source}' is not a valid GeoJSON object.`
                      )
                    );
                  }
                }
              }
              getClusterExpansionZoom(t, e) {
                try {
                  e(
                    null,
                    this._geoJSONIndex.getClusterExpansionZoom(t.clusterId)
                  );
                } catch (t) {
                  e(t);
                }
              }
              getClusterChildren(t, e) {
                try {
                  e(null, this._geoJSONIndex.getChildren(t.clusterId));
                } catch (t) {
                  e(t);
                }
              }
              getClusterLeaves(t, e) {
                try {
                  e(
                    null,
                    this._geoJSONIndex.getLeaves(t.clusterId, t.limit, t.offset)
                  );
                } catch (t) {
                  e(t);
                }
              }
            }
            class St {
              constructor(e) {
                (this.self = e),
                  (this.actor = new t.Actor(e, this)),
                  (this.layerIndexes = {}),
                  (this.availableImages = {}),
                  (this.isSpriteLoaded = !1),
                  (this.workerSourceTypes = {
                    vector: t.VectorTileWorkerSource,
                    geojson: wt,
                  }),
                  (this.workerSources = {}),
                  (this.demWorkerSources = {}),
                  (this.self.registerWorkerSource = (t, e) => {
                    if (this.workerSourceTypes[t])
                      throw new Error(
                        `Worker source with name "${t}" already registered.`
                      );
                    this.workerSourceTypes[t] = e;
                  }),
                  (this.self.registerRTLTextPlugin = (e) => {
                    if (t.plugin.isParsed())
                      throw new Error("RTL text plugin already registered.");
                    (t.plugin.applyArabicShaping = e.applyArabicShaping),
                      (t.plugin.processBidirectionalText =
                        e.processBidirectionalText),
                      (t.plugin.processStyledBidirectionalText =
                        e.processStyledBidirectionalText);
                  });
              }
              checkIfReady(t, e, n) {
                n();
              }
              setReferrer(t, e) {
                this.referrer = e;
              }
              spriteLoaded(e, n) {
                this.isSpriteLoaded = n;
                for (const r in this.workerSources[e]) {
                  const i = this.workerSources[e][r];
                  for (const e in i)
                    i[e] instanceof t.VectorTileWorkerSource &&
                      ((i[e].isSpriteLoaded = n),
                      i[e].fire(new t.Event("isSpriteLoaded")));
                }
              }
              setImages(t, e, n) {
                this.availableImages[t] = e;
                for (const r in this.workerSources[t]) {
                  const n = this.workerSources[t][r];
                  for (const t in n) n[t].availableImages = e;
                }
                n();
              }
              enableTerrain(t, e, n) {
                (this.terrain = e), n();
              }
              setLayers(t, e, n) {
                this.getLayerIndex(t).replace(e), n();
              }
              updateLayers(t, e, n) {
                this.getLayerIndex(t).update(e.layers, e.removedIds), n();
              }
              loadTile(e, n, r) {
                const i = this.enableTerrain
                  ? t.extend({ enableTerrain: this.terrain }, n)
                  : n;
                this.getWorkerSource(e, n.type, n.source).loadTile(i, r);
              }
              loadDEMTile(e, n, r) {
                const i = this.enableTerrain
                  ? t.extend({ buildQuadTree: this.terrain }, n)
                  : n;
                this.getDEMWorkerSource(e, n.source).loadTile(i, r);
              }
              reloadTile(e, n, r) {
                const i = this.enableTerrain
                  ? t.extend({ enableTerrain: this.terrain }, n)
                  : n;
                this.getWorkerSource(e, n.type, n.source).reloadTile(i, r);
              }
              abortTile(t, e, n) {
                this.getWorkerSource(t, e.type, e.source).abortTile(e, n);
              }
              removeTile(t, e, n) {
                this.getWorkerSource(t, e.type, e.source).removeTile(e, n);
              }
              removeSource(t, e, n) {
                if (
                  !this.workerSources[t] ||
                  !this.workerSources[t][e.type] ||
                  !this.workerSources[t][e.type][e.source]
                )
                  return;
                const r = this.workerSources[t][e.type][e.source];
                delete this.workerSources[t][e.type][e.source],
                  void 0 !== r.removeSource ? r.removeSource(e, n) : n();
              }
              loadWorkerSource(t, e, n) {
                try {
                  this.self.importScripts(e.url), n();
                } catch (t) {
                  n(t.toString());
                }
              }
              syncRTLPluginState(e, n, r) {
                try {
                  t.plugin.setState(n);
                  const e = t.plugin.getPluginURL();
                  if (
                    t.plugin.isLoaded() &&
                    !t.plugin.isParsed() &&
                    null != e
                  ) {
                    this.self.importScripts(e);
                    const n = t.plugin.isParsed();
                    r(
                      n
                        ? void 0
                        : new Error(
                            `RTL Text Plugin failed to import scripts from ${e}`
                          ),
                      n
                    );
                  }
                } catch (t) {
                  r(t.toString());
                }
              }
              getAvailableImages(t) {
                let e = this.availableImages[t];
                return e || (e = []), e;
              }
              getLayerIndex(t) {
                let e = this.layerIndexes[t];
                return e || (e = this.layerIndexes[t] = new r()), e;
              }
              getWorkerSource(t, e, n) {
                return (
                  this.workerSources[t] || (this.workerSources[t] = {}),
                  this.workerSources[t][e] || (this.workerSources[t][e] = {}),
                  this.workerSources[t][e][n] ||
                    (this.workerSources[t][e][n] = new this.workerSourceTypes[
                      e
                    ](
                      {
                        send: (e, n, r, i, o, s) => {
                          this.actor.send(e, n, r, t, o, s);
                        },
                        scheduler: this.actor.scheduler,
                      },
                      this.getLayerIndex(t),
                      this.getAvailableImages(t),
                      this.isSpriteLoaded
                    )),
                  this.workerSources[t][e][n]
                );
              }
              getDEMWorkerSource(t, e) {
                return (
                  this.demWorkerSources[t] || (this.demWorkerSources[t] = {}),
                  this.demWorkerSources[t][e] ||
                    (this.demWorkerSources[t][e] = new o()),
                  this.demWorkerSources[t][e]
                );
              }
              enforceCacheSizeLimit(e, n) {
                t.enforceCacheSizeLimit(n);
              }
              getWorkerPerformanceMetrics(t, e, n) {
                n(void 0, void 0);
              }
            }
            return (
              "undefined" != typeof WorkerGlobalScope &&
                "undefined" != typeof self &&
                self instanceof WorkerGlobalScope &&
                (self.worker = new St(self)),
              St
            );
          }),
          i(["./shared"], function (t) {
            var e = n;
            function n(t) {
              return !(function (t) {
                return "undefined" == typeof window ||
                  "undefined" == typeof document
                  ? "not a browser"
                  : Array.prototype &&
                    Array.prototype.every &&
                    Array.prototype.filter &&
                    Array.prototype.forEach &&
                    Array.prototype.indexOf &&
                    Array.prototype.lastIndexOf &&
                    Array.prototype.map &&
                    Array.prototype.some &&
                    Array.prototype.reduce &&
                    Array.prototype.reduceRight &&
                    Array.isArray
                  ? Function.prototype && Function.prototype.bind
                    ? Object.keys &&
                      Object.create &&
                      Object.getPrototypeOf &&
                      Object.getOwnPropertyNames &&
                      Object.isSealed &&
                      Object.isFrozen &&
                      Object.isExtensible &&
                      Object.getOwnPropertyDescriptor &&
                      Object.defineProperty &&
                      Object.defineProperties &&
                      Object.seal &&
                      Object.freeze &&
                      Object.preventExtensions
                      ? "JSON" in window &&
                        "parse" in JSON &&
                        "stringify" in JSON
                        ? (function () {
                            if (
                              !(
                                "Worker" in window &&
                                "Blob" in window &&
                                "URL" in window
                              )
                            )
                              return !1;
                            var t,
                              e,
                              n = new Blob([""], { type: "text/javascript" }),
                              r = URL.createObjectURL(n);
                            try {
                              (e = new Worker(r)), (t = !0);
                            } catch (e) {
                              t = !1;
                            }
                            return (
                              e && e.terminate(), URL.revokeObjectURL(r), t
                            );
                          })()
                          ? "Uint8ClampedArray" in window
                            ? ArrayBuffer.isView
                              ? (function () {
                                  var t = document.createElement("canvas");
                                  t.width = t.height = 1;
                                  var e = t.getContext("2d");
                                  if (!e) return !1;
                                  var n = e.getImageData(0, 0, 1, 1);
                                  return n && n.width === t.width;
                                })()
                                ? (void 0 ===
                                    r[
                                      (e = t && t.failIfMajorPerformanceCaveat)
                                    ] &&
                                    (r[e] = (function (t) {
                                      var e,
                                        r = (function (t) {
                                          var e =
                                              document.createElement("canvas"),
                                            r = Object.create(
                                              n.webGLContextAttributes
                                            );
                                          return (
                                            (r.failIfMajorPerformanceCaveat =
                                              t),
                                            e.getContext("webgl", r) ||
                                              e.getContext(
                                                "experimental-webgl",
                                                r
                                              )
                                          );
                                        })(t);
                                      if (!r) return !1;
                                      try {
                                        e = r.createShader(r.VERTEX_SHADER);
                                      } catch (t) {
                                        return !1;
                                      }
                                      return (
                                        !(!e || r.isContextLost()) &&
                                        (r.shaderSource(e, "void main() {}"),
                                        r.compileShader(e),
                                        !0 ===
                                          r.getShaderParameter(
                                            e,
                                            r.COMPILE_STATUS
                                          ))
                                      );
                                    })(e)),
                                  r[e]
                                    ? document.documentMode
                                      ? "insufficient ECMAScript 6 support"
                                      : void 0
                                    : "insufficient WebGL support")
                                : "insufficient Canvas/getImageData support"
                              : "insufficient ArrayBuffer support"
                            : "insufficient Uint8ClampedArray support"
                          : "insufficient worker support"
                        : "insufficient JSON support"
                      : "insufficient Object support"
                    : "insufficient Function support"
                  : "insufficent Array support";
                var e;
              })(t);
            }
            var r = {};
            function i(t, e) {
              if (Array.isArray(t)) {
                if (!Array.isArray(e) || t.length !== e.length) return !1;
                for (let n = 0; n < t.length; n++)
                  if (!i(t[n], e[n])) return !1;
                return !0;
              }
              if ("object" == typeof t && null !== t && null !== e) {
                if ("object" != typeof e) return !1;
                if (Object.keys(t).length !== Object.keys(e).length) return !1;
                for (const n in t) if (!i(t[n], e[n])) return !1;
                return !0;
              }
              return t === e;
            }
            n.webGLContextAttributes = {
              antialias: !1,
              alpha: !0,
              stencil: !0,
              depth: !0,
            };
            const o = {
                create: function (e, n, r) {
                  const i = t.window.document.createElement(e);
                  return (
                    void 0 !== n && (i.className = n), r && r.appendChild(i), i
                  );
                },
                createNS: function (e, n) {
                  return t.window.document.createElementNS(e, n);
                },
              },
              s = t.window.document && t.window.document.documentElement.style,
              a =
                s && void 0 !== s.userSelect
                  ? "userSelect"
                  : "WebkitUserSelect";
            let l;
            (o.disableDrag = function () {
              s && a && ((l = s[a]), (s[a] = "none"));
            }),
              (o.enableDrag = function () {
                s && a && (s[a] = l);
              }),
              (o.setTransform = function (t, e) {
                t.style.transform = e;
              });
            let c = !1;
            try {
              const e = Object.defineProperty({}, "passive", {
                get() {
                  c = !0;
                },
              });
              t.window.addEventListener("test", e, e),
                t.window.removeEventListener("test", e, e);
            } catch (t) {
              c = !1;
            }
            (o.addEventListener = function (t, e, n, r = {}) {
              t.addEventListener(e, n, "passive" in r && c ? r : r.capture);
            }),
              (o.removeEventListener = function (t, e, n, r = {}) {
                t.removeEventListener(
                  e,
                  n,
                  "passive" in r && c ? r : r.capture
                );
              });
            const u = function (e) {
              e.preventDefault(),
                e.stopPropagation(),
                t.window.removeEventListener("click", u, !0);
            };
            function h(e, n, r) {
              const i = e.offsetWidth === n.width ? 1 : e.offsetWidth / n.width;
              return new t.pointGeometry(
                (r.clientX - n.left) * i,
                (r.clientY - n.top) * i
              );
            }
            (o.suppressClick = function () {
              t.window.addEventListener("click", u, !0),
                t.window.setTimeout(() => {
                  t.window.removeEventListener("click", u, !0);
                }, 0);
            }),
              (o.mousePos = function (t, e) {
                const n = t.getBoundingClientRect();
                return h(t, n, e);
              }),
              (o.touchPos = function (t, e) {
                const n = t.getBoundingClientRect(),
                  r = [];
                for (let i = 0; i < e.length; i++) r.push(h(t, n, e[i]));
                return r;
              }),
              (o.mouseButton = function (e) {
                return void 0 !== t.window.InstallTrigger &&
                  2 === e.button &&
                  e.ctrlKey &&
                  t.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0
                  ? 0
                  : e.button;
              }),
              (o.remove = function (t) {
                t.parentNode && t.parentNode.removeChild(t);
              });
            class p {
              constructor(t, e) {
                (this.pos = t), (this.dir = e);
              }
              intersectsPlane(e, n, r) {
                const i = t.dot(n, this.dir);
                if (Math.abs(i) < 1e-6) return !1;
                const o = t.dot(t.sub(t.create(), e, this.pos), n) / i,
                  s = t.scaleAndAdd(t.create(), this.pos, this.dir, o);
                return t.copy(r, s), !0;
              }
            }
            class d {
              constructor(t, e) {
                (this.points = t), (this.planes = e);
              }
              static fromInvProjectionMatrix(e, n, r) {
                const i = Math.pow(2, r),
                  o = [
                    [-1, 1, -1, 1],
                    [1, 1, -1, 1],
                    [1, -1, -1, 1],
                    [-1, -1, -1, 1],
                    [-1, 1, 1, 1],
                    [1, 1, 1, 1],
                    [1, -1, 1, 1],
                    [-1, -1, 1, 1],
                  ].map((r) => {
                    const o = t.transformMat4([], r, e),
                      s = (1 / o[3] / n) * i;
                    return t.mul(o, o, [s, s, 1 / o[3], s]);
                  }),
                  s = [
                    [0, 1, 2],
                    [6, 5, 4],
                    [0, 3, 7],
                    [2, 1, 5],
                    [3, 2, 6],
                    [0, 4, 5],
                  ].map((e) => {
                    const n = t.sub([], o[e[0]], o[e[1]]),
                      r = t.sub([], o[e[2]], o[e[1]]),
                      i = t.normalize([], t.cross([], n, r)),
                      s = -t.dot(i, o[e[1]]);
                    return i.concat(s);
                  });
                return new d(o, s);
              }
            }
            class f {
              constructor(e, n) {
                (this.min = e),
                  (this.max = n),
                  (this.center = t.scale(
                    [],
                    t.add([], this.min, this.max),
                    0.5
                  ));
              }
              quadrant(e) {
                const n = [e % 2 == 0, e < 2],
                  r = t.clone(this.min),
                  i = t.clone(this.max);
                for (let t = 0; t < n.length; t++)
                  (r[t] = n[t] ? this.min[t] : this.center[t]),
                    (i[t] = n[t] ? this.center[t] : this.max[t]);
                return (i[2] = this.max[2]), new f(r, i);
              }
              distanceX(t) {
                return (
                  Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0]
                );
              }
              distanceY(t) {
                return (
                  Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1]
                );
              }
              distanceZ(t) {
                return (
                  Math.max(Math.min(this.max[2], t[2]), this.min[2]) - t[2]
                );
              }
              intersects(e) {
                const n = [
                  [this.min[0], this.min[1], this.min[2], 1],
                  [this.max[0], this.min[1], this.min[2], 1],
                  [this.max[0], this.max[1], this.min[2], 1],
                  [this.min[0], this.max[1], this.min[2], 1],
                  [this.min[0], this.min[1], this.max[2], 1],
                  [this.max[0], this.min[1], this.max[2], 1],
                  [this.max[0], this.max[1], this.max[2], 1],
                  [this.min[0], this.max[1], this.max[2], 1],
                ];
                let r = !0;
                for (let i = 0; i < e.planes.length; i++) {
                  const o = e.planes[i];
                  let s = 0;
                  for (let e = 0; e < n.length; e++) s += t.dot$1(o, n[e]) >= 0;
                  if (0 === s) return 0;
                  s !== n.length && (r = !1);
                }
                if (r) return 2;
                for (let t = 0; t < 3; t++) {
                  let n = Number.MAX_VALUE,
                    r = -Number.MAX_VALUE;
                  for (let i = 0; i < e.points.length; i++) {
                    const o = e.points[i][t] - this.min[t];
                    (n = Math.min(n, o)), (r = Math.max(r, o));
                  }
                  if (r < 0 || n > this.max[t] - this.min[t]) return 0;
                }
                return 1;
              }
            }
            function m(t) {
              const { userImage: e } = t;
              return (
                !!(e && e.render && e.render()) &&
                (t.data.replace(new Uint8Array(e.data.buffer)), !0)
              );
            }
            class g extends t.Evented {
              constructor() {
                super(),
                  (this.images = {}),
                  (this.updatedImages = {}),
                  (this.callbackDispatchedThisFrame = {}),
                  (this.loaded = !1),
                  (this.requestors = []),
                  (this.patterns = {}),
                  (this.atlasImage = new t.RGBAImage({ width: 1, height: 1 })),
                  (this.dirty = !0);
              }
              isLoaded() {
                return this.loaded;
              }
              setLoaded(t) {
                if (this.loaded !== t && ((this.loaded = t), t)) {
                  for (const { ids: t, callback: e } of this.requestors)
                    this._notify(t, e);
                  this.requestors = [];
                }
              }
              getImage(t) {
                return this.images[t];
              }
              addImage(t, e) {
                this._validate(t, e) && (this.images[t] = e);
              }
              _validate(e, n) {
                let r = !0;
                return (
                  this._validateStretch(n.stretchX, n.data && n.data.width) ||
                    (this.fire(
                      new t.ErrorEvent(
                        new Error(`Image "${e}" has invalid "stretchX" value`)
                      )
                    ),
                    (r = !1)),
                  this._validateStretch(n.stretchY, n.data && n.data.height) ||
                    (this.fire(
                      new t.ErrorEvent(
                        new Error(`Image "${e}" has invalid "stretchY" value`)
                      )
                    ),
                    (r = !1)),
                  this._validateContent(n.content, n) ||
                    (this.fire(
                      new t.ErrorEvent(
                        new Error(`Image "${e}" has invalid "content" value`)
                      )
                    ),
                    (r = !1)),
                  r
                );
              }
              _validateStretch(t, e) {
                if (!t) return !0;
                let n = 0;
                for (const r of t) {
                  if (r[0] < n || r[1] < r[0] || e < r[1]) return !1;
                  n = r[1];
                }
                return !0;
              }
              _validateContent(t, e) {
                return !(
                  t &&
                  (4 !== t.length ||
                    t[0] < 0 ||
                    e.data.width < t[0] ||
                    t[1] < 0 ||
                    e.data.height < t[1] ||
                    t[2] < 0 ||
                    e.data.width < t[2] ||
                    t[3] < 0 ||
                    e.data.height < t[3] ||
                    t[2] < t[0] ||
                    t[3] < t[1])
                );
              }
              updateImage(t, e) {
                (e.version = this.images[t].version + 1),
                  (this.images[t] = e),
                  (this.updatedImages[t] = !0);
              }
              removeImage(t) {
                const e = this.images[t];
                delete this.images[t],
                  delete this.patterns[t],
                  e.userImage && e.userImage.onRemove && e.userImage.onRemove();
              }
              listImages() {
                return Object.keys(this.images);
              }
              getImages(t, e) {
                let n = !0;
                if (!this.isLoaded())
                  for (const r of t) this.images[r] || (n = !1);
                this.isLoaded() || n
                  ? this._notify(t, e)
                  : this.requestors.push({ ids: t, callback: e });
              }
              _notify(e, n) {
                const r = {};
                for (const i of e) {
                  this.images[i] ||
                    this.fire(new t.Event("styleimagemissing", { id: i }));
                  const e = this.images[i];
                  e
                    ? (r[i] = {
                        data: e.data.clone(),
                        pixelRatio: e.pixelRatio,
                        sdf: e.sdf,
                        version: e.version,
                        stretchX: e.stretchX,
                        stretchY: e.stretchY,
                        content: e.content,
                        hasRenderCallback: Boolean(
                          e.userImage && e.userImage.render
                        ),
                      })
                    : t.warnOnce(
                        `Image "${i}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`
                      );
                }
                n(null, r);
              }
              getPixelSize() {
                const { width: t, height: e } = this.atlasImage;
                return { width: t, height: e };
              }
              getPattern(e) {
                const n = this.patterns[e],
                  r = this.getImage(e);
                if (!r) return null;
                if (n && n.position.version === r.version) return n.position;
                if (n) n.position.version = r.version;
                else {
                  const n = {
                      w: r.data.width + 2,
                      h: r.data.height + 2,
                      x: 0,
                      y: 0,
                    },
                    i = new t.ImagePosition(n, r);
                  this.patterns[e] = { bin: n, position: i };
                }
                return this._updatePatternAtlas(), this.patterns[e].position;
              }
              bind(e) {
                const n = e.gl;
                this.atlasTexture
                  ? this.dirty &&
                    (this.atlasTexture.update(this.atlasImage),
                    (this.dirty = !1))
                  : (this.atlasTexture = new t.Texture(
                      e,
                      this.atlasImage,
                      n.RGBA
                    )),
                  this.atlasTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE);
              }
              _updatePatternAtlas() {
                const e = [];
                for (const t in this.patterns) e.push(this.patterns[t].bin);
                const { w: n, h: r } = t.potpack(e),
                  i = this.atlasImage;
                i.resize({ width: n || 1, height: r || 1 });
                for (const o in this.patterns) {
                  const { bin: e } = this.patterns[o],
                    n = e.x + 1,
                    r = e.y + 1,
                    s = this.images[o].data,
                    a = s.width,
                    l = s.height;
                  t.RGBAImage.copy(
                    s,
                    i,
                    { x: 0, y: 0 },
                    { x: n, y: r },
                    { width: a, height: l }
                  ),
                    t.RGBAImage.copy(
                      s,
                      i,
                      { x: 0, y: l - 1 },
                      { x: n, y: r - 1 },
                      { width: a, height: 1 }
                    ),
                    t.RGBAImage.copy(
                      s,
                      i,
                      { x: 0, y: 0 },
                      { x: n, y: r + l },
                      { width: a, height: 1 }
                    ),
                    t.RGBAImage.copy(
                      s,
                      i,
                      { x: a - 1, y: 0 },
                      { x: n - 1, y: r },
                      { width: 1, height: l }
                    ),
                    t.RGBAImage.copy(
                      s,
                      i,
                      { x: 0, y: 0 },
                      { x: n + a, y: r },
                      { width: 1, height: l }
                    );
                }
                this.dirty = !0;
              }
              beginFrame() {
                this.callbackDispatchedThisFrame = {};
              }
              dispatchRenderCallbacks(t) {
                for (const e of t) {
                  if (this.callbackDispatchedThisFrame[e]) continue;
                  this.callbackDispatchedThisFrame[e] = !0;
                  const t = this.images[e];
                  m(t) && this.updateImage(e, t);
                }
              }
            }
            const y = new t.Properties({
                anchor: new t.DataConstantProperty(t.spec.light.anchor),
                position: new (class {
                  constructor() {
                    this.specification = t.spec.light.position;
                  }
                  possiblyEvaluate(e, n) {
                    return (function ([e, n, r]) {
                      const i = t.degToRad(n + 90),
                        o = t.degToRad(r);
                      return {
                        x: e * Math.cos(i) * Math.sin(o),
                        y: e * Math.sin(i) * Math.sin(o),
                        z: e * Math.cos(o),
                        azimuthal: n,
                        polar: r,
                      };
                    })(e.expression.evaluate(n));
                  }
                  interpolate(e, n, r) {
                    return {
                      x: t.number(e.x, n.x, r),
                      y: t.number(e.y, n.y, r),
                      z: t.number(e.z, n.z, r),
                      azimuthal: t.number(e.azimuthal, n.azimuthal, r),
                      polar: t.number(e.polar, n.polar, r),
                    };
                  }
                })(),
                color: new t.DataConstantProperty(t.spec.light.color),
                intensity: new t.DataConstantProperty(t.spec.light.intensity),
              }),
              _ = "-transition";
            class v extends t.Evented {
              constructor(e) {
                super(),
                  (this._transitionable = new t.Transitionable(y)),
                  this.setLight(e),
                  (this._transitioning = this._transitionable.untransitioned());
              }
              getLight() {
                return this._transitionable.serialize();
              }
              setLight(e, n = {}) {
                if (!this._validate(t.validateLight, e, n))
                  for (const r in e) {
                    const n = e[r];
                    t.endsWith(r, _)
                      ? this._transitionable.setTransition(
                          r.slice(0, -_.length),
                          n
                        )
                      : this._transitionable.setValue(r, n);
                  }
              }
              updateTransitions(t) {
                this._transitioning = this._transitionable.transitioned(
                  t,
                  this._transitioning
                );
              }
              hasTransition() {
                return this._transitioning.hasTransition();
              }
              recalculate(t) {
                this.properties = this._transitioning.possiblyEvaluate(t);
              }
              _validate(e, n, r) {
                return (
                  (!r || !1 !== r.validate) &&
                  t.emitValidationErrors(
                    this,
                    e.call(
                      t.validateStyle,
                      t.extend({
                        value: n,
                        style: { glyphs: !0, sprite: !0 },
                        styleSpec: t.spec,
                      })
                    )
                  )
                );
              }
            }
            const b = new t.Properties({
                source: new t.DataConstantProperty(t.spec.terrain.source),
                exaggeration: new t.DataConstantProperty(
                  t.spec.terrain.exaggeration
                ),
              }),
              x = "-transition";
            class w extends t.Evented {
              constructor(e) {
                super(),
                  (this._transitionable = new t.Transitionable(b)),
                  this.set(e),
                  (this._transitioning = this._transitionable.untransitioned());
              }
              get() {
                return this._transitionable.serialize();
              }
              set(e) {
                for (const n in e) {
                  const r = e[n];
                  t.endsWith(n, x)
                    ? this._transitionable.setTransition(
                        n.slice(0, -x.length),
                        r
                      )
                    : this._transitionable.setValue(n, r);
                }
              }
              updateTransitions(t) {
                this._transitioning = this._transitionable.transitioned(
                  t,
                  this._transitioning
                );
              }
              hasTransition() {
                return this._transitioning.hasTransition();
              }
              recalculate(t) {
                this.properties = this._transitioning.possiblyEvaluate(t);
              }
            }
            function S(e, n, r, i) {
              const o = t.smoothstep(45, 65, r),
                [s, a] = E(e, i),
                l = t.length(n);
              let c = 1 - Math.min(1, Math.exp(((l - s) / (a - s)) * -6));
              return (
                (c *= c * c), (c = Math.min(1, 1.00747 * c)), c * o * e.alpha
              );
            }
            function E(t, e) {
              const n = 0.5 / Math.tan(0.5 * e);
              return [t.range[0] + n, t.range[1] + n];
            }
            const T = new t.Properties({
                range: new t.DataConstantProperty(t.spec.fog.range),
                color: new t.DataConstantProperty(t.spec.fog.color),
                "horizon-blend": new t.DataConstantProperty(
                  t.spec.fog["horizon-blend"]
                ),
              }),
              A = "-transition";
            class C extends t.Evented {
              constructor(e) {
                super(),
                  (this._transitionable = new t.Transitionable(T)),
                  this.set(e),
                  (this._transitioning = this._transitionable.untransitioned());
              }
              get state() {
                return {
                  range: this.properties.get("range"),
                  horizonBlend: this.properties.get("horizon-blend"),
                  alpha: this.properties.get("color").a,
                };
              }
              get() {
                return this._transitionable.serialize();
              }
              set(e, n = {}) {
                if (!this._validate(t.validateFog, e, n))
                  for (const r in e) {
                    const n = e[r];
                    t.endsWith(r, A)
                      ? this._transitionable.setTransition(
                          r.slice(0, -A.length),
                          n
                        )
                      : this._transitionable.setValue(r, n);
                  }
              }
              getOpacity(e) {
                const n =
                  (this.properties && this.properties.get("color")) || 1;
                return t.smoothstep(45, 65, e) * n.a;
              }
              getOpacityAtLatLng(e, n) {
                return (function (e, n, r) {
                  const i = t.MercatorCoordinate.fromLngLat(n),
                    o = r.elevation ? r.elevation.getAtPointOrZero(i) : 0,
                    s = [i.x, i.y, o];
                  return (
                    t.transformMat4$1(s, s, r.mercatorFogMatrix),
                    S(e, s, r.pitch, r._fov)
                  );
                })(this.state, e, n);
              }
              getFovAdjustedRange(t) {
                return E(this.state, t);
              }
              updateTransitions(t) {
                this._transitioning = this._transitionable.transitioned(
                  t,
                  this._transitioning
                );
              }
              hasTransition() {
                return this._transitioning.hasTransition();
              }
              recalculate(t) {
                this.properties = this._transitioning.possiblyEvaluate(t);
              }
              _validate(e, n, r) {
                return (
                  (!r || !1 !== r.validate) &&
                  t.emitValidationErrors(
                    this,
                    e.call(
                      t.validateStyle,
                      t.extend({
                        value: n,
                        style: { glyphs: !0, sprite: !0 },
                        styleSpec: t.spec,
                      })
                    )
                  )
                );
              }
            }
            class P {
              constructor(e, n) {
                (this.workerPool = e),
                  (this.actors = []),
                  (this.currentActor = 0),
                  (this.id = t.uniqueId());
                const r = this.workerPool.acquire(this.id);
                for (let t = 0; t < r.length; t++) {
                  const e = new P.Actor(r[t], n, this.id);
                  (e.name = `Worker ${t}`), this.actors.push(e);
                }
                (this.ready = !1),
                  this.broadcast("checkIfReady", null, () => {
                    this.ready = !0;
                  });
              }
              broadcast(e, n, r) {
                t.asyncAll(
                  this.actors,
                  (t, r) => {
                    t.send(e, n, r);
                  },
                  (r = r || function () {})
                );
              }
              getActor() {
                return (
                  (this.currentActor =
                    (this.currentActor + 1) % this.actors.length),
                  this.actors[this.currentActor]
                );
              }
              remove() {
                this.actors.forEach((t) => {
                  t.remove();
                }),
                  (this.actors = []),
                  this.workerPool.release(this.id);
              }
            }
            function M(e, n, r) {
              return (
                n *
                (t.EXTENT /
                  (e.tileSize * Math.pow(2, r - e.tileID.overscaledZ)))
              );
            }
            P.Actor = t.Actor;
            class O {
              constructor(t, e, n, r) {
                (this.screenBounds = t),
                  (this.cameraPoint = e),
                  (this._screenRaycastCache = {}),
                  (this._cameraRaycastCache = {}),
                  (this.isAboveHorizon = n),
                  (this.screenGeometry = this.bufferedScreenGeometry(0)),
                  (this.screenGeometryMercator = this.screenGeometry.map((t) =>
                    r.pointCoordinate3D(t)
                  )),
                  (this.cameraGeometry = this.bufferedCameraGeometry(0));
              }
              static createFromScreenPoints(e, n) {
                let r, i;
                if (e instanceof t.pointGeometry || "number" == typeof e[0]) {
                  const o = t.pointGeometry.convert(e);
                  (r = [t.pointGeometry.convert(e)]),
                    (i = n.isPointAboveHorizon(o));
                } else {
                  const o = t.pointGeometry.convert(e[0]),
                    s = t.pointGeometry.convert(e[1]);
                  (r = [o, s]),
                    (i = t
                      .polygonizeBounds(o, s)
                      .every((t) => n.isPointAboveHorizon(t)));
                }
                return new O(r, n.getCameraPoint(), i, n);
              }
              isPointQuery() {
                return 1 === this.screenBounds.length;
              }
              bufferedScreenGeometry(e) {
                return t.polygonizeBounds(
                  this.screenBounds[0],
                  1 === this.screenBounds.length
                    ? this.screenBounds[0]
                    : this.screenBounds[1],
                  e
                );
              }
              bufferedCameraGeometry(e) {
                const n = this.screenBounds[0],
                  r =
                    1 === this.screenBounds.length
                      ? this.screenBounds[0].add(new t.pointGeometry(1, 1))
                      : this.screenBounds[1],
                  i = t.polygonizeBounds(n, r, 0, !1);
                return (
                  this.cameraPoint.y > r.y &&
                    (this.cameraPoint.x > n.x && this.cameraPoint.x < r.x
                      ? i.splice(3, 0, this.cameraPoint)
                      : this.cameraPoint.x >= r.x
                      ? (i[2] = this.cameraPoint)
                      : this.cameraPoint.x <= n.x && (i[3] = this.cameraPoint)),
                  t.bufferConvexPolygon(i, e)
                );
              }
              containsTile(e, n, r) {
                const i = e.queryPadding + 1,
                  o = r
                    ? this._bufferedCameraMercator(i, n).map((t) =>
                        e.tileID.getTilePoint(t)
                      )
                    : this._bufferedScreenMercator(i, n).map((t) =>
                        e.tileID.getTilePoint(t)
                      ),
                  s = this.screenGeometryMercator.map((t) =>
                    e.tileID.getTileVec3(t)
                  ),
                  a = s.map((e) => new t.pointGeometry(e[0], e[1])),
                  l =
                    n.getFreeCameraOptions().position ||
                    new t.MercatorCoordinate(0, 0, 0),
                  c = e.tileID.getTileVec3(l),
                  u = s.map((e) => {
                    const n = t.sub(e, e, c);
                    return t.normalize(n, n), new p(c, n);
                  }),
                  h = M(e, 1, n.zoom);
                if (t.polygonIntersectsBox(o, 0, 0, t.EXTENT, t.EXTENT))
                  return {
                    queryGeometry: this,
                    tilespaceGeometry: a,
                    tilespaceRays: u,
                    bufferedTilespaceGeometry: o,
                    bufferedTilespaceBounds:
                      ((d = t.getBounds(o)),
                      (d.min.x = t.clamp(d.min.x, 0, t.EXTENT)),
                      (d.min.y = t.clamp(d.min.y, 0, t.EXTENT)),
                      (d.max.x = t.clamp(d.max.x, 0, t.EXTENT)),
                      (d.max.y = t.clamp(d.max.y, 0, t.EXTENT)),
                      d),
                    tile: e,
                    tileID: e.tileID,
                    pixelToTileUnitsFactor: h,
                  };
                var d;
              }
              _bufferedScreenMercator(t, e) {
                const n = k(t);
                if (this._screenRaycastCache[n])
                  return this._screenRaycastCache[n];
                {
                  const r = this.bufferedScreenGeometry(t).map((t) =>
                    e.pointCoordinate3D(t)
                  );
                  return (this._screenRaycastCache[n] = r), r;
                }
              }
              _bufferedCameraMercator(t, e) {
                const n = k(t);
                if (this._cameraRaycastCache[n])
                  return this._cameraRaycastCache[n];
                {
                  const r = this.bufferedCameraGeometry(t).map((t) =>
                    e.pointCoordinate3D(t)
                  );
                  return (this._cameraRaycastCache[n] = r), r;
                }
              }
            }
            function k(t) {
              return (100 * t) | 0;
            }
            function I(e, n, r) {
              const i = function (i, o) {
                if (i) return r(i);
                if (o) {
                  const i = t.pick(t.extend(o, e), [
                    "tiles",
                    "minzoom",
                    "maxzoom",
                    "attribution",
                    "mapbox_logo",
                    "bounds",
                    "scheme",
                    "tileSize",
                    "encoding",
                  ]);
                  o.vector_layers &&
                    ((i.vectorLayers = o.vector_layers),
                    (i.vectorLayerIds = i.vectorLayers.map((t) => t.id))),
                    (i.tiles = n.canonicalizeTileset(i, e.url)),
                    r(null, i);
                }
              };
              return e.url
                ? t.getJSON(
                    n.transformRequest(
                      n.normalizeSourceURL(e.url),
                      t.ResourceType.Source
                    ),
                    i
                  )
                : t.exported.frame(() => i(null, e));
            }
            class D {
              constructor(e, n, r) {
                (this.bounds = t.LngLatBounds.convert(this.validateBounds(e))),
                  (this.minzoom = n || 0),
                  (this.maxzoom = r || 24);
              }
              validateBounds(t) {
                return Array.isArray(t) && 4 === t.length
                  ? [
                      Math.max(-180, t[0]),
                      Math.max(-90, t[1]),
                      Math.min(180, t[2]),
                      Math.min(90, t[3]),
                    ]
                  : [-180, -90, 180, 90];
              }
              contains(e) {
                const n = Math.pow(2, e.z),
                  r = Math.floor(t.mercatorXfromLng(this.bounds.getWest()) * n),
                  i = Math.floor(
                    t.mercatorYfromLat(this.bounds.getNorth()) * n
                  ),
                  o = Math.ceil(t.mercatorXfromLng(this.bounds.getEast()) * n),
                  s = Math.ceil(t.mercatorYfromLat(this.bounds.getSouth()) * n);
                return e.x >= r && e.x < o && e.y >= i && e.y < s;
              }
            }
            class z {
              constructor(t, e, n) {
                this.context = t;
                const r = t.gl;
                (this.buffer = r.createBuffer()),
                  (this.dynamicDraw = Boolean(n)),
                  this.context.unbindVAO(),
                  t.bindElementBuffer.set(this.buffer),
                  r.bufferData(
                    r.ELEMENT_ARRAY_BUFFER,
                    e.arrayBuffer,
                    this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW
                  ),
                  this.dynamicDraw || delete e.arrayBuffer;
              }
              bind() {
                this.context.bindElementBuffer.set(this.buffer);
              }
              updateData(t) {
                const e = this.context.gl;
                this.context.unbindVAO(),
                  this.bind(),
                  e.bufferSubData(e.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer);
              }
              destroy() {
                this.buffer &&
                  (this.context.gl.deleteBuffer(this.buffer),
                  delete this.buffer);
              }
            }
            const R = {
              Int8: "BYTE",
              Uint8: "UNSIGNED_BYTE",
              Int16: "SHORT",
              Uint16: "UNSIGNED_SHORT",
              Int32: "INT",
              Uint32: "UNSIGNED_INT",
              Float32: "FLOAT",
            };
            class L {
              constructor(t, e, n, r) {
                (this.length = e.length),
                  (this.attributes = n),
                  (this.itemSize = e.bytesPerElement),
                  (this.dynamicDraw = r),
                  (this.context = t);
                const i = t.gl;
                (this.buffer = i.createBuffer()),
                  t.bindVertexBuffer.set(this.buffer),
                  i.bufferData(
                    i.ARRAY_BUFFER,
                    e.arrayBuffer,
                    this.dynamicDraw ? i.DYNAMIC_DRAW : i.STATIC_DRAW
                  ),
                  this.dynamicDraw || delete e.arrayBuffer;
              }
              bind() {
                this.context.bindVertexBuffer.set(this.buffer);
              }
              updateData(t) {
                const e = this.context.gl;
                this.bind(), e.bufferSubData(e.ARRAY_BUFFER, 0, t.arrayBuffer);
              }
              enableAttributes(t, e) {
                for (let n = 0; n < this.attributes.length; n++) {
                  const r = e.attributes[this.attributes[n].name];
                  void 0 !== r && t.enableVertexAttribArray(r);
                }
              }
              setVertexAttribPointers(t, e, n) {
                for (let r = 0; r < this.attributes.length; r++) {
                  const i = this.attributes[r],
                    o = e.attributes[i.name];
                  void 0 !== o &&
                    t.vertexAttribPointer(
                      o,
                      i.components,
                      t[R[i.type]],
                      !1,
                      this.itemSize,
                      i.offset + this.itemSize * (n || 0)
                    );
                }
              }
              destroy() {
                this.buffer &&
                  (this.context.gl.deleteBuffer(this.buffer),
                  delete this.buffer);
              }
            }
            class F {
              constructor(t) {
                (this.gl = t.gl),
                  (this.default = this.getDefault()),
                  (this.current = this.default),
                  (this.dirty = !1);
              }
              get() {
                return this.current;
              }
              set(t) {}
              getDefault() {
                return this.default;
              }
              setDefault() {
                this.set(this.default);
              }
            }
            class B extends F {
              getDefault() {
                return t.Color.transparent;
              }
              set(t) {
                const e = this.current;
                (t.r !== e.r ||
                  t.g !== e.g ||
                  t.b !== e.b ||
                  t.a !== e.a ||
                  this.dirty) &&
                  (this.gl.clearColor(t.r, t.g, t.b, t.a),
                  (this.current = t),
                  (this.dirty = !1));
              }
            }
            class N extends F {
              getDefault() {
                return 1;
              }
              set(t) {
                (t !== this.current || this.dirty) &&
                  (this.gl.clearDepth(t),
                  (this.current = t),
                  (this.dirty = !1));
              }
            }
            class j extends F {
              getDefault() {
                return 0;
              }
              set(t) {
                (t !== this.current || this.dirty) &&
                  (this.gl.clearStencil(t),
                  (this.current = t),
                  (this.dirty = !1));
              }
            }
            class U extends F {
              getDefault() {
                return [!0, !0, !0, !0];
              }
              set(t) {
                const e = this.current;
                (t[0] !== e[0] ||
                  t[1] !== e[1] ||
                  t[2] !== e[2] ||
                  t[3] !== e[3] ||
                  this.dirty) &&
                  (this.gl.colorMask(t[0], t[1], t[2], t[3]),
                  (this.current = t),
                  (this.dirty = !1));
              }
            }
            class Z extends F {
              getDefault() {
                return !0;
              }
              set(t) {
                (t !== this.current || this.dirty) &&
                  (this.gl.depthMask(t), (this.current = t), (this.dirty = !1));
              }
            }
            class V extends F {
              getDefault() {
                return 255;
              }
              set(t) {
                (t !== this.current || this.dirty) &&
                  (this.gl.stencilMask(t),
                  (this.current = t),
                  (this.dirty = !1));
              }
            }
            class q extends F {
              getDefault() {
                return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
              }
              set(t) {
                const e = this.current;
                (t.func !== e.func ||
                  t.ref !== e.ref ||
                  t.mask !== e.mask ||
                  this.dirty) &&
                  (this.gl.stencilFunc(t.func, t.ref, t.mask),
                  (this.current = t),
                  (this.dirty = !1));
              }
            }
            class $ extends F {
              getDefault() {
                const t = this.gl;
                return [t.KEEP, t.KEEP, t.KEEP];
              }
              set(t) {
                const e = this.current;
                (t[0] !== e[0] ||
                  t[1] !== e[1] ||
                  t[2] !== e[2] ||
                  this.dirty) &&
                  (this.gl.stencilOp(t[0], t[1], t[2]),
                  (this.current = t),
                  (this.dirty = !1));
              }
            }
            class G extends F {
              getDefault() {
                return !1;
              }
              set(t) {
                if (t === this.current && !this.dirty) return;
                const e = this.gl;
                t ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST),
                  (this.current = t),
                  (this.dirty = !1);
              }
            }
            class W extends F {
              getDefault() {
                return [0, 1];
              }
              set(t) {
                const e = this.current;
                (t[0] !== e[0] || t[1] !== e[1] || this.dirty) &&
                  (this.gl.depthRange(t[0], t[1]),
                  (this.current = t),
                  (this.dirty = !1));
              }
            }
            class H extends F {
              getDefault() {
                return !1;
              }
              set(t) {
                if (t === this.current && !this.dirty) return;
                const e = this.gl;
                t ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST),
                  (this.current = t),
                  (this.dirty = !1);
              }
            }
            class X extends F {
              getDefault() {
                return this.gl.LESS;
              }
              set(t) {
                (t !== this.current || this.dirty) &&
                  (this.gl.depthFunc(t), (this.current = t), (this.dirty = !1));
              }
            }
            class K extends F {
              getDefault() {
                return !1;
              }
              set(t) {
                if (t === this.current && !this.dirty) return;
                const e = this.gl;
                t ? e.enable(e.BLEND) : e.disable(e.BLEND),
                  (this.current = t),
                  (this.dirty = !1);
              }
            }
            class Y extends F {
              getDefault() {
                const t = this.gl;
                return [t.ONE, t.ZERO];
              }
              set(t) {
                const e = this.current;
                (t[0] !== e[0] || t[1] !== e[1] || this.dirty) &&
                  (this.gl.blendFunc(t[0], t[1]),
                  (this.current = t),
                  (this.dirty = !1));
              }
            }
            class Q extends F {
              getDefault() {
                return t.Color.transparent;
              }
              set(t) {
                const e = this.current;
                (t.r !== e.r ||
                  t.g !== e.g ||
                  t.b !== e.b ||
                  t.a !== e.a ||
                  this.dirty) &&
                  (this.gl.blendColor(t.r, t.g, t.b, t.a),
                  (this.current = t),
                  (this.dirty = !1));
              }
            }
            class J extends F {
              getDefault() {
                return this.gl.FUNC_ADD;
              }
              set(t) {
                (t !== this.current || this.dirty) &&
                  (this.gl.blendEquation(t),
                  (this.current = t),
                  (this.dirty = !1));
              }
            }
            class tt extends F {
              getDefault() {
                return !1;
              }
              set(t) {
                if (t === this.current && !this.dirty) return;
                const e = this.gl;
                t ? e.enable(e.CULL_FACE) : e.disable(e.CULL_FACE),
                  (this.current = t),
                  (this.dirty = !1);
              }
            }
            class et extends F {
              getDefault() {
                return this.gl.BACK;
              }
              set(t) {
                (t !== this.current || this.dirty) &&
                  (this.gl.cullFace(t), (this.current = t), (this.dirty = !1));
              }
            }
            class nt extends F {
              getDefault() {
                return this.gl.CCW;
              }
              set(t) {
                (t !== this.current || this.dirty) &&
                  (this.gl.frontFace(t), (this.current = t), (this.dirty = !1));
              }
            }
            class rt extends F {
              getDefault() {
                return null;
              }
              set(t) {
                (t !== this.current || this.dirty) &&
                  (this.gl.useProgram(t),
                  (this.current = t),
                  (this.dirty = !1));
              }
            }
            class it extends F {
              getDefault() {
                return this.gl.TEXTURE0;
              }
              set(t) {
                (t !== this.current || this.dirty) &&
                  (this.gl.activeTexture(t),
                  (this.current = t),
                  (this.dirty = !1));
              }
            }
            class ot extends F {
              getDefault() {
                const t = this.gl;
                return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight];
              }
              set(t) {
                const e = this.current;
                (t[0] !== e[0] ||
                  t[1] !== e[1] ||
                  t[2] !== e[2] ||
                  t[3] !== e[3] ||
                  this.dirty) &&
                  (this.gl.viewport(t[0], t[1], t[2], t[3]),
                  (this.current = t),
                  (this.dirty = !1));
              }
            }
            class st extends F {
              getDefault() {
                return null;
              }
              set(t) {
                if (t === this.current && !this.dirty) return;
                const e = this.gl;
                e.bindFramebuffer(e.FRAMEBUFFER, t),
                  (this.current = t),
                  (this.dirty = !1);
              }
            }
            class at extends F {
              getDefault() {
                return null;
              }
              set(t) {
                if (t === this.current && !this.dirty) return;
                const e = this.gl;
                e.bindRenderbuffer(e.RENDERBUFFER, t),
                  (this.current = t),
                  (this.dirty = !1);
              }
            }
            class lt extends F {
              getDefault() {
                return null;
              }
              set(t) {
                if (t === this.current && !this.dirty) return;
                const e = this.gl;
                e.bindTexture(e.TEXTURE_2D, t),
                  (this.current = t),
                  (this.dirty = !1);
              }
            }
            class ct extends F {
              getDefault() {
                return null;
              }
              set(t) {
                if (t === this.current && !this.dirty) return;
                const e = this.gl;
                e.bindBuffer(e.ARRAY_BUFFER, t),
                  (this.current = t),
                  (this.dirty = !1);
              }
            }
            class ut extends F {
              getDefault() {
                return null;
              }
              set(t) {
                const e = this.gl;
                e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t),
                  (this.current = t),
                  (this.dirty = !1);
              }
            }
            class ht extends F {
              constructor(t) {
                super(t), (this.vao = t.extVertexArrayObject);
              }
              getDefault() {
                return null;
              }
              set(t) {
                this.vao &&
                  (t !== this.current || this.dirty) &&
                  (this.vao.bindVertexArrayOES(t),
                  (this.current = t),
                  (this.dirty = !1));
              }
            }
            class pt extends F {
              getDefault() {
                return 4;
              }
              set(t) {
                if (t === this.current && !this.dirty) return;
                const e = this.gl;
                e.pixelStorei(e.UNPACK_ALIGNMENT, t),
                  (this.current = t),
                  (this.dirty = !1);
              }
            }
            class dt extends F {
              getDefault() {
                return !1;
              }
              set(t) {
                if (t === this.current && !this.dirty) return;
                const e = this.gl;
                e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t),
                  (this.current = t),
                  (this.dirty = !1);
              }
            }
            class ft extends F {
              getDefault() {
                return !1;
              }
              set(t) {
                if (t === this.current && !this.dirty) return;
                const e = this.gl;
                e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t),
                  (this.current = t),
                  (this.dirty = !1);
              }
            }
            class mt extends F {
              constructor(t, e) {
                super(t), (this.context = t), (this.parent = e);
              }
              getDefault() {
                return null;
              }
            }
            class gt extends mt {
              setDirty() {
                this.dirty = !0;
              }
              set(t) {
                if (t === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const e = this.gl;
                e.framebufferTexture2D(
                  e.FRAMEBUFFER,
                  e.COLOR_ATTACHMENT0,
                  e.TEXTURE_2D,
                  t,
                  0
                ),
                  (this.current = t),
                  (this.dirty = !1);
              }
            }
            class yt extends mt {
              attachment() {
                return this.gl.DEPTH_ATTACHMENT;
              }
              set(t) {
                if (t === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const e = this.gl;
                e.framebufferRenderbuffer(
                  e.FRAMEBUFFER,
                  this.attachment(),
                  e.RENDERBUFFER,
                  t
                ),
                  (this.current = t),
                  (this.dirty = !1);
              }
            }
            class _t extends yt {
              attachment() {
                return this.gl.DEPTH_STENCIL_ATTACHMENT;
              }
            }
            class vt {
              constructor(t, e, n, r) {
                (this.context = t), (this.width = e), (this.height = n);
                const i = (this.framebuffer = t.gl.createFramebuffer());
                (this.colorAttachment = new gt(t, i)),
                  r && (this.depthAttachment = new yt(t, i));
              }
              destroy() {
                const t = this.context.gl,
                  e = this.colorAttachment.get();
                if ((e && t.deleteTexture(e), this.depthAttachment)) {
                  const e = this.depthAttachment.get();
                  e && t.deleteRenderbuffer(e);
                }
                t.deleteFramebuffer(this.framebuffer);
              }
            }
            class bt {
              constructor(t) {
                (this.gl = t),
                  (this.extVertexArrayObject = this.gl.getExtension(
                    "OES_vertex_array_object"
                  )),
                  (this.clearColor = new B(this)),
                  (this.clearDepth = new N(this)),
                  (this.clearStencil = new j(this)),
                  (this.colorMask = new U(this)),
                  (this.depthMask = new Z(this)),
                  (this.stencilMask = new V(this)),
                  (this.stencilFunc = new q(this)),
                  (this.stencilOp = new $(this)),
                  (this.stencilTest = new G(this)),
                  (this.depthRange = new W(this)),
                  (this.depthTest = new H(this)),
                  (this.depthFunc = new X(this)),
                  (this.blend = new K(this)),
                  (this.blendFunc = new Y(this)),
                  (this.blendColor = new Q(this)),
                  (this.blendEquation = new J(this)),
                  (this.cullFace = new tt(this)),
                  (this.cullFaceSide = new et(this)),
                  (this.frontFace = new nt(this)),
                  (this.program = new rt(this)),
                  (this.activeTexture = new it(this)),
                  (this.viewport = new ot(this)),
                  (this.bindFramebuffer = new st(this)),
                  (this.bindRenderbuffer = new at(this)),
                  (this.bindTexture = new lt(this)),
                  (this.bindVertexBuffer = new ct(this)),
                  (this.bindElementBuffer = new ut(this)),
                  (this.bindVertexArrayOES =
                    this.extVertexArrayObject && new ht(this)),
                  (this.pixelStoreUnpack = new pt(this)),
                  (this.pixelStoreUnpackPremultiplyAlpha = new dt(this)),
                  (this.pixelStoreUnpackFlipY = new ft(this)),
                  (this.extTextureFilterAnisotropic =
                    t.getExtension("EXT_texture_filter_anisotropic") ||
                    t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                    t.getExtension("WEBKIT_EXT_texture_filter_anisotropic")),
                  this.extTextureFilterAnisotropic &&
                    (this.extTextureFilterAnisotropicMax = t.getParameter(
                      this.extTextureFilterAnisotropic
                        .MAX_TEXTURE_MAX_ANISOTROPY_EXT
                    )),
                  (this.extTextureFilterAnisotropicForceOff = !1),
                  (this.extTextureHalfFloat = t.getExtension(
                    "OES_texture_half_float"
                  )),
                  this.extTextureHalfFloat &&
                    (t.getExtension("OES_texture_half_float_linear"),
                    (this.extRenderToTextureHalfFloat = t.getExtension(
                      "EXT_color_buffer_half_float"
                    ))),
                  (this.extTimerQuery = t.getExtension(
                    "EXT_disjoint_timer_query"
                  )),
                  (this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE));
              }
              setDefault() {
                this.unbindVAO(),
                  this.clearColor.setDefault(),
                  this.clearDepth.setDefault(),
                  this.clearStencil.setDefault(),
                  this.colorMask.setDefault(),
                  this.depthMask.setDefault(),
                  this.stencilMask.setDefault(),
                  this.stencilFunc.setDefault(),
                  this.stencilOp.setDefault(),
                  this.stencilTest.setDefault(),
                  this.depthRange.setDefault(),
                  this.depthTest.setDefault(),
                  this.depthFunc.setDefault(),
                  this.blend.setDefault(),
                  this.blendFunc.setDefault(),
                  this.blendColor.setDefault(),
                  this.blendEquation.setDefault(),
                  this.cullFace.setDefault(),
                  this.cullFaceSide.setDefault(),
                  this.frontFace.setDefault(),
                  this.program.setDefault(),
                  this.activeTexture.setDefault(),
                  this.bindFramebuffer.setDefault(),
                  this.pixelStoreUnpack.setDefault(),
                  this.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                  this.pixelStoreUnpackFlipY.setDefault();
              }
              setDirty() {
                (this.clearColor.dirty = !0),
                  (this.clearDepth.dirty = !0),
                  (this.clearStencil.dirty = !0),
                  (this.colorMask.dirty = !0),
                  (this.depthMask.dirty = !0),
                  (this.stencilMask.dirty = !0),
                  (this.stencilFunc.dirty = !0),
                  (this.stencilOp.dirty = !0),
                  (this.stencilTest.dirty = !0),
                  (this.depthRange.dirty = !0),
                  (this.depthTest.dirty = !0),
                  (this.depthFunc.dirty = !0),
                  (this.blend.dirty = !0),
                  (this.blendFunc.dirty = !0),
                  (this.blendColor.dirty = !0),
                  (this.blendEquation.dirty = !0),
                  (this.cullFace.dirty = !0),
                  (this.cullFaceSide.dirty = !0),
                  (this.frontFace.dirty = !0),
                  (this.program.dirty = !0),
                  (this.activeTexture.dirty = !0),
                  (this.viewport.dirty = !0),
                  (this.bindFramebuffer.dirty = !0),
                  (this.bindRenderbuffer.dirty = !0),
                  (this.bindTexture.dirty = !0),
                  (this.bindVertexBuffer.dirty = !0),
                  (this.bindElementBuffer.dirty = !0),
                  this.extVertexArrayObject &&
                    (this.bindVertexArrayOES.dirty = !0),
                  (this.pixelStoreUnpack.dirty = !0),
                  (this.pixelStoreUnpackPremultiplyAlpha.dirty = !0),
                  (this.pixelStoreUnpackFlipY.dirty = !0);
              }
              createIndexBuffer(t, e) {
                return new z(this, t, e);
              }
              createVertexBuffer(t, e, n) {
                return new L(this, t, e, n);
              }
              createRenderbuffer(t, e, n) {
                const r = this.gl,
                  i = r.createRenderbuffer();
                return (
                  this.bindRenderbuffer.set(i),
                  r.renderbufferStorage(r.RENDERBUFFER, t, e, n),
                  this.bindRenderbuffer.set(null),
                  i
                );
              }
              createFramebuffer(t, e, n) {
                return new vt(this, t, e, n);
              }
              clear({ color: t, depth: e, stencil: n }) {
                const r = this.gl;
                let i = 0;
                t &&
                  ((i |= r.COLOR_BUFFER_BIT),
                  this.clearColor.set(t),
                  this.colorMask.set([!0, !0, !0, !0])),
                  void 0 !== e &&
                    ((i |= r.DEPTH_BUFFER_BIT),
                    this.depthRange.set([0, 1]),
                    this.clearDepth.set(e),
                    this.depthMask.set(!0)),
                  void 0 !== n &&
                    ((i |= r.STENCIL_BUFFER_BIT),
                    this.clearStencil.set(n),
                    this.stencilMask.set(255)),
                  r.clear(i);
              }
              setCullFace(t) {
                !1 === t.enable
                  ? this.cullFace.set(!1)
                  : (this.cullFace.set(!0),
                    this.cullFaceSide.set(t.mode),
                    this.frontFace.set(t.frontFace));
              }
              setDepthMode(t) {
                t.func !== this.gl.ALWAYS || t.mask
                  ? (this.depthTest.set(!0),
                    this.depthFunc.set(t.func),
                    this.depthMask.set(t.mask),
                    this.depthRange.set(t.range))
                  : this.depthTest.set(!1);
              }
              setStencilMode(t) {
                t.test.func !== this.gl.ALWAYS || t.mask
                  ? (this.stencilTest.set(!0),
                    this.stencilMask.set(t.mask),
                    this.stencilOp.set([t.fail, t.depthFail, t.pass]),
                    this.stencilFunc.set({
                      func: t.test.func,
                      ref: t.ref,
                      mask: t.test.mask,
                    }))
                  : this.stencilTest.set(!1);
              }
              setColorMode(e) {
                i(e.blendFunction, t.ColorMode.Replace)
                  ? this.blend.set(!1)
                  : (this.blend.set(!0),
                    this.blendFunc.set(e.blendFunction),
                    this.blendColor.set(e.blendColor)),
                  this.colorMask.set(e.mask);
              }
              unbindVAO() {
                this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
              }
            }
            class xt extends t.Evented {
              constructor(e, n, r, i) {
                super(),
                  (this.id = e),
                  (this.dispatcher = r),
                  this.setEventedParent(i),
                  (this.type = "raster"),
                  (this.minzoom = 0),
                  (this.maxzoom = 22),
                  (this.roundZoom = !0),
                  (this.scheme = "xyz"),
                  (this.tileSize = 512),
                  (this._loaded = !1),
                  (this._options = t.extend({ type: "raster" }, n)),
                  t.extend(this, t.pick(n, ["url", "scheme", "tileSize"]));
              }
              load() {
                (this._loaded = !1),
                  this.fire(new t.Event("dataloading", { dataType: "source" })),
                  (this._tileJSONRequest = I(
                    this._options,
                    this.map._requestManager,
                    (e, n) => {
                      (this._tileJSONRequest = null),
                        (this._loaded = !0),
                        e
                          ? this.fire(new t.ErrorEvent(e))
                          : n &&
                            (t.extend(this, n),
                            n.bounds &&
                              (this.tileBounds = new D(
                                n.bounds,
                                this.minzoom,
                                this.maxzoom
                              )),
                            t.postTurnstileEvent(n.tiles),
                            this.fire(
                              new t.Event("data", {
                                dataType: "source",
                                sourceDataType: "metadata",
                              })
                            ),
                            this.fire(
                              new t.Event("data", {
                                dataType: "source",
                                sourceDataType: "content",
                              })
                            ));
                    }
                  ));
              }
              loaded() {
                return this._loaded;
              }
              onAdd(t) {
                (this.map = t), this.load();
              }
              onRemove() {
                this._tileJSONRequest &&
                  (this._tileJSONRequest.cancel(),
                  (this._tileJSONRequest = null));
              }
              serialize() {
                return t.extend({}, this._options);
              }
              hasTile(t) {
                return (
                  !this.tileBounds || this.tileBounds.contains(t.canonical)
                );
              }
              loadTile(e, n) {
                const r = t.exported.devicePixelRatio >= 2,
                  i = this.map._requestManager.normalizeTileURL(
                    e.tileID.canonical.url(this.tiles, this.scheme),
                    r,
                    this.tileSize
                  );
                e.request = t.getImage(
                  this.map._requestManager.transformRequest(
                    i,
                    t.ResourceType.Tile
                  ),
                  (r, i, o, s) => {
                    if ((delete e.request, e.aborted))
                      (e.state = "unloaded"), n(null);
                    else if (r) (e.state = "errored"), n(r);
                    else if (i) {
                      this.map._refreshExpiredTiles &&
                        e.setExpiryData({ cacheControl: o, expires: s });
                      const r = this.map.painter.context,
                        a = r.gl;
                      (e.texture = this.map.painter.getTileTexture(i.width)),
                        e.texture
                          ? e.texture.update(i, { useMipmap: !0 })
                          : ((e.texture = new t.Texture(r, i, a.RGBA, {
                              useMipmap: !0,
                            })),
                            e.texture.bind(
                              a.LINEAR,
                              a.CLAMP_TO_EDGE,
                              a.LINEAR_MIPMAP_NEAREST
                            ),
                            r.extTextureFilterAnisotropic &&
                              a.texParameterf(
                                a.TEXTURE_2D,
                                r.extTextureFilterAnisotropic
                                  .TEXTURE_MAX_ANISOTROPY_EXT,
                                r.extTextureFilterAnisotropicMax
                              )),
                        (e.state = "loaded"),
                        t.cacheEntryPossiblyAdded(this.dispatcher),
                        n(null);
                    }
                  }
                );
              }
              abortTile(t, e) {
                t.request && (t.request.cancel(), delete t.request), e();
              }
              unloadTile(t, e) {
                t.texture && this.map.painter.saveTileTexture(t.texture), e();
              }
              hasTransition() {
                return !1;
              }
            }
            let wt;
            var St = t.createLayout([
              { name: "a_pos", type: "Int16", components: 2 },
              { name: "a_texture_pos", type: "Int16", components: 2 },
            ]);
            class Et extends t.Evented {
              constructor(t, e, n, r) {
                super(),
                  (this.id = t),
                  (this.dispatcher = n),
                  (this.coordinates = e.coordinates),
                  (this.type = "image"),
                  (this.minzoom = 0),
                  (this.maxzoom = 22),
                  (this.tileSize = 512),
                  (this.tiles = {}),
                  (this._loaded = !1),
                  this.setEventedParent(r),
                  (this.options = e);
              }
              load(e, n) {
                (this._loaded = !1),
                  this.fire(new t.Event("dataloading", { dataType: "source" })),
                  (this.url = this.options.url),
                  t.getImage(
                    this.map._requestManager.transformRequest(
                      this.url,
                      t.ResourceType.Image
                    ),
                    (r, i) => {
                      (this._loaded = !0),
                        r
                          ? this.fire(new t.ErrorEvent(r))
                          : i &&
                            ((this.image = t.exported.getImageData(i)),
                            e && (this.coordinates = e),
                            n && n(),
                            this._finishLoading());
                    }
                  );
              }
              loaded() {
                return this._loaded;
              }
              updateImage(t) {
                return this.image && t.url
                  ? ((this.options.url = t.url),
                    this.load(t.coordinates, () => {
                      this.texture = null;
                    }),
                    this)
                  : this;
              }
              _finishLoading() {
                this.map &&
                  (this.setCoordinates(this.coordinates),
                  this.fire(
                    new t.Event("data", {
                      dataType: "source",
                      sourceDataType: "metadata",
                    })
                  ));
              }
              onAdd(t) {
                (this.map = t), this.load();
              }
              setCoordinates(e) {
                this.coordinates = e;
                const n = e.map(t.MercatorCoordinate.fromLngLat);
                (this.tileID = (function (e) {
                  let n = 1 / 0,
                    r = 1 / 0,
                    i = -1 / 0,
                    o = -1 / 0;
                  for (const t of e)
                    (n = Math.min(n, t.x)),
                      (r = Math.min(r, t.y)),
                      (i = Math.max(i, t.x)),
                      (o = Math.max(o, t.y));
                  const s = Math.max(i - n, o - r),
                    a = Math.max(0, Math.floor(-Math.log(s) / Math.LN2)),
                    l = Math.pow(2, a);
                  return new t.CanonicalTileID(
                    a,
                    Math.floor(((n + i) / 2) * l),
                    Math.floor(((r + o) / 2) * l)
                  );
                })(n)),
                  (this.minzoom = this.maxzoom = this.tileID.z);
                const r = n.map((t) => this.tileID.getTilePoint(t)._round());
                return (
                  (this._boundsArray = new t.StructArrayLayout4i8()),
                  this._boundsArray.emplaceBack(r[0].x, r[0].y, 0, 0),
                  this._boundsArray.emplaceBack(r[1].x, r[1].y, t.EXTENT, 0),
                  this._boundsArray.emplaceBack(r[3].x, r[3].y, 0, t.EXTENT),
                  this._boundsArray.emplaceBack(
                    r[2].x,
                    r[2].y,
                    t.EXTENT,
                    t.EXTENT
                  ),
                  this.boundsBuffer &&
                    (this.boundsBuffer.destroy(), delete this.boundsBuffer),
                  this.fire(
                    new t.Event("data", {
                      dataType: "source",
                      sourceDataType: "content",
                    })
                  ),
                  this
                );
              }
              prepare() {
                if (0 === Object.keys(this.tiles).length || !this.image) return;
                const e = this.map.painter.context,
                  n = e.gl;
                this.boundsBuffer ||
                  (this.boundsBuffer = e.createVertexBuffer(
                    this._boundsArray,
                    St.members
                  )),
                  this.boundsSegments ||
                    (this.boundsSegments = t.SegmentVector.simpleSegment(
                      0,
                      0,
                      4,
                      2
                    )),
                  this.texture ||
                    ((this.texture = new t.Texture(e, this.image, n.RGBA)),
                    this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE));
                for (const t in this.tiles) {
                  const e = this.tiles[t];
                  "loaded" !== e.state &&
                    ((e.state = "loaded"), (e.texture = this.texture));
                }
              }
              loadTile(t, e) {
                this.tileID && this.tileID.equals(t.tileID.canonical)
                  ? ((this.tiles[String(t.tileID.wrap)] = t),
                    (t.buckets = {}),
                    e(null))
                  : ((t.state = "errored"), e(null));
              }
              serialize() {
                return {
                  type: "image",
                  url: this.options.url,
                  coordinates: this.coordinates,
                };
              }
              hasTransition() {
                return !1;
              }
            }
            const Tt = {
                vector: class extends t.Evented {
                  constructor(e, n, r, i) {
                    if (
                      (super(),
                      (this.id = e),
                      (this.dispatcher = r),
                      (this.type = "vector"),
                      (this.minzoom = 0),
                      (this.maxzoom = 22),
                      (this.scheme = "xyz"),
                      (this.tileSize = 512),
                      (this.reparseOverscaled = !0),
                      (this.isTileClipped = !0),
                      (this._loaded = !1),
                      t.extend(
                        this,
                        t.pick(n, ["url", "scheme", "tileSize", "promoteId"])
                      ),
                      (this._options = t.extend({ type: "vector" }, n)),
                      (this._collectResourceTiming = n.collectResourceTiming),
                      512 !== this.tileSize)
                    )
                      throw new Error(
                        "vector tile sources must have a tileSize of 512"
                      );
                    this.setEventedParent(i),
                      (this._tileWorkers = {}),
                      (this._deduped = new t.DedupedRequest());
                  }
                  load() {
                    (this._loaded = !1),
                      this.fire(
                        new t.Event("dataloading", { dataType: "source" })
                      ),
                      (this._tileJSONRequest = I(
                        this._options,
                        this.map._requestManager,
                        (e, n) => {
                          (this._tileJSONRequest = null),
                            (this._loaded = !0),
                            e
                              ? this.fire(new t.ErrorEvent(e))
                              : n &&
                                (t.extend(this, n),
                                n.bounds &&
                                  (this.tileBounds = new D(
                                    n.bounds,
                                    this.minzoom,
                                    this.maxzoom
                                  )),
                                t.postTurnstileEvent(
                                  n.tiles,
                                  this.map._requestManager._customAccessToken
                                ),
                                this.fire(
                                  new t.Event("data", {
                                    dataType: "source",
                                    sourceDataType: "metadata",
                                  })
                                ),
                                this.fire(
                                  new t.Event("data", {
                                    dataType: "source",
                                    sourceDataType: "content",
                                  })
                                ));
                        }
                      ));
                  }
                  loaded() {
                    return this._loaded;
                  }
                  hasTile(t) {
                    return (
                      !this.tileBounds || this.tileBounds.contains(t.canonical)
                    );
                  }
                  onAdd(t) {
                    (this.map = t), this.load();
                  }
                  setSourceProperty(t) {
                    this._tileJSONRequest && this._tileJSONRequest.cancel(),
                      t();
                    const e = this.map.style._getSourceCaches(this.id);
                    for (const n of e) n.clearTiles();
                    this.load();
                  }
                  setTiles(t) {
                    return (
                      this.setSourceProperty(() => {
                        this._options.tiles = t;
                      }),
                      this
                    );
                  }
                  setUrl(t) {
                    return (
                      this.setSourceProperty(() => {
                        (this.url = t), (this._options.url = t);
                      }),
                      this
                    );
                  }
                  onRemove() {
                    this._tileJSONRequest &&
                      (this._tileJSONRequest.cancel(),
                      (this._tileJSONRequest = null));
                  }
                  serialize() {
                    return t.extend({}, this._options);
                  }
                  loadTile(e, n) {
                    const r = this.map._requestManager.normalizeTileURL(
                        e.tileID.canonical.url(this.tiles, this.scheme)
                      ),
                      i = {
                        request: this.map._requestManager.transformRequest(
                          r,
                          t.ResourceType.Tile
                        ),
                        data: void 0,
                        uid: e.uid,
                        tileID: e.tileID,
                        tileZoom: e.tileZoom,
                        zoom: e.tileID.overscaledZ,
                        tileSize: this.tileSize * e.tileID.overscaleFactor(),
                        type: this.type,
                        source: this.id,
                        pixelRatio: t.exported.devicePixelRatio,
                        showCollisionBoxes: this.map.showCollisionBoxes,
                        promoteId: this.promoteId,
                        isSymbolTile: e.isSymbolTile,
                      };
                    if (
                      ((i.request.collectResourceTiming =
                        this._collectResourceTiming),
                      e.actor && "expired" !== e.state)
                    )
                      "loading" === e.state
                        ? (e.reloadCallback = n)
                        : (e.request = e.actor.send(
                            "reloadTile",
                            i,
                            o.bind(this)
                          ));
                    else if (
                      ((e.actor = this._tileWorkers[r] =
                        this._tileWorkers[r] || this.dispatcher.getActor()),
                      this.dispatcher.ready)
                    )
                      e.request = e.actor.send(
                        "loadTile",
                        i,
                        o.bind(this),
                        void 0,
                        !0
                      );
                    else {
                      const n = t.loadVectorTile.call(
                        { deduped: this._deduped },
                        i,
                        (t, n) => {
                          t || !n
                            ? o.call(this, t)
                            : ((i.data = {
                                cacheControl: n.cacheControl,
                                expires: n.expires,
                                rawData: n.rawData.slice(0),
                              }),
                              e.actor &&
                                e.actor.send(
                                  "loadTile",
                                  i,
                                  o.bind(this),
                                  void 0,
                                  !0
                                ));
                        },
                        !0
                      );
                      e.request = { cancel: n };
                    }
                    function o(r, i) {
                      return (
                        delete e.request,
                        e.aborted
                          ? n(null)
                          : r && 404 !== r.status
                          ? n(r)
                          : (i &&
                              i.resourceTiming &&
                              (e.resourceTiming = i.resourceTiming),
                            this.map._refreshExpiredTiles &&
                              i &&
                              e.setExpiryData(i),
                            e.loadVectorData(i, this.map.painter),
                            t.cacheEntryPossiblyAdded(this.dispatcher),
                            n(null),
                            void (
                              e.reloadCallback &&
                              (this.loadTile(e, e.reloadCallback),
                              (e.reloadCallback = null))
                            ))
                      );
                    }
                  }
                  abortTile(t) {
                    t.request && (t.request.cancel(), delete t.request),
                      t.actor &&
                        t.actor.send("abortTile", {
                          uid: t.uid,
                          type: this.type,
                          source: this.id,
                        });
                  }
                  unloadTile(t) {
                    t.unloadVectorData(),
                      t.actor &&
                        t.actor.send("removeTile", {
                          uid: t.uid,
                          type: this.type,
                          source: this.id,
                        });
                  }
                  hasTransition() {
                    return !1;
                  }
                  afterUpdate() {
                    this._tileWorkers = {};
                  }
                },
                raster: xt,
                "raster-dem": class extends xt {
                  constructor(e, n, r, i) {
                    super(e, n, r, i),
                      (this.type = "raster-dem"),
                      (this.maxzoom = 22),
                      (this._options = t.extend({ type: "raster-dem" }, n)),
                      (this.encoding = n.encoding || "mapbox");
                  }
                  loadTile(e, n) {
                    const r = this.map._requestManager.normalizeTileURL(
                      e.tileID.canonical.url(this.tiles, this.scheme),
                      !1,
                      this.tileSize
                    );
                    function i(t, r) {
                      t && ((e.state = "errored"), n(t)),
                        r &&
                          ((e.dem = r),
                          e.dem.onDeserialize(),
                          (e.needsHillshadePrepare = !0),
                          (e.needsDEMTextureUpload = !0),
                          (e.state = "loaded"),
                          n(null));
                    }
                    e.request = t.getImage(
                      this.map._requestManager.transformRequest(
                        r,
                        t.ResourceType.Tile
                      ),
                      function (r, o, s, a) {
                        if ((delete e.request, e.aborted))
                          (e.state = "unloaded"), n(null);
                        else if (r) (e.state = "errored"), n(r);
                        else if (o) {
                          this.map._refreshExpiredTiles &&
                            e.setExpiryData({ cacheControl: s, expires: a });
                          const n =
                              t.window.ImageBitmap &&
                              o instanceof t.window.ImageBitmap &&
                              (null == wt &&
                                (wt =
                                  t.window.OffscreenCanvas &&
                                  new t.window.OffscreenCanvas(1, 1).getContext(
                                    "2d"
                                  ) &&
                                  "function" ==
                                    typeof t.window.createImageBitmap),
                              wt),
                            r = 1 - (o.width - t.prevPowerOfTwo(o.width)) / 2;
                          r < 1 ||
                            e.neighboringTiles ||
                            (e.neighboringTiles = this._getNeighboringTiles(
                              e.tileID
                            ));
                          const l = n ? o : t.exported.getImageData(o, r),
                            c = {
                              uid: e.uid,
                              coord: e.tileID,
                              source: this.id,
                              rawImageData: l,
                              encoding: this.encoding,
                              padding: r,
                            };
                          (e.actor && "expired" !== e.state) ||
                            ((e.actor = this.dispatcher.getActor()),
                            e.actor.send(
                              "loadDEMTile",
                              c,
                              i.bind(this),
                              void 0,
                              !0
                            ));
                        }
                      }.bind(this)
                    );
                  }
                  _getNeighboringTiles(e) {
                    const n = e.canonical,
                      r = Math.pow(2, n.z),
                      i = (n.x - 1 + r) % r,
                      o = 0 === n.x ? e.wrap - 1 : e.wrap,
                      s = (n.x + 1 + r) % r,
                      a = n.x + 1 === r ? e.wrap + 1 : e.wrap,
                      l = {};
                    return (
                      (l[
                        new t.OverscaledTileID(
                          e.overscaledZ,
                          o,
                          n.z,
                          i,
                          n.y
                        ).key
                      ] = { backfilled: !1 }),
                      (l[
                        new t.OverscaledTileID(
                          e.overscaledZ,
                          a,
                          n.z,
                          s,
                          n.y
                        ).key
                      ] = { backfilled: !1 }),
                      n.y > 0 &&
                        ((l[
                          new t.OverscaledTileID(
                            e.overscaledZ,
                            o,
                            n.z,
                            i,
                            n.y - 1
                          ).key
                        ] = { backfilled: !1 }),
                        (l[
                          new t.OverscaledTileID(
                            e.overscaledZ,
                            e.wrap,
                            n.z,
                            n.x,
                            n.y - 1
                          ).key
                        ] = { backfilled: !1 }),
                        (l[
                          new t.OverscaledTileID(
                            e.overscaledZ,
                            a,
                            n.z,
                            s,
                            n.y - 1
                          ).key
                        ] = { backfilled: !1 })),
                      n.y + 1 < r &&
                        ((l[
                          new t.OverscaledTileID(
                            e.overscaledZ,
                            o,
                            n.z,
                            i,
                            n.y + 1
                          ).key
                        ] = { backfilled: !1 }),
                        (l[
                          new t.OverscaledTileID(
                            e.overscaledZ,
                            e.wrap,
                            n.z,
                            n.x,
                            n.y + 1
                          ).key
                        ] = { backfilled: !1 }),
                        (l[
                          new t.OverscaledTileID(
                            e.overscaledZ,
                            a,
                            n.z,
                            s,
                            n.y + 1
                          ).key
                        ] = { backfilled: !1 })),
                      l
                    );
                  }
                  unloadTile(t) {
                    t.demTexture &&
                      this.map.painter.saveTileTexture(t.demTexture),
                      t.fbo && (t.fbo.destroy(), delete t.fbo),
                      t.dem && delete t.dem,
                      delete t.neighboringTiles,
                      (t.state = "unloaded");
                  }
                },
                geojson: class extends t.Evented {
                  constructor(e, n, r, i) {
                    super(),
                      (this.id = e),
                      (this.type = "geojson"),
                      (this.minzoom = 0),
                      (this.maxzoom = 18),
                      (this.tileSize = 512),
                      (this.isTileClipped = !0),
                      (this.reparseOverscaled = !0),
                      (this._loaded = !1),
                      (this.actor = r.getActor()),
                      this.setEventedParent(i),
                      (this._data = n.data),
                      (this._options = t.extend({}, n)),
                      (this._collectResourceTiming = n.collectResourceTiming),
                      void 0 !== n.maxzoom && (this.maxzoom = n.maxzoom),
                      n.type && (this.type = n.type),
                      n.attribution && (this.attribution = n.attribution),
                      (this.promoteId = n.promoteId);
                    const o = t.EXTENT / this.tileSize;
                    this.workerOptions = t.extend(
                      {
                        source: this.id,
                        cluster: n.cluster || !1,
                        geojsonVtOptions: {
                          buffer: (void 0 !== n.buffer ? n.buffer : 128) * o,
                          tolerance:
                            (void 0 !== n.tolerance ? n.tolerance : 0.375) * o,
                          extent: t.EXTENT,
                          maxZoom: this.maxzoom,
                          lineMetrics: n.lineMetrics || !1,
                          generateId: n.generateId || !1,
                        },
                        superclusterOptions: {
                          maxZoom:
                            void 0 !== n.clusterMaxZoom
                              ? n.clusterMaxZoom
                              : this.maxzoom - 1,
                          minPoints: Math.max(2, n.clusterMinPoints || 2),
                          extent: t.EXTENT,
                          radius:
                            (void 0 !== n.clusterRadius
                              ? n.clusterRadius
                              : 50) * o,
                          log: !1,
                          generateId: n.generateId || !1,
                        },
                        clusterProperties: n.clusterProperties,
                        filter: n.filter,
                      },
                      n.workerOptions
                    );
                  }
                  onAdd(t) {
                    (this.map = t), this.setData(this._data);
                  }
                  setData(t) {
                    return (this._data = t), this._updateWorkerData(), this;
                  }
                  getClusterExpansionZoom(t, e) {
                    return (
                      this.actor.send(
                        "geojson.getClusterExpansionZoom",
                        { clusterId: t, source: this.id },
                        e
                      ),
                      this
                    );
                  }
                  getClusterChildren(t, e) {
                    return (
                      this.actor.send(
                        "geojson.getClusterChildren",
                        { clusterId: t, source: this.id },
                        e
                      ),
                      this
                    );
                  }
                  getClusterLeaves(t, e, n, r) {
                    return (
                      this.actor.send(
                        "geojson.getClusterLeaves",
                        { source: this.id, clusterId: t, limit: e, offset: n },
                        r
                      ),
                      this
                    );
                  }
                  _updateWorkerData() {
                    if (this._pendingLoad) return void (this._coalesce = !0);
                    this.fire(
                      new t.Event("dataloading", { dataType: "source" })
                    ),
                      (this._loaded = !1);
                    const e = t.extend({}, this.workerOptions),
                      n = this._data;
                    "string" == typeof n
                      ? ((e.request = this.map._requestManager.transformRequest(
                          t.exported.resolveURL(n),
                          t.ResourceType.Source
                        )),
                        (e.request.collectResourceTiming =
                          this._collectResourceTiming))
                      : (e.data = JSON.stringify(n)),
                      (this._pendingLoad = this.actor.send(
                        `${this.type}.loadData`,
                        e,
                        (e, n) => {
                          if (
                            ((this._loaded = !0), (this._pendingLoad = null), e)
                          )
                            this.fire(new t.ErrorEvent(e));
                          else {
                            const e = {
                              dataType: "source",
                              sourceDataType: this._metadataFired
                                ? "content"
                                : "metadata",
                            };
                            this._collectResourceTiming &&
                              n &&
                              n.resourceTiming &&
                              n.resourceTiming[this.id] &&
                              (e.resourceTiming = n.resourceTiming[this.id]),
                              this.fire(new t.Event("data", e)),
                              (this._metadataFired = !0);
                          }
                          this._coalesce &&
                            (this._updateWorkerData(), (this._coalesce = !1));
                        }
                      ));
                  }
                  loaded() {
                    return this._loaded;
                  }
                  loadTile(e, n) {
                    const r = e.actor ? "reloadTile" : "loadTile";
                    (e.actor = this.actor),
                      (e.request = this.actor.send(
                        r,
                        {
                          type: this.type,
                          uid: e.uid,
                          tileID: e.tileID,
                          tileZoom: e.tileZoom,
                          zoom: e.tileID.overscaledZ,
                          maxZoom: this.maxzoom,
                          tileSize: this.tileSize,
                          source: this.id,
                          pixelRatio: t.exported.devicePixelRatio,
                          showCollisionBoxes: this.map.showCollisionBoxes,
                          promoteId: this.promoteId,
                        },
                        (t, i) => (
                          delete e.request,
                          e.unloadVectorData(),
                          e.aborted
                            ? n(null)
                            : t
                            ? n(t)
                            : (e.loadVectorData(
                                i,
                                this.map.painter,
                                "reloadTile" === r
                              ),
                              n(null))
                        ),
                        void 0,
                        "loadTile" === r
                      ));
                  }
                  abortTile(t) {
                    t.request && (t.request.cancel(), delete t.request),
                      (t.aborted = !0);
                  }
                  unloadTile(t) {
                    t.unloadVectorData(),
                      this.actor.send("removeTile", {
                        uid: t.uid,
                        type: this.type,
                        source: this.id,
                      });
                  }
                  onRemove() {
                    this._pendingLoad && this._pendingLoad.cancel();
                  }
                  serialize() {
                    return t.extend({}, this._options, {
                      type: this.type,
                      data: this._data,
                    });
                  }
                  hasTransition() {
                    return !1;
                  }
                },
                video: class extends Et {
                  constructor(t, e, n, r) {
                    super(t, e, n, r),
                      (this.roundZoom = !0),
                      (this.type = "video"),
                      (this.options = e);
                  }
                  load() {
                    this._loaded = !1;
                    const e = this.options;
                    this.urls = [];
                    for (const n of e.urls)
                      this.urls.push(
                        this.map._requestManager.transformRequest(
                          n,
                          t.ResourceType.Source
                        ).url
                      );
                    t.getVideo(this.urls, (e, n) => {
                      (this._loaded = !0),
                        e
                          ? this.fire(new t.ErrorEvent(e))
                          : n &&
                            ((this.video = n),
                            (this.video.loop = !0),
                            this.video.addEventListener("playing", () => {
                              this.map.triggerRepaint();
                            }),
                            this.map && this.video.play(),
                            this._finishLoading());
                    });
                  }
                  pause() {
                    this.video && this.video.pause();
                  }
                  play() {
                    this.video && this.video.play();
                  }
                  seek(e) {
                    if (this.video) {
                      const n = this.video.seekable;
                      e < n.start(0) || e > n.end(0)
                        ? this.fire(
                            new t.ErrorEvent(
                              new t.ValidationError(
                                `sources.${this.id}`,
                                null,
                                `Playback for this video can be set only between the ${n.start(
                                  0
                                )} and ${n.end(0)}-second mark.`
                              )
                            )
                          )
                        : (this.video.currentTime = e);
                    }
                  }
                  getVideo() {
                    return this.video;
                  }
                  onAdd(t) {
                    this.map ||
                      ((this.map = t),
                      this.load(),
                      this.video &&
                        (this.video.play(),
                        this.setCoordinates(this.coordinates)));
                  }
                  prepare() {
                    if (
                      0 === Object.keys(this.tiles).length ||
                      this.video.readyState < 2
                    )
                      return;
                    const e = this.map.painter.context,
                      n = e.gl;
                    this.boundsBuffer ||
                      (this.boundsBuffer = e.createVertexBuffer(
                        this._boundsArray,
                        St.members
                      )),
                      this.boundsSegments ||
                        (this.boundsSegments = t.SegmentVector.simpleSegment(
                          0,
                          0,
                          4,
                          2
                        )),
                      this.texture
                        ? this.video.paused ||
                          (this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE),
                          n.texSubImage2D(
                            n.TEXTURE_2D,
                            0,
                            0,
                            0,
                            n.RGBA,
                            n.UNSIGNED_BYTE,
                            this.video
                          ))
                        : ((this.texture = new t.Texture(
                            e,
                            this.video,
                            n.RGBA
                          )),
                          this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE));
                    for (const t in this.tiles) {
                      const e = this.tiles[t];
                      "loaded" !== e.state &&
                        ((e.state = "loaded"), (e.texture = this.texture));
                    }
                  }
                  serialize() {
                    return {
                      type: "video",
                      urls: this.urls,
                      coordinates: this.coordinates,
                    };
                  }
                  hasTransition() {
                    return this.video && !this.video.paused;
                  }
                },
                image: Et,
                canvas: class extends Et {
                  constructor(e, n, r, i) {
                    super(e, n, r, i),
                      n.coordinates
                        ? (Array.isArray(n.coordinates) &&
                            4 === n.coordinates.length &&
                            !n.coordinates.some(
                              (t) =>
                                !Array.isArray(t) ||
                                2 !== t.length ||
                                t.some((t) => "number" != typeof t)
                            )) ||
                          this.fire(
                            new t.ErrorEvent(
                              new t.ValidationError(
                                `sources.${e}`,
                                null,
                                '"coordinates" property must be an array of 4 longitude/latitude array pairs'
                              )
                            )
                          )
                        : this.fire(
                            new t.ErrorEvent(
                              new t.ValidationError(
                                `sources.${e}`,
                                null,
                                'missing required property "coordinates"'
                              )
                            )
                          ),
                      n.animate &&
                        "boolean" != typeof n.animate &&
                        this.fire(
                          new t.ErrorEvent(
                            new t.ValidationError(
                              `sources.${e}`,
                              null,
                              'optional "animate" property must be a boolean value'
                            )
                          )
                        ),
                      n.canvas
                        ? "string" == typeof n.canvas ||
                          n.canvas instanceof t.window.HTMLCanvasElement ||
                          this.fire(
                            new t.ErrorEvent(
                              new t.ValidationError(
                                `sources.${e}`,
                                null,
                                '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'
                              )
                            )
                          )
                        : this.fire(
                            new t.ErrorEvent(
                              new t.ValidationError(
                                `sources.${e}`,
                                null,
                                'missing required property "canvas"'
                              )
                            )
                          ),
                      (this.options = n),
                      (this.animate = void 0 === n.animate || n.animate);
                  }
                  load() {
                    (this._loaded = !0),
                      this.canvas ||
                        (this.canvas =
                          this.options.canvas instanceof
                          t.window.HTMLCanvasElement
                            ? this.options.canvas
                            : t.window.document.getElementById(
                                this.options.canvas
                              )),
                      (this.width = this.canvas.width),
                      (this.height = this.canvas.height),
                      this._hasInvalidDimensions()
                        ? this.fire(
                            new t.ErrorEvent(
                              new Error(
                                "Canvas dimensions cannot be less than or equal to zero."
                              )
                            )
                          )
                        : ((this.play = function () {
                            (this._playing = !0), this.map.triggerRepaint();
                          }),
                          (this.pause = function () {
                            this._playing &&
                              (this.prepare(), (this._playing = !1));
                          }),
                          this._finishLoading());
                  }
                  getCanvas() {
                    return this.canvas;
                  }
                  onAdd(t) {
                    (this.map = t),
                      this.load(),
                      this.canvas && this.animate && this.play();
                  }
                  onRemove() {
                    this.pause();
                  }
                  prepare() {
                    let e = !1;
                    if (
                      (this.canvas.width !== this.width &&
                        ((this.width = this.canvas.width), (e = !0)),
                      this.canvas.height !== this.height &&
                        ((this.height = this.canvas.height), (e = !0)),
                      this._hasInvalidDimensions())
                    )
                      return;
                    if (0 === Object.keys(this.tiles).length) return;
                    const n = this.map.painter.context,
                      r = n.gl;
                    this.boundsBuffer ||
                      (this.boundsBuffer = n.createVertexBuffer(
                        this._boundsArray,
                        St.members
                      )),
                      this.boundsSegments ||
                        (this.boundsSegments = t.SegmentVector.simpleSegment(
                          0,
                          0,
                          4,
                          2
                        )),
                      this.texture
                        ? (e || this._playing) &&
                          this.texture.update(this.canvas, { premultiply: !0 })
                        : (this.texture = new t.Texture(
                            n,
                            this.canvas,
                            r.RGBA,
                            { premultiply: !0 }
                          ));
                    for (const t in this.tiles) {
                      const e = this.tiles[t];
                      "loaded" !== e.state &&
                        ((e.state = "loaded"), (e.texture = this.texture));
                    }
                  }
                  serialize() {
                    return { type: "canvas", coordinates: this.coordinates };
                  }
                  hasTransition() {
                    return this._playing;
                  }
                  _hasInvalidDimensions() {
                    for (const t of [this.canvas.width, this.canvas.height])
                      if (isNaN(t) || t <= 0) return !0;
                    return !1;
                  }
                },
              },
              At = function (e, n, r, i) {
                const o = new Tt[n.type](e, n, r, i);
                if (o.id !== e)
                  throw new Error(
                    `Expected Source id to be ${e} instead of ${o.id}`
                  );
                return (
                  t.bindAll(
                    ["load", "abort", "unload", "serialize", "prepare"],
                    o
                  ),
                  o
                );
              };
            function Ct(e, n) {
              const r = t.identity([]);
              return (
                t.scale$1(r, r, [0.5 * e.width, 0.5 * -e.height, 1]),
                t.translate(r, r, [1, -1, 0]),
                t.multiply(r, r, e.calculateProjMatrix(n.toUnwrapped()))
              );
            }
            function Pt(t, e, n, r, i, o, s, a = !1) {
              const l = t.tilesIn(r, s, a);
              l.sort(Ot);
              const c = [];
              for (const h of l)
                c.push({
                  wrappedTileID: h.tile.tileID.wrapped().key,
                  queryResults: h.tile.queryRenderedFeatures(
                    e,
                    n,
                    t._state,
                    h,
                    i,
                    o,
                    Ct(t.transform, h.tile.tileID),
                    a
                  ),
                });
              const u = (function (t) {
                const e = {},
                  n = {};
                for (const r of t) {
                  const t = r.queryResults,
                    i = r.wrappedTileID,
                    o = (n[i] = n[i] || {});
                  for (const n in t) {
                    const r = t[n],
                      i = (o[n] = o[n] || {}),
                      s = (e[n] = e[n] || []);
                    for (const t of r)
                      i[t.featureIndex] ||
                        ((i[t.featureIndex] = !0), s.push(t));
                  }
                }
                return e;
              })(c);
              for (const h in u)
                u[h].forEach((e) => {
                  const n = e.feature,
                    r = t.getFeatureState(n.layer["source-layer"], n.id);
                  (n.source = n.layer.source),
                    n.layer["source-layer"] &&
                      (n.sourceLayer = n.layer["source-layer"]),
                    (n.state = r);
                });
              return u;
            }
            function Mt(t, e) {
              const n = t.getRenderableIds().map((e) => t.getTileByID(e)),
                r = [],
                i = {};
              for (let o = 0; o < n.length; o++) {
                const t = n[o],
                  s = t.tileID.canonical.key;
                i[s] || ((i[s] = !0), t.querySourceFeatures(r, e));
              }
              return r;
            }
            function Ot(t, e) {
              const n = t.tileID,
                r = e.tileID;
              return (
                n.overscaledZ - r.overscaledZ ||
                n.canonical.y - r.canonical.y ||
                n.wrap - r.wrap ||
                n.canonical.x - r.canonical.x
              );
            }
            function kt() {
              return null != Wi.workerClass
                ? new Wi.workerClass()
                : new t.window.Worker(Wi.workerUrl);
            }
            const It = "mapboxgl_preloaded_worker_pool";
            class Dt {
              constructor() {
                this.active = {};
              }
              acquire(t) {
                if (!this.workers)
                  for (
                    this.workers = [];
                    this.workers.length < Dt.workerCount;

                  )
                    this.workers.push(new kt());
                return (this.active[t] = !0), this.workers.slice();
              }
              release(t) {
                delete this.active[t],
                  0 === this.numActive() &&
                    (this.workers.forEach((t) => {
                      t.terminate();
                    }),
                    (this.workers = null));
              }
              isPreloaded() {
                return !!this.active[It];
              }
              numActive() {
                return Object.keys(this.active).length;
              }
            }
            let zt;
            function Rt() {
              return zt || (zt = new Dt()), zt;
            }
            function Lt(e, n) {
              const r = {};
              for (const t in e) "ref" !== t && (r[t] = e[t]);
              return (
                t.refProperties.forEach((t) => {
                  t in n && (r[t] = n[t]);
                }),
                r
              );
            }
            function Ft(t) {
              t = t.slice();
              const e = Object.create(null);
              for (let n = 0; n < t.length; n++) e[t[n].id] = t[n];
              for (let n = 0; n < t.length; n++)
                "ref" in t[n] && (t[n] = Lt(t[n], e[t[n].ref]));
              return t;
            }
            Dt.workerCount = 2;
            const Bt = {
              setStyle: "setStyle",
              addLayer: "addLayer",
              removeLayer: "removeLayer",
              setPaintProperty: "setPaintProperty",
              setLayoutProperty: "setLayoutProperty",
              setFilter: "setFilter",
              addSource: "addSource",
              removeSource: "removeSource",
              setGeoJSONSourceData: "setGeoJSONSourceData",
              setLayerZoomRange: "setLayerZoomRange",
              setLayerProperty: "setLayerProperty",
              setCenter: "setCenter",
              setZoom: "setZoom",
              setBearing: "setBearing",
              setPitch: "setPitch",
              setSprite: "setSprite",
              setGlyphs: "setGlyphs",
              setTransition: "setTransition",
              setLight: "setLight",
              setTerrain: "setTerrain",
              setFog: "setFog",
            };
            function Nt(t, e, n) {
              n.push({ command: Bt.addSource, args: [t, e[t]] });
            }
            function jt(t, e, n) {
              e.push({ command: Bt.removeSource, args: [t] }), (n[t] = !0);
            }
            function Ut(t, e, n, r) {
              jt(t, n, r), Nt(t, e, n);
            }
            function Zt(t, e, n) {
              let r;
              for (r in t[n])
                if (
                  t[n].hasOwnProperty(r) &&
                  "data" !== r &&
                  !i(t[n][r], e[n][r])
                )
                  return !1;
              for (r in e[n])
                if (
                  e[n].hasOwnProperty(r) &&
                  "data" !== r &&
                  !i(t[n][r], e[n][r])
                )
                  return !1;
              return !0;
            }
            function Vt(t, e, n, r, o, s) {
              let a;
              for (a in ((e = e || {}), (t = t || {})))
                t.hasOwnProperty(a) &&
                  (i(t[a], e[a]) ||
                    n.push({ command: s, args: [r, a, e[a], o] }));
              for (a in e)
                e.hasOwnProperty(a) &&
                  !t.hasOwnProperty(a) &&
                  (i(t[a], e[a]) ||
                    n.push({ command: s, args: [r, a, e[a], o] }));
            }
            function qt(t) {
              return t.id;
            }
            function $t(t, e) {
              return (t[e.id] = e), t;
            }
            class Gt {
              constructor(t, e) {
                this.reset(t, e);
              }
              reset(t, e) {
                (this.points = t || []), (this._distances = [0]);
                for (let n = 1; n < this.points.length; n++)
                  this._distances[n] =
                    this._distances[n - 1] +
                    this.points[n].dist(this.points[n - 1]);
                (this.length = this._distances[this._distances.length - 1]),
                  (this.padding = Math.min(e || 0, 0.5 * this.length)),
                  (this.paddedLength = this.length - 2 * this.padding);
              }
              lerp(e) {
                if (1 === this.points.length) return this.points[0];
                e = t.clamp(e, 0, 1);
                let n = 1,
                  r = this._distances[n];
                const i = e * this.paddedLength + this.padding;
                for (; r < i && n < this._distances.length; )
                  r = this._distances[++n];
                const o = n - 1,
                  s = this._distances[o],
                  a = r - s,
                  l = a > 0 ? (i - s) / a : 0;
                return this.points[o].mult(1 - l).add(this.points[n].mult(l));
              }
            }
            class Wt {
              constructor(t, e, n) {
                const r = (this.boxCells = []),
                  i = (this.circleCells = []);
                (this.xCellCount = Math.ceil(t / n)),
                  (this.yCellCount = Math.ceil(e / n));
                for (let o = 0; o < this.xCellCount * this.yCellCount; o++)
                  r.push([]), i.push([]);
                (this.circleKeys = []),
                  (this.boxKeys = []),
                  (this.bboxes = []),
                  (this.circles = []),
                  (this.width = t),
                  (this.height = e),
                  (this.xScale = this.xCellCount / t),
                  (this.yScale = this.yCellCount / e),
                  (this.boxUid = 0),
                  (this.circleUid = 0);
              }
              keysLength() {
                return this.boxKeys.length + this.circleKeys.length;
              }
              insert(t, e, n, r, i) {
                this._forEachCell(
                  e,
                  n,
                  r,
                  i,
                  this._insertBoxCell,
                  this.boxUid++
                ),
                  this.boxKeys.push(t),
                  this.bboxes.push(e),
                  this.bboxes.push(n),
                  this.bboxes.push(r),
                  this.bboxes.push(i);
              }
              insertCircle(t, e, n, r) {
                this._forEachCell(
                  e - r,
                  n - r,
                  e + r,
                  n + r,
                  this._insertCircleCell,
                  this.circleUid++
                ),
                  this.circleKeys.push(t),
                  this.circles.push(e),
                  this.circles.push(n),
                  this.circles.push(r);
              }
              _insertBoxCell(t, e, n, r, i, o) {
                this.boxCells[i].push(o);
              }
              _insertCircleCell(t, e, n, r, i, o) {
                this.circleCells[i].push(o);
              }
              _query(t, e, n, r, i, o) {
                if (n < 0 || t > this.width || r < 0 || e > this.height)
                  return !i && [];
                const s = [];
                if (t <= 0 && e <= 0 && this.width <= n && this.height <= r) {
                  if (i) return !0;
                  for (let t = 0; t < this.boxKeys.length; t++)
                    s.push({
                      key: this.boxKeys[t],
                      x1: this.bboxes[4 * t],
                      y1: this.bboxes[4 * t + 1],
                      x2: this.bboxes[4 * t + 2],
                      y2: this.bboxes[4 * t + 3],
                    });
                  for (let t = 0; t < this.circleKeys.length; t++) {
                    const e = this.circles[3 * t],
                      n = this.circles[3 * t + 1],
                      r = this.circles[3 * t + 2];
                    s.push({
                      key: this.circleKeys[t],
                      x1: e - r,
                      y1: n - r,
                      x2: e + r,
                      y2: n + r,
                    });
                  }
                  return o ? s.filter(o) : s;
                }
                return (
                  this._forEachCell(
                    t,
                    e,
                    n,
                    r,
                    this._queryCell,
                    s,
                    { hitTest: i, seenUids: { box: {}, circle: {} } },
                    o
                  ),
                  i ? s.length > 0 : s
                );
              }
              _queryCircle(t, e, n, r, i) {
                const o = t - n,
                  s = t + n,
                  a = e - n,
                  l = e + n;
                if (s < 0 || o > this.width || l < 0 || a > this.height)
                  return !r && [];
                const c = [];
                return (
                  this._forEachCell(
                    o,
                    a,
                    s,
                    l,
                    this._queryCellCircle,
                    c,
                    {
                      hitTest: r,
                      circle: { x: t, y: e, radius: n },
                      seenUids: { box: {}, circle: {} },
                    },
                    i
                  ),
                  r ? c.length > 0 : c
                );
              }
              query(t, e, n, r, i) {
                return this._query(t, e, n, r, !1, i);
              }
              hitTest(t, e, n, r, i) {
                return this._query(t, e, n, r, !0, i);
              }
              hitTestCircle(t, e, n, r) {
                return this._queryCircle(t, e, n, !0, r);
              }
              _queryCell(t, e, n, r, i, o, s, a) {
                const l = s.seenUids,
                  c = this.boxCells[i];
                if (null !== c) {
                  const i = this.bboxes;
                  for (const u of c)
                    if (!l.box[u]) {
                      l.box[u] = !0;
                      const c = 4 * u;
                      if (
                        t <= i[c + 2] &&
                        e <= i[c + 3] &&
                        n >= i[c + 0] &&
                        r >= i[c + 1] &&
                        (!a || a(this.boxKeys[u]))
                      ) {
                        if (s.hitTest) return o.push(!0), !0;
                        o.push({
                          key: this.boxKeys[u],
                          x1: i[c],
                          y1: i[c + 1],
                          x2: i[c + 2],
                          y2: i[c + 3],
                        });
                      }
                    }
                }
                const u = this.circleCells[i];
                if (null !== u) {
                  const i = this.circles;
                  for (const c of u)
                    if (!l.circle[c]) {
                      l.circle[c] = !0;
                      const u = 3 * c;
                      if (
                        this._circleAndRectCollide(
                          i[u],
                          i[u + 1],
                          i[u + 2],
                          t,
                          e,
                          n,
                          r
                        ) &&
                        (!a || a(this.circleKeys[c]))
                      ) {
                        if (s.hitTest) return o.push(!0), !0;
                        {
                          const t = i[u],
                            e = i[u + 1],
                            n = i[u + 2];
                          o.push({
                            key: this.circleKeys[c],
                            x1: t - n,
                            y1: e - n,
                            x2: t + n,
                            y2: e + n,
                          });
                        }
                      }
                    }
                }
              }
              _queryCellCircle(t, e, n, r, i, o, s, a) {
                const l = s.circle,
                  c = s.seenUids,
                  u = this.boxCells[i];
                if (null !== u) {
                  const t = this.bboxes;
                  for (const e of u)
                    if (!c.box[e]) {
                      c.box[e] = !0;
                      const n = 4 * e;
                      if (
                        this._circleAndRectCollide(
                          l.x,
                          l.y,
                          l.radius,
                          t[n + 0],
                          t[n + 1],
                          t[n + 2],
                          t[n + 3]
                        ) &&
                        (!a || a(this.boxKeys[e]))
                      )
                        return o.push(!0), !0;
                    }
                }
                const h = this.circleCells[i];
                if (null !== h) {
                  const t = this.circles;
                  for (const e of h)
                    if (!c.circle[e]) {
                      c.circle[e] = !0;
                      const n = 3 * e;
                      if (
                        this._circlesCollide(
                          t[n],
                          t[n + 1],
                          t[n + 2],
                          l.x,
                          l.y,
                          l.radius
                        ) &&
                        (!a || a(this.circleKeys[e]))
                      )
                        return o.push(!0), !0;
                    }
                }
              }
              _forEachCell(t, e, n, r, i, o, s, a) {
                const l = this._convertToXCellCoord(t),
                  c = this._convertToYCellCoord(e),
                  u = this._convertToXCellCoord(n),
                  h = this._convertToYCellCoord(r);
                for (let p = l; p <= u; p++)
                  for (let l = c; l <= h; l++)
                    if (
                      i.call(this, t, e, n, r, this.xCellCount * l + p, o, s, a)
                    )
                      return;
              }
              _convertToXCellCoord(t) {
                return Math.max(
                  0,
                  Math.min(this.xCellCount - 1, Math.floor(t * this.xScale))
                );
              }
              _convertToYCellCoord(t) {
                return Math.max(
                  0,
                  Math.min(this.yCellCount - 1, Math.floor(t * this.yScale))
                );
              }
              _circlesCollide(t, e, n, r, i, o) {
                const s = r - t,
                  a = i - e,
                  l = n + o;
                return l * l > s * s + a * a;
              }
              _circleAndRectCollide(t, e, n, r, i, o, s) {
                const a = (o - r) / 2,
                  l = Math.abs(t - (r + a));
                if (l > a + n) return !1;
                const c = (s - i) / 2,
                  u = Math.abs(e - (i + c));
                if (u > c + n) return !1;
                if (l <= a || u <= c) return !0;
                const h = l - a,
                  p = u - c;
                return h * h + p * p <= n * n;
              }
            }
            const Ht = Math.tan((85 * Math.PI) / 180);
            function Xt(e, n, r, i, o) {
              const s = t.create$1();
              return (
                n
                  ? (t.scale$1(s, s, [1 / o, 1 / o, 1]),
                    r || t.rotateZ(s, s, i.angle))
                  : t.multiply(s, i.labelPlaneMatrix, e),
                s
              );
            }
            function Kt(e, n, r, i, o) {
              if (n) {
                const n = t.clone$1(e);
                return (
                  t.scale$1(n, n, [o, o, 1]), r || t.rotateZ(n, n, -i.angle), n
                );
              }
              return i.glCoordMatrix;
            }
            function Yt(e, n, r = 0) {
              const i = [e.x, e.y, r, 1];
              r ? t.transformMat4(i, i, n) : le(i, i, n);
              const o = i[3];
              return {
                point: new t.pointGeometry(i[0] / o, i[1] / o),
                signedDistanceFromCamera: o,
              };
            }
            function Qt(t, e) {
              return Math.min(0.5 + (t / e) * 0.5, 1.5);
            }
            function Jt(t, e) {
              const n = t[0] / t[3],
                r = t[1] / t[3];
              return n >= -e[0] && n <= e[0] && r >= -e[1] && r <= e[1];
            }
            function te(e, n, r, i, o, s, a, l, c) {
              const u = i ? e.textSizeData : e.iconSizeData,
                h = t.evaluateSizeForZoom(u, r.transform.zoom),
                p = [(256 / r.width) * 2 + 1, (256 / r.height) * 2 + 1],
                d = i
                  ? e.text.dynamicLayoutVertexArray
                  : e.icon.dynamicLayoutVertexArray;
              d.clear();
              const f = e.lineVertexArray,
                m = i ? e.text.placedSymbolArray : e.icon.placedSymbolArray,
                g = r.transform.width / r.transform.height;
              let y = !1;
              for (let _ = 0; _ < m.length; _++) {
                const i = m.get(_);
                if (
                  (i.writingMode !== t.WritingMode.vertical ||
                    y ||
                    (0 !== _ &&
                      m.get(_ - 1).writingMode === t.WritingMode.horizontal) ||
                    (y = !0),
                  i.hidden || (i.writingMode === t.WritingMode.vertical && !y))
                ) {
                  ae(i.numGlyphs, d);
                  continue;
                }
                y = !1;
                const v = c ? c({ x: i.anchorX, y: i.anchorY }) : 0,
                  b = [i.anchorX, i.anchorY, v, 1];
                if ((t.transformMat4(b, b, n), !Jt(b, p))) {
                  ae(i.numGlyphs, d);
                  continue;
                }
                const x = Qt(r.transform.cameraToCenterDistance, b[3]),
                  w = t.evaluateSizeForFeature(u, h, i),
                  S = a ? w / x : w * x,
                  E = new t.pointGeometry(i.anchorX, i.anchorY),
                  T = Yt(E, o, v);
                if (T.signedDistanceFromCamera <= 0) {
                  ae(i.numGlyphs, d);
                  continue;
                }
                const A = T.point;
                let C = {};
                const P = a ? null : c,
                  M = re(
                    i,
                    S,
                    !1,
                    l,
                    n,
                    o,
                    s,
                    e.glyphOffsetArray,
                    f,
                    d,
                    A,
                    E,
                    C,
                    g,
                    P
                  );
                (y = M.useVertical),
                  P && M.needsFlipping && (C = {}),
                  (M.notEnoughRoom ||
                    y ||
                    (M.needsFlipping &&
                      re(
                        i,
                        S,
                        !0,
                        l,
                        n,
                        o,
                        s,
                        e.glyphOffsetArray,
                        f,
                        d,
                        A,
                        E,
                        C,
                        g,
                        P
                      ).notEnoughRoom)) &&
                    ae(i.numGlyphs, d);
              }
              i
                ? e.text.dynamicLayoutVertexBuffer.updateData(d)
                : e.icon.dynamicLayoutVertexBuffer.updateData(d);
            }
            function ee(t, e, n, r, i, o, s, a, l, c, u, h, p) {
              const d = a.glyphStartIndex + a.numGlyphs,
                f = a.lineStartIndex,
                m = a.lineStartIndex + a.lineLength,
                g = e.getoffsetX(a.glyphStartIndex),
                y = e.getoffsetX(d - 1),
                _ = oe(
                  t * g,
                  n,
                  r,
                  i,
                  o,
                  s,
                  a.segment,
                  f,
                  m,
                  l,
                  c,
                  u,
                  h,
                  p,
                  !0
                );
              if (!_) return null;
              const v = oe(
                t * y,
                n,
                r,
                i,
                o,
                s,
                a.segment,
                f,
                m,
                l,
                c,
                u,
                h,
                p,
                !0
              );
              return v ? { first: _, last: v } : null;
            }
            function ne(e, n, r, i) {
              return e.writingMode === t.WritingMode.horizontal &&
                Math.abs(r.y - n.y) > Math.abs(r.x - n.x) * i
                ? { useVertical: !0 }
                : e.writingMode === t.WritingMode.vertical
                ? n.y < r.y
                  ? { needsFlipping: !0 }
                  : null
                : 0 !== e.flipState &&
                  (function (t, e, n) {
                    const r = (e.x - t.x) * n;
                    return 0 === r || Math.abs((e.y - t.y) / r) > Ht;
                  })(n, r, i)
                ? 1 === e.flipState
                  ? { needsFlipping: !0 }
                  : null
                : n.x > r.x
                ? { needsFlipping: !0 }
                : null;
            }
            function re(e, n, r, i, o, s, a, l, c, u, h, p, d, f, m) {
              const g = n / 24,
                y = e.lineOffsetX * g,
                _ = e.lineOffsetY * g;
              let v;
              if (e.numGlyphs > 1) {
                const t = e.glyphStartIndex + e.numGlyphs,
                  n = e.lineStartIndex,
                  o = e.lineStartIndex + e.lineLength,
                  u = ee(g, l, y, _, r, h, p, e, c, s, d, m);
                if (!u) return { notEnoughRoom: !0 };
                const b = Yt(u.first.point, a).point,
                  x = Yt(u.last.point, a).point;
                if (i && !r) {
                  const t = ne(e, b, x, f);
                  if (((e.flipState = t && t.needsFlipping ? 1 : 2), t))
                    return t;
                }
                v = [u.first];
                for (let i = e.glyphStartIndex + 1; i < t - 1; i++)
                  v.push(
                    oe(
                      g * l.getoffsetX(i),
                      y,
                      _,
                      r,
                      h,
                      p,
                      e.segment,
                      n,
                      o,
                      c,
                      s,
                      d,
                      m
                    )
                  );
                v.push(u.last);
              } else {
                if (i && !r) {
                  const n = Yt(p, o).point,
                    r = e.lineStartIndex + e.segment + 1,
                    i = new t.pointGeometry(c.getx(r), c.gety(r)),
                    s = Yt(i, o),
                    a = ne(
                      e,
                      n,
                      s.signedDistanceFromCamera > 0
                        ? s.point
                        : ie(p, i, n, 1, o),
                      f
                    );
                  if (((e.flipState = a && a.needsFlipping ? 1 : 2), a))
                    return a;
                }
                const n = oe(
                  g * l.getoffsetX(e.glyphStartIndex),
                  y,
                  _,
                  r,
                  h,
                  p,
                  e.segment,
                  e.lineStartIndex,
                  e.lineStartIndex + e.lineLength,
                  c,
                  s,
                  d,
                  m
                );
                if (!n) return { notEnoughRoom: !0 };
                v = [n];
              }
              for (const b of v) t.addDynamicAttributes(u, b.point, b.angle);
              return {};
            }
            function ie(t, e, n, r, i, o) {
              const s = t.add(t.sub(e)._unit()),
                a = Yt(s, i, o ? o(s) : 0).point,
                l = n.sub(a);
              return n.add(l._mult(r / l.mag()));
            }
            function oe(e, n, r, i, o, s, a, l, c, u, h, p, d, f, m) {
              const g = i ? e - n : e + n;
              let y = g > 0 ? 1 : -1,
                _ = 0;
              i && ((y *= -1), (_ = Math.PI)), y < 0 && (_ += Math.PI);
              let v = y > 0 ? l + a : l + a + 1,
                b = o,
                x = o,
                w = 0,
                S = 0;
              const E = Math.abs(g),
                T = [],
                A = [];
              let C = s;
              const P = () => {
                  const e = v - y;
                  return 0 === w
                    ? s
                    : new t.pointGeometry(u.getx(e), u.gety(e));
                },
                M = () => ie(P(), C, x, E - w + 1, h, d);
              for (; w + S <= E; ) {
                if (((v += y), v < l || v >= c)) return null;
                if (
                  ((x = b),
                  T.push(b),
                  f && A.push(C || P()),
                  (b = p[v]),
                  void 0 === b)
                ) {
                  C = new t.pointGeometry(u.getx(v), u.gety(v));
                  const e = Yt(C, h, d ? d(C) : 0);
                  b = e.signedDistanceFromCamera > 0 ? (p[v] = e.point) : M();
                } else C = null;
                (w += S), (S = x.dist(b));
              }
              m &&
                d &&
                ((C = C || new t.pointGeometry(u.getx(v), u.gety(v))),
                (p[v] = b = void 0 === p[v] ? b : M()),
                (S = x.dist(b)));
              const O = (E - w) / S,
                k = b.sub(x),
                I = k.mult(O)._add(x);
              r &&
                I._add(
                  k
                    ._unit()
                    ._perp()
                    ._mult(r * y)
                );
              const D = _ + Math.atan2(b.y - x.y, b.x - x.x);
              return (
                T.push(I),
                f &&
                  ((C = C || new t.pointGeometry(u.getx(v), u.gety(v))),
                  A.push(
                    (function (e, n, r) {
                      const i = 1 - r;
                      return new t.pointGeometry(
                        e.x * i + n.x * r,
                        e.y * i + n.y * r
                      );
                    })(A.length > 0 ? A[A.length - 1] : C, C, O)
                  )),
                { point: I, angle: D, path: T, tilePath: A }
              );
            }
            const se = new Float32Array([
              -1 / 0,
              -1 / 0,
              0,
              -1 / 0,
              -1 / 0,
              0,
              -1 / 0,
              -1 / 0,
              0,
              -1 / 0,
              -1 / 0,
              0,
            ]);
            function ae(t, e) {
              for (let n = 0; n < t; n++) {
                const t = e.length;
                e.resize(t + 4), e.float32.set(se, 3 * t);
              }
            }
            function le(t, e, n) {
              const r = e[0],
                i = e[1];
              return (
                (t[0] = n[0] * r + n[4] * i + n[12]),
                (t[1] = n[1] * r + n[5] * i + n[13]),
                (t[3] = n[3] * r + n[7] * i + n[15]),
                t
              );
            }
            const ce = 100;
            class ue {
              constructor(
                t,
                e,
                n = new Wt(t.width + 200, t.height + 200, 25),
                r = new Wt(t.width + 200, t.height + 200, 25)
              ) {
                (this.transform = t),
                  (this.grid = n),
                  (this.ignoredGrid = r),
                  (this.pitchfactor =
                    Math.cos(t._pitch) * t.cameraToCenterDistance),
                  (this.screenRightBoundary = t.width + ce),
                  (this.screenBottomBoundary = t.height + ce),
                  (this.gridRightBoundary = t.width + 200),
                  (this.gridBottomBoundary = t.height + 200),
                  (this.fogState = e);
              }
              placeCollisionBox(t, e, n, r, i, o, s) {
                const a = this.projectAndGetPerspectiveRatio(
                    o,
                    e.anchorPointX,
                    e.anchorPointY,
                    e.elevation,
                    e.tileID
                  ),
                  l = i * a.perspectiveRatio,
                  c = (e.x1 * t + n.x - e.padding) * l + a.point.x,
                  u = (e.y1 * t + n.y - e.padding) * l + a.point.y,
                  h = (e.x2 * t + n.x + e.padding) * l + a.point.x,
                  p = (e.y2 * t + n.y + e.padding) * l + a.point.y,
                  d = a.perspectiveRatio <= 0.55 || a.aboveHorizon;
                return !this.isInsideGrid(c, u, h, p) ||
                  (!r && this.grid.hitTest(c, u, h, p, s)) ||
                  d
                  ? { box: [], offscreen: !1 }
                  : {
                      box: [c, u, h, p],
                      offscreen: this.isOffscreen(c, u, h, p),
                    };
              }
              placeCollisionCircles(e, n, r, i, o, s, a, l, c, u, h, p, d, f) {
                const m = [],
                  g = this.transform.elevation,
                  y = g ? (t) => g.getAtTileOffset(f, t.x, t.y) : (t) => 0,
                  _ = new t.pointGeometry(n.anchorX, n.anchorY),
                  v = y(_),
                  b = this.projectAndGetPerspectiveRatio(s, _.x, _.y, v, f),
                  { perspectiveRatio: x } = b,
                  w = (u ? o / x : o * x) / t.ONE_EM,
                  S = Yt(_, a, v).point,
                  E =
                    b.signedDistanceFromCamera > 0
                      ? ee(
                          w,
                          i,
                          n.lineOffsetX * w,
                          n.lineOffsetY * w,
                          !1,
                          S,
                          _,
                          n,
                          r,
                          a,
                          {},
                          g && !u ? y : null,
                          u && !!g
                        )
                      : null;
                let T = !1,
                  A = !1,
                  C = !0;
                if (E && !b.aboveHorizon) {
                  const n = 0.5 * p * x + d,
                    r = new t.pointGeometry(-100, -100),
                    i = new t.pointGeometry(
                      this.screenRightBoundary,
                      this.screenBottomBoundary
                    ),
                    o = new Gt(),
                    s = E.first,
                    a = E.last;
                  let u = [];
                  for (let t = s.path.length - 1; t >= 1; t--)
                    u.push(s.path[t]);
                  for (let t = 1; t < a.path.length; t++) u.push(a.path[t]);
                  const f = 2.5 * n;
                  if (l) {
                    const t = u.map(
                      g
                        ? (t, e) => {
                            const n = y(
                              e < s.path.length - 1
                                ? s.tilePath[s.path.length - 1 - e]
                                : a.tilePath[e - s.path.length + 2]
                            );
                            return Yt(t, l, n);
                          }
                        : (t) => Yt(t, l)
                    );
                    u = t.some((t) => t.signedDistanceFromCamera <= 0)
                      ? []
                      : t.map((t) => t.point);
                  }
                  let _ = [];
                  if (u.length > 0) {
                    const e = u[0].clone(),
                      n = u[0].clone();
                    for (let t = 1; t < u.length; t++)
                      (e.x = Math.min(e.x, u[t].x)),
                        (e.y = Math.min(e.y, u[t].y)),
                        (n.x = Math.max(n.x, u[t].x)),
                        (n.y = Math.max(n.y, u[t].y));
                    _ =
                      e.x >= r.x && n.x <= i.x && e.y >= r.y && n.y <= i.y
                        ? [u]
                        : n.x < r.x || e.x > i.x || n.y < r.y || e.y > i.y
                        ? []
                        : t.clipLine([u], r.x, r.y, i.x, i.y);
                  }
                  for (const t of _) {
                    o.reset(t, 0.25 * n);
                    let r = 0;
                    r =
                      o.length <= 0.5 * n
                        ? 1
                        : Math.ceil(o.paddedLength / f) + 1;
                    for (let t = 0; t < r; t++) {
                      const i = t / Math.max(r - 1, 1),
                        s = o.lerp(i),
                        a = s.x + ce,
                        l = s.y + ce;
                      m.push(a, l, n, 0);
                      const u = a - n,
                        p = l - n,
                        d = a + n,
                        f = l + n;
                      if (
                        ((C = C && this.isOffscreen(u, p, d, f)),
                        (A = A || this.isInsideGrid(u, p, d, f)),
                        !e &&
                          this.grid.hitTestCircle(a, l, n, h) &&
                          ((T = !0), !c))
                      )
                        return {
                          circles: [],
                          offscreen: !1,
                          collisionDetected: T,
                        };
                    }
                  }
                }
                return {
                  circles: (!c && T) || !A ? [] : m,
                  offscreen: C,
                  collisionDetected: T,
                };
              }
              queryRenderedSymbols(e) {
                if (
                  0 === e.length ||
                  (0 === this.grid.keysLength() &&
                    0 === this.ignoredGrid.keysLength())
                )
                  return {};
                const n = [];
                let r = 1 / 0,
                  i = 1 / 0,
                  o = -1 / 0,
                  s = -1 / 0;
                for (const u of e) {
                  const e = new t.pointGeometry(u.x + ce, u.y + ce);
                  (r = Math.min(r, e.x)),
                    (i = Math.min(i, e.y)),
                    (o = Math.max(o, e.x)),
                    (s = Math.max(s, e.y)),
                    n.push(e);
                }
                const a = this.grid
                    .query(r, i, o, s)
                    .concat(this.ignoredGrid.query(r, i, o, s)),
                  l = {},
                  c = {};
                for (const u of a) {
                  const e = u.key;
                  if (
                    (void 0 === l[e.bucketInstanceId] &&
                      (l[e.bucketInstanceId] = {}),
                    l[e.bucketInstanceId][e.featureIndex])
                  )
                    continue;
                  const r = [
                    new t.pointGeometry(u.x1, u.y1),
                    new t.pointGeometry(u.x2, u.y1),
                    new t.pointGeometry(u.x2, u.y2),
                    new t.pointGeometry(u.x1, u.y2),
                  ];
                  t.polygonIntersectsPolygon(n, r) &&
                    ((l[e.bucketInstanceId][e.featureIndex] = !0),
                    void 0 === c[e.bucketInstanceId] &&
                      (c[e.bucketInstanceId] = []),
                    c[e.bucketInstanceId].push(e.featureIndex));
                }
                return c;
              }
              insertCollisionBox(t, e, n, r, i) {
                (e ? this.ignoredGrid : this.grid).insert(
                  { bucketInstanceId: n, featureIndex: r, collisionGroupID: i },
                  t[0],
                  t[1],
                  t[2],
                  t[3]
                );
              }
              insertCollisionCircles(t, e, n, r, i) {
                const o = e ? this.ignoredGrid : this.grid,
                  s = {
                    bucketInstanceId: n,
                    featureIndex: r,
                    collisionGroupID: i,
                  };
                for (let a = 0; a < t.length; a += 4)
                  o.insertCircle(s, t[a], t[a + 1], t[a + 2]);
              }
              projectAndGetPerspectiveRatio(e, n, r, i, o) {
                const s = [n, r, i || 0, 1];
                let a = !1;
                if (i || this.transform.pitch > 0) {
                  t.transformMat4(s, s, e);
                  let l = !1;
                  this.fogState &&
                    o &&
                    (l =
                      (function (e, n, r, i, o, s) {
                        const a = s.calculateFogTileMatrix(o),
                          l = [n, r, i];
                        return (
                          t.transformMat4$1(l, l, a), S(e, l, s.pitch, s._fov)
                        );
                      })(
                        this.fogState,
                        n,
                        r,
                        i || 0,
                        o.toUnwrapped(),
                        this.transform
                      ) > 0.9),
                    (a = s[2] > s[3] || l);
                } else le(s, s, e);
                return {
                  point: new t.pointGeometry(
                    ((s[0] / s[3] + 1) / 2) * this.transform.width + ce,
                    ((-s[1] / s[3] + 1) / 2) * this.transform.height + ce
                  ),
                  perspectiveRatio: Math.min(
                    0.5 + (this.transform.cameraToCenterDistance / s[3]) * 0.5,
                    1.5
                  ),
                  signedDistanceFromCamera: s[3],
                  aboveHorizon: a,
                };
              }
              isOffscreen(t, e, n, r) {
                return (
                  n < ce ||
                  t >= this.screenRightBoundary ||
                  r < ce ||
                  e > this.screenBottomBoundary
                );
              }
              isInsideGrid(t, e, n, r) {
                return (
                  n >= 0 &&
                  t < this.gridRightBoundary &&
                  r >= 0 &&
                  e < this.gridBottomBoundary
                );
              }
              getViewportMatrix() {
                const e = t.identity([]);
                return t.translate(e, e, [-100, -100, 0]), e;
              }
            }
            class he {
              constructor(t, e, n, r) {
                (this.opacity = t
                  ? Math.max(0, Math.min(1, t.opacity + (t.placed ? e : -e)))
                  : r && n
                  ? 1
                  : 0),
                  (this.placed = n);
              }
              isHidden() {
                return 0 === this.opacity && !this.placed;
              }
            }
            class pe {
              constructor(t, e, n, r, i) {
                (this.text = new he(t ? t.text : null, e, n, i)),
                  (this.icon = new he(t ? t.icon : null, e, r, i));
              }
              isHidden() {
                return this.text.isHidden() && this.icon.isHidden();
              }
            }
            class de {
              constructor(t, e, n) {
                (this.text = t), (this.icon = e), (this.skipFade = n);
              }
            }
            class fe {
              constructor() {
                (this.invProjMatrix = t.create$1()),
                  (this.viewportMatrix = t.create$1()),
                  (this.circles = []);
              }
            }
            class me {
              constructor(t, e, n, r, i) {
                (this.bucketInstanceId = t),
                  (this.featureIndex = e),
                  (this.sourceLayerIndex = n),
                  (this.bucketIndex = r),
                  (this.tileID = i);
              }
            }
            class ge {
              constructor(t) {
                (this.crossSourceCollisions = t),
                  (this.maxGroupID = 0),
                  (this.collisionGroups = {});
              }
              get(t) {
                if (this.crossSourceCollisions)
                  return { ID: 0, predicate: null };
                if (!this.collisionGroups[t]) {
                  const e = ++this.maxGroupID;
                  this.collisionGroups[t] = {
                    ID: e,
                    predicate: (t) => t.collisionGroupID === e,
                  };
                }
                return this.collisionGroups[t];
              }
            }
            function ye(e, n, r, i, o) {
              const { horizontalAlign: s, verticalAlign: a } =
                  t.getAnchorAlignment(e),
                l = -(s - 0.5) * n,
                c = -(a - 0.5) * r,
                u = t.evaluateVariableOffset(e, i);
              return new t.pointGeometry(l + u[0] * o, c + u[1] * o);
            }
            function _e(e, n, r, i, o) {
              const s = new t.pointGeometry(e, n);
              return r && s._rotate(i ? o : -o), s;
            }
            class ve {
              constructor(t, e, n, r, i) {
                (this.transform = t.clone()),
                  (this.collisionIndex = new ue(this.transform, i)),
                  (this.placements = {}),
                  (this.opacities = {}),
                  (this.variableOffsets = {}),
                  (this.stale = !1),
                  (this.commitTime = 0),
                  (this.fadeDuration = e),
                  (this.retainedQueryData = {}),
                  (this.collisionGroups = new ge(n)),
                  (this.collisionCircleArrays = {}),
                  (this.prevPlacement = r),
                  r && (r.prevPlacement = void 0),
                  (this.placedOrientations = {});
              }
              getBucketParts(e, n, r, i) {
                const o = r.getBucket(n),
                  s = r.latestFeatureIndex;
                if (!o || !s || n.id !== o.layerIds[0]) return;
                const a = r.collisionBoxArray,
                  l = o.layers[0].layout,
                  c = Math.pow(2, this.transform.zoom - r.tileID.overscaledZ),
                  u = r.tileSize / t.EXTENT,
                  h = this.transform.calculateProjMatrix(
                    r.tileID.toUnwrapped()
                  ),
                  p = "map" === l.get("text-pitch-alignment"),
                  d = "map" === l.get("text-rotation-alignment"),
                  f = M(r, 1, this.transform.zoom),
                  m = Xt(h, p, d, this.transform, f);
                let g = null;
                if (p) {
                  const e = Kt(h, p, d, this.transform, f);
                  g = t.multiply([], this.transform.labelPlaneMatrix, e);
                }
                this.retainedQueryData[o.bucketInstanceId] = new me(
                  o.bucketInstanceId,
                  s,
                  o.sourceLayerIndex,
                  o.index,
                  r.tileID
                );
                const y = {
                  bucket: o,
                  layout: l,
                  posMatrix: h,
                  textLabelPlaneMatrix: m,
                  labelToScreenMatrix: g,
                  scale: c,
                  textPixelRatio: u,
                  holdingForFade: r.holdingForFade(),
                  collisionBoxArray: a,
                  partiallyEvaluatedTextSize: t.evaluateSizeForZoom(
                    o.textSizeData,
                    this.transform.zoom
                  ),
                  partiallyEvaluatedIconSize: t.evaluateSizeForZoom(
                    o.iconSizeData,
                    this.transform.zoom
                  ),
                  collisionGroup: this.collisionGroups.get(o.sourceID),
                };
                if (i)
                  for (const t of o.sortKeyRanges) {
                    const {
                      sortKey: n,
                      symbolInstanceStart: r,
                      symbolInstanceEnd: i,
                    } = t;
                    e.push({
                      sortKey: n,
                      symbolInstanceStart: r,
                      symbolInstanceEnd: i,
                      parameters: y,
                    });
                  }
                else
                  e.push({
                    symbolInstanceStart: 0,
                    symbolInstanceEnd: o.symbolInstances.length,
                    parameters: y,
                  });
              }
              attemptAnchorPlacement(
                t,
                e,
                n,
                r,
                i,
                o,
                s,
                a,
                l,
                c,
                u,
                h,
                p,
                d,
                f,
                m,
                g,
                y
              ) {
                const _ = [h.textOffset0, h.textOffset1],
                  v = ye(t, n, r, _, i),
                  b = this.collisionIndex.placeCollisionBox(
                    i,
                    e,
                    _e(v.x, v.y, o, s, this.transform.angle),
                    u,
                    a,
                    l,
                    c.predicate
                  );
                if (
                  (!m ||
                    0 !==
                      this.collisionIndex.placeCollisionBox(
                        d.getSymbolInstanceIconSize(y, this.transform.zoom, p),
                        m,
                        _e(v.x, v.y, o, s, this.transform.angle),
                        u,
                        a,
                        l,
                        c.predicate
                      ).box.length) &&
                  b.box.length > 0
                ) {
                  let e;
                  return (
                    this.prevPlacement &&
                      this.prevPlacement.variableOffsets[h.crossTileID] &&
                      this.prevPlacement.placements[h.crossTileID] &&
                      this.prevPlacement.placements[h.crossTileID].text &&
                      (e =
                        this.prevPlacement.variableOffsets[h.crossTileID]
                          .anchor),
                    (this.variableOffsets[h.crossTileID] = {
                      textOffset: _,
                      width: n,
                      height: r,
                      anchor: t,
                      textScale: i,
                      prevAnchor: e,
                    }),
                    this.markUsedJustification(d, t, h, f),
                    d.allowVerticalPlacement &&
                      (this.markUsedOrientation(d, f, h),
                      (this.placedOrientations[h.crossTileID] = f)),
                    { shift: v, placedGlyphBoxes: b }
                  );
                }
              }
              placeLayerBucketPart(e, n, r) {
                const {
                    bucket: i,
                    layout: o,
                    posMatrix: s,
                    textLabelPlaneMatrix: a,
                    labelToScreenMatrix: l,
                    textPixelRatio: c,
                    holdingForFade: u,
                    collisionBoxArray: h,
                    partiallyEvaluatedTextSize: p,
                    partiallyEvaluatedIconSize: d,
                    collisionGroup: f,
                  } = e.parameters,
                  m = o.get("text-optional"),
                  g = o.get("icon-optional"),
                  y = o.get("text-allow-overlap"),
                  _ = o.get("icon-allow-overlap"),
                  v = "map" === o.get("text-rotation-alignment"),
                  b = "map" === o.get("text-pitch-alignment"),
                  x = "none" !== o.get("icon-text-fit"),
                  w = "viewport-y" === o.get("symbol-z-order"),
                  S = y && (_ || !i.hasIconData() || g),
                  E = _ && (y || !i.hasTextData() || m);
                !i.collisionArrays && h && i.deserializeCollisionBoxes(h),
                  r && i.updateCollisionDebugBuffers(this.transform.zoom, h);
                const T = (e, h, w) => {
                  if (n[e.crossTileID]) return;
                  if (u)
                    return void (this.placements[e.crossTileID] = new de(
                      !1,
                      !1,
                      !1
                    ));
                  let T = !1,
                    A = !1,
                    C = !0,
                    P = null,
                    M = { box: null, offscreen: null },
                    O = { box: null, offscreen: null },
                    k = null,
                    I = null,
                    D = null,
                    z = 0,
                    R = 0,
                    L = 0;
                  w.textFeatureIndex
                    ? (z = w.textFeatureIndex)
                    : e.useRuntimeCollisionCircles && (z = e.featureIndex),
                    w.verticalTextFeatureIndex &&
                      (R = w.verticalTextFeatureIndex);
                  const F = (t) => {
                      (t.tileID =
                        this.retainedQueryData[i.bucketInstanceId].tileID),
                        (this.transform.elevation || t.elevation) &&
                          (t.elevation = this.transform.elevation
                            ? this.transform.elevation.getAtTileOffset(
                                this.retainedQueryData[i.bucketInstanceId]
                                  .tileID,
                                t.anchorPointX,
                                t.anchorPointY
                              )
                            : 0);
                    },
                    B = w.textBox;
                  if (B) {
                    F(B);
                    const n = (n) => {
                        let r = t.WritingMode.horizontal;
                        if (
                          i.allowVerticalPlacement &&
                          !n &&
                          this.prevPlacement
                        ) {
                          const t =
                            this.prevPlacement.placedOrientations[
                              e.crossTileID
                            ];
                          t &&
                            ((this.placedOrientations[e.crossTileID] = t),
                            (r = t),
                            this.markUsedOrientation(i, r, e));
                        }
                        return r;
                      },
                      r = (n, r) => {
                        if (
                          i.allowVerticalPlacement &&
                          e.numVerticalGlyphVertices > 0 &&
                          w.verticalTextBox
                        ) {
                          for (const e of i.writingModes)
                            if (
                              (e === t.WritingMode.vertical
                                ? ((M = r()), (O = M))
                                : (M = n()),
                              M && M.box && M.box.length)
                            )
                              break;
                        } else M = n();
                      };
                    if (o.get("text-variable-anchor")) {
                      let a = o.get("text-variable-anchor");
                      if (
                        this.prevPlacement &&
                        this.prevPlacement.variableOffsets[e.crossTileID]
                      ) {
                        const t =
                          this.prevPlacement.variableOffsets[e.crossTileID];
                        a.indexOf(t.anchor) > 0 &&
                          ((a = a.filter((e) => e !== t.anchor)),
                          a.unshift(t.anchor));
                      }
                      const l = (t, n, r) => {
                        const o = i.getSymbolInstanceTextSize(
                            p,
                            e,
                            this.transform.zoom,
                            h
                          ),
                          l = (t.x2 - t.x1) * o + 2 * t.padding,
                          u = (t.y2 - t.y1) * o + 2 * t.padding,
                          m = x && !_ ? n : null;
                        m && F(m);
                        let g = { box: [], offscreen: !1 };
                        const w = y ? 2 * a.length : a.length;
                        for (let y = 0; y < w; ++y) {
                          const n = this.attemptAnchorPlacement(
                            a[y % a.length],
                            t,
                            l,
                            u,
                            o,
                            v,
                            b,
                            c,
                            s,
                            f,
                            y >= a.length,
                            e,
                            h,
                            i,
                            r,
                            m,
                            p,
                            d
                          );
                          if (
                            n &&
                            ((g = n.placedGlyphBoxes),
                            g && g.box && g.box.length)
                          ) {
                            (T = !0), (P = n.shift);
                            break;
                          }
                        }
                        return g;
                      };
                      r(
                        () => l(B, w.iconBox, t.WritingMode.horizontal),
                        () => {
                          const n = w.verticalTextBox;
                          return (
                            n && F(n),
                            i.allowVerticalPlacement &&
                            !(M && M.box && M.box.length) &&
                            e.numVerticalGlyphVertices > 0 &&
                            n
                              ? l(n, w.verticalIconBox, t.WritingMode.vertical)
                              : { box: null, offscreen: null }
                          );
                        }
                      ),
                        M && ((T = M.box), (C = M.offscreen));
                      const u = n(M && M.box);
                      if (!T && this.prevPlacement) {
                        const t =
                          this.prevPlacement.variableOffsets[e.crossTileID];
                        t &&
                          ((this.variableOffsets[e.crossTileID] = t),
                          this.markUsedJustification(i, t.anchor, e, u));
                      }
                    } else {
                      const o = (n, r) => {
                        const o = i.getSymbolInstanceTextSize(
                            p,
                            e,
                            this.transform.zoom,
                            h
                          ),
                          a = this.collisionIndex.placeCollisionBox(
                            o,
                            n,
                            new t.pointGeometry(0, 0),
                            y,
                            c,
                            s,
                            f.predicate
                          );
                        return (
                          a &&
                            a.box &&
                            a.box.length &&
                            (this.markUsedOrientation(i, r, e),
                            (this.placedOrientations[e.crossTileID] = r)),
                          a
                        );
                      };
                      r(
                        () => o(B, t.WritingMode.horizontal),
                        () => {
                          const n = w.verticalTextBox;
                          return i.allowVerticalPlacement &&
                            e.numVerticalGlyphVertices > 0 &&
                            n
                            ? (F(n), o(n, t.WritingMode.vertical))
                            : { box: null, offscreen: null };
                        }
                      ),
                        n(M && M.box && M.box.length);
                    }
                  }
                  if (
                    ((k = M),
                    (T = k && k.box && k.box.length > 0),
                    (C = k && k.offscreen),
                    e.useRuntimeCollisionCircles)
                  ) {
                    const n = i.text.placedSymbolArray.get(
                        e.centerJustifiedTextSymbolIndex >= 0
                          ? e.centerJustifiedTextSymbolIndex
                          : e.verticalPlacedTextSymbolIndex
                      ),
                      c = t.evaluateSizeForFeature(i.textSizeData, p, n),
                      u = o.get("text-padding");
                    (I = this.collisionIndex.placeCollisionCircles(
                      y,
                      n,
                      i.lineVertexArray,
                      i.glyphOffsetArray,
                      c,
                      s,
                      a,
                      l,
                      r,
                      b,
                      f.predicate,
                      e.collisionCircleDiameter,
                      u,
                      this.retainedQueryData[i.bucketInstanceId].tileID
                    )),
                      (T = y || (I.circles.length > 0 && !I.collisionDetected)),
                      (C = C && I.offscreen);
                  }
                  if (
                    (w.iconFeatureIndex && (L = w.iconFeatureIndex), w.iconBox)
                  ) {
                    const e = (e) => {
                      F(e);
                      const n =
                          x && P
                            ? _e(P.x, P.y, v, b, this.transform.angle)
                            : new t.pointGeometry(0, 0),
                        r = i.getSymbolInstanceIconSize(
                          d,
                          this.transform.zoom,
                          h
                        );
                      return this.collisionIndex.placeCollisionBox(
                        r,
                        e,
                        n,
                        _,
                        c,
                        s,
                        f.predicate
                      );
                    };
                    O && O.box && O.box.length && w.verticalIconBox
                      ? ((D = e(w.verticalIconBox)), (A = D.box.length > 0))
                      : ((D = e(w.iconBox)), (A = D.box.length > 0)),
                      (C = C && D.offscreen);
                  }
                  const N =
                      m ||
                      (0 === e.numHorizontalGlyphVertices &&
                        0 === e.numVerticalGlyphVertices),
                    j = g || 0 === e.numIconVertices;
                  if (
                    (N || j
                      ? j
                        ? N || (A = A && T)
                        : (T = A && T)
                      : (A = T = A && T),
                    T &&
                      k &&
                      k.box &&
                      this.collisionIndex.insertCollisionBox(
                        k.box,
                        o.get("text-ignore-placement"),
                        i.bucketInstanceId,
                        O && O.box && R ? R : z,
                        f.ID
                      ),
                    A &&
                      D &&
                      this.collisionIndex.insertCollisionBox(
                        D.box,
                        o.get("icon-ignore-placement"),
                        i.bucketInstanceId,
                        L,
                        f.ID
                      ),
                    I &&
                      (T &&
                        this.collisionIndex.insertCollisionCircles(
                          I.circles,
                          o.get("text-ignore-placement"),
                          i.bucketInstanceId,
                          z,
                          f.ID
                        ),
                      r))
                  ) {
                    const t = i.bucketInstanceId;
                    let e = this.collisionCircleArrays[t];
                    void 0 === e &&
                      (e = this.collisionCircleArrays[t] = new fe());
                    for (let n = 0; n < I.circles.length; n += 4)
                      e.circles.push(I.circles[n + 0]),
                        e.circles.push(I.circles[n + 1]),
                        e.circles.push(I.circles[n + 2]),
                        e.circles.push(I.collisionDetected ? 1 : 0);
                  }
                  (this.placements[e.crossTileID] = new de(
                    T || S,
                    A || E,
                    C || i.justReloaded
                  )),
                    (n[e.crossTileID] = !0);
                };
                if (w) {
                  const t = i.getSortedSymbolIndexes(this.transform.angle);
                  for (let e = t.length - 1; e >= 0; --e) {
                    const n = t[e];
                    T(i.symbolInstances.get(n), n, i.collisionArrays[n]);
                  }
                } else for (let t = e.symbolInstanceStart; t < e.symbolInstanceEnd; t++) T(i.symbolInstances.get(t), t, i.collisionArrays[t]);
                if (r && i.bucketInstanceId in this.collisionCircleArrays) {
                  const e = this.collisionCircleArrays[i.bucketInstanceId];
                  t.invert(e.invProjMatrix, s),
                    (e.viewportMatrix =
                      this.collisionIndex.getViewportMatrix());
                }
                i.justReloaded = !1;
              }
              markUsedJustification(e, n, r, i) {
                let o;
                o =
                  i === t.WritingMode.vertical
                    ? r.verticalPlacedTextSymbolIndex
                    : {
                        left: r.leftJustifiedTextSymbolIndex,
                        center: r.centerJustifiedTextSymbolIndex,
                        right: r.rightJustifiedTextSymbolIndex,
                      }[t.getAnchorJustification(n)];
                const s = [
                  r.leftJustifiedTextSymbolIndex,
                  r.centerJustifiedTextSymbolIndex,
                  r.rightJustifiedTextSymbolIndex,
                  r.verticalPlacedTextSymbolIndex,
                ];
                for (const t of s)
                  t >= 0 &&
                    (e.text.placedSymbolArray.get(t).crossTileID =
                      o >= 0 && t !== o ? 0 : r.crossTileID);
              }
              markUsedOrientation(e, n, r) {
                const i =
                    n === t.WritingMode.horizontal ||
                    n === t.WritingMode.horizontalOnly
                      ? n
                      : 0,
                  o = n === t.WritingMode.vertical ? n : 0,
                  s = [
                    r.leftJustifiedTextSymbolIndex,
                    r.centerJustifiedTextSymbolIndex,
                    r.rightJustifiedTextSymbolIndex,
                  ];
                for (const t of s)
                  e.text.placedSymbolArray.get(t).placedOrientation = i;
                r.verticalPlacedTextSymbolIndex &&
                  (e.text.placedSymbolArray.get(
                    r.verticalPlacedTextSymbolIndex
                  ).placedOrientation = o);
              }
              commit(t) {
                (this.commitTime = t),
                  (this.zoomAtLastRecencyCheck = this.transform.zoom);
                const e = this.prevPlacement;
                let n = !1;
                this.prevZoomAdjustment = e
                  ? e.zoomAdjustment(this.transform.zoom)
                  : 0;
                const r = e ? e.symbolFadeChange(t) : 1,
                  i = e ? e.opacities : {},
                  o = e ? e.variableOffsets : {},
                  s = e ? e.placedOrientations : {};
                for (const a in this.placements) {
                  const t = this.placements[a],
                    e = i[a];
                  e
                    ? ((this.opacities[a] = new pe(e, r, t.text, t.icon)),
                      (n =
                        n ||
                        t.text !== e.text.placed ||
                        t.icon !== e.icon.placed))
                    : ((this.opacities[a] = new pe(
                        null,
                        r,
                        t.text,
                        t.icon,
                        t.skipFade
                      )),
                      (n = n || t.text || t.icon));
                }
                for (const a in i) {
                  const t = i[a];
                  if (!this.opacities[a]) {
                    const e = new pe(t, r, !1, !1);
                    e.isHidden() ||
                      ((this.opacities[a] = e),
                      (n = n || t.text.placed || t.icon.placed));
                  }
                }
                for (const a in o)
                  this.variableOffsets[a] ||
                    !this.opacities[a] ||
                    this.opacities[a].isHidden() ||
                    (this.variableOffsets[a] = o[a]);
                for (const a in s)
                  this.placedOrientations[a] ||
                    !this.opacities[a] ||
                    this.opacities[a].isHidden() ||
                    (this.placedOrientations[a] = s[a]);
                n
                  ? (this.lastPlacementChangeTime = t)
                  : "number" != typeof this.lastPlacementChangeTime &&
                    (this.lastPlacementChangeTime = e
                      ? e.lastPlacementChangeTime
                      : t);
              }
              updateLayerOpacities(t, e) {
                const n = {};
                for (const r of e) {
                  const e = r.getBucket(t);
                  e &&
                    r.latestFeatureIndex &&
                    t.id === e.layerIds[0] &&
                    this.updateBucketOpacities(e, n, r.collisionBoxArray);
                }
              }
              updateBucketOpacities(e, n, r) {
                e.hasTextData() && e.text.opacityVertexArray.clear(),
                  e.hasIconData() && e.icon.opacityVertexArray.clear(),
                  e.hasIconCollisionBoxData() &&
                    e.iconCollisionBox.collisionVertexArray.clear(),
                  e.hasTextCollisionBoxData() &&
                    e.textCollisionBox.collisionVertexArray.clear();
                const i = e.layers[0].layout,
                  o = new pe(null, 0, !1, !1, !0),
                  s = i.get("text-allow-overlap"),
                  a = i.get("icon-allow-overlap"),
                  l = i.get("text-variable-anchor"),
                  c = "map" === i.get("text-rotation-alignment"),
                  u = "map" === i.get("text-pitch-alignment"),
                  h = "none" !== i.get("icon-text-fit"),
                  p = new pe(
                    null,
                    0,
                    s && (a || !e.hasIconData() || i.get("icon-optional")),
                    a && (s || !e.hasTextData() || i.get("text-optional")),
                    !0
                  );
                !e.collisionArrays &&
                  r &&
                  (e.hasIconCollisionBoxData() ||
                    e.hasTextCollisionBoxData()) &&
                  e.deserializeCollisionBoxes(r);
                const d = (t, e, n) => {
                  for (let r = 0; r < e / 4; r++)
                    t.opacityVertexArray.emplaceBack(n);
                };
                for (let f = 0; f < e.symbolInstances.length; f++) {
                  const r = e.symbolInstances.get(f),
                    {
                      numHorizontalGlyphVertices: i,
                      numVerticalGlyphVertices: s,
                      crossTileID: a,
                    } = r;
                  let m = this.opacities[a];
                  n[a] ? (m = o) : m || ((m = p), (this.opacities[a] = m)),
                    (n[a] = !0);
                  const g = r.numIconVertices > 0,
                    y = this.placedOrientations[r.crossTileID],
                    _ = y === t.WritingMode.vertical,
                    v =
                      y === t.WritingMode.horizontal ||
                      y === t.WritingMode.horizontalOnly;
                  if (i > 0 || s > 0) {
                    const t = Pe(m.text);
                    d(e.text, i, _ ? Me : t), d(e.text, s, v ? Me : t);
                    const n = m.text.isHidden();
                    [
                      r.rightJustifiedTextSymbolIndex,
                      r.centerJustifiedTextSymbolIndex,
                      r.leftJustifiedTextSymbolIndex,
                    ].forEach((t) => {
                      t >= 0 &&
                        (e.text.placedSymbolArray.get(t).hidden =
                          n || _ ? 1 : 0);
                    }),
                      r.verticalPlacedTextSymbolIndex >= 0 &&
                        (e.text.placedSymbolArray.get(
                          r.verticalPlacedTextSymbolIndex
                        ).hidden = n || v ? 1 : 0);
                    const o = this.variableOffsets[r.crossTileID];
                    o && this.markUsedJustification(e, o.anchor, r, y);
                    const a = this.placedOrientations[r.crossTileID];
                    a &&
                      (this.markUsedJustification(e, "left", r, a),
                      this.markUsedOrientation(e, a, r));
                  }
                  if (g) {
                    const t = Pe(m.icon);
                    r.placedIconSymbolIndex >= 0 &&
                      (d(e.icon, r.numIconVertices, _ ? Me : t),
                      (e.icon.placedSymbolArray.get(
                        r.placedIconSymbolIndex
                      ).hidden = m.icon.isHidden())),
                      r.verticalPlacedIconSymbolIndex >= 0 &&
                        (d(e.icon, r.numVerticalIconVertices, v ? Me : t),
                        (e.icon.placedSymbolArray.get(
                          r.verticalPlacedIconSymbolIndex
                        ).hidden = m.icon.isHidden()));
                  }
                  if (
                    e.hasIconCollisionBoxData() ||
                    e.hasTextCollisionBoxData()
                  ) {
                    const n = e.collisionArrays[f];
                    if (n) {
                      let r = new t.pointGeometry(0, 0);
                      if (n.textBox || n.verticalTextBox) {
                        let t = !0;
                        if (l) {
                          const e = this.variableOffsets[a];
                          e
                            ? ((r = ye(
                                e.anchor,
                                e.width,
                                e.height,
                                e.textOffset,
                                e.textScale
                              )),
                              c &&
                                r._rotate(
                                  u
                                    ? this.transform.angle
                                    : -this.transform.angle
                                ))
                            : (t = !1);
                        }
                        n.textBox &&
                          be(
                            e.textCollisionBox.collisionVertexArray,
                            m.text.placed,
                            !t || _,
                            r.x,
                            r.y
                          ),
                          n.verticalTextBox &&
                            be(
                              e.textCollisionBox.collisionVertexArray,
                              m.text.placed,
                              !t || v,
                              r.x,
                              r.y
                            );
                      }
                      const i = Boolean(!v && n.verticalIconBox);
                      n.iconBox &&
                        be(
                          e.iconCollisionBox.collisionVertexArray,
                          m.icon.placed,
                          i,
                          h ? r.x : 0,
                          h ? r.y : 0
                        ),
                        n.verticalIconBox &&
                          be(
                            e.iconCollisionBox.collisionVertexArray,
                            m.icon.placed,
                            !i,
                            h ? r.x : 0,
                            h ? r.y : 0
                          );
                    }
                  }
                }
                if (
                  (e.sortFeatures(this.transform.angle),
                  this.retainedQueryData[e.bucketInstanceId] &&
                    (this.retainedQueryData[
                      e.bucketInstanceId
                    ].featureSortOrder = e.featureSortOrder),
                  e.hasTextData() &&
                    e.text.opacityVertexBuffer &&
                    e.text.opacityVertexBuffer.updateData(
                      e.text.opacityVertexArray
                    ),
                  e.hasIconData() &&
                    e.icon.opacityVertexBuffer &&
                    e.icon.opacityVertexBuffer.updateData(
                      e.icon.opacityVertexArray
                    ),
                  e.hasIconCollisionBoxData() &&
                    e.iconCollisionBox.collisionVertexBuffer &&
                    e.iconCollisionBox.collisionVertexBuffer.updateData(
                      e.iconCollisionBox.collisionVertexArray
                    ),
                  e.hasTextCollisionBoxData() &&
                    e.textCollisionBox.collisionVertexBuffer &&
                    e.textCollisionBox.collisionVertexBuffer.updateData(
                      e.textCollisionBox.collisionVertexArray
                    ),
                  e.bucketInstanceId in this.collisionCircleArrays)
                ) {
                  const t = this.collisionCircleArrays[e.bucketInstanceId];
                  (e.placementInvProjMatrix = t.invProjMatrix),
                    (e.placementViewportMatrix = t.viewportMatrix),
                    (e.collisionCircleArray = t.circles),
                    delete this.collisionCircleArrays[e.bucketInstanceId];
                }
              }
              symbolFadeChange(t) {
                return 0 === this.fadeDuration
                  ? 1
                  : (t - this.commitTime) / this.fadeDuration +
                      this.prevZoomAdjustment;
              }
              zoomAdjustment(t) {
                return Math.max(0, (this.transform.zoom - t) / 1.5);
              }
              hasTransitions(t) {
                return (
                  this.stale ||
                  t - this.lastPlacementChangeTime < this.fadeDuration
                );
              }
              stillRecent(t, e) {
                const n =
                  this.zoomAtLastRecencyCheck === e
                    ? 1 - this.zoomAdjustment(e)
                    : 1;
                return (
                  (this.zoomAtLastRecencyCheck = e),
                  this.commitTime + this.fadeDuration * n > t
                );
              }
              setStale() {
                this.stale = !0;
              }
            }
            function be(t, e, n, r, i) {
              t.emplaceBack(e ? 1 : 0, n ? 1 : 0, r || 0, i || 0),
                t.emplaceBack(e ? 1 : 0, n ? 1 : 0, r || 0, i || 0),
                t.emplaceBack(e ? 1 : 0, n ? 1 : 0, r || 0, i || 0),
                t.emplaceBack(e ? 1 : 0, n ? 1 : 0, r || 0, i || 0);
            }
            const xe = Math.pow(2, 25),
              we = Math.pow(2, 24),
              Se = Math.pow(2, 17),
              Ee = Math.pow(2, 16),
              Te = Math.pow(2, 9),
              Ae = Math.pow(2, 8),
              Ce = Math.pow(2, 1);
            function Pe(t) {
              if (0 === t.opacity && !t.placed) return 0;
              if (1 === t.opacity && t.placed) return 4294967295;
              const e = t.placed ? 1 : 0,
                n = Math.floor(127 * t.opacity);
              return (
                n * xe + e * we + n * Se + e * Ee + n * Te + e * Ae + n * Ce + e
              );
            }
            const Me = 0;
            class Oe {
              constructor(t) {
                (this._sortAcrossTiles =
                  "viewport-y" !== t.layout.get("symbol-z-order") &&
                  void 0 !== t.layout.get("symbol-sort-key").constantOr(1)),
                  (this._currentTileIndex = 0),
                  (this._currentPartIndex = 0),
                  (this._seenCrossTileIDs = {}),
                  (this._bucketParts = []);
              }
              continuePlacement(t, e, n, r, i) {
                const o = this._bucketParts;
                for (; this._currentTileIndex < t.length; )
                  if (
                    (e.getBucketParts(
                      o,
                      r,
                      t[this._currentTileIndex],
                      this._sortAcrossTiles
                    ),
                    this._currentTileIndex++,
                    i())
                  )
                    return !0;
                for (
                  this._sortAcrossTiles &&
                  ((this._sortAcrossTiles = !1),
                  o.sort((t, e) => t.sortKey - e.sortKey));
                  this._currentPartIndex < o.length;

                )
                  if (
                    (e.placeLayerBucketPart(
                      o[this._currentPartIndex],
                      this._seenCrossTileIDs,
                      n
                    ),
                    this._currentPartIndex++,
                    i())
                  )
                    return !0;
                return !1;
              }
            }
            class ke {
              constructor(t, e, n, r, i, o, s, a) {
                (this.placement = new ve(t, i, o, s, a)),
                  (this._currentPlacementIndex = e.length - 1),
                  (this._forceFullPlacement = n),
                  (this._showCollisionBoxes = r),
                  (this._done = !1);
              }
              isDone() {
                return this._done;
              }
              continuePlacement(e, n, r) {
                const i = t.exported.now(),
                  o = () => {
                    const e = t.exported.now() - i;
                    return !this._forceFullPlacement && e > 2;
                  };
                for (; this._currentPlacementIndex >= 0; ) {
                  const t = n[e[this._currentPlacementIndex]],
                    i = this.placement.collisionIndex.transform.zoom;
                  if (
                    "symbol" === t.type &&
                    (!t.minzoom || t.minzoom <= i) &&
                    (!t.maxzoom || t.maxzoom > i)
                  ) {
                    if (
                      (this._inProgressLayer ||
                        (this._inProgressLayer = new Oe(t)),
                      this._inProgressLayer.continuePlacement(
                        r[t.source],
                        this.placement,
                        this._showCollisionBoxes,
                        t,
                        o
                      ))
                    )
                      return;
                    delete this._inProgressLayer;
                  }
                  this._currentPlacementIndex--;
                }
                this._done = !0;
              }
              commit(t) {
                return this.placement.commit(t), this.placement;
              }
            }
            const Ie = 512 / t.EXTENT / 2;
            class De {
              constructor(t, e, n) {
                (this.tileID = t),
                  (this.indexedSymbolInstances = {}),
                  (this.bucketInstanceId = n);
                for (let r = 0; r < e.length; r++) {
                  const n = e.get(r),
                    i = n.key;
                  this.indexedSymbolInstances[i] ||
                    (this.indexedSymbolInstances[i] = []),
                    this.indexedSymbolInstances[i].push({
                      crossTileID: n.crossTileID,
                      coord: this.getScaledCoordinates(n, t),
                    });
                }
              }
              getScaledCoordinates(e, n) {
                const r =
                  Ie / Math.pow(2, n.canonical.z - this.tileID.canonical.z);
                return {
                  x: Math.floor((n.canonical.x * t.EXTENT + e.anchorX) * r),
                  y: Math.floor((n.canonical.y * t.EXTENT + e.anchorY) * r),
                };
              }
              findMatches(t, e, n) {
                const r =
                  this.tileID.canonical.z < e.canonical.z
                    ? 1
                    : Math.pow(2, this.tileID.canonical.z - e.canonical.z);
                for (let i = 0; i < t.length; i++) {
                  const o = t.get(i);
                  if (o.crossTileID) continue;
                  const s = this.indexedSymbolInstances[o.key];
                  if (!s) continue;
                  const a = this.getScaledCoordinates(o, e);
                  for (const t of s)
                    if (
                      Math.abs(t.coord.x - a.x) <= r &&
                      Math.abs(t.coord.y - a.y) <= r &&
                      !n[t.crossTileID]
                    ) {
                      (n[t.crossTileID] = !0), (o.crossTileID = t.crossTileID);
                      break;
                    }
                }
              }
            }
            class ze {
              constructor() {
                this.maxCrossTileID = 0;
              }
              generate() {
                return ++this.maxCrossTileID;
              }
            }
            class Re {
              constructor() {
                (this.indexes = {}),
                  (this.usedCrossTileIDs = {}),
                  (this.lng = 0);
              }
              handleWrapJump(t) {
                const e = Math.round((t - this.lng) / 360);
                if (0 !== e)
                  for (const n in this.indexes) {
                    const t = this.indexes[n],
                      r = {};
                    for (const n in t) {
                      const i = t[n];
                      (i.tileID = i.tileID.unwrapTo(i.tileID.wrap + e)),
                        (r[i.tileID.key] = i);
                    }
                    this.indexes[n] = r;
                  }
                this.lng = t;
              }
              addBucket(t, e, n) {
                if (
                  this.indexes[t.overscaledZ] &&
                  this.indexes[t.overscaledZ][t.key]
                ) {
                  if (
                    this.indexes[t.overscaledZ][t.key].bucketInstanceId ===
                    e.bucketInstanceId
                  )
                    return !1;
                  this.removeBucketCrossTileIDs(
                    t.overscaledZ,
                    this.indexes[t.overscaledZ][t.key]
                  );
                }
                for (let i = 0; i < e.symbolInstances.length; i++)
                  e.symbolInstances.get(i).crossTileID = 0;
                this.usedCrossTileIDs[t.overscaledZ] ||
                  (this.usedCrossTileIDs[t.overscaledZ] = {});
                const r = this.usedCrossTileIDs[t.overscaledZ];
                for (const i in this.indexes) {
                  const n = this.indexes[i];
                  if (Number(i) > t.overscaledZ)
                    for (const i in n) {
                      const o = n[i];
                      o.tileID.isChildOf(t) &&
                        o.findMatches(e.symbolInstances, t, r);
                    }
                  else {
                    const o = n[t.scaledTo(Number(i)).key];
                    o && o.findMatches(e.symbolInstances, t, r);
                  }
                }
                for (let i = 0; i < e.symbolInstances.length; i++) {
                  const t = e.symbolInstances.get(i);
                  t.crossTileID ||
                    ((t.crossTileID = n.generate()), (r[t.crossTileID] = !0));
                }
                return (
                  void 0 === this.indexes[t.overscaledZ] &&
                    (this.indexes[t.overscaledZ] = {}),
                  (this.indexes[t.overscaledZ][t.key] = new De(
                    t,
                    e.symbolInstances,
                    e.bucketInstanceId
                  )),
                  !0
                );
              }
              removeBucketCrossTileIDs(t, e) {
                for (const n in e.indexedSymbolInstances)
                  for (const r of e.indexedSymbolInstances[n])
                    delete this.usedCrossTileIDs[t][r.crossTileID];
              }
              removeStaleBuckets(t) {
                let e = !1;
                for (const n in this.indexes) {
                  const r = this.indexes[n];
                  for (const i in r)
                    t[r[i].bucketInstanceId] ||
                      (this.removeBucketCrossTileIDs(n, r[i]),
                      delete r[i],
                      (e = !0));
                }
                return e;
              }
            }
            class Le {
              constructor() {
                (this.layerIndexes = {}),
                  (this.crossTileIDs = new ze()),
                  (this.maxBucketInstanceId = 0),
                  (this.bucketsInCurrentPlacement = {});
              }
              addLayer(t, e, n) {
                let r = this.layerIndexes[t.id];
                void 0 === r && (r = this.layerIndexes[t.id] = new Re());
                let i = !1;
                const o = {};
                r.handleWrapJump(n);
                for (const s of e) {
                  const e = s.getBucket(t);
                  e &&
                    t.id === e.layerIds[0] &&
                    (e.bucketInstanceId ||
                      (e.bucketInstanceId = ++this.maxBucketInstanceId),
                    r.addBucket(s.tileID, e, this.crossTileIDs) && (i = !0),
                    (o[e.bucketInstanceId] = !0));
                }
                return r.removeStaleBuckets(o) && (i = !0), i;
              }
              pruneUnusedLayers(t) {
                const e = {};
                t.forEach((t) => {
                  e[t] = !0;
                });
                for (const n in this.layerIndexes)
                  e[n] || delete this.layerIndexes[n];
              }
            }
            const Fe = (e, n) =>
                t.emitValidationErrors(
                  e,
                  n && n.filter((t) => "source.canvas" !== t.identifier)
                ),
              Be = t.pick(Bt, [
                "addLayer",
                "removeLayer",
                "setPaintProperty",
                "setLayoutProperty",
                "setFilter",
                "addSource",
                "removeSource",
                "setLayerZoomRange",
                "setLight",
                "setTransition",
                "setGeoJSONSourceData",
                "setTerrain",
                "setFog",
              ]),
              Ne = t.pick(Bt, [
                "setCenter",
                "setZoom",
                "setBearing",
                "setPitch",
              ]),
              je = (function () {
                const e = {},
                  n = t.spec.$version;
                for (const r in t.spec.$root) {
                  const i = t.spec.$root[r];
                  if (i.required) {
                    let t = null;
                    (t = "version" === r ? n : "array" === i.type ? [] : {}),
                      null != t && (e[r] = t);
                  }
                }
                return e;
              })(),
              Ue = {
                fill: !0,
                line: !0,
                background: !0,
                hillshade: !0,
                raster: !0,
              };
            class Ze extends t.Evented {
              constructor(e, n = {}) {
                super(),
                  (this.map = e),
                  (this.dispatcher = new P(Rt(), this)),
                  (this.imageManager = new g()),
                  this.imageManager.setEventedParent(this),
                  (this.glyphManager = new t.GlyphManager(
                    e._requestManager,
                    n.localFontFamily
                      ? t.LocalGlyphMode.all
                      : n.localIdeographFontFamily
                      ? t.LocalGlyphMode.ideographs
                      : t.LocalGlyphMode.none,
                    n.localFontFamily || n.localIdeographFontFamily
                  )),
                  (this.lineAtlas = new t.LineAtlas(256, 512)),
                  (this.crossTileSymbolIndex = new Le()),
                  (this._layers = {}),
                  (this._num3DLayers = 0),
                  (this._numSymbolLayers = 0),
                  (this._numCircleLayers = 0),
                  (this._serializedLayers = {}),
                  (this._sourceCaches = {}),
                  (this._otherSourceCaches = {}),
                  (this._symbolSourceCaches = {}),
                  (this.zoomHistory = new t.ZoomHistory()),
                  (this._loaded = !1),
                  (this._availableImages = []),
                  (this._order = []),
                  (this._drapedFirstOrder = []),
                  (this._markersNeedUpdate = !1),
                  this._resetUpdates(),
                  this.dispatcher.broadcast("setReferrer", t.getReferrer());
                const r = this;
                (this._rtlTextPluginCallback = Ze.registerForPluginStateChange(
                  (e) => {
                    r.dispatcher.broadcast(
                      "syncRTLPluginState",
                      { pluginStatus: e.pluginStatus, pluginURL: e.pluginURL },
                      (e, n) => {
                        if (
                          (t.triggerPluginCompletionEvent(e),
                          n && n.every((t) => t))
                        )
                          for (const t in r._sourceCaches) {
                            const e = r._sourceCaches[t],
                              n = e.getSource().type;
                            ("vector" !== n && "geojson" !== n) || e.reload();
                          }
                      }
                    );
                  }
                )),
                  this.on("data", (t) => {
                    if (
                      "source" !== t.dataType ||
                      "metadata" !== t.sourceDataType
                    )
                      return;
                    const e = this.getSource(t.sourceId);
                    if (e && e.vectorLayerIds)
                      for (const n in this._layers) {
                        const t = this._layers[n];
                        t.source === e.id && this._validateLayer(t);
                      }
                  });
              }
              loadURL(e, n = {}) {
                this.fire(new t.Event("dataloading", { dataType: "style" }));
                const r =
                  "boolean" == typeof n.validate
                    ? n.validate
                    : !t.isMapboxURL(e);
                e = this.map._requestManager.normalizeStyleURL(
                  e,
                  n.accessToken
                );
                const i = this.map._requestManager.transformRequest(
                  e,
                  t.ResourceType.Style
                );
                this._request = t.getJSON(i, (e, n) => {
                  (this._request = null),
                    e ? this.fire(new t.ErrorEvent(e)) : n && this._load(n, r);
                });
              }
              loadJSON(e, n = {}) {
                this.fire(new t.Event("dataloading", { dataType: "style" })),
                  (this._request = t.exported.frame(() => {
                    (this._request = null), this._load(e, !1 !== n.validate);
                  }));
              }
              loadEmpty() {
                this.fire(new t.Event("dataloading", { dataType: "style" })),
                  this._load(je, !1);
              }
              _updateLayerCount(t, e) {
                const n = e ? 1 : -1;
                t.is3D() && (this._num3DLayers += n),
                  "circle" === t.type && (this._numCircleLayers += n),
                  "symbol" === t.type && (this._numSymbolLayers += n);
              }
              _load(e, n) {
                if (n && Fe(this, t.validateStyle(e))) return;
                (this._loaded = !0), (this.stylesheet = e);
                for (const t in e.sources)
                  this.addSource(t, e.sources[t], { validate: !1 });
                (this._changed = !1),
                  e.sprite
                    ? this._loadSprite(e.sprite)
                    : (this.imageManager.setLoaded(!0),
                      this.dispatcher.broadcast("spriteLoaded", !0)),
                  this.glyphManager.setURL(e.glyphs);
                const r = Ft(this.stylesheet.layers);
                (this._order = r.map((t) => t.id)),
                  (this._layers = {}),
                  (this._serializedLayers = {});
                for (let i of r)
                  (i = t.createStyleLayer(i)),
                    i.setEventedParent(this, { layer: { id: i.id } }),
                    (this._layers[i.id] = i),
                    (this._serializedLayers[i.id] = i.serialize()),
                    this._updateLayerCount(i, !0);
                this.dispatcher.broadcast(
                  "setLayers",
                  this._serializeLayers(this._order)
                ),
                  (this.light = new v(this.stylesheet.light)),
                  this.stylesheet.terrain &&
                    this._createTerrain(this.stylesheet.terrain),
                  this.stylesheet.fog && this._createFog(this.stylesheet.fog),
                  this._updateDrapeFirstLayers(),
                  this.fire(new t.Event("data", { dataType: "style" })),
                  this.fire(new t.Event("style.load"));
              }
              _loadSprite(e) {
                this._spriteRequest = (function (e, n, r) {
                  let i, o, s;
                  const a = t.exported.devicePixelRatio > 1 ? "@2x" : "";
                  let l = t.getJSON(
                      n.transformRequest(
                        n.normalizeSpriteURL(e, a, ".json"),
                        t.ResourceType.SpriteJSON
                      ),
                      (t, e) => {
                        (l = null), s || ((s = t), (i = e), u());
                      }
                    ),
                    c = t.getImage(
                      n.transformRequest(
                        n.normalizeSpriteURL(e, a, ".png"),
                        t.ResourceType.SpriteImage
                      ),
                      (t, e) => {
                        (c = null), s || ((s = t), (o = e), u());
                      }
                    );
                  function u() {
                    if (s) r(s);
                    else if (i && o) {
                      const e = t.exported.getImageData(o),
                        n = {};
                      for (const r in i) {
                        const {
                            width: o,
                            height: s,
                            x: a,
                            y: l,
                            sdf: c,
                            pixelRatio: u,
                            stretchX: h,
                            stretchY: p,
                            content: d,
                          } = i[r],
                          f = new t.RGBAImage({ width: o, height: s });
                        t.RGBAImage.copy(
                          e,
                          f,
                          { x: a, y: l },
                          { x: 0, y: 0 },
                          { width: o, height: s }
                        ),
                          (n[r] = {
                            data: f,
                            pixelRatio: u,
                            sdf: c,
                            stretchX: h,
                            stretchY: p,
                            content: d,
                          });
                      }
                      r(null, n);
                    }
                  }
                  return {
                    cancel() {
                      l && (l.cancel(), (l = null)),
                        c && (c.cancel(), (c = null));
                    },
                  };
                })(e, this.map._requestManager, (e, n) => {
                  if (((this._spriteRequest = null), e))
                    this.fire(new t.ErrorEvent(e));
                  else if (n)
                    for (const t in n) this.imageManager.addImage(t, n[t]);
                  this.imageManager.setLoaded(!0),
                    (this._availableImages = this.imageManager.listImages()),
                    this.dispatcher.broadcast(
                      "setImages",
                      this._availableImages
                    ),
                    this.dispatcher.broadcast("spriteLoaded", !0),
                    this.fire(new t.Event("data", { dataType: "style" }));
                });
              }
              _validateLayer(e) {
                const n = this.getSource(e.source);
                if (!n) return;
                const r = e.sourceLayer;
                r &&
                  ("geojson" === n.type ||
                    (n.vectorLayerIds && -1 === n.vectorLayerIds.indexOf(r))) &&
                  this.fire(
                    new t.ErrorEvent(
                      new Error(
                        `Source layer "${r}" does not exist on source "${n.id}" as specified by style layer "${e.id}"`
                      )
                    )
                  );
              }
              loaded() {
                if (!this._loaded) return !1;
                if (Object.keys(this._updatedSources).length) return !1;
                for (const t in this._sourceCaches)
                  if (!this._sourceCaches[t].loaded()) return !1;
                return !!this.imageManager.isLoaded();
              }
              _serializeLayers(t) {
                const e = [];
                for (const n of t) {
                  const t = this._layers[n];
                  "custom" !== t.type && e.push(t.serialize());
                }
                return e;
              }
              hasTransitions() {
                if (this.light && this.light.hasTransition()) return !0;
                if (this.fog && this.fog.hasTransition()) return !0;
                for (const t in this._sourceCaches)
                  if (this._sourceCaches[t].hasTransition()) return !0;
                for (const t in this._layers)
                  if (this._layers[t].hasTransition()) return !0;
                return !1;
              }
              get order() {
                return this.map._optimizeForTerrain && this.terrain
                  ? this._drapedFirstOrder
                  : this._order;
              }
              isLayerDraped(t) {
                return !!this.terrain && Ue[t.type];
              }
              _checkLoaded() {
                if (!this._loaded) throw new Error("Style is not done loading");
              }
              update(e) {
                if (!this._loaded) return;
                const n = this._changed;
                if (this._changed) {
                  const t = Object.keys(this._updatedLayers),
                    n = Object.keys(this._removedLayers);
                  (t.length || n.length) && this._updateWorkerLayers(t, n);
                  for (const e in this._updatedSources) {
                    const t = this._updatedSources[e];
                    "reload" === t
                      ? this._reloadSource(e)
                      : "clear" === t && this._clearSource(e);
                  }
                  this._updateTilesForChangedImages();
                  for (const r in this._updatedPaintProps)
                    this._layers[r].updateTransitions(e);
                  this.light.updateTransitions(e),
                    this.fog && this.fog.updateTransitions(e),
                    this._resetUpdates();
                }
                const r = {};
                for (const t in this._sourceCaches) {
                  const e = this._sourceCaches[t];
                  (r[t] = e.used), (e.used = !1);
                }
                for (const t of this._order) {
                  const n = this._layers[t];
                  if (
                    (n.recalculate(e, this._availableImages),
                    !n.isHidden(e.zoom))
                  ) {
                    const t = this._getLayerSourceCache(n);
                    t && (t.used = !0);
                  }
                  const r = this.map.painter;
                  if (r) {
                    const t = n.getProgramIds();
                    if (!t) continue;
                    const i = n.getProgramConfiguration(e.zoom);
                    for (const e of t) r.useProgram(e, i);
                  }
                }
                for (const i in r) {
                  const e = this._sourceCaches[i];
                  r[i] !== e.used &&
                    e
                      .getSource()
                      .fire(
                        new t.Event("data", {
                          sourceDataType: "visibility",
                          dataType: "source",
                          sourceId: e.getSource().id,
                        })
                      );
                }
                this.light.recalculate(e),
                  this.terrain && this.terrain.recalculate(e),
                  this.fog && this.fog.recalculate(e),
                  (this.z = e.zoom),
                  this._markersNeedUpdate &&
                    (this._updateMarkersOpacity(),
                    (this._markersNeedUpdate = !1)),
                  n && this.fire(new t.Event("data", { dataType: "style" }));
              }
              _updateTilesForChangedImages() {
                const t = Object.keys(this._changedImages);
                if (t.length) {
                  for (const e in this._sourceCaches)
                    this._sourceCaches[e].reloadTilesForDependencies(
                      ["icons", "patterns"],
                      t
                    );
                  this._changedImages = {};
                }
              }
              _updateWorkerLayers(t, e) {
                this.dispatcher.broadcast("updateLayers", {
                  layers: this._serializeLayers(t),
                  removedIds: e,
                });
              }
              _resetUpdates() {
                (this._changed = !1),
                  (this._updatedLayers = {}),
                  (this._removedLayers = {}),
                  (this._updatedSources = {}),
                  (this._updatedPaintProps = {}),
                  (this._changedImages = {});
              }
              setState(e) {
                if ((this._checkLoaded(), Fe(this, t.validateStyle(e))))
                  return !1;
                (e = t.clone$2(e)).layers = Ft(e.layers);
                const n = (function (t, e) {
                  if (!t) return [{ command: Bt.setStyle, args: [e] }];
                  let n = [];
                  try {
                    if (!i(t.version, e.version))
                      return [{ command: Bt.setStyle, args: [e] }];
                    i(t.center, e.center) ||
                      n.push({ command: Bt.setCenter, args: [e.center] }),
                      i(t.zoom, e.zoom) ||
                        n.push({ command: Bt.setZoom, args: [e.zoom] }),
                      i(t.bearing, e.bearing) ||
                        n.push({ command: Bt.setBearing, args: [e.bearing] }),
                      i(t.pitch, e.pitch) ||
                        n.push({ command: Bt.setPitch, args: [e.pitch] }),
                      i(t.sprite, e.sprite) ||
                        n.push({ command: Bt.setSprite, args: [e.sprite] }),
                      i(t.glyphs, e.glyphs) ||
                        n.push({ command: Bt.setGlyphs, args: [e.glyphs] }),
                      i(t.transition, e.transition) ||
                        n.push({
                          command: Bt.setTransition,
                          args: [e.transition],
                        }),
                      i(t.light, e.light) ||
                        n.push({ command: Bt.setLight, args: [e.light] }),
                      i(t.fog, e.fog) ||
                        n.push({ command: Bt.setFog, args: [e.fog] });
                    const r = {},
                      o = [];
                    !(function (t, e, n, r) {
                      let o;
                      for (o in ((e = e || {}), (t = t || {})))
                        t.hasOwnProperty(o) &&
                          (e.hasOwnProperty(o) || jt(o, n, r));
                      for (o in e)
                        e.hasOwnProperty(o) &&
                          (t.hasOwnProperty(o)
                            ? i(t[o], e[o]) ||
                              ("geojson" === t[o].type &&
                              "geojson" === e[o].type &&
                              Zt(t, e, o)
                                ? n.push({
                                    command: Bt.setGeoJSONSourceData,
                                    args: [o, e[o].data],
                                  })
                                : Ut(o, e, n, r))
                            : Nt(o, e, n));
                    })(t.sources, e.sources, o, r);
                    const s = [];
                    t.layers &&
                      t.layers.forEach((t) => {
                        r[t.source]
                          ? n.push({ command: Bt.removeLayer, args: [t.id] })
                          : s.push(t);
                      });
                    let a = t.terrain;
                    a &&
                      r[a.source] &&
                      (n.push({ command: Bt.setTerrain, args: [void 0] }),
                      (a = void 0)),
                      (n = n.concat(o)),
                      i(a, e.terrain) ||
                        n.push({ command: Bt.setTerrain, args: [e.terrain] }),
                      (function (t, e, n) {
                        e = e || [];
                        const r = (t = t || []).map(qt),
                          o = e.map(qt),
                          s = t.reduce($t, {}),
                          a = e.reduce($t, {}),
                          l = r.slice(),
                          c = Object.create(null);
                        let u, h, p, d, f, m, g;
                        for (u = 0, h = 0; u < r.length; u++)
                          (p = r[u]),
                            a.hasOwnProperty(p)
                              ? h++
                              : (n.push({ command: Bt.removeLayer, args: [p] }),
                                l.splice(l.indexOf(p, h), 1));
                        for (u = 0, h = 0; u < o.length; u++)
                          (p = o[o.length - 1 - u]),
                            l[l.length - 1 - u] !== p &&
                              (s.hasOwnProperty(p)
                                ? (n.push({
                                    command: Bt.removeLayer,
                                    args: [p],
                                  }),
                                  l.splice(l.lastIndexOf(p, l.length - h), 1))
                                : h++,
                              (m = l[l.length - u]),
                              n.push({ command: Bt.addLayer, args: [a[p], m] }),
                              l.splice(l.length - u, 0, p),
                              (c[p] = !0));
                        for (u = 0; u < o.length; u++)
                          if (
                            ((p = o[u]),
                            (d = s[p]),
                            (f = a[p]),
                            !c[p] && !i(d, f))
                          )
                            if (
                              i(d.source, f.source) &&
                              i(d["source-layer"], f["source-layer"]) &&
                              i(d.type, f.type)
                            ) {
                              for (g in (Vt(
                                d.layout,
                                f.layout,
                                n,
                                p,
                                null,
                                Bt.setLayoutProperty
                              ),
                              Vt(
                                d.paint,
                                f.paint,
                                n,
                                p,
                                null,
                                Bt.setPaintProperty
                              ),
                              i(d.filter, f.filter) ||
                                n.push({
                                  command: Bt.setFilter,
                                  args: [p, f.filter],
                                }),
                              (i(d.minzoom, f.minzoom) &&
                                i(d.maxzoom, f.maxzoom)) ||
                                n.push({
                                  command: Bt.setLayerZoomRange,
                                  args: [p, f.minzoom, f.maxzoom],
                                }),
                              d))
                                d.hasOwnProperty(g) &&
                                  "layout" !== g &&
                                  "paint" !== g &&
                                  "filter" !== g &&
                                  "metadata" !== g &&
                                  "minzoom" !== g &&
                                  "maxzoom" !== g &&
                                  (0 === g.indexOf("paint.")
                                    ? Vt(
                                        d[g],
                                        f[g],
                                        n,
                                        p,
                                        g.slice(6),
                                        Bt.setPaintProperty
                                      )
                                    : i(d[g], f[g]) ||
                                      n.push({
                                        command: Bt.setLayerProperty,
                                        args: [p, g, f[g]],
                                      }));
                              for (g in f)
                                f.hasOwnProperty(g) &&
                                  !d.hasOwnProperty(g) &&
                                  "layout" !== g &&
                                  "paint" !== g &&
                                  "filter" !== g &&
                                  "metadata" !== g &&
                                  "minzoom" !== g &&
                                  "maxzoom" !== g &&
                                  (0 === g.indexOf("paint.")
                                    ? Vt(
                                        d[g],
                                        f[g],
                                        n,
                                        p,
                                        g.slice(6),
                                        Bt.setPaintProperty
                                      )
                                    : i(d[g], f[g]) ||
                                      n.push({
                                        command: Bt.setLayerProperty,
                                        args: [p, g, f[g]],
                                      }));
                            } else
                              n.push({ command: Bt.removeLayer, args: [p] }),
                                (m = l[l.lastIndexOf(p) + 1]),
                                n.push({ command: Bt.addLayer, args: [f, m] });
                      })(s, e.layers, n);
                  } catch (t) {
                    console.warn("Unable to compute style diff:", t),
                      (n = [{ command: Bt.setStyle, args: [e] }]);
                  }
                  return n;
                })(this.serialize(), e).filter((t) => !(t.command in Ne));
                if (0 === n.length) return !1;
                const r = n.filter((t) => !(t.command in Be));
                if (r.length > 0)
                  throw new Error(
                    `Unimplemented: ${r.map((t) => t.command).join(", ")}.`
                  );
                return (
                  n.forEach((t) => {
                    "setTransition" !== t.command &&
                      this[t.command].apply(this, t.args);
                  }),
                  (this.stylesheet = e),
                  !0
                );
              }
              addImage(e, n) {
                if (this.getImage(e))
                  return this.fire(
                    new t.ErrorEvent(
                      new Error("An image with this name already exists.")
                    )
                  );
                this.imageManager.addImage(e, n), this._afterImageUpdated(e);
              }
              updateImage(t, e) {
                this.imageManager.updateImage(t, e);
              }
              getImage(t) {
                return this.imageManager.getImage(t);
              }
              removeImage(e) {
                if (!this.getImage(e))
                  return this.fire(
                    new t.ErrorEvent(
                      new Error("No image with this name exists.")
                    )
                  );
                this.imageManager.removeImage(e), this._afterImageUpdated(e);
              }
              _afterImageUpdated(e) {
                (this._availableImages = this.imageManager.listImages()),
                  (this._changedImages[e] = !0),
                  (this._changed = !0),
                  this.dispatcher.broadcast("setImages", this._availableImages),
                  this.fire(new t.Event("data", { dataType: "style" }));
              }
              listImages() {
                return this._checkLoaded(), this.imageManager.listImages();
              }
              addSource(e, n, r = {}) {
                if ((this._checkLoaded(), void 0 !== this.getSource(e)))
                  throw new Error("There is already a source with this ID");
                if (!n.type)
                  throw new Error(
                    `The type property must be defined, but only the following properties were given: ${Object.keys(
                      n
                    ).join(", ")}.`
                  );
                if (
                  ["vector", "raster", "geojson", "video", "image"].indexOf(
                    n.type
                  ) >= 0 &&
                  this._validate(
                    t.validateStyle.source,
                    `sources.${e}`,
                    n,
                    null,
                    r
                  )
                )
                  return;
                this.map &&
                  this.map._collectResourceTiming &&
                  (n.collectResourceTiming = !0);
                const i = At(e, n, this.dispatcher, this);
                i.setEventedParent(this, () => ({
                  isSourceLoaded: this.loaded(),
                  source: i.serialize(),
                  sourceId: e,
                }));
                const o = (n) => {
                  const r = (n ? "symbol:" : "other:") + e,
                    o = (this._sourceCaches[r] = new t.SourceCache(r, i, n));
                  ((n ? this._symbolSourceCaches : this._otherSourceCaches)[e] =
                    o),
                    (o.style = this),
                    o.onAdd(this.map);
                };
                o(!1),
                  ("vector" !== n.type && "geojson" !== n.type) || o(!0),
                  i.onAdd && i.onAdd(this.map),
                  (this._changed = !0);
              }
              removeSource(e) {
                this._checkLoaded();
                const n = this.getSource(e);
                if (void 0 === n)
                  throw new Error("There is no source with this ID");
                for (const i in this._layers)
                  if (this._layers[i].source === e)
                    return this.fire(
                      new t.ErrorEvent(
                        new Error(
                          `Source "${e}" cannot be removed while layer "${i}" is using it.`
                        )
                      )
                    );
                if (this.terrain && this.terrain.get().source === e)
                  return this.fire(
                    new t.ErrorEvent(
                      new Error(
                        `Source "${e}" cannot be removed while terrain is using it.`
                      )
                    )
                  );
                const r = this._getSourceCaches(e);
                for (const i of r)
                  delete this._sourceCaches[i.id],
                    delete this._updatedSources[i.id],
                    i.fire(
                      new t.Event("data", {
                        sourceDataType: "metadata",
                        dataType: "source",
                        sourceId: i.getSource().id,
                      })
                    ),
                    i.setEventedParent(null),
                    i.clearTiles();
                delete this._otherSourceCaches[e],
                  delete this._symbolSourceCaches[e],
                  n.setEventedParent(null),
                  n.onRemove && n.onRemove(this.map),
                  (this._changed = !0);
              }
              setGeoJSONSourceData(t, e) {
                this._checkLoaded(),
                  this.getSource(t).setData(e),
                  (this._changed = !0);
              }
              getSource(t) {
                const e = this._getSourceCache(t);
                return e && e.getSource();
              }
              addLayer(e, n, r = {}) {
                this._checkLoaded();
                const i = e.id;
                if (this.getLayer(i))
                  return void this.fire(
                    new t.ErrorEvent(
                      new Error(
                        `Layer with id "${i}" already exists on this map`
                      )
                    )
                  );
                let o;
                if ("custom" === e.type) {
                  if (Fe(this, t.validateCustomStyleLayer(e))) return;
                  o = t.createStyleLayer(e);
                } else {
                  if (
                    ("object" == typeof e.source &&
                      (this.addSource(i, e.source),
                      (e = t.clone$2(e)),
                      (e = t.extend(e, { source: i }))),
                    this._validate(
                      t.validateStyle.layer,
                      `layers.${i}`,
                      e,
                      { arrayIndex: -1 },
                      r
                    ))
                  )
                    return;
                  (o = t.createStyleLayer(e)),
                    this._validateLayer(o),
                    o.setEventedParent(this, { layer: { id: i } }),
                    (this._serializedLayers[o.id] = o.serialize()),
                    this._updateLayerCount(o, !0);
                }
                const s = n ? this._order.indexOf(n) : this._order.length;
                if (n && -1 === s)
                  return void this.fire(
                    new t.ErrorEvent(
                      new Error(
                        `Layer with id "${n}" does not exist on this map.`
                      )
                    )
                  );
                this._order.splice(s, 0, i),
                  (this._layerOrderChanged = !0),
                  (this._layers[i] = o);
                const a = this._getLayerSourceCache(o);
                if (
                  this._removedLayers[i] &&
                  o.source &&
                  a &&
                  "custom" !== o.type
                ) {
                  const t = this._removedLayers[i];
                  delete this._removedLayers[i],
                    t.type !== o.type
                      ? (this._updatedSources[o.source] = "clear")
                      : ((this._updatedSources[o.source] = "reload"),
                        a.pause());
                }
                this._updateLayer(o),
                  o.onAdd && o.onAdd(this.map),
                  this._updateDrapeFirstLayers();
              }
              moveLayer(e, n) {
                if (
                  (this._checkLoaded(), (this._changed = !0), !this._layers[e])
                )
                  return void this.fire(
                    new t.ErrorEvent(
                      new Error(
                        `The layer '${e}' does not exist in the map's style and cannot be moved.`
                      )
                    )
                  );
                if (e === n) return;
                const r = this._order.indexOf(e);
                this._order.splice(r, 1);
                const i = n ? this._order.indexOf(n) : this._order.length;
                n && -1 === i
                  ? this.fire(
                      new t.ErrorEvent(
                        new Error(
                          `Layer with id "${n}" does not exist on this map.`
                        )
                      )
                    )
                  : (this._order.splice(i, 0, e),
                    (this._layerOrderChanged = !0),
                    this._updateDrapeFirstLayers());
              }
              removeLayer(e) {
                this._checkLoaded();
                const n = this._layers[e];
                if (!n)
                  return void this.fire(
                    new t.ErrorEvent(
                      new Error(
                        `The layer '${e}' does not exist in the map's style and cannot be removed.`
                      )
                    )
                  );
                n.setEventedParent(null), this._updateLayerCount(n, !1);
                const r = this._order.indexOf(e);
                this._order.splice(r, 1),
                  (this._layerOrderChanged = !0),
                  (this._changed = !0),
                  (this._removedLayers[e] = n),
                  delete this._layers[e],
                  delete this._serializedLayers[e],
                  delete this._updatedLayers[e],
                  delete this._updatedPaintProps[e],
                  n.onRemove && n.onRemove(this.map),
                  this._updateDrapeFirstLayers();
              }
              getLayer(t) {
                return this._layers[t];
              }
              hasLayer(t) {
                return t in this._layers;
              }
              hasLayerType(t) {
                for (const e in this._layers)
                  if (this._layers[e].type === t) return !0;
                return !1;
              }
              setLayerZoomRange(e, n, r) {
                this._checkLoaded();
                const i = this.getLayer(e);
                i
                  ? (i.minzoom === n && i.maxzoom === r) ||
                    (null != n && (i.minzoom = n),
                    null != r && (i.maxzoom = r),
                    this._updateLayer(i))
                  : this.fire(
                      new t.ErrorEvent(
                        new Error(
                          `The layer '${e}' does not exist in the map's style and cannot have zoom extent.`
                        )
                      )
                    );
              }
              setFilter(e, n, r = {}) {
                this._checkLoaded();
                const o = this.getLayer(e);
                if (o) {
                  if (!i(o.filter, n))
                    return null == n
                      ? ((o.filter = void 0), void this._updateLayer(o))
                      : void (
                          this._validate(
                            t.validateStyle.filter,
                            `layers.${o.id}.filter`,
                            n,
                            null,
                            r
                          ) || ((o.filter = t.clone$2(n)), this._updateLayer(o))
                        );
                } else this.fire(new t.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style and cannot be filtered.`)));
              }
              getFilter(e) {
                return t.clone$2(this.getLayer(e).filter);
              }
              setLayoutProperty(e, n, r, o = {}) {
                this._checkLoaded();
                const s = this.getLayer(e);
                s
                  ? i(s.getLayoutProperty(n), r) ||
                    (s.setLayoutProperty(n, r, o), this._updateLayer(s))
                  : this.fire(
                      new t.ErrorEvent(
                        new Error(
                          `The layer '${e}' does not exist in the map's style and cannot be styled.`
                        )
                      )
                    );
              }
              getLayoutProperty(e, n) {
                const r = this.getLayer(e);
                if (r) return r.getLayoutProperty(n);
                this.fire(
                  new t.ErrorEvent(
                    new Error(
                      `The layer '${e}' does not exist in the map's style.`
                    )
                  )
                );
              }
              setPaintProperty(e, n, r, o = {}) {
                this._checkLoaded();
                const s = this.getLayer(e);
                s
                  ? i(s.getPaintProperty(n), r) ||
                    (s.setPaintProperty(n, r, o) && this._updateLayer(s),
                    (this._changed = !0),
                    (this._updatedPaintProps[e] = !0))
                  : this.fire(
                      new t.ErrorEvent(
                        new Error(
                          `The layer '${e}' does not exist in the map's style and cannot be styled.`
                        )
                      )
                    );
              }
              getPaintProperty(t, e) {
                return this.getLayer(t).getPaintProperty(e);
              }
              setFeatureState(e, n) {
                this._checkLoaded();
                const r = e.source,
                  i = e.sourceLayer,
                  o = this.getSource(r);
                if (void 0 === o)
                  return void this.fire(
                    new t.ErrorEvent(
                      new Error(
                        `The source '${r}' does not exist in the map's style.`
                      )
                    )
                  );
                const s = o.type;
                if ("geojson" === s && i)
                  return void this.fire(
                    new t.ErrorEvent(
                      new Error(
                        "GeoJSON sources cannot have a sourceLayer parameter."
                      )
                    )
                  );
                if ("vector" === s && !i)
                  return void this.fire(
                    new t.ErrorEvent(
                      new Error(
                        "The sourceLayer parameter must be provided for vector source types."
                      )
                    )
                  );
                void 0 === e.id &&
                  this.fire(
                    new t.ErrorEvent(
                      new Error("The feature id parameter must be provided.")
                    )
                  );
                const a = this._getSourceCaches(r);
                for (const t of a) t.setFeatureState(i, e.id, n);
              }
              removeFeatureState(e, n) {
                this._checkLoaded();
                const r = e.source,
                  i = this.getSource(r);
                if (void 0 === i)
                  return void this.fire(
                    new t.ErrorEvent(
                      new Error(
                        `The source '${r}' does not exist in the map's style.`
                      )
                    )
                  );
                const o = i.type,
                  s = "vector" === o ? e.sourceLayer : void 0;
                if ("vector" === o && !s)
                  return void this.fire(
                    new t.ErrorEvent(
                      new Error(
                        "The sourceLayer parameter must be provided for vector source types."
                      )
                    )
                  );
                if (n && "string" != typeof e.id && "number" != typeof e.id)
                  return void this.fire(
                    new t.ErrorEvent(
                      new Error(
                        "A feature id is required to remove its specific state property."
                      )
                    )
                  );
                const a = this._getSourceCaches(r);
                for (const t of a) t.removeFeatureState(s, e.id, n);
              }
              getFeatureState(e) {
                this._checkLoaded();
                const n = e.source,
                  r = e.sourceLayer,
                  i = this.getSource(n);
                if (void 0 !== i) {
                  if ("vector" !== i.type || r)
                    return (
                      void 0 === e.id &&
                        this.fire(
                          new t.ErrorEvent(
                            new Error(
                              "The feature id parameter must be provided."
                            )
                          )
                        ),
                      this._getSourceCaches(n)[0].getFeatureState(r, e.id)
                    );
                  this.fire(
                    new t.ErrorEvent(
                      new Error(
                        "The sourceLayer parameter must be provided for vector source types."
                      )
                    )
                  );
                } else this.fire(new t.ErrorEvent(new Error(`The source '${n}' does not exist in the map's style.`)));
              }
              getTransition() {
                return t.extend(
                  { duration: 300, delay: 0 },
                  this.stylesheet && this.stylesheet.transition
                );
              }
              serialize() {
                const e = {};
                for (const t in this._sourceCaches) {
                  const n = this._sourceCaches[t].getSource();
                  e[n.id] || (e[n.id] = n.serialize());
                }
                return t.filterObject(
                  {
                    version: this.stylesheet.version,
                    name: this.stylesheet.name,
                    metadata: this.stylesheet.metadata,
                    light: this.stylesheet.light,
                    terrain: this.stylesheet.terrain,
                    fog: this.stylesheet.fog,
                    center: this.stylesheet.center,
                    zoom: this.stylesheet.zoom,
                    bearing: this.stylesheet.bearing,
                    pitch: this.stylesheet.pitch,
                    sprite: this.stylesheet.sprite,
                    glyphs: this.stylesheet.glyphs,
                    transition: this.stylesheet.transition,
                    sources: e,
                    layers: this._serializeLayers(this._order),
                  },
                  (t) => void 0 !== t
                );
              }
              _updateLayer(t) {
                this._updatedLayers[t.id] = !0;
                const e = this._getLayerSourceCache(t);
                t.source &&
                  !this._updatedSources[t.source] &&
                  e &&
                  "raster" !== e.getSource().type &&
                  ((this._updatedSources[t.source] = "reload"), e.pause()),
                  (this._changed = !0);
              }
              _flattenAndSortRenderedFeatures(t) {
                const e = (t) => "fill-extrusion" === this._layers[t].type,
                  n = {},
                  r = [];
                for (let o = this._order.length - 1; o >= 0; o--) {
                  const i = this._order[o];
                  if (e(i)) {
                    n[i] = o;
                    for (const e of t) {
                      const t = e[i];
                      if (t) for (const e of t) r.push(e);
                    }
                  }
                }
                r.sort((t, e) => e.intersectionZ - t.intersectionZ);
                const i = [];
                for (let o = this._order.length - 1; o >= 0; o--) {
                  const s = this._order[o];
                  if (e(s))
                    for (let t = r.length - 1; t >= 0; t--) {
                      const e = r[t].feature;
                      if (n[e.layer.id] < o) break;
                      i.push(e), r.pop();
                    }
                  else
                    for (const e of t) {
                      const t = e[s];
                      if (t) for (const e of t) i.push(e.feature);
                    }
                }
                return i;
              }
              queryRenderedFeatures(e, n, r) {
                n &&
                  n.filter &&
                  this._validate(
                    t.validateStyle.filter,
                    "queryRenderedFeatures.filter",
                    n.filter,
                    null,
                    n
                  );
                const i = {};
                if (n && n.layers) {
                  if (!Array.isArray(n.layers))
                    return (
                      this.fire(
                        new t.ErrorEvent(
                          new Error("parameters.layers must be an Array.")
                        )
                      ),
                      []
                    );
                  for (const e of n.layers) {
                    const n = this._layers[e];
                    if (!n)
                      return (
                        this.fire(
                          new t.ErrorEvent(
                            new Error(
                              `The layer '${e}' does not exist in the map's style and cannot be queried for features.`
                            )
                          )
                        ),
                        []
                      );
                    i[n.source] = !0;
                  }
                }
                const o = [];
                n.availableImages = this._availableImages;
                const s =
                    n && n.layers
                      ? n.layers.some((t) => {
                          const e = this.getLayer(t);
                          return e && e.is3D();
                        })
                      : this.has3DLayers(),
                  a = O.createFromScreenPoints(e, r);
                for (const t in this._sourceCaches) {
                  const e = this._sourceCaches[t].getSource().id;
                  (n.layers && !i[e]) ||
                    o.push(
                      Pt(
                        this._sourceCaches[t],
                        this._layers,
                        this._serializedLayers,
                        a,
                        n,
                        r,
                        s,
                        !!this.map._showQueryGeometry
                      )
                    );
                }
                return (
                  this.placement &&
                    o.push(
                      (function (t, e, n, r, i, o, s) {
                        const a = {},
                          l = o.queryRenderedSymbols(r),
                          c = [];
                        for (const u of Object.keys(l).map(Number))
                          c.push(s[u]);
                        c.sort(Ot);
                        for (const u of c) {
                          const n = u.featureIndex.lookupSymbolFeatures(
                            l[u.bucketInstanceId],
                            e,
                            u.bucketIndex,
                            u.sourceLayerIndex,
                            i.filter,
                            i.layers,
                            i.availableImages,
                            t
                          );
                          for (const t in n) {
                            const e = (a[t] = a[t] || []),
                              r = n[t];
                            r.sort((t, e) => {
                              const n = u.featureSortOrder;
                              if (n) {
                                const r = n.indexOf(t.featureIndex);
                                return n.indexOf(e.featureIndex) - r;
                              }
                              return e.featureIndex - t.featureIndex;
                            });
                            for (const t of r) e.push(t);
                          }
                        }
                        for (const u in a)
                          a[u].forEach((e) => {
                            const r = e.feature,
                              i = n(t[u]).getFeatureState(
                                r.layer["source-layer"],
                                r.id
                              );
                            (r.source = r.layer.source),
                              r.layer["source-layer"] &&
                                (r.sourceLayer = r.layer["source-layer"]),
                              (r.state = i);
                          });
                        return a;
                      })(
                        this._layers,
                        this._serializedLayers,
                        this._getLayerSourceCache.bind(this),
                        a.screenGeometry,
                        n,
                        this.placement.collisionIndex,
                        this.placement.retainedQueryData
                      )
                    ),
                  this._flattenAndSortRenderedFeatures(o)
                );
              }
              querySourceFeatures(e, n) {
                n &&
                  n.filter &&
                  this._validate(
                    t.validateStyle.filter,
                    "querySourceFeatures.filter",
                    n.filter,
                    null,
                    n
                  );
                const r = this._getSourceCaches(e);
                let i = [];
                for (const t of r) i = i.concat(Mt(t, n));
                return i;
              }
              addSourceType(t, e, n) {
                return Ze.getSourceType(t)
                  ? n(new Error(`A source type called "${t}" already exists.`))
                  : (Ze.setSourceType(t, e),
                    e.workerSourceURL
                      ? void this.dispatcher.broadcast(
                          "loadWorkerSource",
                          { name: t, url: e.workerSourceURL },
                          n
                        )
                      : n(null, null));
              }
              getLight() {
                return this.light.getLight();
              }
              setLight(e, n = {}) {
                this._checkLoaded();
                const r = this.light.getLight();
                let o = !1;
                for (const t in e)
                  if (!i(e[t], r[t])) {
                    o = !0;
                    break;
                  }
                if (!o) return;
                const s = {
                  now: t.exported.now(),
                  transition: t.extend(
                    { duration: 300, delay: 0 },
                    this.stylesheet.transition
                  ),
                };
                this.light.setLight(e, n), this.light.updateTransitions(s);
              }
              getTerrain() {
                return this.terrain ? this.terrain.get() : null;
              }
              setTerrain(e) {
                if ((this._checkLoaded(), !e))
                  return (
                    delete this.terrain,
                    delete this.stylesheet.terrain,
                    this.dispatcher.broadcast("enableTerrain", !1),
                    this._force3DLayerUpdate(),
                    void (this._markersNeedUpdate = !0)
                  );
                if ("object" == typeof e.source) {
                  const n = "terrain-dem-src";
                  this.addSource(n, e.source),
                    (e = t.clone$2(e)),
                    (e = t.extend(e, { source: n }));
                }
                if (!this._validate(t.validateStyle.terrain, "terrain", e)) {
                  if (this.terrain) {
                    const n = this.terrain,
                      r = n.get();
                    for (const o in e)
                      if (!i(e[o], r[o])) {
                        n.set(e), (this.stylesheet.terrain = e);
                        const r = {
                          now: t.exported.now(),
                          transition: t.extend(
                            { duration: 0 },
                            this.stylesheet.transition
                          ),
                        };
                        n.updateTransitions(r);
                        break;
                      }
                  } else this._createTerrain(e);
                  this._updateDrapeFirstLayers(),
                    (this._markersNeedUpdate = !0);
                }
              }
              _createFog(e) {
                const n = (this.fog = new C(e));
                this.stylesheet.fog = e;
                const r = {
                  now: t.exported.now(),
                  transition: t.extend(
                    { duration: 0 },
                    this.stylesheet.transition
                  ),
                };
                n.updateTransitions(r);
              }
              _updateMarkersOpacity() {
                0 !== this.map._markers.length &&
                  this.map._requestDomTask(() => {
                    for (const t of this.map._markers) t._evaluateOpacity();
                  });
              }
              getFog() {
                return this.fog ? this.fog.get() : null;
              }
              setFog(e) {
                if ((this._checkLoaded(), !e))
                  return (
                    delete this.fog,
                    delete this.stylesheet.fog,
                    void (this._markersNeedUpdate = !0)
                  );
                if (this.fog) {
                  const n = this.fog,
                    r = n.get();
                  for (const o in e)
                    if (!i(e[o], r[o])) {
                      n.set(e), (this.stylesheet.fog = e);
                      const r = {
                        now: t.exported.now(),
                        transition: t.extend(
                          { duration: 0 },
                          this.stylesheet.transition
                        ),
                      };
                      n.updateTransitions(r);
                      break;
                    }
                } else this._createFog(e);
                this._markersNeedUpdate = !0;
              }
              _updateDrapeFirstLayers() {
                if (!this.map._optimizeForTerrain || !this.terrain) return;
                const t = this._order.filter((t) =>
                    this.isLayerDraped(this._layers[t])
                  ),
                  e = this._order.filter(
                    (t) => !this.isLayerDraped(this._layers[t])
                  );
                (this._drapedFirstOrder = []),
                  this._drapedFirstOrder.push(...t),
                  this._drapedFirstOrder.push(...e);
              }
              _createTerrain(e) {
                const n = (this.terrain = new w(e));
                (this.stylesheet.terrain = e),
                  this.dispatcher.broadcast("enableTerrain", !0),
                  this._force3DLayerUpdate();
                const r = {
                  now: t.exported.now(),
                  transition: t.extend(
                    { duration: 0 },
                    this.stylesheet.transition
                  ),
                };
                n.updateTransitions(r);
              }
              _force3DLayerUpdate() {
                for (const t in this._layers) {
                  const e = this._layers[t];
                  "fill-extrusion" === e.type && this._updateLayer(e);
                }
              }
              _validate(e, n, r, i, o = {}) {
                return (
                  (!o || !1 !== o.validate) &&
                  Fe(
                    this,
                    e.call(
                      t.validateStyle,
                      t.extend(
                        {
                          key: n,
                          style: this.serialize(),
                          value: r,
                          styleSpec: t.spec,
                        },
                        i
                      )
                    )
                  )
                );
              }
              _remove() {
                this._request &&
                  (this._request.cancel(), (this._request = null)),
                  this._spriteRequest &&
                    (this._spriteRequest.cancel(),
                    (this._spriteRequest = null)),
                  t.evented.off(
                    "pluginStateChange",
                    this._rtlTextPluginCallback
                  );
                for (const t in this._layers)
                  this._layers[t].setEventedParent(null);
                for (const t in this._sourceCaches)
                  this._sourceCaches[t].clearTiles(),
                    this._sourceCaches[t].setEventedParent(null);
                this.imageManager.setEventedParent(null),
                  this.setEventedParent(null),
                  this.dispatcher.remove();
              }
              _clearSource(t) {
                const e = this._getSourceCaches(t);
                for (const n of e) n.clearTiles();
              }
              _reloadSource(t) {
                const e = this._getSourceCaches(t);
                for (const n of e) n.resume(), n.reload();
              }
              _updateSources(t) {
                for (const e in this._sourceCaches)
                  this._sourceCaches[e].update(t);
              }
              _generateCollisionBoxes() {
                for (const t in this._sourceCaches) {
                  const e = this._sourceCaches[t];
                  e.resume(), e.reload();
                }
              }
              _updatePlacement(e, n, r, i, o = !1) {
                let s = !1,
                  a = !1;
                const l = {};
                for (const t of this._order) {
                  const n = this._layers[t];
                  if ("symbol" !== n.type) continue;
                  if (!l[n.source]) {
                    const t = this._getLayerSourceCache(n);
                    if (!t) continue;
                    l[n.source] = t
                      .getRenderableIds(!0)
                      .map((e) => t.getTileByID(e))
                      .sort(
                        (t, e) =>
                          e.tileID.overscaledZ - t.tileID.overscaledZ ||
                          (t.tileID.isLessThan(e.tileID) ? -1 : 1)
                      );
                  }
                  const r = this.crossTileSymbolIndex.addLayer(
                    n,
                    l[n.source],
                    e.center.lng
                  );
                  s = s || r;
                }
                if (
                  (this.crossTileSymbolIndex.pruneUnusedLayers(this._order),
                  (o = o || this._layerOrderChanged || 0 === r),
                  this._layerOrderChanged && this.fire(new t.Event("neworder")),
                  (o ||
                    !this.pauseablePlacement ||
                    (this.pauseablePlacement.isDone() &&
                      !this.placement.stillRecent(t.exported.now(), e.zoom))) &&
                    ((this.pauseablePlacement = new ke(
                      e,
                      this._order,
                      o,
                      n,
                      r,
                      i,
                      this.placement,
                      this.fog ? this.fog.state : null
                    )),
                    (this._layerOrderChanged = !1)),
                  this.pauseablePlacement.isDone()
                    ? this.placement.setStale()
                    : (this.pauseablePlacement.continuePlacement(
                        this._order,
                        this._layers,
                        l
                      ),
                      this.pauseablePlacement.isDone() &&
                        ((this.placement = this.pauseablePlacement.commit(
                          t.exported.now()
                        )),
                        (a = !0)),
                      s && this.pauseablePlacement.placement.setStale()),
                  a || s)
                )
                  for (const t of this._order) {
                    const e = this._layers[t];
                    "symbol" === e.type &&
                      this.placement.updateLayerOpacities(e, l[e.source]);
                  }
                return (
                  !this.pauseablePlacement.isDone() ||
                  this.placement.hasTransitions(t.exported.now())
                );
              }
              _releaseSymbolFadeTiles() {
                for (const t in this._sourceCaches)
                  this._sourceCaches[t].releaseSymbolFadeTiles();
              }
              getImages(t, e, n) {
                this.imageManager.getImages(e.icons, n),
                  this._updateTilesForChangedImages();
                const r = (t) => {
                  t && t.setDependencies(e.tileID.key, e.type, e.icons);
                };
                r(this._otherSourceCaches[e.source]),
                  r(this._symbolSourceCaches[e.source]);
              }
              getGlyphs(t, e, n) {
                this.glyphManager.getGlyphs(e.stacks, n);
              }
              getResource(e, n, r) {
                return t.makeRequest(n, r);
              }
              _getSourceCache(t) {
                return this._otherSourceCaches[t];
              }
              _getLayerSourceCache(t) {
                return "symbol" === t.type
                  ? this._symbolSourceCaches[t.source]
                  : this._otherSourceCaches[t.source];
              }
              _getSourceCaches(t) {
                const e = [];
                return (
                  this._otherSourceCaches[t] &&
                    e.push(this._otherSourceCaches[t]),
                  this._symbolSourceCaches[t] &&
                    e.push(this._symbolSourceCaches[t]),
                  e
                );
              }
              has3DLayers() {
                return this._num3DLayers > 0;
              }
              hasSymbolLayers() {
                return this._numSymbolLayers > 0;
              }
              hasCircleLayers() {
                return this._numCircleLayers > 0;
              }
            }
            (Ze.getSourceType = function (t) {
              return Tt[t];
            }),
              (Ze.setSourceType = function (t, e) {
                Tt[t] = e;
              }),
              (Ze.registerForPluginStateChange =
                t.registerForPluginStateChange);
            var Ve =
                "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}\n#endif",
              qe =
                "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}";
            let $e = {},
              Ge = {};
            ($e = Ke(
              "",
              "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {float nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {return currentElevation(apos);}\n#endif\nfloat unpack_depth(vec4 rgba_depth)\n{const vec4 bit_shift=vec4(1.0/(256.0*256.0*256.0),1.0/(256.0*256.0),1.0/256.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;vec4 bounds=vec4(d,vec2(1.0)-d);h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif",
              !0
            )),
              (Ge = Ke(
                "#ifdef FOG\nuniform float u_fog_temporal_offset;float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif",
                "#ifdef FOG\nuniform mat4 u_fog_matrix;vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif",
                !0
              ));
            const We = Ke(
                "#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}",
                "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."
              ),
              He = Ve;
            var Xe = {
              background: Ke(
                "uniform vec4 u_color;uniform float u_opacity;void main() {vec4 out_color=u_color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              backgroundPattern: Ke(
                "uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_mix);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              circle: Ke(
                "varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float height=circle_elevation(circle_center);vec4 world_center=vec4(circle_center,height,1);vec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);vec4 occlusion_world_center=vec4(circle_center,cantilevered_height,1);vec4 occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nvec4 occlusion_world_center=world_center;vec4 occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"
              ),
              clippingMask: Ke(
                "void main() {gl_FragColor=vec4(1.0);}",
                "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"
              ),
              heatmap: Ke(
                "uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\ngl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec3 pos=vec3(floor(a_pos*0.5)+extrude,elevation(floor(a_pos*0.5)));gl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"
              ),
              heatmapTexture: Ke(
                "uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}",
                "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"
              ),
              collisionBox: Ke(
                "varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}",
                "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=u_matrix*vec4(a_pos,elevation(a_pos),1.0);gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"
              ),
              collisionCircle: Ke(
                "varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}",
                "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"
              ),
              debug: Ke(
                "uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}",
                "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);}"
              ),
              fill: Ke(
                "#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              fillOutline: Ke(
                "varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              fillOutlinePattern: Ke(
                "uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=mix(color1,color2,u_fade);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              fillPattern: Ke(
                "uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_fade);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              fillExtrusion: Ke(
                "varying vec4 v_color;void main() {vec4 color=v_color;\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;varying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;\n#ifdef TERRAIN\nvec2 centroid_pos=a_centroid_pos;bool flat_roof=centroid_pos.x !=0.0;float ele=elevation(pos_nx.xy);float hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);vec3 pos=vec3(pos_nx.xy,h);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\n#else\nvec3 pos=vec3(pos_nx.xy,t > 0.0 ? height : base);gl_Position=u_matrix*vec4(pos,1);\n#endif\nfloat colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.rgb+=clamp(color.rgb*directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"
              ),
              fillExtrusionPattern: Ke(
                "uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_fade);out_color=out_color*v_lighting;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;\n#ifdef TERRAIN\nvec2 centroid_pos=a_centroid_pos;bool flat_roof=centroid_pos.x !=0.0;float ele=elevation(pos_nx.xy);float hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);vec3 p=vec3(pos_nx.xy,h);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);\n#else\nvec3 p=vec3(pos_nx.xy,z);gl_Position=u_matrix*vec4(p,1);\n#endif\nvec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"
              ),
              hillshadePrepare: Ke(
                "#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos);float f=getElevation(v_pos+vec2(epsilon.x,0));float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float h=getElevation(v_pos+vec2(0,epsilon.y));float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"
              ),
              hillshade: Ke(
                "uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              line: Ke(
                "uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 out_color=color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"
              ),
              lineGradient: Ke(
                "uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"
              ),
              linePattern: Ke(
                "uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"
              ),
              lineSDF: Ke(
                "uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_mix;uniform vec3 u_scale;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash_from\n#pragma mapbox: define lowp vec4 dash_to\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dash_from\n#pragma mapbox: initialize mediump vec4 dash_to\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfwidth=min(dash_from.z*u_scale.y,dash_to.z*u_scale.z);float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/sdfwidth;alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);vec4 out_color=color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform vec2 u_texsize;uniform mediump vec3 u_scale;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash_from\n#pragma mapbox: define lowp vec4 dash_to\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dash_from\n#pragma mapbox: initialize mediump vec4 dash_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nfloat tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;float scaleA=dash_from.z==0.0 ? 0.0 : tileZoomRatio/(dash_from.z*fromScale);float scaleB=dash_to.z==0.0 ? 0.0 : tileZoomRatio/(dash_to.z*toScale);float heightA=dash_from.y;float heightB=dash_to.y;v_tex_a=vec2(a_linesofar*scaleA/floorwidth,(-normal.y*heightA+dash_from.x+0.5)/u_texsize.y);v_tex_b=vec2(a_linesofar*scaleB/floorwidth,(-normal.y*heightB+dash_to.x+0.5)/u_texsize.y);v_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"
              ),
              raster: Ke(
                "uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              symbolIcon: Ke(
                "uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}float h=elevation(a_pos);vec4 projectedPoint=u_matrix*vec4(a_pos,h,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),h,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h,1.0);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0);\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\nfloat occlusion_fade=occlusionFade(projectedPoint);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projectedPoint.w <=0.0 || occlusion_fade==0.0));v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));}"
              ),
              symbolSDF: Ke(
                "#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}float h=elevation(a_pos);vec4 projectedPoint=u_matrix*vec4(a_pos,h,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),h,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h,1.0);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\nfloat occlusion_fade=occlusionFade(projectedPoint);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projectedPoint.w <=0.0 || occlusion_fade==0.0));float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"
              ),
              symbolTextAndIcon: Ke(
                "#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}float h=elevation(a_pos);vec4 projectedPoint=u_matrix*vec4(a_pos,h,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),h,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h,1.0);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale);\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\nfloat occlusion_fade=occlusionFade(projectedPoint);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projectedPoint.w <=0.0 || occlusion_fade==0.0));float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"
              ),
              terrainRaster: Ke(
                "uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef FOG\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\nconst float skirtOffset=24575.0;const float wireframeOffset=0.00015;void main() {v_pos0=a_texture_pos/8192.0;float skirt=float(a_pos.x >=skirtOffset);float elevation=elevation(a_texture_pos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=u_skirt_height*u_skirt_height*wireframeOffset;\n#endif\nvec2 decodedPos=a_pos-vec2(skirt*skirtOffset,0.0);gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n}"
              ),
              terrainDepth: Ke(
                "#ifdef GL_ES\nprecision highp float;\n#endif\nvec4 pack_depth(float ndc_z) {float depth=ndc_z*0.5+0.5;const vec4 bit_shift=vec4(256.0*256.0*256.0,256.0*256.0,256.0,1.0);const vec4 bit_mask =vec4(0.0,1.0/256.0,1.0/256.0,1.0/256.0);vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}varying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}",
                "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying float v_depth;void main() {float elevation=elevation(a_texture_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"
              ),
              skybox: Ke(
                "\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                qe
              ),
              skyboxGradient: Ke(
                "varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                qe
              ),
              skyboxCapture: Ke(
                "\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}",
                "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"
              ),
            };
            function Ke(t, e, n) {
              const r = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
                i =
                  /uniform (highp |mediump |lowp )?([\w]+) ([\w]+)([\s]*)([\w]*)/g,
                o = e.match(
                  /attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g
                ),
                s = t.match(i),
                a = e.match(i),
                l = Ve.match(i);
              let c = a ? a.concat(s) : s;
              n ||
                ($e.staticUniforms && (c = $e.staticUniforms.concat(c)),
                Ge.staticUniforms && (c = Ge.staticUniforms.concat(c))),
                c && (c = c.concat(l));
              const u = {};
              return {
                fragmentSource: (t = t.replace(
                  r,
                  (t, e, n, r, i) => (
                    (u[i] = !0),
                    "define" === e
                      ? `\n#ifndef HAS_UNIFORM_u_${i}\nvarying ${n} ${r} ${i};\n#else\nuniform ${n} ${r} u_${i};\n#endif\n`
                      : `\n#ifdef HAS_UNIFORM_u_${i}\n    ${n} ${r} ${i} = u_${i};\n#endif\n`
                  )
                )),
                vertexSource: (e = e.replace(r, (t, e, n, r, i) => {
                  const o = "float" === r ? "vec2" : "vec4",
                    s = i.match(/color/) ? "color" : o;
                  return u[i]
                    ? "define" === e
                      ? `\n#ifndef HAS_UNIFORM_u_${i}\nuniform lowp float u_${i}_t;\nattribute ${n} ${o} a_${i};\nvarying ${n} ${r} ${i};\n#else\nuniform ${n} ${r} u_${i};\n#endif\n`
                      : "vec4" === s
                      ? `\n#ifndef HAS_UNIFORM_u_${i}\n    ${i} = a_${i};\n#else\n    ${n} ${r} ${i} = u_${i};\n#endif\n`
                      : `\n#ifndef HAS_UNIFORM_u_${i}\n    ${i} = unpack_mix_${s}(a_${i}, u_${i}_t);\n#else\n    ${n} ${r} ${i} = u_${i};\n#endif\n`
                    : "define" === e
                    ? `\n#ifndef HAS_UNIFORM_u_${i}\nuniform lowp float u_${i}_t;\nattribute ${n} ${o} a_${i};\n#else\nuniform ${n} ${r} u_${i};\n#endif\n`
                    : "vec4" === s
                    ? `\n#ifndef HAS_UNIFORM_u_${i}\n    ${n} ${r} ${i} = a_${i};\n#else\n    ${n} ${r} ${i} = u_${i};\n#endif\n`
                    : `\n#ifndef HAS_UNIFORM_u_${i}\n    ${n} ${r} ${i} = unpack_mix_${s}(a_${i}, u_${i}_t);\n#else\n    ${n} ${r} ${i} = u_${i};\n#endif\n`;
                })),
                staticAttributes: o,
                staticUniforms: c,
              };
            }
            class Ye {
              constructor() {
                (this.boundProgram = null),
                  (this.boundLayoutVertexBuffer = null),
                  (this.boundPaintVertexBuffers = []),
                  (this.boundIndexBuffer = null),
                  (this.boundVertexOffset = null),
                  (this.boundDynamicVertexBuffer = null),
                  (this.vao = null);
              }
              bind(t, e, n, r, i, o, s, a) {
                this.context = t;
                let l = this.boundPaintVertexBuffers.length !== r.length;
                for (let c = 0; !l && c < r.length; c++)
                  this.boundPaintVertexBuffers[c] !== r[c] && (l = !0);
                t.extVertexArrayObject &&
                this.vao &&
                this.boundProgram === e &&
                this.boundLayoutVertexBuffer === n &&
                !l &&
                this.boundIndexBuffer === i &&
                this.boundVertexOffset === o &&
                this.boundDynamicVertexBuffer === s &&
                this.boundDynamicVertexBuffer2 === a
                  ? (t.bindVertexArrayOES.set(this.vao),
                    s && s.bind(),
                    i && i.dynamicDraw && i.bind(),
                    a && a.bind())
                  : this.freshBind(e, n, r, i, o, s, a);
              }
              freshBind(t, e, n, r, i, o, s) {
                let a;
                const l = t.numAttributes,
                  c = this.context,
                  u = c.gl;
                if (c.extVertexArrayObject)
                  this.vao && this.destroy(),
                    (this.vao = c.extVertexArrayObject.createVertexArrayOES()),
                    c.bindVertexArrayOES.set(this.vao),
                    (a = 0),
                    (this.boundProgram = t),
                    (this.boundLayoutVertexBuffer = e),
                    (this.boundPaintVertexBuffers = n),
                    (this.boundIndexBuffer = r),
                    (this.boundVertexOffset = i),
                    (this.boundDynamicVertexBuffer = o),
                    (this.boundDynamicVertexBuffer2 = s);
                else {
                  a = c.currentNumAttributes || 0;
                  for (let t = l; t < a; t++) u.disableVertexAttribArray(t);
                }
                e.enableAttributes(u, t);
                for (const h of n) h.enableAttributes(u, t);
                o && o.enableAttributes(u, t),
                  s && s.enableAttributes(u, t),
                  e.bind(),
                  e.setVertexAttribPointers(u, t, i);
                for (const h of n) h.bind(), h.setVertexAttribPointers(u, t, i);
                o && (o.bind(), o.setVertexAttribPointers(u, t, i)),
                  r && r.bind(),
                  s && (s.bind(), s.setVertexAttribPointers(u, t, i)),
                  (c.currentNumAttributes = l);
              }
              destroy() {
                this.vao &&
                  (this.context.extVertexArrayObject.deleteVertexArrayOES(
                    this.vao
                  ),
                  (this.vao = null));
              }
            }
            function Qe(e, n) {
              const r = Math.pow(2, n.canonical.z),
                i = n.canonical.y;
              return [
                new t.MercatorCoordinate(0, i / r).toLngLat().lat,
                new t.MercatorCoordinate(0, (i + 1) / r).toLngLat().lat,
              ];
            }
            function Je(e, n, r, i, o, s, a) {
              const l = e.context,
                c = l.gl,
                u = r.fbo;
              if (!u) return;
              e.prepareDrawTile(n);
              const h = e.useProgram("hillshade");
              l.activeTexture.set(c.TEXTURE0),
                c.bindTexture(c.TEXTURE_2D, u.colorAttachment.get());
              const p = ((t, e, n, r) => {
                const i = n.paint.get("hillshade-shadow-color"),
                  o = n.paint.get("hillshade-highlight-color"),
                  s = n.paint.get("hillshade-accent-color");
                let a =
                  n.paint.get("hillshade-illumination-direction") *
                  (Math.PI / 180);
                "viewport" === n.paint.get("hillshade-illumination-anchor") &&
                  (a -= t.transform.angle);
                const l = !t.options.moving;
                return {
                  u_matrix:
                    r ||
                    t.transform.calculateProjMatrix(e.tileID.toUnwrapped(), l),
                  u_image: 0,
                  u_latrange: Qe(0, e.tileID),
                  u_light: [n.paint.get("hillshade-exaggeration"), a],
                  u_shadow: i,
                  u_highlight: o,
                  u_accent: s,
                };
              })(e, r, i, e.terrain ? n.projMatrix : null);
              e.prepareDrawProgram(l, h, n.toUnwrapped()),
                h.draw(
                  l,
                  c.TRIANGLES,
                  o,
                  s,
                  a,
                  t.CullFaceMode.disabled,
                  p,
                  i.id,
                  e.rasterBoundsBuffer,
                  e.quadTriangleIndexBuffer,
                  e.rasterBoundsSegments
                );
            }
            function tn(e, n, r) {
              if (!n.needsDEMTextureUpload) return;
              const i = e.context,
                o = i.gl;
              i.pixelStoreUnpackPremultiplyAlpha.set(!1),
                (n.demTexture = n.demTexture || e.getTileTexture(r.stride));
              const s = r.getPixels();
              n.demTexture
                ? n.demTexture.update(s, { premultiply: !1 })
                : (n.demTexture = new t.Texture(i, s, o.RGBA, {
                    premultiply: !1,
                  })),
                (n.needsDEMTextureUpload = !1);
            }
            function en(e, n, r, i, o, s) {
              const a = e.context,
                l = a.gl;
              if (!n.dem) return;
              const c = n.dem;
              if ((a.activeTexture.set(l.TEXTURE1), tn(e, n, c), !n.demTexture))
                return;
              n.demTexture.bind(l.NEAREST, l.CLAMP_TO_EDGE);
              const u = c.dim;
              a.activeTexture.set(l.TEXTURE0);
              let h = n.fbo;
              if (!h) {
                const e = new t.Texture(
                  a,
                  { width: u, height: u, data: null },
                  l.RGBA
                );
                e.bind(l.LINEAR, l.CLAMP_TO_EDGE),
                  (h = n.fbo = a.createFramebuffer(u, u, !0)),
                  h.colorAttachment.set(e.texture);
              }
              a.bindFramebuffer.set(h.framebuffer),
                a.viewport.set([0, 0, u, u]),
                e.useProgram("hillshadePrepare").draw(
                  a,
                  l.TRIANGLES,
                  i,
                  o,
                  s,
                  t.CullFaceMode.disabled,
                  ((e, n) => {
                    const r = n.stride,
                      i = t.create$1();
                    return (
                      t.ortho(i, 0, t.EXTENT, -t.EXTENT, 0, 0, 1),
                      t.translate(i, i, [0, -t.EXTENT, 0]),
                      {
                        u_matrix: i,
                        u_image: 1,
                        u_dimension: [r, r],
                        u_zoom: e.overscaledZ,
                        u_unpack: n.unpackVector,
                      }
                    );
                  })(n.tileID, c),
                  r.id,
                  e.rasterBoundsBuffer,
                  e.quadTriangleIndexBuffer,
                  e.rasterBoundsSegments
                ),
                (n.needsHillshadePrepare = !1);
            }
            const nn = (e, n) => ({
                u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                u_image0: new t.Uniform1i(e, n.u_image0),
                u_skirt_height: new t.Uniform1f(e, n.u_skirt_height),
              }),
              rn = (t, e) => ({ u_matrix: t, u_image0: 0, u_skirt_height: e }),
              on = new (class {
                constructor() {
                  this.operations = {};
                }
                newMorphing(t, e, n, r, i) {
                  if (t in this.operations) {
                    const e = this.operations[t];
                    e.to.tileID.key !== n.tileID.key && (e.queued = n);
                  } else
                    this.operations[t] = {
                      startTime: r,
                      phase: 0,
                      duration: i,
                      from: e,
                      to: n,
                      queued: null,
                    };
                }
                getMorphValuesForProxy(t) {
                  if (!(t in this.operations)) return null;
                  const e = this.operations[t];
                  return { from: e.from, to: e.to, phase: e.phase };
                }
                update(t) {
                  for (const e in this.operations) {
                    const n = this.operations[e];
                    for (
                      n.phase = (t - n.startTime) / n.duration;
                      n.phase >= 1 || !this._validOp(n);

                    )
                      if (!this._nextOp(n, t)) {
                        delete this.operations[e];
                        break;
                      }
                  }
                }
                _nextOp(t, e) {
                  return (
                    !!t.queued &&
                    ((t.from = t.to),
                    (t.to = t.queued),
                    (t.queued = null),
                    (t.phase = 0),
                    (t.startTime = e),
                    !0)
                  );
                }
                _validOp(t) {
                  return t.from.hasData() && t.to.hasData();
                }
              })(),
              sn = {
                0: null,
                1: "TERRAIN_VERTEX_MORPHING",
                2: "TERRAIN_WIREFRAME",
              };
            function an(t, e) {
              const n = 1 << t.z;
              return (
                (!e && (0 === t.x || t.x === n - 1)) ||
                0 === t.y ||
                t.y === n - 1
              );
            }
            const ln = (t) => ({ u_matrix: t });
            function cn(e, n, r, i, o) {
              if (o > 0) {
                const s = t.exported.now(),
                  a = (s - e.timeAdded) / o,
                  l = n ? (s - n.timeAdded) / o : -1,
                  c = r.getSource(),
                  u = i.coveringZoomLevel({
                    tileSize: c.tileSize,
                    roundZoom: c.roundZoom,
                  }),
                  h =
                    !n ||
                    Math.abs(n.tileID.overscaledZ - u) >
                      Math.abs(e.tileID.overscaledZ - u),
                  p =
                    h && e.refreshedUponExpiration
                      ? 1
                      : t.clamp(h ? a : 1 - l, 0, 1);
                return (
                  e.refreshedUponExpiration &&
                    a >= 1 &&
                    (e.refreshedUponExpiration = !1),
                  n ? { opacity: 1, mix: 1 - p } : { opacity: p, mix: 0 }
                );
              }
              return { opacity: 1, mix: 0 };
            }
            class un extends t.SourceCache {
              constructor(t) {
                const e = At(
                  "proxy",
                  { type: "geojson", maxzoom: t.transform.maxZoom },
                  new P(Rt(), null),
                  t.style
                );
                super("proxy", e, !1),
                  e.setEventedParent(this),
                  (this.map = this.getSource().map = t),
                  (this.used = this._sourceLoaded = !0),
                  (this.renderCache = []),
                  (this.renderCachePool = []),
                  (this.proxyCachedFBO = {});
              }
              update(e, n, r) {
                if (e.freezeTileCoverage) return;
                this.transform = e;
                const i = e
                  .coveringTiles({
                    tileSize: this._source.tileSize,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: this._source.roundZoom,
                    reparseOverscaled: this._source.reparseOverscaled,
                  })
                  .reduce((n, r) => {
                    if (((n[r.key] = ""), !this._tiles[r.key])) {
                      const n = new t.Tile(
                        r,
                        this._source.tileSize * r.overscaleFactor(),
                        e.tileZoom
                      );
                      (n.state = "loaded"), (this._tiles[r.key] = n);
                    }
                    return n;
                  }, {});
                for (const t in this._tiles)
                  t in i ||
                    (this.freeFBO(t),
                    (this._tiles[t].state = "unloaded"),
                    delete this._tiles[t]);
              }
              freeFBO(t) {
                const e = this.proxyCachedFBO[t];
                if (void 0 !== e) {
                  const n = Object.values(e);
                  this.renderCachePool.push(...n),
                    delete this.proxyCachedFBO[t];
                }
              }
              deallocRenderCache() {
                this.renderCache.forEach((t) => t.fb.destroy()),
                  (this.renderCache = []),
                  (this.renderCachePool = []),
                  (this.proxyCachedFBO = {});
              }
            }
            class hn extends t.OverscaledTileID {
              constructor(t, e, n) {
                super(
                  t.overscaledZ,
                  t.wrap,
                  t.canonical.z,
                  t.canonical.x,
                  t.canonical.y
                ),
                  (this.proxyTileKey = e),
                  (this.projMatrix = n);
              }
            }
            class pn extends t.Elevation {
              constructor(e, n) {
                super(),
                  (this.painter = e),
                  (this.terrainTileForTile = {}),
                  (this.prevTerrainTileForTile = {});
                const [r, i, o] = (function (e) {
                    const n = new t.StructArrayLayout4i8(),
                      r = new t.StructArrayLayout3ui6(),
                      i = 131;
                    n.reserve(17161), r.reserve(33800);
                    const o = t.EXTENT / 128,
                      s = t.EXTENT + o / 2,
                      a = s + o;
                    for (let c = -o; c < a; c += o)
                      for (let e = -o; e < a; e += o) {
                        const r = e < 0 || e > s || c < 0 || c > s ? 24575 : 0,
                          i = t.clamp(Math.round(e), 0, t.EXTENT),
                          o = t.clamp(Math.round(c), 0, t.EXTENT);
                        n.emplaceBack(i + r, o, i, o);
                      }
                    const l = (t, e) => {
                      const n = e * i + t;
                      r.emplaceBack(n + 1, n, n + i),
                        r.emplaceBack(n + i, n + i + 1, n + 1);
                    };
                    for (let t = 1; t < 129; t++)
                      for (let e = 1; e < 129; e++) l(e, t);
                    return (
                      [0, 129].forEach((t) => {
                        for (let e = 0; e < 130; e++) l(e, t), l(t, e);
                      }),
                      [n, r, 32768]
                    );
                  })(),
                  s = e.context;
                (this.gridBuffer = s.createVertexBuffer(r, St.members)),
                  (this.gridIndexBuffer = s.createIndexBuffer(i)),
                  (this.gridSegments = t.SegmentVector.simpleSegment(
                    0,
                    0,
                    r.length,
                    i.length
                  )),
                  (this.gridNoSkirtSegments = t.SegmentVector.simpleSegment(
                    0,
                    0,
                    r.length,
                    o
                  )),
                  (this.proxyCoords = []),
                  (this.proxiedCoords = {}),
                  (this._visibleDemTiles = []),
                  (this._drapedRenderBatches = []),
                  (this._sourceTilesOverlap = {}),
                  (this.proxySourceCache = new un(n.map)),
                  (this.orthoMatrix = t.create$1()),
                  t.ortho(this.orthoMatrix, 0, t.EXTENT, 0, t.EXTENT, 0, 1);
                const a = s.gl;
                (this._overlapStencilMode = new t.StencilMode(
                  { func: a.GEQUAL, mask: 255 },
                  0,
                  255,
                  a.KEEP,
                  a.KEEP,
                  a.REPLACE
                )),
                  (this._previousZoom = e.transform.zoom),
                  (this.pool = []),
                  (this._findCoveringTileCache = {}),
                  (this._tilesDirty = {}),
                  (this.style = n),
                  (this._useVertexMorphing = !0),
                  (this._exaggeration = 1);
              }
              set style(t) {
                t.on("data", this._onStyleDataEvent.bind(this)),
                  t.on("neworder", this._checkRenderCacheEfficiency.bind(this)),
                  (this._style = t),
                  this._checkRenderCacheEfficiency();
              }
              update(e, n, r) {
                if (e && e.terrain) {
                  this._style !== e && (this.style = e), (this.enabled = !0);
                  const i = e.terrain.properties;
                  (this.sourceCache = e._getSourceCache(i.get("source"))),
                    (this._exaggeration = i.get("exaggeration"));
                  const o = () => {
                    this.sourceCache.used &&
                      t.warnOnce(
                        `Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`
                      );
                    const e = this.sourceCache.getSource().tileSize / 128,
                      r = this.proxySourceCache.getSource().tileSize;
                    this.sourceCache.update(n, e * r, !0),
                      (this._findCoveringTileCache[this.sourceCache.id] = {});
                  };
                  this.sourceCache.usedForTerrain ||
                    ((this._findCoveringTileCache[this.sourceCache.id] = {}),
                    (this.sourceCache.usedForTerrain = !0),
                    o(),
                    (this._initializing = !0)),
                    o(),
                    n.updateElevation(!r),
                    (this._findCoveringTileCache[this.proxySourceCache.id] =
                      {}),
                    this.proxySourceCache.update(n),
                    (this._emptyDEMTextureDirty = !0);
                } else this._disable();
              }
              _checkRenderCacheEfficiency() {
                const e = this.renderCacheEfficiency(this._style);
                this._style.map._optimizeForTerrain ||
                  (100 !== e.efficiency &&
                    t.warnOnce(
                      `Terrain render cache efficiency is not optimal (${e.efficiency}%) and performance\n                may be affected negatively, consider placing all background, fill and line layers before layer\n                with id '${e.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`
                    ));
              }
              _onStyleDataEvent(t) {
                t.coord && "source" === t.dataType
                  ? this._clearRenderCacheForTile(t.sourceCacheId, t.coord)
                  : "style" === t.dataType &&
                    (this._invalidateRenderCache = !0);
              }
              _disable() {
                if (
                  this.enabled &&
                  ((this.enabled = !1),
                  (this._sharedDepthStencil = void 0),
                  this.proxySourceCache.deallocRenderCache(),
                  this._style)
                )
                  for (const t in this._style._sourceCaches)
                    this._style._sourceCaches[t].usedForTerrain = !1;
              }
              destroy() {
                this._disable(),
                  this._emptyDEMTexture && this._emptyDEMTexture.destroy(),
                  this.pool.forEach((t) => t.fb.destroy()),
                  (this.pool = []),
                  this._depthFBO &&
                    (this._depthFBO.destroy(),
                    delete this._depthFBO,
                    delete this._depthTexture);
              }
              _source() {
                return this.enabled ? this.sourceCache : null;
              }
              exaggeration() {
                return this._exaggeration;
              }
              get visibleDemTiles() {
                return this._visibleDemTiles;
              }
              get drapeBufferSize() {
                const t = 2 * this.proxySourceCache.getSource().tileSize;
                return [t, t];
              }
              set useVertexMorphing(t) {
                this._useVertexMorphing = t;
              }
              updateTileBinding(e) {
                if (!this.enabled) return;
                this.prevTerrainTileForTile = this.terrainTileForTile;
                const n = this.proxySourceCache,
                  r = this.painter.transform;
                this._initializing &&
                  ((this._initializing =
                    0 === r._centerAltitude &&
                    -1 ===
                      this.getAtPointOrZero(
                        t.MercatorCoordinate.fromLngLat(r.center),
                        -1
                      )),
                  (this._emptyDEMTextureDirty = !this._initializing));
                const i = (this.proxyCoords = n.getIds().map((t) => {
                  const e = n.getTileByID(t).tileID;
                  return (
                    (e.projMatrix = r.calculateProjMatrix(e.toUnwrapped())), e
                  );
                }));
                !(function (e, n) {
                  const r = n.transform.pointCoordinate(
                      n.transform.getCameraPoint()
                    ),
                    i = new t.pointGeometry(r.x, r.y);
                  e.sort((e, n) => {
                    if (n.overscaledZ - e.overscaledZ)
                      return n.overscaledZ - e.overscaledZ;
                    const r = new t.pointGeometry(
                        e.canonical.x + (1 << e.canonical.z) * e.wrap,
                        e.canonical.y
                      ),
                      o = new t.pointGeometry(
                        n.canonical.x + (1 << n.canonical.z) * n.wrap,
                        n.canonical.y
                      ),
                      s = i.mult(1 << e.canonical.z);
                    return (
                      (s.x -= 0.5), (s.y -= 0.5), s.distSqr(r) - s.distSqr(o)
                    );
                  });
                })(i, this.painter),
                  (this._previousZoom = r.zoom);
                const o = this.proxyToSource || {};
                (this.proxyToSource = {}),
                  i.forEach((t) => {
                    this.proxyToSource[t.key] = {};
                  }),
                  (this.terrainTileForTile = {});
                const s = this._style._sourceCaches;
                for (const t in s) {
                  const n = s[t];
                  if (!n.used) continue;
                  if (
                    (n !== this.sourceCache &&
                      (this._findCoveringTileCache[n.id] = {}),
                    this._setupProxiedCoordsForOrtho(n, e[t], o),
                    n.usedForTerrain)
                  )
                    continue;
                  const r = e[t];
                  n.getSource().reparseOverscaled &&
                    this._assignTerrainTiles(r);
                }
                (this.proxiedCoords[n.id] = i.map(
                  (t) => new hn(t, t.key, this.orthoMatrix)
                )),
                  this._assignTerrainTiles(i),
                  this._prepareDEMTextures(),
                  this._setupDrapedRenderBatches(),
                  this._initFBOPool(),
                  this._setupRenderCache(o),
                  (this.renderingToTexture = !1),
                  (this._updateTimestamp = t.exported.now());
                const a = {};
                this._visibleDemTiles = [];
                for (const t of this.proxyCoords) {
                  const e = this.terrainTileForTile[t.key];
                  if (!e) continue;
                  const n = e.tileID.key;
                  n in a || (this._visibleDemTiles.push(e), (a[n] = n));
                }
              }
              _assignTerrainTiles(t) {
                this._initializing ||
                  t.forEach((t) => {
                    if (this.terrainTileForTile[t.key]) return;
                    const e = this._findTileCoveringTileID(t, this.sourceCache);
                    e && (this.terrainTileForTile[t.key] = e);
                  });
              }
              _prepareDEMTextures() {
                const t = this.painter.context,
                  e = t.gl;
                for (const n in this.terrainTileForTile) {
                  const r = this.terrainTileForTile[n],
                    i = r.dem;
                  !i ||
                    (r.demTexture && !r.needsDEMTextureUpload) ||
                    (t.activeTexture.set(e.TEXTURE1), tn(this.painter, r, i));
                }
              }
              _prepareDemTileUniforms(t, e, n, r) {
                if (!e || null == e.demTexture) return !1;
                const i = t.tileID.canonical,
                  o = Math.pow(2, e.tileID.canonical.z - i.z),
                  s = r || "";
                return (
                  (n[`u_dem_tl${s}`] = [(i.x * o) % 1, (i.y * o) % 1]),
                  (n[`u_dem_scale${s}`] = o),
                  !0
                );
              }
              get emptyDEMTexture() {
                return !this._emptyDEMTextureDirty && this._emptyDEMTexture
                  ? this._emptyDEMTexture
                  : this._updateEmptyDEMTexture();
              }
              _getLoadedAreaMinimum() {
                let t = 0;
                const e = this._visibleDemTiles.reduce((e, n) => {
                  if (!n.dem) return e;
                  const r = n.dem.tree.minimums[0];
                  return r > 0 && t++, e + r;
                }, 0);
                return t ? e / t : 0;
              }
              _updateEmptyDEMTexture() {
                const e = this.painter.context,
                  n = e.gl;
                e.activeTexture.set(n.TEXTURE2);
                const r = this._getLoadedAreaMinimum(),
                  i = {
                    width: 1,
                    height: 1,
                    data: new Uint8Array(
                      t.DEMData.pack(r, this.sourceCache.getSource().encoding)
                    ),
                  };
                this._emptyDEMTextureDirty = !1;
                let o = this._emptyDEMTexture;
                return (
                  o
                    ? o.update(i, { premultiply: !1 })
                    : (o = this._emptyDEMTexture =
                        new t.Texture(e, i, n.RGBA, { premultiply: !1 })),
                  o
                );
              }
              setupElevationDraw(e, n, r) {
                const i = this.painter.context,
                  o = i.gl,
                  s =
                    ((a = this.sourceCache.getSource().encoding),
                    {
                      u_dem: 2,
                      u_dem_prev: 4,
                      u_dem_unpack: t.DEMData.getUnpackVector(a),
                      u_dem_tl: [0, 0],
                      u_dem_tl_prev: [0, 0],
                      u_dem_scale: 0,
                      u_dem_scale_prev: 0,
                      u_dem_size: 0,
                      u_dem_lerp: 1,
                      u_depth: 3,
                      u_depth_size_inv: [0, 0],
                      u_exaggeration: 0,
                    });
                var a;
                (s.u_dem_size = this.sourceCache.getSource().tileSize),
                  (s.u_exaggeration = this.exaggeration());
                let l = null,
                  c = null,
                  u = 1;
                if (r && r.morphing && this._useVertexMorphing) {
                  const t = r.morphing.srcDemTile,
                    n = r.morphing.dstDemTile;
                  (u = r.morphing.phase),
                    t &&
                      n &&
                      (this._prepareDemTileUniforms(e, t, s, "_prev") &&
                        (c = t),
                      this._prepareDemTileUniforms(e, n, s) && (l = n));
                }
                if (
                  (c && l
                    ? (i.activeTexture.set(o.TEXTURE2),
                      l.demTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE, o.NEAREST),
                      i.activeTexture.set(o.TEXTURE4),
                      c.demTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE, o.NEAREST),
                      (s.u_dem_lerp = u))
                    : ((l = this.terrainTileForTile[e.tileID.key]),
                      i.activeTexture.set(o.TEXTURE2),
                      (this._prepareDemTileUniforms(e, l, s)
                        ? l.demTexture
                        : this.emptyDEMTexture
                      ).bind(o.NEAREST, o.CLAMP_TO_EDGE, o.NEAREST)),
                  r &&
                    r.useDepthForOcclusion &&
                    (i.activeTexture.set(o.TEXTURE3),
                    this._depthTexture.bind(
                      o.NEAREST,
                      o.CLAMP_TO_EDGE,
                      o.NEAREST
                    ),
                    (s.u_depth_size_inv = [
                      1 / this._depthFBO.width,
                      1 / this._depthFBO.height,
                    ])),
                  r && r.useMeterToDem && l)
                ) {
                  const e =
                    (1 << l.tileID.canonical.z) *
                    t.mercatorZfromAltitude(
                      1,
                      this.painter.transform.center.lat
                    ) *
                    this.sourceCache.getSource().tileSize;
                  s.u_meter_to_dem = e;
                }
                r &&
                  r.labelPlaneMatrixInv &&
                  (s.u_label_plane_matrix_inv = r.labelPlaneMatrixInv),
                  n.setTerrainUniformValues(i, s);
              }
              renderToBackBuffer(e) {
                const n = this.painter,
                  r = this.painter.context;
                0 !== e.length &&
                  (r.bindFramebuffer.set(null),
                  r.viewport.set([0, 0, n.width, n.height]),
                  (this.renderingToTexture = !1),
                  (function (e, n, r, i, o) {
                    const s = e.context,
                      a = s.gl;
                    let l, c;
                    const u = e.options.showTerrainWireframe ? 2 : 0,
                      h = (t, n) => {
                        if (c === t) return;
                        const r = [sn[t]];
                        n && r.push(sn[u]),
                          (l = e.useProgram("terrainRaster", null, r)),
                          (c = t);
                      },
                      p = e.colorModeForRenderPass(),
                      d = new t.DepthMode(
                        a.LEQUAL,
                        t.DepthMode.ReadWrite,
                        e.depthRangeFor3D
                      );
                    on.update(o);
                    const f = e.transform,
                      m = 6 * Math.pow(1.5, 22 - f.zoom) * n.exaggeration();
                    (u ? [!1, !0] : [!1]).forEach((u) => {
                      c = -1;
                      const g = u ? a.LINES : a.TRIANGLES,
                        [y, _] = u
                          ? n.getWirefameBuffer()
                          : [n.gridIndexBuffer, n.gridSegments];
                      for (const c of i) {
                        const i = r.getTile(c),
                          x = t.StencilMode.disabled,
                          w = n.prevTerrainTileForTile[c.key],
                          S = n.terrainTileForTile[c.key];
                        (b = S),
                          null != (v = w) &&
                            null != b &&
                            v.hasData() &&
                            b.hasData() &&
                            null != v.demTexture &&
                            null != b.demTexture &&
                            v.tileID.key !== b.tileID.key &&
                            on.newMorphing(c.key, w, S, o, 250),
                          s.activeTexture.set(a.TEXTURE0),
                          i.texture.bind(
                            a.LINEAR,
                            a.CLAMP_TO_EDGE,
                            a.LINEAR_MIPMAP_NEAREST
                          );
                        const E = on.getMorphValuesForProxy(c.key),
                          T = E ? 1 : 0;
                        let A;
                        E &&
                          (A = {
                            morphing: {
                              srcDemTile: E.from,
                              dstDemTile: E.to,
                              phase: t.easeCubicInOut(E.phase),
                            },
                          });
                        const C = rn(
                          c.projMatrix,
                          an(c.canonical, f.renderWorldCopies) ? m / 10 : m
                        );
                        h(T, u),
                          n.setupElevationDraw(i, l, A),
                          e.prepareDrawProgram(s, l, c.toUnwrapped()),
                          l.draw(
                            s,
                            g,
                            d,
                            x,
                            p,
                            t.CullFaceMode.backCCW,
                            C,
                            "terrain_raster",
                            n.gridBuffer,
                            y,
                            _
                          );
                      }
                      var v, b;
                    });
                  })(n, this, this.proxySourceCache, e, this._updateTimestamp),
                  (this.renderingToTexture = !0),
                  e.splice(0, e.length));
              }
              renderBatch(e) {
                if (0 === this._drapedRenderBatches.length) return e + 1;
                this.renderingToTexture = !0;
                const n = this.painter,
                  r = this.painter.context,
                  i = this.proxySourceCache,
                  o = this.proxiedCoords[i.id],
                  s = this._drapedRenderBatches.shift(),
                  a = [],
                  l = n.style.order;
                let c = 0;
                for (const u of o) {
                  const o = i.getTileByID(u.proxyTileKey),
                    h = i.proxyCachedFBO[u.key]
                      ? i.proxyCachedFBO[u.key][e]
                      : void 0,
                    p = void 0 !== h ? i.renderCache[h] : this.pool[c++],
                    d = void 0 !== h;
                  if (((o.texture = p.tex), d && !p.dirty)) {
                    a.push(o.tileID);
                    continue;
                  }
                  let f;
                  r.bindFramebuffer.set(p.fb.framebuffer),
                    (this.renderedToTile = !1),
                    p.dirty &&
                      (r.clear({ color: t.Color.transparent }), (p.dirty = !1));
                  for (let t = s.start; t <= s.end; ++t) {
                    const e = n.style._layers[l[t]];
                    if (e.isHidden(n.transform.zoom)) continue;
                    const i = n.style._getLayerSourceCache(e),
                      o = i ? this.proxyToSource[u.key][i.id] : [u];
                    if (!o) continue;
                    const s = o;
                    r.viewport.set([0, 0, p.fb.width, p.fb.height]),
                      f !== (i ? i.id : null) &&
                        (this._setupStencil(p, o, e, i), (f = i ? i.id : null)),
                      n.renderLayer(n, i, e, s);
                  }
                  this.renderedToTile
                    ? ((p.dirty = !0), a.push(o.tileID))
                    : d || --c,
                    5 === c && ((c = 0), this.renderToBackBuffer(a));
                }
                return (
                  this.renderToBackBuffer(a),
                  (this.renderingToTexture = !1),
                  r.bindFramebuffer.set(null),
                  r.viewport.set([0, 0, n.width, n.height]),
                  s.end + 1
                );
              }
              postRender() {}
              renderCacheEfficiency(t) {
                const e = t.order.length;
                if (0 === e) return { efficiency: 100 };
                let n,
                  r = 0,
                  i = 0,
                  o = !1;
                for (let s = 0; s < e; ++s) {
                  const e = t._layers[t.order[s]];
                  this._style.isLayerDraped(e)
                    ? (o && ++r, ++i)
                    : o || ((o = !0), (n = e.id));
                }
                return 0 === i
                  ? { efficiency: 100 }
                  : { efficiency: 100 * (1 - r / i), firstUndrapedLayer: n };
              }
              getMinElevationBelowMSL() {
                let t = 0;
                return (
                  this._visibleDemTiles
                    .filter((t) => t.dem)
                    .forEach((e) => {
                      t = Math.min(t, e.dem.tree.minimums[0]);
                    }),
                  0 === t ? t : (t - 30) * this._exaggeration
                );
              }
              raycast(t, e, n) {
                if (!this._visibleDemTiles) return null;
                const r = this._visibleDemTiles
                  .filter((t) => t.dem)
                  .map((r) => {
                    const i = r.tileID,
                      o = Math.pow(2, i.overscaledZ),
                      { x: s, y: a } = i.canonical,
                      l = s / o,
                      c = (s + 1) / o,
                      u = a / o,
                      h = (a + 1) / o;
                    return {
                      minx: l,
                      miny: u,
                      maxx: c,
                      maxy: h,
                      t: r.dem.tree.raycastRoot(l, u, c, h, t, e, n),
                      tile: r,
                    };
                  });
                r.sort(
                  (t, e) =>
                    (null !== t.t ? t.t : Number.MAX_VALUE) -
                    (null !== e.t ? e.t : Number.MAX_VALUE)
                );
                for (const i of r) {
                  if (null == i.t) return null;
                  const r = i.tile.dem.tree.raycast(
                    i.minx,
                    i.miny,
                    i.maxx,
                    i.maxy,
                    t,
                    e,
                    n
                  );
                  if (null != r) return r;
                }
                return null;
              }
              _createFBO() {
                const e = this.painter.context,
                  n = e.gl,
                  r = this.drapeBufferSize;
                e.activeTexture.set(n.TEXTURE0);
                const i = new t.Texture(
                  e,
                  { width: r[0], height: r[1], data: null },
                  n.RGBA
                );
                i.bind(n.LINEAR, n.CLAMP_TO_EDGE);
                const o = e.createFramebuffer(r[0], r[1], !1);
                return (
                  o.colorAttachment.set(i.texture),
                  (o.depthAttachment = new _t(e, o.framebuffer)),
                  void 0 === this._sharedDepthStencil
                    ? ((this._sharedDepthStencil = e.createRenderbuffer(
                        e.gl.DEPTH_STENCIL,
                        r[0],
                        r[1]
                      )),
                      (this._stencilRef = 0),
                      o.depthAttachment.set(this._sharedDepthStencil),
                      e.clear({ stencil: 0 }))
                    : o.depthAttachment.set(this._sharedDepthStencil),
                  e.extTextureFilterAnisotropic &&
                    !e.extTextureFilterAnisotropicForceOff &&
                    n.texParameterf(
                      n.TEXTURE_2D,
                      e.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
                      e.extTextureFilterAnisotropicMax
                    ),
                  { fb: o, tex: i, dirty: !1 }
                );
              }
              _initFBOPool() {
                for (
                  ;
                  this.pool.length < Math.min(5, this.proxyCoords.length);

                )
                  this.pool.push(this._createFBO());
              }
              _shouldDisableRenderCache() {
                if (this._style.light && this._style.light.hasTransition())
                  return !0;
                for (const t in this._style._sourceCaches)
                  if (this._style._sourceCaches[t].hasTransition()) return !0;
                return this._style.order.some((t) => {
                  const e = this._style._layers[t],
                    n = e.isHidden(this.painter.transform.zoom),
                    r = e.getCrossfadeParameters(),
                    i = !!r && 1 !== r.t,
                    o = e.hasTransition();
                  return "custom" !== e.type && !n && (i || o);
                });
              }
              _clearRasterFadeFromRenderCache() {
                let t = !1;
                for (const e in this._style._sourceCaches)
                  if (this._style._sourceCaches[e]._source instanceof xt) {
                    t = !0;
                    break;
                  }
                if (t)
                  for (let e = 0; e < this._style.order.length; ++e) {
                    const t = this._style._layers[this._style.order[e]],
                      n = t.isHidden(this.painter.transform.zoom),
                      r = this._style._getLayerSourceCache(t);
                    if ("raster" !== t.type || n || !r) continue;
                    const i = t.paint.get("raster-fade-duration");
                    for (const e of this.proxyCoords) {
                      const t = this.proxyToSource[e.key][r.id];
                      if (t)
                        for (const e of t) {
                          const t = cn(
                            r.getTile(e),
                            r.findLoadedParent(e, 0),
                            r,
                            this.painter.transform,
                            i
                          );
                          (1 !== t.opacity || 0 !== t.mix) &&
                            this._clearRenderCacheForTile(r.id, e);
                        }
                    }
                  }
              }
              _setupDrapedRenderBatches() {
                const t = this._style.order,
                  e = t.length;
                if (0 === e) return;
                const n = [];
                let r,
                  i = 0,
                  o = this._style._layers[t[i]];
                for (
                  ;
                  !this._style.isLayerDraped(o) &&
                  o.isHidden(this.painter.transform.zoom) &&
                  ++i < e;

                )
                  o = this._style._layers[t[i]];
                for (; i < e; ++i) {
                  const e = this._style._layers[t[i]];
                  e.isHidden(this.painter.transform.zoom) ||
                    (this._style.isLayerDraped(e)
                      ? void 0 === r && (r = i)
                      : void 0 !== r &&
                        (n.push({ start: r, end: i - 1 }), (r = void 0)));
                }
                void 0 !== r && n.push({ start: r, end: i - 1 }),
                  (this._drapedRenderBatches = n);
              }
              _setupRenderCache(t) {
                const e = this.proxySourceCache;
                if (
                  this._shouldDisableRenderCache() ||
                  this._invalidateRenderCache
                ) {
                  if (
                    ((this._invalidateRenderCache = !1),
                    e.renderCache.length > e.renderCachePool.length)
                  ) {
                    const t = Object.values(e.proxyCachedFBO);
                    e.proxyCachedFBO = {};
                    for (let n = 0; n < t.length; ++n) {
                      const r = Object.values(t[n]);
                      e.renderCachePool.push(...r);
                    }
                  }
                  return;
                }
                this._clearRasterFadeFromRenderCache();
                const n = this.proxyCoords,
                  r = this._tilesDirty;
                for (let o = n.length - 1; o >= 0; o--) {
                  const i = n[o];
                  if (
                    (e.getTileByID(i.key), void 0 !== e.proxyCachedFBO[i.key])
                  ) {
                    const n = t[i.key],
                      o = this.proxyToSource[i.key];
                    let s = 0;
                    for (const t in o) {
                      const e = o[t],
                        i = n[t];
                      if (
                        !i ||
                        i.length !== e.length ||
                        e.some(
                          (e, n) =>
                            e !== i[n] || (r[t] && r[t].hasOwnProperty(e.key))
                        )
                      ) {
                        s = -1;
                        break;
                      }
                      ++s;
                    }
                    for (const t in e.proxyCachedFBO[i.key])
                      e.renderCache[e.proxyCachedFBO[i.key][t]].dirty =
                        s < 0 || s !== Object.values(n).length;
                  }
                }
                const i = [...this._drapedRenderBatches];
                i.sort((t, e) => e.end - e.start - (t.end - t.start));
                for (const o of i)
                  for (const t of n) {
                    if (e.proxyCachedFBO[t.key]) continue;
                    let n = e.renderCachePool.pop();
                    void 0 === n &&
                      e.renderCache.length < 50 &&
                      ((n = e.renderCache.length),
                      e.renderCache.push(this._createFBO())),
                      void 0 !== n &&
                        ((e.proxyCachedFBO[t.key] = {}),
                        (e.proxyCachedFBO[t.key][o.start] = n),
                        (e.renderCache[n].dirty = !0));
                  }
                this._tilesDirty = {};
              }
              _setupStencil(t, e, n, r) {
                if (!r || !this._sourceTilesOverlap[r.id])
                  return void (
                    this._overlapStencilType && (this._overlapStencilType = !1)
                  );
                const i = this.painter.context,
                  o = i.gl;
                if (e.length <= 1) return void (this._overlapStencilType = !1);
                let s;
                if (n.isTileClipped())
                  (s = e.length),
                    (this._overlapStencilMode.test = {
                      func: o.EQUAL,
                      mask: 255,
                    }),
                    (this._overlapStencilType = "Clip");
                else {
                  if (!(e[0].overscaledZ > e[e.length - 1].overscaledZ))
                    return void (this._overlapStencilType = !1);
                  (s = 1),
                    (this._overlapStencilMode.test = {
                      func: o.GREATER,
                      mask: 255,
                    }),
                    (this._overlapStencilType = "Mask");
                }
                this._stencilRef + s > 255 &&
                  (i.clear({ stencil: 0 }), (this._stencilRef = 0)),
                  (this._stencilRef += s),
                  (this._overlapStencilMode.ref = this._stencilRef),
                  n.isTileClipped() &&
                    this._renderTileClippingMasks(
                      e,
                      this._overlapStencilMode.ref
                    );
              }
              stencilModeForRTTOverlap(e) {
                return this.renderingToTexture && this._overlapStencilType
                  ? ("Clip" === this._overlapStencilType &&
                      (this._overlapStencilMode.ref =
                        this.painter._tileClippingMaskIDs[e.key]),
                    this._overlapStencilMode)
                  : t.StencilMode.disabled;
              }
              _renderTileClippingMasks(e, n) {
                const r = this.painter,
                  i = this.painter.context,
                  o = i.gl;
                (r._tileClippingMaskIDs = {}),
                  i.setColorMode(t.ColorMode.disabled),
                  i.setDepthMode(t.DepthMode.disabled);
                const s = r.useProgram("clippingMask");
                for (const a of e) {
                  const e = (r._tileClippingMaskIDs[a.key] = --n);
                  s.draw(
                    i,
                    o.TRIANGLES,
                    t.DepthMode.disabled,
                    new t.StencilMode(
                      { func: o.ALWAYS, mask: 0 },
                      e,
                      255,
                      o.KEEP,
                      o.KEEP,
                      o.REPLACE
                    ),
                    t.ColorMode.disabled,
                    t.CullFaceMode.disabled,
                    ln(a.projMatrix),
                    "$clipping",
                    r.tileExtentBuffer,
                    r.quadTriangleIndexBuffer,
                    r.tileExtentSegments
                  );
                }
              }
              pointCoordinate(e) {
                const n = this.painter.transform;
                if (e.x < 0 || e.x > n.width || e.y < 0 || e.y > n.height)
                  return null;
                const r = [e.x, e.y, 1, 1];
                t.transformMat4(r, r, n.pixelMatrixInverse),
                  t.scale$2(r, r, 1 / r[3]),
                  (r[0] /= n.worldSize),
                  (r[1] /= n.worldSize);
                const i = n._camera.position,
                  o = t.mercatorZfromAltitude(1, n.center.lat),
                  s = [i[0], i[1], i[2] / o, 0],
                  a = t.subtract([], r.slice(0, 3), s);
                t.normalize(a, a);
                const l = this.raycast(s, a, this._exaggeration);
                return null !== l && l
                  ? (t.scaleAndAdd(s, s, a, l), (s[3] = s[2]), (s[2] *= o), s)
                  : null;
              }
              drawDepth() {
                const e = this.painter,
                  n = e.context,
                  r = this.proxySourceCache,
                  i = Math.ceil(e.width),
                  o = Math.ceil(e.height);
                if (
                  (!this._depthFBO ||
                    (this._depthFBO.width === i &&
                      this._depthFBO.height === o) ||
                    (this._depthFBO.destroy(),
                    delete this._depthFBO,
                    delete this._depthTexture),
                  !this._depthFBO)
                ) {
                  const e = n.gl,
                    r = n.createFramebuffer(i, o, !0);
                  n.activeTexture.set(e.TEXTURE0);
                  const s = new t.Texture(
                    n,
                    { width: i, height: o, data: null },
                    e.RGBA
                  );
                  s.bind(e.NEAREST, e.CLAMP_TO_EDGE),
                    r.colorAttachment.set(s.texture);
                  const a = n.createRenderbuffer(n.gl.DEPTH_COMPONENT16, i, o);
                  r.depthAttachment.set(a),
                    (this._depthFBO = r),
                    (this._depthTexture = s);
                }
                n.bindFramebuffer.set(this._depthFBO.framebuffer),
                  n.viewport.set([0, 0, i, o]),
                  (function (e, n, r, i) {
                    const o = e.context,
                      s = o.gl;
                    o.clear({ depth: 1 });
                    const a = e.useProgram("terrainDepth"),
                      l = new t.DepthMode(
                        s.LESS,
                        t.DepthMode.ReadWrite,
                        e.depthRangeFor3D
                      );
                    for (const c of i) {
                      const e = r.getTile(c),
                        i = rn(c.projMatrix, 0);
                      n.setupElevationDraw(e, a),
                        a.draw(
                          o,
                          s.TRIANGLES,
                          l,
                          t.StencilMode.disabled,
                          t.ColorMode.unblended,
                          t.CullFaceMode.backCCW,
                          i,
                          "terrain_depth",
                          n.gridBuffer,
                          n.gridIndexBuffer,
                          n.gridNoSkirtSegments
                        );
                    }
                  })(e, this, r, this.proxyCoords);
              }
              _setupProxiedCoordsForOrtho(t, e, n) {
                if (t.getSource() instanceof Et)
                  return this._setupProxiedCoordsForImageSource(t, e, n);
                this._findCoveringTileCache[t.id] =
                  this._findCoveringTileCache[t.id] || {};
                const r = (this.proxiedCoords[t.id] = []),
                  i = this.proxyCoords;
                for (let s = 0; s < i.length; s++) {
                  const e = i[s],
                    o = this._findTileCoveringTileID(e, t);
                  if (o) {
                    const i = this._createProxiedId(
                      e,
                      o,
                      n[e.key] && n[e.key][t.id]
                    );
                    r.push(i), (this.proxyToSource[e.key][t.id] = [i]);
                  }
                }
                let o = !1;
                for (let s = 0; s < e.length; s++) {
                  const i = t.getTile(e[s]);
                  if (!i || !i.hasData()) continue;
                  const a = this._findTileCoveringTileID(
                    i.tileID,
                    this.proxySourceCache
                  );
                  if (a && a.tileID.canonical.z !== i.tileID.canonical.z) {
                    const e = this.proxyToSource[a.tileID.key][t.id],
                      s = this._createProxiedId(
                        a.tileID,
                        i,
                        n[a.tileID.key] && n[a.tileID.key][t.id]
                      );
                    e
                      ? e.splice(e.length - 1, 0, s)
                      : (this.proxyToSource[a.tileID.key][t.id] = [s]),
                      r.push(s),
                      (o = !0);
                  }
                }
                this._sourceTilesOverlap[t.id] = o;
              }
              _setupProxiedCoordsForImageSource(e, n, r) {
                if (!e.getSource().loaded()) return;
                const i = (this.proxiedCoords[e.id] = []),
                  o = this.proxyCoords,
                  s = e.getSource(),
                  a = new t.pointGeometry(s.tileID.x, s.tileID.y)._div(
                    1 << s.tileID.z
                  ),
                  l = s.coordinates
                    .map(t.MercatorCoordinate.fromLngLat)
                    .reduce(
                      (t, e) => (
                        (t.min.x = Math.min(t.min.x, e.x - a.x)),
                        (t.min.y = Math.min(t.min.y, e.y - a.y)),
                        (t.max.x = Math.max(t.max.x, e.x - a.x)),
                        (t.max.y = Math.max(t.max.y, e.y - a.y)),
                        t
                      ),
                      {
                        min: new t.pointGeometry(
                          Number.MAX_VALUE,
                          Number.MAX_VALUE
                        ),
                        max: new t.pointGeometry(
                          -Number.MAX_VALUE,
                          -Number.MAX_VALUE
                        ),
                      }
                    ),
                  c = (e, n) => {
                    const r = e.wrap + e.canonical.x / (1 << e.canonical.z),
                      i = e.canonical.y / (1 << e.canonical.z),
                      o = t.EXTENT / (1 << e.canonical.z),
                      s = n.wrap + n.canonical.x / (1 << n.canonical.z),
                      a = n.canonical.y / (1 << n.canonical.z);
                    return (
                      r + o < s + l.min.x ||
                      r > s + l.max.x ||
                      i + o < a + l.min.y ||
                      i > a + l.max.y
                    );
                  };
                for (let t = 0; t < o.length; t++) {
                  const s = o[t];
                  for (let t = 0; t < n.length; t++) {
                    const o = e.getTile(n[t]);
                    if (!o || !o.hasData()) continue;
                    if (c(s, o.tileID)) continue;
                    const a = this._createProxiedId(
                        s,
                        o,
                        r[s.key] && r[s.key][e.id]
                      ),
                      l = this.proxyToSource[s.key][e.id];
                    l ? l.push(a) : (this.proxyToSource[s.key][e.id] = [a]),
                      i.push(a);
                  }
                }
              }
              _createProxiedId(e, n, r) {
                let i = this.orthoMatrix;
                if (r) {
                  const t = r.find((t) => t.key === n.tileID.key);
                  if (t) return t;
                }
                if (n.tileID.key !== e.key) {
                  const r = e.canonical.z - n.tileID.canonical.z;
                  let o, s, a;
                  i = t.create$1();
                  const l = (n.tileID.wrap - e.wrap) << e.overscaledZ;
                  r > 0
                    ? ((o = t.EXTENT >> r),
                      (s =
                        o * ((n.tileID.canonical.x << r) - e.canonical.x + l)),
                      (a = o * ((n.tileID.canonical.y << r) - e.canonical.y)))
                    : ((o = t.EXTENT << -r),
                      (s =
                        t.EXTENT *
                        (n.tileID.canonical.x - ((e.canonical.x + l) << -r))),
                      (a =
                        t.EXTENT *
                        (n.tileID.canonical.y - (e.canonical.y << -r)))),
                    t.ortho(i, 0, o, 0, o, 0, 1),
                    t.translate(i, i, [s, a, 0]);
                }
                return new hn(n.tileID, e.key, i);
              }
              _findTileCoveringTileID(e, n) {
                let r = n.getTile(e);
                if (r && r.hasData()) return r;
                const i = this._findCoveringTileCache[n.id],
                  o = i[e.key];
                if (
                  ((r = o ? n.getTileByID(o) : null),
                  (r && r.hasData()) || null === o)
                )
                  return r;
                let s = r ? r.tileID : e,
                  a = s.overscaledZ;
                const l = n.getSource().minzoom,
                  c = [];
                if (!o) {
                  const i = n.getSource().maxzoom;
                  if (e.canonical.z >= i) {
                    const r = e.canonical.z - i;
                    n.getSource().reparseOverscaled
                      ? ((a = Math.max(
                          e.canonical.z + 2,
                          n.transform.tileZoom
                        )),
                        (s = new t.OverscaledTileID(
                          a,
                          e.wrap,
                          i,
                          e.canonical.x >> r,
                          e.canonical.y >> r
                        )))
                      : 0 !== r &&
                        ((a = i),
                        (s = new t.OverscaledTileID(
                          a,
                          e.wrap,
                          i,
                          e.canonical.x >> r,
                          e.canonical.y >> r
                        )));
                  }
                  s.key !== e.key && (c.push(s.key), (r = n.getTile(s)));
                }
                const u = (t) => {
                  c.forEach((e) => {
                    i[e] = t;
                  }),
                    (c.length = 0);
                };
                for (a -= 1; a >= l && (!r || !r.hasData()); a--) {
                  r && u(r.tileID.key);
                  const t = s.calculateScaledKey(a);
                  if (((r = n.getTileByID(t)), r && r.hasData())) break;
                  const e = i[t];
                  if (null === e) break;
                  void 0 === e ? c.push(t) : (r = n.getTileByID(e));
                }
                return u(r ? r.tileID.key : null), r && r.hasData() ? r : null;
              }
              findDEMTileFor(t) {
                return this.enabled
                  ? this._findTileCoveringTileID(t, this.sourceCache)
                  : null;
              }
              prepareDrawTile(t) {
                this.renderedToTile = !0;
              }
              _clearRenderCacheForTile(t, e) {
                let n = this._tilesDirty[t];
                n || (n = this._tilesDirty[t] = {}), (n[e.key] = !0);
              }
              getWirefameBuffer() {
                if (!this.wireframeSegments) {
                  const e = (function (e) {
                    let n, r, i;
                    const o = new t.StructArrayLayout2ui4(),
                      s = 131;
                    for (r = 1; r < 129; r++) {
                      for (n = 1; n < 129; n++)
                        (i = r * s + n),
                          o.emplaceBack(i, i + 1),
                          o.emplaceBack(i, i + s),
                          o.emplaceBack(i + 1, i + s),
                          128 === r && o.emplaceBack(i + s, i + s + 1);
                      o.emplaceBack(i + 1, i + 1 + s);
                    }
                    return o;
                  })();
                  (this.wireframeIndexBuffer =
                    this.painter.context.createIndexBuffer(e)),
                    (this.wireframeSegments = t.SegmentVector.simpleSegment(
                      0,
                      0,
                      this.gridBuffer.length,
                      e.length
                    ));
                }
                return [this.wireframeIndexBuffer, this.wireframeSegments];
              }
            }
            function dn(t) {
              const e = [];
              for (let n = 0; n < t.length; n++) {
                if (null === t[n]) continue;
                const r = t[n].split(" ");
                e.push(r.pop());
              }
              return e;
            }
            class fn {
              static cacheKey(t, e, n) {
                let r = `${t}${n ? n.cacheKey : ""}`;
                for (const i of e) r += `/${i}`;
                return r;
              }
              constructor(e, n, r, i, o, s) {
                const a = e.gl;
                this.program = a.createProgram();
                const l = dn(r.staticAttributes),
                  c = i ? i.getBinderAttributes() : [],
                  u = l.concat(c),
                  h = r.staticUniforms ? dn(r.staticUniforms) : [],
                  p = i ? i.getBinderUniforms() : [],
                  d = h.concat(p),
                  f = [];
                for (const t of d) f.indexOf(t) < 0 && f.push(t);
                let m = i ? i.defines() : [];
                m = m.concat(s.map((t) => `#define ${t}`));
                const g = m
                    .concat(
                      We.fragmentSource,
                      He,
                      Ge.fragmentSource,
                      r.fragmentSource
                    )
                    .join("\n"),
                  y = m
                    .concat(
                      We.vertexSource,
                      He,
                      Ge.vertexSource,
                      $e.vertexSource,
                      r.vertexSource
                    )
                    .join("\n"),
                  _ = a.createShader(a.FRAGMENT_SHADER);
                if (a.isContextLost()) return void (this.failedToCreate = !0);
                a.shaderSource(_, g),
                  a.compileShader(_),
                  a.attachShader(this.program, _);
                const v = a.createShader(a.VERTEX_SHADER);
                if (a.isContextLost()) return void (this.failedToCreate = !0);
                a.shaderSource(v, y),
                  a.compileShader(v),
                  a.attachShader(this.program, v),
                  (this.attributes = {});
                const b = {};
                this.numAttributes = u.length;
                for (let t = 0; t < this.numAttributes; t++)
                  u[t] &&
                    (a.bindAttribLocation(this.program, t, u[t]),
                    (this.attributes[u[t]] = t));
                a.linkProgram(this.program),
                  a.deleteShader(v),
                  a.deleteShader(_);
                for (let t = 0; t < f.length; t++) {
                  const e = f[t];
                  if (e && !b[e]) {
                    const t = a.getUniformLocation(this.program, e);
                    t && (b[e] = t);
                  }
                }
                (this.fixedUniforms = o(e, b)),
                  (this.binderUniforms = i ? i.getUniforms(e, b) : []),
                  -1 !== s.indexOf("TERRAIN") &&
                    (this.terrainUniforms = ((e, n) => ({
                      u_dem: new t.Uniform1i(e, n.u_dem),
                      u_dem_prev: new t.Uniform1i(e, n.u_dem_prev),
                      u_dem_unpack: new t.Uniform4f(e, n.u_dem_unpack),
                      u_dem_tl: new t.Uniform2f(e, n.u_dem_tl),
                      u_dem_scale: new t.Uniform1f(e, n.u_dem_scale),
                      u_dem_tl_prev: new t.Uniform2f(e, n.u_dem_tl_prev),
                      u_dem_scale_prev: new t.Uniform1f(e, n.u_dem_scale_prev),
                      u_dem_size: new t.Uniform1f(e, n.u_dem_size),
                      u_dem_lerp: new t.Uniform1f(e, n.u_dem_lerp),
                      u_exaggeration: new t.Uniform1f(e, n.u_exaggeration),
                      u_depth: new t.Uniform1i(e, n.u_depth),
                      u_depth_size_inv: new t.Uniform2f(e, n.u_depth_size_inv),
                      u_meter_to_dem: new t.Uniform1f(e, n.u_meter_to_dem),
                      u_label_plane_matrix_inv: new t.UniformMatrix4f(
                        e,
                        n.u_label_plane_matrix_inv
                      ),
                    }))(e, b)),
                  -1 !== s.indexOf("FOG") &&
                    (this.fogUniforms = ((e, n) => ({
                      u_fog_matrix: new t.UniformMatrix4f(e, n.u_fog_matrix),
                      u_fog_range: new t.Uniform2f(e, n.u_fog_range),
                      u_fog_color: new t.Uniform4f(e, n.u_fog_color),
                      u_fog_horizon_blend: new t.Uniform1f(
                        e,
                        n.u_fog_horizon_blend
                      ),
                      u_fog_temporal_offset: new t.Uniform1f(
                        e,
                        n.u_fog_temporal_offset
                      ),
                    }))(e, b));
              }
              setTerrainUniformValues(t, e) {
                if (!this.terrainUniforms) return;
                const n = this.terrainUniforms;
                if (!this.failedToCreate) {
                  t.program.set(this.program);
                  for (const t in e) n[t].set(e[t]);
                }
              }
              setFogUniformValues(t, e) {
                if (!this.fogUniforms) return;
                const n = this.fogUniforms;
                if (!this.failedToCreate) {
                  t.program.set(this.program);
                  for (const t in e) n[t].location && n[t].set(e[t]);
                }
              }
              draw(t, e, n, r, i, o, s, a, l, c, u, h, p, d, f, m) {
                const g = t.gl;
                if (this.failedToCreate) return;
                t.program.set(this.program),
                  t.setDepthMode(n),
                  t.setStencilMode(r),
                  t.setColorMode(i),
                  t.setCullFace(o);
                for (const _ in this.fixedUniforms)
                  this.fixedUniforms[_].set(s[_]);
                d && d.setUniforms(t, this.binderUniforms, h, { zoom: p });
                const y = { [g.LINES]: 2, [g.TRIANGLES]: 3, [g.LINE_STRIP]: 1 }[
                  e
                ];
                for (const _ of u.get()) {
                  const n = _.vaos || (_.vaos = {});
                  (n[a] || (n[a] = new Ye())).bind(
                    t,
                    this,
                    l,
                    d ? d.getPaintVertexBuffers() : [],
                    c,
                    _.vertexOffset,
                    f,
                    m
                  ),
                    g.drawElements(
                      e,
                      _.primitiveLength * y,
                      g.UNSIGNED_SHORT,
                      _.primitiveOffset * y * 2
                    );
                }
              }
            }
            function mn(t, e, n) {
              const r = 1 / M(n, 1, e.transform.tileZoom),
                i = Math.pow(2, n.tileID.overscaledZ),
                o = (n.tileSize * Math.pow(2, e.transform.tileZoom)) / i,
                s = o * (n.tileID.canonical.x + n.tileID.wrap * i),
                a = o * n.tileID.canonical.y;
              return {
                u_image: 0,
                u_texsize: n.imageAtlasTexture.size,
                u_scale: [r, t.fromScale, t.toScale],
                u_fade: t.t,
                u_pixel_coord_upper: [s >> 16, a >> 16],
                u_pixel_coord_lower: [65535 & s, 65535 & a],
              };
            }
            const gn = (e, n, r, i) => {
                const o = n.style.light,
                  s = o.properties.get("position"),
                  a = [s.x, s.y, s.z],
                  l = t.create$2();
                "viewport" === o.properties.get("anchor") &&
                  (t.fromRotation(l, -n.transform.angle),
                  t.transformMat3(a, a, l));
                const c = o.properties.get("color");
                return {
                  u_matrix: e,
                  u_lightpos: a,
                  u_lightintensity: o.properties.get("intensity"),
                  u_lightcolor: [c.r, c.g, c.b],
                  u_vertical_gradient: +r,
                  u_opacity: i,
                };
              },
              yn = (e, n, r, i, o, s, a) =>
                t.extend(gn(e, n, r, i), mn(s, n, a), {
                  u_height_factor: -Math.pow(2, o.overscaledZ) / a.tileSize / 8,
                }),
              _n = (t) => ({ u_matrix: t }),
              vn = (e, n, r, i) => t.extend(_n(e), mn(r, n, i)),
              bn = (t, e) => ({ u_matrix: t, u_world: e }),
              xn = (e, n, r, i, o) => t.extend(vn(e, n, r, i), { u_world: o }),
              wn = (e, n, r, i) => {
                const o = e.transform;
                let s;
                if ("map" === i.paint.get("circle-pitch-alignment")) {
                  const t = M(r, 1, o.zoom);
                  s = [t, t];
                } else s = o.pixelsToGLUnits;
                return {
                  u_camera_to_center_distance: o.cameraToCenterDistance,
                  u_matrix: e.translatePosMatrix(
                    n.projMatrix,
                    r,
                    i.paint.get("circle-translate"),
                    i.paint.get("circle-translate-anchor")
                  ),
                  u_device_pixel_ratio: t.exported.devicePixelRatio,
                  u_extrude_scale: s,
                };
              },
              Sn = (t) => {
                const e = [];
                return (
                  "map" === t.paint.get("circle-pitch-alignment") &&
                    e.push("PITCH_WITH_MAP"),
                  "map" === t.paint.get("circle-pitch-scale") &&
                    e.push("SCALE_WITH_MAP"),
                  e
                );
              },
              En = (e, n, r) => {
                const i = t.EXTENT / r.tileSize;
                return {
                  u_matrix: e,
                  u_camera_to_center_distance: n.cameraToCenterDistance,
                  u_extrude_scale: [
                    n.pixelsToGLUnits[0] / i,
                    n.pixelsToGLUnits[1] / i,
                  ],
                };
              },
              Tn = (t, e, n = 1) => ({
                u_matrix: t,
                u_color: e,
                u_overlay: 0,
                u_overlay_scale: n,
              }),
              An = (t, e, n, r) => ({
                u_matrix: t,
                u_extrude_scale: M(e, 1, n),
                u_intensity: r,
              }),
              Cn = (e, n, r, i) => {
                const o = e.transform;
                return {
                  u_matrix: In(e, n, r, i),
                  u_ratio: 1 / M(n, 1, o.zoom),
                  u_device_pixel_ratio: t.exported.devicePixelRatio,
                  u_units_to_pixels: [
                    1 / o.pixelsToGLUnits[0],
                    1 / o.pixelsToGLUnits[1],
                  ],
                };
              },
              Pn = (e, n, r, i, o) =>
                t.extend(Cn(e, n, r, i), { u_image: 0, u_image_height: o }),
              Mn = (e, n, r, i, o) => {
                const s = e.transform,
                  a = kn(n, s);
                return {
                  u_matrix: In(e, n, r, o),
                  u_texsize: n.imageAtlasTexture.size,
                  u_ratio: 1 / M(n, 1, s.zoom),
                  u_device_pixel_ratio: t.exported.devicePixelRatio,
                  u_image: 0,
                  u_scale: [a, i.fromScale, i.toScale],
                  u_fade: i.t,
                  u_units_to_pixels: [
                    1 / s.pixelsToGLUnits[0],
                    1 / s.pixelsToGLUnits[1],
                  ],
                };
              },
              On = (e, n, r, i, o) => {
                const s = kn(n, e.transform);
                return t.extend(Cn(e, n, r, o), {
                  u_texsize: n.lineAtlasTexture.size,
                  u_scale: [s, i.fromScale, i.toScale],
                  u_image: 0,
                  u_mix: i.t,
                });
              };
            function kn(t, e) {
              return 1 / M(t, 1, e.tileZoom);
            }
            function In(t, e, n, r) {
              return t.translatePosMatrix(
                r || e.tileID.projMatrix,
                e,
                n.paint.get("line-translate"),
                n.paint.get("line-translate-anchor")
              );
            }
            const Dn = (t, e, n, r, i) => {
              return {
                u_matrix: t,
                u_tl_parent: e,
                u_scale_parent: n,
                u_buffer_scale: 1,
                u_fade_t: r.mix,
                u_opacity: r.opacity * i.paint.get("raster-opacity"),
                u_image0: 0,
                u_image1: 1,
                u_brightness_low: i.paint.get("raster-brightness-min"),
                u_brightness_high: i.paint.get("raster-brightness-max"),
                u_saturation_factor:
                  ((s = i.paint.get("raster-saturation")),
                  s > 0 ? 1 - 1 / (1.001 - s) : -s),
                u_contrast_factor:
                  ((o = i.paint.get("raster-contrast")),
                  o > 0 ? 1 / (1 - o) : 1 + o),
                u_spin_weights: zn(i.paint.get("raster-hue-rotate")),
              };
              var o, s;
            };
            function zn(t) {
              t *= Math.PI / 180;
              const e = Math.sin(t),
                n = Math.cos(t);
              return [
                (2 * n + 1) / 3,
                (-Math.sqrt(3) * e - n + 1) / 3,
                (Math.sqrt(3) * e - n + 1) / 3,
              ];
            }
            const Rn = (t, e, n, r, i, o, s, a, l, c) => {
                const u = i.transform;
                return {
                  u_is_size_zoom_constant: +(
                    "constant" === t || "source" === t
                  ),
                  u_is_size_feature_constant: +(
                    "constant" === t || "camera" === t
                  ),
                  u_size_t: e ? e.uSizeT : 0,
                  u_size: e ? e.uSize : 0,
                  u_camera_to_center_distance: u.cameraToCenterDistance,
                  u_pitch: (u.pitch / 360) * 2 * Math.PI,
                  u_rotate_symbol: +n,
                  u_aspect_ratio: u.width / u.height,
                  u_fade_change: i.options.fadeDuration
                    ? i.symbolFadeChange
                    : 1,
                  u_matrix: o,
                  u_label_plane_matrix: s,
                  u_coord_matrix: a,
                  u_is_text: +l,
                  u_pitch_with_map: +r,
                  u_texsize: c,
                  u_texture: 0,
                };
              },
              Ln = (e, n, r, i, o, s, a, l, c, u, h) => {
                const { cameraToCenterDistance: p, _pitch: d } = o.transform;
                return t.extend(Rn(e, n, r, i, o, s, a, l, c, u), {
                  u_gamma_scale: i ? p * Math.cos(o.terrain ? 0 : d) : 1,
                  u_device_pixel_ratio: t.exported.devicePixelRatio,
                  u_is_halo: +h,
                });
              },
              Fn = (e, n, r, i, o, s, a, l, c, u) =>
                t.extend(Ln(e, n, r, i, o, s, a, l, !0, c, !0), {
                  u_texsize_icon: u,
                  u_texture_icon: 1,
                }),
              Bn = (t, e, n) => ({ u_matrix: t, u_opacity: e, u_color: n }),
              Nn = (e, n, r, i, o, s) =>
                t.extend(
                  (function (t, e, n, r) {
                    const i = n.imageManager.getPattern(t.from.toString()),
                      o = n.imageManager.getPattern(t.to.toString()),
                      { width: s, height: a } = n.imageManager.getPixelSize(),
                      l = Math.pow(2, r.tileID.overscaledZ),
                      c = (r.tileSize * Math.pow(2, n.transform.tileZoom)) / l,
                      u = c * (r.tileID.canonical.x + r.tileID.wrap * l),
                      h = c * r.tileID.canonical.y;
                    return {
                      u_image: 0,
                      u_pattern_tl_a: i.tl,
                      u_pattern_br_a: i.br,
                      u_pattern_tl_b: o.tl,
                      u_pattern_br_b: o.br,
                      u_texsize: [s, a],
                      u_mix: e.t,
                      u_pattern_size_a: i.displaySize,
                      u_pattern_size_b: o.displaySize,
                      u_scale_a: e.fromScale,
                      u_scale_b: e.toScale,
                      u_tile_units_to_pixels: 1 / M(r, 1, n.transform.tileZoom),
                      u_pixel_coord_upper: [u >> 16, h >> 16],
                      u_pixel_coord_lower: [65535 & u, 65535 & h],
                    };
                  })(i, s, r, o),
                  { u_matrix: e, u_opacity: n }
                ),
              jn = {
                fillExtrusion: (e, n) => ({
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_lightpos: new t.Uniform3f(e, n.u_lightpos),
                  u_lightintensity: new t.Uniform1f(e, n.u_lightintensity),
                  u_lightcolor: new t.Uniform3f(e, n.u_lightcolor),
                  u_vertical_gradient: new t.Uniform1f(
                    e,
                    n.u_vertical_gradient
                  ),
                  u_opacity: new t.Uniform1f(e, n.u_opacity),
                }),
                fillExtrusionPattern: (e, n) => ({
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_lightpos: new t.Uniform3f(e, n.u_lightpos),
                  u_lightintensity: new t.Uniform1f(e, n.u_lightintensity),
                  u_lightcolor: new t.Uniform3f(e, n.u_lightcolor),
                  u_vertical_gradient: new t.Uniform1f(
                    e,
                    n.u_vertical_gradient
                  ),
                  u_height_factor: new t.Uniform1f(e, n.u_height_factor),
                  u_image: new t.Uniform1i(e, n.u_image),
                  u_texsize: new t.Uniform2f(e, n.u_texsize),
                  u_pixel_coord_upper: new t.Uniform2f(
                    e,
                    n.u_pixel_coord_upper
                  ),
                  u_pixel_coord_lower: new t.Uniform2f(
                    e,
                    n.u_pixel_coord_lower
                  ),
                  u_scale: new t.Uniform3f(e, n.u_scale),
                  u_fade: new t.Uniform1f(e, n.u_fade),
                  u_opacity: new t.Uniform1f(e, n.u_opacity),
                }),
                fill: (e, n) => ({
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                }),
                fillPattern: (e, n) => ({
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_image: new t.Uniform1i(e, n.u_image),
                  u_texsize: new t.Uniform2f(e, n.u_texsize),
                  u_pixel_coord_upper: new t.Uniform2f(
                    e,
                    n.u_pixel_coord_upper
                  ),
                  u_pixel_coord_lower: new t.Uniform2f(
                    e,
                    n.u_pixel_coord_lower
                  ),
                  u_scale: new t.Uniform3f(e, n.u_scale),
                  u_fade: new t.Uniform1f(e, n.u_fade),
                }),
                fillOutline: (e, n) => ({
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_world: new t.Uniform2f(e, n.u_world),
                }),
                fillOutlinePattern: (e, n) => ({
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_world: new t.Uniform2f(e, n.u_world),
                  u_image: new t.Uniform1i(e, n.u_image),
                  u_texsize: new t.Uniform2f(e, n.u_texsize),
                  u_pixel_coord_upper: new t.Uniform2f(
                    e,
                    n.u_pixel_coord_upper
                  ),
                  u_pixel_coord_lower: new t.Uniform2f(
                    e,
                    n.u_pixel_coord_lower
                  ),
                  u_scale: new t.Uniform3f(e, n.u_scale),
                  u_fade: new t.Uniform1f(e, n.u_fade),
                }),
                circle: (e, n) => ({
                  u_camera_to_center_distance: new t.Uniform1f(
                    e,
                    n.u_camera_to_center_distance
                  ),
                  u_extrude_scale: new t.Uniform2f(e, n.u_extrude_scale),
                  u_device_pixel_ratio: new t.Uniform1f(
                    e,
                    n.u_device_pixel_ratio
                  ),
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                }),
                collisionBox: (e, n) => ({
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_camera_to_center_distance: new t.Uniform1f(
                    e,
                    n.u_camera_to_center_distance
                  ),
                  u_extrude_scale: new t.Uniform2f(e, n.u_extrude_scale),
                }),
                collisionCircle: (e, n) => ({
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_inv_matrix: new t.UniformMatrix4f(e, n.u_inv_matrix),
                  u_camera_to_center_distance: new t.Uniform1f(
                    e,
                    n.u_camera_to_center_distance
                  ),
                  u_viewport_size: new t.Uniform2f(e, n.u_viewport_size),
                }),
                debug: (e, n) => ({
                  u_color: new t.UniformColor(e, n.u_color),
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_overlay: new t.Uniform1i(e, n.u_overlay),
                  u_overlay_scale: new t.Uniform1f(e, n.u_overlay_scale),
                }),
                clippingMask: (e, n) => ({
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                }),
                heatmap: (e, n) => ({
                  u_extrude_scale: new t.Uniform1f(e, n.u_extrude_scale),
                  u_intensity: new t.Uniform1f(e, n.u_intensity),
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                }),
                heatmapTexture: (e, n) => ({
                  u_image: new t.Uniform1i(e, n.u_image),
                  u_color_ramp: new t.Uniform1i(e, n.u_color_ramp),
                  u_opacity: new t.Uniform1f(e, n.u_opacity),
                }),
                hillshade: (e, n) => ({
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_image: new t.Uniform1i(e, n.u_image),
                  u_latrange: new t.Uniform2f(e, n.u_latrange),
                  u_light: new t.Uniform2f(e, n.u_light),
                  u_shadow: new t.UniformColor(e, n.u_shadow),
                  u_highlight: new t.UniformColor(e, n.u_highlight),
                  u_accent: new t.UniformColor(e, n.u_accent),
                }),
                hillshadePrepare: (e, n) => ({
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_image: new t.Uniform1i(e, n.u_image),
                  u_dimension: new t.Uniform2f(e, n.u_dimension),
                  u_zoom: new t.Uniform1f(e, n.u_zoom),
                  u_unpack: new t.Uniform4f(e, n.u_unpack),
                }),
                line: (e, n) => ({
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_ratio: new t.Uniform1f(e, n.u_ratio),
                  u_device_pixel_ratio: new t.Uniform1f(
                    e,
                    n.u_device_pixel_ratio
                  ),
                  u_units_to_pixels: new t.Uniform2f(e, n.u_units_to_pixels),
                }),
                lineGradient: (e, n) => ({
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_ratio: new t.Uniform1f(e, n.u_ratio),
                  u_device_pixel_ratio: new t.Uniform1f(
                    e,
                    n.u_device_pixel_ratio
                  ),
                  u_units_to_pixels: new t.Uniform2f(e, n.u_units_to_pixels),
                  u_image: new t.Uniform1i(e, n.u_image),
                  u_image_height: new t.Uniform1f(e, n.u_image_height),
                }),
                linePattern: (e, n) => ({
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_texsize: new t.Uniform2f(e, n.u_texsize),
                  u_ratio: new t.Uniform1f(e, n.u_ratio),
                  u_device_pixel_ratio: new t.Uniform1f(
                    e,
                    n.u_device_pixel_ratio
                  ),
                  u_image: new t.Uniform1i(e, n.u_image),
                  u_units_to_pixels: new t.Uniform2f(e, n.u_units_to_pixels),
                  u_scale: new t.Uniform3f(e, n.u_scale),
                  u_fade: new t.Uniform1f(e, n.u_fade),
                }),
                lineSDF: (e, n) => ({
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_texsize: new t.Uniform2f(e, n.u_texsize),
                  u_ratio: new t.Uniform1f(e, n.u_ratio),
                  u_device_pixel_ratio: new t.Uniform1f(
                    e,
                    n.u_device_pixel_ratio
                  ),
                  u_units_to_pixels: new t.Uniform2f(e, n.u_units_to_pixels),
                  u_image: new t.Uniform1i(e, n.u_image),
                  u_scale: new t.Uniform3f(e, n.u_scale),
                  u_mix: new t.Uniform1f(e, n.u_mix),
                }),
                raster: (e, n) => ({
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_tl_parent: new t.Uniform2f(e, n.u_tl_parent),
                  u_scale_parent: new t.Uniform1f(e, n.u_scale_parent),
                  u_buffer_scale: new t.Uniform1f(e, n.u_buffer_scale),
                  u_fade_t: new t.Uniform1f(e, n.u_fade_t),
                  u_opacity: new t.Uniform1f(e, n.u_opacity),
                  u_image0: new t.Uniform1i(e, n.u_image0),
                  u_image1: new t.Uniform1i(e, n.u_image1),
                  u_brightness_low: new t.Uniform1f(e, n.u_brightness_low),
                  u_brightness_high: new t.Uniform1f(e, n.u_brightness_high),
                  u_saturation_factor: new t.Uniform1f(
                    e,
                    n.u_saturation_factor
                  ),
                  u_contrast_factor: new t.Uniform1f(e, n.u_contrast_factor),
                  u_spin_weights: new t.Uniform3f(e, n.u_spin_weights),
                }),
                symbolIcon: (e, n) => ({
                  u_is_size_zoom_constant: new t.Uniform1i(
                    e,
                    n.u_is_size_zoom_constant
                  ),
                  u_is_size_feature_constant: new t.Uniform1i(
                    e,
                    n.u_is_size_feature_constant
                  ),
                  u_size_t: new t.Uniform1f(e, n.u_size_t),
                  u_size: new t.Uniform1f(e, n.u_size),
                  u_camera_to_center_distance: new t.Uniform1f(
                    e,
                    n.u_camera_to_center_distance
                  ),
                  u_pitch: new t.Uniform1f(e, n.u_pitch),
                  u_rotate_symbol: new t.Uniform1i(e, n.u_rotate_symbol),
                  u_aspect_ratio: new t.Uniform1f(e, n.u_aspect_ratio),
                  u_fade_change: new t.Uniform1f(e, n.u_fade_change),
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_label_plane_matrix: new t.UniformMatrix4f(
                    e,
                    n.u_label_plane_matrix
                  ),
                  u_coord_matrix: new t.UniformMatrix4f(e, n.u_coord_matrix),
                  u_is_text: new t.Uniform1i(e, n.u_is_text),
                  u_pitch_with_map: new t.Uniform1i(e, n.u_pitch_with_map),
                  u_texsize: new t.Uniform2f(e, n.u_texsize),
                  u_texture: new t.Uniform1i(e, n.u_texture),
                }),
                symbolSDF: (e, n) => ({
                  u_is_size_zoom_constant: new t.Uniform1i(
                    e,
                    n.u_is_size_zoom_constant
                  ),
                  u_is_size_feature_constant: new t.Uniform1i(
                    e,
                    n.u_is_size_feature_constant
                  ),
                  u_size_t: new t.Uniform1f(e, n.u_size_t),
                  u_size: new t.Uniform1f(e, n.u_size),
                  u_camera_to_center_distance: new t.Uniform1f(
                    e,
                    n.u_camera_to_center_distance
                  ),
                  u_pitch: new t.Uniform1f(e, n.u_pitch),
                  u_rotate_symbol: new t.Uniform1i(e, n.u_rotate_symbol),
                  u_aspect_ratio: new t.Uniform1f(e, n.u_aspect_ratio),
                  u_fade_change: new t.Uniform1f(e, n.u_fade_change),
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_label_plane_matrix: new t.UniformMatrix4f(
                    e,
                    n.u_label_plane_matrix
                  ),
                  u_coord_matrix: new t.UniformMatrix4f(e, n.u_coord_matrix),
                  u_is_text: new t.Uniform1i(e, n.u_is_text),
                  u_pitch_with_map: new t.Uniform1i(e, n.u_pitch_with_map),
                  u_texsize: new t.Uniform2f(e, n.u_texsize),
                  u_texture: new t.Uniform1i(e, n.u_texture),
                  u_gamma_scale: new t.Uniform1f(e, n.u_gamma_scale),
                  u_device_pixel_ratio: new t.Uniform1f(
                    e,
                    n.u_device_pixel_ratio
                  ),
                  u_is_halo: new t.Uniform1i(e, n.u_is_halo),
                }),
                symbolTextAndIcon: (e, n) => ({
                  u_is_size_zoom_constant: new t.Uniform1i(
                    e,
                    n.u_is_size_zoom_constant
                  ),
                  u_is_size_feature_constant: new t.Uniform1i(
                    e,
                    n.u_is_size_feature_constant
                  ),
                  u_size_t: new t.Uniform1f(e, n.u_size_t),
                  u_size: new t.Uniform1f(e, n.u_size),
                  u_camera_to_center_distance: new t.Uniform1f(
                    e,
                    n.u_camera_to_center_distance
                  ),
                  u_pitch: new t.Uniform1f(e, n.u_pitch),
                  u_rotate_symbol: new t.Uniform1i(e, n.u_rotate_symbol),
                  u_aspect_ratio: new t.Uniform1f(e, n.u_aspect_ratio),
                  u_fade_change: new t.Uniform1f(e, n.u_fade_change),
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_label_plane_matrix: new t.UniformMatrix4f(
                    e,
                    n.u_label_plane_matrix
                  ),
                  u_coord_matrix: new t.UniformMatrix4f(e, n.u_coord_matrix),
                  u_is_text: new t.Uniform1i(e, n.u_is_text),
                  u_pitch_with_map: new t.Uniform1i(e, n.u_pitch_with_map),
                  u_texsize: new t.Uniform2f(e, n.u_texsize),
                  u_texsize_icon: new t.Uniform2f(e, n.u_texsize_icon),
                  u_texture: new t.Uniform1i(e, n.u_texture),
                  u_texture_icon: new t.Uniform1i(e, n.u_texture_icon),
                  u_gamma_scale: new t.Uniform1f(e, n.u_gamma_scale),
                  u_device_pixel_ratio: new t.Uniform1f(
                    e,
                    n.u_device_pixel_ratio
                  ),
                  u_is_halo: new t.Uniform1i(e, n.u_is_halo),
                }),
                background: (e, n) => ({
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_opacity: new t.Uniform1f(e, n.u_opacity),
                  u_color: new t.UniformColor(e, n.u_color),
                }),
                backgroundPattern: (e, n) => ({
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_opacity: new t.Uniform1f(e, n.u_opacity),
                  u_image: new t.Uniform1i(e, n.u_image),
                  u_pattern_tl_a: new t.Uniform2f(e, n.u_pattern_tl_a),
                  u_pattern_br_a: new t.Uniform2f(e, n.u_pattern_br_a),
                  u_pattern_tl_b: new t.Uniform2f(e, n.u_pattern_tl_b),
                  u_pattern_br_b: new t.Uniform2f(e, n.u_pattern_br_b),
                  u_texsize: new t.Uniform2f(e, n.u_texsize),
                  u_mix: new t.Uniform1f(e, n.u_mix),
                  u_pattern_size_a: new t.Uniform2f(e, n.u_pattern_size_a),
                  u_pattern_size_b: new t.Uniform2f(e, n.u_pattern_size_b),
                  u_scale_a: new t.Uniform1f(e, n.u_scale_a),
                  u_scale_b: new t.Uniform1f(e, n.u_scale_b),
                  u_pixel_coord_upper: new t.Uniform2f(
                    e,
                    n.u_pixel_coord_upper
                  ),
                  u_pixel_coord_lower: new t.Uniform2f(
                    e,
                    n.u_pixel_coord_lower
                  ),
                  u_tile_units_to_pixels: new t.Uniform1f(
                    e,
                    n.u_tile_units_to_pixels
                  ),
                }),
                terrainRaster: nn,
                terrainDepth: nn,
                skybox: (e, n) => ({
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_sun_direction: new t.Uniform3f(e, n.u_sun_direction),
                  u_cubemap: new t.Uniform1i(e, n.u_cubemap),
                  u_opacity: new t.Uniform1f(e, n.u_opacity),
                  u_temporal_offset: new t.Uniform1f(e, n.u_temporal_offset),
                }),
                skyboxGradient: (e, n) => ({
                  u_matrix: new t.UniformMatrix4f(e, n.u_matrix),
                  u_color_ramp: new t.Uniform1i(e, n.u_color_ramp),
                  u_center_direction: new t.Uniform3f(e, n.u_center_direction),
                  u_radius: new t.Uniform1f(e, n.u_radius),
                  u_opacity: new t.Uniform1f(e, n.u_opacity),
                  u_temporal_offset: new t.Uniform1f(e, n.u_temporal_offset),
                }),
                skyboxCapture: (e, n) => ({
                  u_matrix_3f: new t.UniformMatrix3f(e, n.u_matrix_3f),
                  u_sun_direction: new t.Uniform3f(e, n.u_sun_direction),
                  u_sun_intensity: new t.Uniform1f(e, n.u_sun_intensity),
                  u_color_tint_r: new t.Uniform4f(e, n.u_color_tint_r),
                  u_color_tint_m: new t.Uniform4f(e, n.u_color_tint_m),
                  u_luminance: new t.Uniform1f(e, n.u_luminance),
                }),
              };
            let Un;
            function Zn(e, n, r, i, o, s, a) {
              const l = e.context,
                c = l.gl,
                u = e.useProgram("collisionBox"),
                h = [];
              let p = 0,
                d = 0;
              for (let b = 0; b < i.length; b++) {
                const f = i[b],
                  m = n.getTile(f),
                  g = m.getBucket(r);
                if (!g) continue;
                let y = f.projMatrix;
                (0 === o[0] && 0 === o[1]) ||
                  (y = e.translatePosMatrix(f.projMatrix, m, o, s));
                const _ = a ? g.textCollisionBox : g.iconCollisionBox,
                  v = g.collisionCircleArray;
                if (v.length > 0) {
                  const n = t.create$1(),
                    r = y;
                  t.mul$1(
                    n,
                    g.placementInvProjMatrix,
                    e.transform.glCoordMatrix
                  ),
                    t.mul$1(n, n, g.placementViewportMatrix),
                    h.push({
                      circleArray: v,
                      circleOffset: d,
                      transform: r,
                      invTransform: n,
                    }),
                    (p += v.length / 4),
                    (d = p);
                }
                _ &&
                  (e.terrain && e.terrain.setupElevationDraw(m, u),
                  u.draw(
                    l,
                    c.LINES,
                    t.DepthMode.disabled,
                    t.StencilMode.disabled,
                    e.colorModeForRenderPass(),
                    t.CullFaceMode.disabled,
                    En(y, e.transform, m),
                    r.id,
                    _.layoutVertexBuffer,
                    _.indexBuffer,
                    _.segments,
                    null,
                    e.transform.zoom,
                    null,
                    _.collisionVertexBuffer,
                    _.collisionVertexBufferExt
                  ));
              }
              if (!a || !h.length) return;
              const f = e.useProgram("collisionCircle"),
                m = new t.StructArrayLayout2f1f2i16();
              m.resize(4 * p), m._trim();
              let g = 0;
              for (const t of h)
                for (let e = 0; e < t.circleArray.length / 4; e++) {
                  const n = 4 * e,
                    r = t.circleArray[n + 0],
                    i = t.circleArray[n + 1],
                    o = t.circleArray[n + 2],
                    s = t.circleArray[n + 3];
                  m.emplace(g++, r, i, o, s, 0),
                    m.emplace(g++, r, i, o, s, 1),
                    m.emplace(g++, r, i, o, s, 2),
                    m.emplace(g++, r, i, o, s, 3);
                }
              (!Un || Un.length < 2 * p) &&
                (Un = (function (e) {
                  const n = 2 * e,
                    r = new t.StructArrayLayout3ui6();
                  r.resize(n), r._trim();
                  for (let t = 0; t < n; t++) {
                    const e = 6 * t;
                    (r.uint16[e + 0] = 4 * t + 0),
                      (r.uint16[e + 1] = 4 * t + 1),
                      (r.uint16[e + 2] = 4 * t + 2),
                      (r.uint16[e + 3] = 4 * t + 2),
                      (r.uint16[e + 4] = 4 * t + 3),
                      (r.uint16[e + 5] = 4 * t + 0);
                  }
                  return r;
                })(p));
              const y = l.createIndexBuffer(Un, !0),
                _ = l.createVertexBuffer(
                  m,
                  t.collisionCircleLayout.members,
                  !0
                );
              for (const b of h) {
                const n = {
                  u_matrix: b.transform,
                  u_inv_matrix: b.invTransform,
                  u_camera_to_center_distance: (v = e.transform)
                    .cameraToCenterDistance,
                  u_viewport_size: [v.width, v.height],
                };
                f.draw(
                  l,
                  c.TRIANGLES,
                  t.DepthMode.disabled,
                  t.StencilMode.disabled,
                  e.colorModeForRenderPass(),
                  t.CullFaceMode.disabled,
                  n,
                  r.id,
                  _,
                  y,
                  t.SegmentVector.simpleSegment(
                    0,
                    2 * b.circleOffset,
                    b.circleArray.length,
                    b.circleArray.length / 2
                  ),
                  null,
                  e.transform.zoom,
                  null,
                  null,
                  null
                );
              }
              var v;
              _.destroy(), y.destroy();
            }
            const Vn = t.identity(new Float32Array(16));
            function qn(e, n, r, i, o, s) {
              const { horizontalAlign: a, verticalAlign: l } =
                  t.getAnchorAlignment(e),
                c = -(a - 0.5) * n,
                u = -(l - 0.5) * r,
                h = t.evaluateVariableOffset(e, i);
              return new t.pointGeometry(
                (c / o + h[0]) * s,
                (u / o + h[1]) * s
              );
            }
            function $n(e, n, r, i, o, s, a, l, c, u, h, p) {
              const d = e.text.placedSymbolArray,
                f = e.text.dynamicLayoutVertexArray,
                m = e.icon.dynamicLayoutVertexArray,
                g = {};
              f.clear();
              for (let y = 0; y < d.length; y++) {
                const m = d.get(y),
                  _ = e.allowVerticalPlacement && !m.placedOrientation,
                  v = m.hidden || !m.crossTileID || _ ? null : i[m.crossTileID];
                if (v) {
                  const i = new t.pointGeometry(m.anchorX, m.anchorY),
                    d = p(i),
                    y = Yt(i, r ? l : a, d),
                    _ = Qt(
                      s.cameraToCenterDistance,
                      y.signedDistanceFromCamera
                    );
                  let b =
                    (o.evaluateSizeForFeature(e.textSizeData, u, m) * _) /
                    t.ONE_EM;
                  r && (b *= e.tilePixelRatio / c);
                  const {
                      width: x,
                      height: w,
                      anchor: S,
                      textOffset: E,
                      textScale: T,
                    } = v,
                    A = qn(S, x, w, E, T, b),
                    C = r
                      ? Yt(i.add(A), a, d).point
                      : y.point.add(n ? A.rotate(-s.angle) : A),
                    P =
                      e.allowVerticalPlacement &&
                      m.placedOrientation === t.WritingMode.vertical
                        ? Math.PI / 2
                        : 0;
                  for (let e = 0; e < m.numGlyphs; e++)
                    t.addDynamicAttributes(f, C, P);
                  h &&
                    m.associatedIconIndex >= 0 &&
                    (g[m.associatedIconIndex] = { shiftedAnchor: C, angle: P });
                } else ae(m.numGlyphs, f);
              }
              if (h) {
                m.clear();
                const n = e.icon.placedSymbolArray;
                for (let e = 0; e < n.length; e++) {
                  const r = n.get(e);
                  if (r.hidden) ae(r.numGlyphs, m);
                  else {
                    const n = g[e];
                    if (n)
                      for (let e = 0; e < r.numGlyphs; e++)
                        t.addDynamicAttributes(m, n.shiftedAnchor, n.angle);
                    else ae(r.numGlyphs, m);
                  }
                }
                e.icon.dynamicLayoutVertexBuffer.updateData(m);
              }
              e.text.dynamicLayoutVertexBuffer.updateData(f);
            }
            function Gn(t, e, n) {
              return n.iconsInText && e
                ? "symbolTextAndIcon"
                : t
                ? "symbolSDF"
                : "symbolIcon";
            }
            function Wn(e, n, r, i, o, s, a, l, c, u, h, p) {
              const d = e.context,
                f = d.gl,
                m = e.transform,
                g = "map" === l,
                y = "map" === c,
                _ = g && "point" !== r.layout.get("symbol-placement"),
                v = g && !y && !_,
                b = void 0 !== r.layout.get("symbol-sort-key").constantOr(1);
              let x = !1;
              const w = e.depthModeForSublayer(0, t.DepthMode.ReadOnly),
                S = r.layout.get("text-variable-anchor"),
                E = [],
                T = e.terrain && y ? ["PITCH_WITH_MAP_TERRAIN"] : null;
              for (const A of i) {
                const i = n.getTile(A),
                  l = i.getBucket(r);
                if (!l) continue;
                const c = o ? l.text : l.icon;
                if (!c || !c.segments.get().length) continue;
                const h = c.programConfigurations.get(r.id),
                  p = o || l.sdfIcons,
                  d = o ? l.textSizeData : l.iconSizeData,
                  w = y || 0 !== m.pitch,
                  C = e.useProgram(Gn(p, o, l), h, T),
                  P = t.evaluateSizeForZoom(d, m.zoom);
                let O,
                  k,
                  I,
                  D,
                  z = [0, 0],
                  R = null;
                if (o) {
                  if (
                    ((k = i.glyphAtlasTexture),
                    (I = f.LINEAR),
                    (O = i.glyphAtlasTexture.size),
                    l.iconsInText)
                  ) {
                    (z = i.imageAtlasTexture.size), (R = i.imageAtlasTexture);
                    const t = "composite" === d.kind || "camera" === d.kind;
                    D =
                      w || e.options.rotating || e.options.zooming || t
                        ? f.LINEAR
                        : f.NEAREST;
                  }
                } else {
                  const t =
                    1 !== r.layout.get("icon-size").constantOr(0) ||
                    l.iconsNeedLinear;
                  (k = i.imageAtlasTexture),
                    (I =
                      p || e.options.rotating || e.options.zooming || t || w
                        ? f.LINEAR
                        : f.NEAREST),
                    (O = i.imageAtlasTexture.size);
                }
                const L = M(i, 1, e.transform.zoom),
                  F = Xt(A.projMatrix, y, g, e.transform, L),
                  B =
                    e.terrain && y && _
                      ? t.invert(new Float32Array(16), F)
                      : Vn,
                  N = Kt(A.projMatrix, y, g, e.transform, L),
                  j = S && l.hasTextData(),
                  U =
                    "none" !== r.layout.get("icon-text-fit") &&
                    j &&
                    l.hasIconData();
                if (_) {
                  const t = m.elevation;
                  te(
                    l,
                    A.projMatrix,
                    e,
                    o,
                    F,
                    N,
                    y,
                    u,
                    t ? (e) => t.getAtTileOffset(A, e.x, e.y) : null
                  );
                }
                const Z = e.translatePosMatrix(A.projMatrix, i, s, a),
                  V = _ || (o && S) || U ? Vn : F,
                  q = e.translatePosMatrix(N, i, s, a, !0),
                  $ =
                    p &&
                    0 !==
                      r.paint
                        .get(o ? "text-halo-width" : "icon-halo-width")
                        .constantOr(1);
                let G;
                G = p
                  ? l.iconsInText
                    ? Fn(d.kind, P, v, y, e, Z, V, q, O, z)
                    : Ln(d.kind, P, v, y, e, Z, V, q, o, O, !0)
                  : Rn(d.kind, P, v, y, e, Z, V, q, o, O);
                const W = {
                  program: C,
                  buffers: c,
                  uniformValues: G,
                  atlasTexture: k,
                  atlasTextureIcon: R,
                  atlasInterpolation: I,
                  atlasInterpolationIcon: D,
                  isSDF: p,
                  hasHalo: $,
                  tile: i,
                  labelPlaneMatrixInv: B,
                };
                if (b && l.canOverlap) {
                  x = !0;
                  const e = c.segments.get();
                  for (const n of e)
                    E.push({
                      segments: new t.SegmentVector([n]),
                      sortKey: n.sortKey,
                      state: W,
                    });
                } else E.push({ segments: c.segments, sortKey: 0, state: W });
              }
              x && E.sort((t, e) => t.sortKey - e.sortKey);
              for (const t of E) {
                const n = t.state;
                if (
                  (e.terrain &&
                    e.terrain.setupElevationDraw(n.tile, n.program, {
                      useDepthForOcclusion: !0,
                      labelPlaneMatrixInv: n.labelPlaneMatrixInv,
                    }),
                  d.activeTexture.set(f.TEXTURE0),
                  n.atlasTexture.bind(n.atlasInterpolation, f.CLAMP_TO_EDGE),
                  n.atlasTextureIcon &&
                    (d.activeTexture.set(f.TEXTURE1),
                    n.atlasTextureIcon &&
                      n.atlasTextureIcon.bind(
                        n.atlasInterpolationIcon,
                        f.CLAMP_TO_EDGE
                      )),
                  n.isSDF)
                ) {
                  const i = n.uniformValues;
                  n.hasHalo &&
                    ((i.u_is_halo = 1),
                    Hn(n.buffers, t.segments, r, e, n.program, w, h, p, i)),
                    (i.u_is_halo = 0);
                }
                Hn(
                  n.buffers,
                  t.segments,
                  r,
                  e,
                  n.program,
                  w,
                  h,
                  p,
                  n.uniformValues
                );
              }
            }
            function Hn(e, n, r, i, o, s, a, l, c) {
              const u = i.context;
              o.draw(
                u,
                u.gl.TRIANGLES,
                s,
                a,
                l,
                t.CullFaceMode.disabled,
                c,
                r.id,
                e.layoutVertexBuffer,
                e.indexBuffer,
                n,
                r.paint,
                i.transform.zoom,
                e.programConfigurations.get(r.id),
                e.dynamicLayoutVertexBuffer,
                e.opacityVertexBuffer
              );
            }
            function Xn(e, n, r, i, o, s, a) {
              const l = e.context.gl,
                c = r.paint.get("fill-pattern"),
                u = c && c.constantOr(1),
                h = r.getCrossfadeParameters();
              let p, d, f, m, g;
              a
                ? ((d =
                    u && !r.getPaintProperty("fill-outline-color")
                      ? "fillOutlinePattern"
                      : "fillOutline"),
                  (p = l.LINES))
                : ((d = u ? "fillPattern" : "fill"), (p = l.TRIANGLES));
              for (const y of i) {
                const i = n.getTile(y);
                if (u && !i.patternsLoaded()) continue;
                const _ = i.getBucket(r);
                if (!_) continue;
                e.prepareDrawTile(y);
                const v = _.programConfigurations.get(r.id),
                  b = e.useProgram(d, v);
                u &&
                  (e.context.activeTexture.set(l.TEXTURE0),
                  i.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE),
                  v.updatePaintBuffers(h));
                const x = c.constantOr(null);
                if (x && i.imageAtlas) {
                  const t = i.imageAtlas,
                    e = t.patternPositions[x.to.toString()],
                    n = t.patternPositions[x.from.toString()];
                  e && n && v.setConstantPatternPositions(e, n);
                }
                const w = e.translatePosMatrix(
                  y.projMatrix,
                  i,
                  r.paint.get("fill-translate"),
                  r.paint.get("fill-translate-anchor")
                );
                if (a) {
                  (m = _.indexBuffer2), (g = _.segments2);
                  const t =
                    e.terrain && e.terrain.renderingToTexture
                      ? e.terrain.drapeBufferSize
                      : [l.drawingBufferWidth, l.drawingBufferHeight];
                  f =
                    "fillOutlinePattern" === d && u
                      ? xn(w, e, h, i, t)
                      : bn(w, t);
                } else
                  (m = _.indexBuffer),
                    (g = _.segments),
                    (f = u ? vn(w, e, h, i) : _n(w));
                e.prepareDrawProgram(e.context, b, y.toUnwrapped()),
                  b.draw(
                    e.context,
                    p,
                    o,
                    e.stencilModeForClipping(y),
                    s,
                    t.CullFaceMode.disabled,
                    f,
                    r.id,
                    _.layoutVertexBuffer,
                    m,
                    g,
                    r.paint,
                    e.transform.zoom,
                    v
                  );
              }
            }
            function Kn(e, n, r, i, o, s, a) {
              const l = e.context,
                c = l.gl,
                u = r.paint.get("fill-extrusion-pattern"),
                h = u.constantOr(1),
                p = r.getCrossfadeParameters(),
                d = r.paint.get("fill-extrusion-opacity");
              for (const f of i) {
                const i = n.getTile(f),
                  m = i.getBucket(r);
                if (!m) continue;
                const g = m.programConfigurations.get(r.id),
                  y = e.useProgram(
                    h ? "fillExtrusionPattern" : "fillExtrusion",
                    g
                  );
                if (e.terrain) {
                  const t = e.terrain;
                  if (!m.enableTerrain) continue;
                  if (
                    (t.setupElevationDraw(i, y, { useMeterToDem: !0 }),
                    Yn(l, n, f, m, r, t),
                    !m.centroidVertexBuffer)
                  ) {
                    const t = y.attributes.a_centroid_pos;
                    void 0 !== t && c.vertexAttrib2f(t, 0, 0);
                  }
                }
                h &&
                  (e.context.activeTexture.set(c.TEXTURE0),
                  i.imageAtlasTexture.bind(c.LINEAR, c.CLAMP_TO_EDGE),
                  g.updatePaintBuffers(p));
                const _ = u.constantOr(null);
                if (_ && i.imageAtlas) {
                  const t = i.imageAtlas,
                    e = t.patternPositions[_.to.toString()],
                    n = t.patternPositions[_.from.toString()];
                  e && n && g.setConstantPatternPositions(e, n);
                }
                const v = e.translatePosMatrix(
                    f.projMatrix,
                    i,
                    r.paint.get("fill-extrusion-translate"),
                    r.paint.get("fill-extrusion-translate-anchor")
                  ),
                  b = r.paint.get("fill-extrusion-vertical-gradient"),
                  x = h ? yn(v, e, b, d, f, p, i) : gn(v, e, b, d);
                e.prepareDrawProgram(l, y, f.toUnwrapped()),
                  y.draw(
                    l,
                    l.gl.TRIANGLES,
                    o,
                    s,
                    a,
                    t.CullFaceMode.backCCW,
                    x,
                    r.id,
                    m.layoutVertexBuffer,
                    m.indexBuffer,
                    m.segments,
                    r.paint,
                    e.transform.zoom,
                    g,
                    e.terrain ? m.centroidVertexBuffer : null
                  );
              }
            }
            function Yn(e, n, r, i, o, s) {
              const a = [
                  (e) => {
                    let n = e.canonical.x - 1,
                      r = e.wrap;
                    return (
                      n < 0 && ((n = (1 << e.canonical.z) - 1), r--),
                      new t.OverscaledTileID(
                        e.overscaledZ,
                        r,
                        e.canonical.z,
                        n,
                        e.canonical.y
                      )
                    );
                  },
                  (e) => {
                    let n = e.canonical.x + 1,
                      r = e.wrap;
                    return (
                      n === 1 << e.canonical.z && ((n = 0), r++),
                      new t.OverscaledTileID(
                        e.overscaledZ,
                        r,
                        e.canonical.z,
                        n,
                        e.canonical.y
                      )
                    );
                  },
                  (e) =>
                    new t.OverscaledTileID(
                      e.overscaledZ,
                      e.wrap,
                      e.canonical.z,
                      e.canonical.x,
                      (0 === e.canonical.y
                        ? 1 << e.canonical.z
                        : e.canonical.y) - 1
                    ),
                  (e) =>
                    new t.OverscaledTileID(
                      e.overscaledZ,
                      e.wrap,
                      e.canonical.z,
                      e.canonical.x,
                      e.canonical.y === (1 << e.canonical.z) - 1
                        ? 0
                        : e.canonical.y + 1
                    ),
                ],
                l = (t) => {
                  const e = n.getSource().maxzoom,
                    r = (t) => {
                      const e = n.getTileByID(t);
                      if (e && e.hasData()) return e.getBucket(o);
                    };
                  let i, s, a;
                  return (
                    (t.overscaledZ === t.canonical.z || t.overscaledZ >= e) &&
                      (i = r(t.key)),
                    t.overscaledZ >= e &&
                      (s = r(t.calculateScaledKey(t.overscaledZ + 1))),
                    t.overscaledZ > e &&
                      (a = r(t.calculateScaledKey(t.overscaledZ - 1))),
                    i || s || a
                  );
                },
                c = [0, 0, 0],
                u = (e, n) => (
                  (c[0] = Math.min(e.min.y, n.min.y)),
                  (c[1] = Math.max(e.max.y, n.max.y)),
                  (c[2] =
                    t.EXTENT - n.min.x > e.max.x
                      ? n.min.x - t.EXTENT
                      : e.max.x),
                  c
                ),
                h = (e, n) => (
                  (c[0] = Math.min(e.min.x, n.min.x)),
                  (c[1] = Math.max(e.max.x, n.max.x)),
                  (c[2] =
                    t.EXTENT - n.min.y > e.max.y
                      ? n.min.y - t.EXTENT
                      : e.max.y),
                  c
                ),
                p = [
                  (t, e) => u(t, e),
                  (t, e) => u(e, t),
                  (t, e) => h(t, e),
                  (t, e) => h(e, t),
                ],
                d = new t.pointGeometry(0, 0);
              let f, m, g;
              const y = (e, n, i, o, a) => {
                const l = [
                    [o ? i : e, o ? e : i, 0],
                    [o ? i : n, o ? n : i, 0],
                  ],
                  c = a < 0 ? t.EXTENT + a : a,
                  u = [o ? c : (e + n) / 2, o ? (e + n) / 2 : c, 0];
                return (
                  (0 === i && a < 0) || (0 !== i && a > 0)
                    ? s.getForTilePoints(g, [u], !0, m)
                    : l.push(u),
                  s.getForTilePoints(r, l, !0, f),
                  Math.max(l[0][2], l[1][2], u[2]) / s.exaggeration()
                );
              };
              for (let _ = 0; _ < 4; _++) {
                const e = i.borders[_];
                if ((0 === e.length && (i.borderDone[_] = !0), i.borderDone[_]))
                  continue;
                const n = (g = a[_](r)),
                  o = l(n);
                if (!o || !o.enableTerrain) continue;
                if (((m = s.findDEMTileFor(n)), !m || !m.dem)) continue;
                if (!f) {
                  const t = s.findDEMTileFor(r);
                  if (!t || !t.dem) return;
                  f = t;
                }
                const c = (_ < 2 ? 1 : 5) - _,
                  u = o.borders[c];
                let h = 0;
                for (let r = 0; r < e.length; r++) {
                  const n = i.featuresOnBorder[e[r]],
                    s = n.borders[_];
                  let a;
                  for (
                    ;
                    h < u.length &&
                    ((a = o.featuresOnBorder[u[h]]),
                    !(a.borders[c][1] > s[0] + 3));

                  )
                    o.borderDone[c] || o.encodeCentroid(void 0, a, !1), h++;
                  if (a && h < u.length) {
                    const e = h;
                    let r = 0;
                    for (
                      ;
                      !(a.borders[c][0] > s[1] - 3) && (r++, ++h !== u.length);

                    )
                      a = o.featuresOnBorder[u[h]];
                    if (
                      ((a = o.featuresOnBorder[u[e]]),
                      n.intersectsCount() > 1 ||
                        a.intersectsCount() > 1 ||
                        1 !== r)
                    ) {
                      1 !== r && (h = e),
                        i.encodeCentroid(void 0, n, !1),
                        o.borderDone[c] || o.encodeCentroid(void 0, a, !1);
                      continue;
                    }
                    const l = p[_](n, a),
                      f = _ % 2 ? t.EXTENT - 1 : 0;
                    (d.x = y(
                      l[0],
                      Math.min(t.EXTENT - 1, l[1]),
                      f,
                      _ < 2,
                      l[2]
                    )),
                      (d.y = 0),
                      i.encodeCentroid(d, n, !1),
                      o.borderDone[c] || o.encodeCentroid(d, a, !1);
                  } else i.encodeCentroid(void 0, n, !1);
                }
                (i.borderDone[_] = i.needsCentroidUpdate = !0),
                  o.borderDone[c] ||
                    (o.borderDone[c] = o.needsCentroidUpdate = !0);
              }
              (i.needsCentroidUpdate ||
                (!i.centroidVertexBuffer &&
                  0 !== i.centroidVertexArray.length)) &&
                i.uploadCentroid(e);
            }
            const Qn = new t.Color(1, 0, 0, 1),
              Jn = new t.Color(0, 1, 0, 1),
              tr = new t.Color(0, 0, 1, 1),
              er = new t.Color(1, 0, 1, 1),
              nr = new t.Color(0, 1, 1, 1);
            function rr(t, e, n, r) {
              or(t, 0, e + n / 2, t.transform.width, n, r);
            }
            function ir(t, e, n, r) {
              or(t, e - n / 2, 0, n, t.transform.height, r);
            }
            function or(e, n, r, i, o, s) {
              const a = e.context,
                l = a.gl;
              l.enable(l.SCISSOR_TEST),
                l.scissor(
                  n * t.exported.devicePixelRatio,
                  r * t.exported.devicePixelRatio,
                  i * t.exported.devicePixelRatio,
                  o * t.exported.devicePixelRatio
                ),
                a.clear({ color: s }),
                l.disable(l.SCISSOR_TEST);
            }
            function sr(e, n, r) {
              const i = e.context,
                o = i.gl,
                s = r.projMatrix,
                a = e.useProgram("debug"),
                l = n.getTileByID(r.key);
              e.terrain && e.terrain.setupElevationDraw(l, a);
              const c = t.DepthMode.disabled,
                u = t.StencilMode.disabled,
                h = e.colorModeForRenderPass(),
                p = "$debug";
              i.activeTexture.set(o.TEXTURE0),
                e.emptyTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE),
                a.draw(
                  i,
                  o.LINE_STRIP,
                  c,
                  u,
                  h,
                  t.CullFaceMode.disabled,
                  Tn(s, t.Color.red),
                  p,
                  e.debugBuffer,
                  e.tileBorderIndexBuffer,
                  e.debugSegments
                );
              const d = l.latestRawTileData,
                f = Math.floor(((d && d.byteLength) || 0) / 1024),
                m = n.getTile(r).tileSize,
                g =
                  (512 / Math.min(m, 512)) *
                  (r.overscaledZ / e.transform.zoom) *
                  0.5;
              let y = r.canonical.toString();
              r.overscaledZ !== r.canonical.z && (y += ` => ${r.overscaledZ}`),
                (function (t, e) {
                  t.initDebugOverlayCanvas();
                  const n = t.debugOverlayCanvas,
                    r = t.context.gl,
                    i = t.debugOverlayCanvas.getContext("2d");
                  i.clearRect(0, 0, n.width, n.height),
                    (i.shadowColor = "white"),
                    (i.shadowBlur = 2),
                    (i.lineWidth = 1.5),
                    (i.strokeStyle = "white"),
                    (i.textBaseline = "top"),
                    (i.font = "bold 36px Open Sans, sans-serif"),
                    i.fillText(e, 5, 5),
                    i.strokeText(e, 5, 5),
                    t.debugOverlayTexture.update(n),
                    t.debugOverlayTexture.bind(r.LINEAR, r.CLAMP_TO_EDGE);
                })(e, `${y} ${f}kb`),
                a.draw(
                  i,
                  o.TRIANGLES,
                  c,
                  u,
                  t.ColorMode.alphaBlended,
                  t.CullFaceMode.disabled,
                  Tn(s, t.Color.transparent, g),
                  p,
                  e.debugBuffer,
                  e.quadTriangleIndexBuffer,
                  e.debugSegments
                );
            }
            const ar = t.createLayout([
                { name: "a_pos_3f", components: 3, type: "Float32" },
              ]),
              { members: lr } = ar;
            function cr(t, e, n, r) {
              t.emplaceBack(e, n, r);
            }
            class ur {
              constructor(e) {
                (this.vertexArray = new t.StructArrayLayout3f12()),
                  (this.indices = new t.StructArrayLayout3ui6()),
                  cr(this.vertexArray, -1, -1, 1),
                  cr(this.vertexArray, 1, -1, 1),
                  cr(this.vertexArray, -1, 1, 1),
                  cr(this.vertexArray, 1, 1, 1),
                  cr(this.vertexArray, -1, -1, -1),
                  cr(this.vertexArray, 1, -1, -1),
                  cr(this.vertexArray, -1, 1, -1),
                  cr(this.vertexArray, 1, 1, -1),
                  this.indices.emplaceBack(5, 1, 3),
                  this.indices.emplaceBack(3, 7, 5),
                  this.indices.emplaceBack(6, 2, 0),
                  this.indices.emplaceBack(0, 4, 6),
                  this.indices.emplaceBack(2, 6, 7),
                  this.indices.emplaceBack(7, 3, 2),
                  this.indices.emplaceBack(5, 4, 0),
                  this.indices.emplaceBack(0, 1, 5),
                  this.indices.emplaceBack(0, 2, 3),
                  this.indices.emplaceBack(3, 1, 0),
                  this.indices.emplaceBack(7, 6, 4),
                  this.indices.emplaceBack(4, 5, 7),
                  (this.vertexBuffer = e.createVertexBuffer(
                    this.vertexArray,
                    lr
                  )),
                  (this.indexBuffer = e.createIndexBuffer(this.indices)),
                  (this.segment = t.SegmentVector.simpleSegment(0, 0, 36, 12));
              }
            }
            function hr(e, n, r, i, o, s) {
              const a = e.gl,
                l = n.paint.get("sky-atmosphere-color"),
                c = n.paint.get("sky-atmosphere-halo-color"),
                u = n.paint.get("sky-atmosphere-sun-intensity"),
                h = ((t, e, n, r, i) => ({
                  u_matrix_3f: t,
                  u_sun_direction: e,
                  u_sun_intensity: n,
                  u_color_tint_r: [r.r, r.g, r.b, r.a],
                  u_color_tint_m: [i.r, i.g, i.b, i.a],
                  u_luminance: 5e-5,
                }))(t.fromMat4([], i), o, u, l, c);
              a.framebufferTexture2D(
                a.FRAMEBUFFER,
                a.COLOR_ATTACHMENT0,
                a.TEXTURE_CUBE_MAP_POSITIVE_X + s,
                n.skyboxTexture,
                0
              ),
                r.draw(
                  e,
                  a.TRIANGLES,
                  t.DepthMode.disabled,
                  t.StencilMode.disabled,
                  t.ColorMode.unblended,
                  t.CullFaceMode.frontCW,
                  h,
                  "skyboxCapture",
                  n.skyboxGeometry.vertexBuffer,
                  n.skyboxGeometry.indexBuffer,
                  n.skyboxGeometry.segment
                );
            }
            const pr = {
              symbol: function (e, n, r, i, o) {
                if ("translucent" !== e.renderPass) return;
                const s = t.StencilMode.disabled,
                  a = e.colorModeForRenderPass();
                r.layout.get("text-variable-anchor") &&
                  (function (e, n, r, i, o, s, a) {
                    const l = n.transform,
                      c = "map" === o,
                      u = "map" === s;
                    for (const h of e) {
                      const e = i.getTile(h),
                        o = e.getBucket(r);
                      if (!o || !o.text || !o.text.segments.get().length)
                        continue;
                      const s = t.evaluateSizeForZoom(o.textSizeData, l.zoom),
                        p = M(e, 1, n.transform.zoom),
                        d = Xt(h.projMatrix, u, c, n.transform, p),
                        f =
                          "none" !== r.layout.get("icon-text-fit") &&
                          o.hasIconData();
                      if (s) {
                        const n = Math.pow(2, l.zoom - e.tileID.overscaledZ),
                          r = l.elevation;
                        $n(
                          o,
                          c,
                          u,
                          a,
                          t.symbolSize,
                          l,
                          d,
                          h.projMatrix,
                          n,
                          s,
                          f,
                          r ? (t) => r.getAtTileOffset(h, t.x, t.y) : (t) => 0
                        );
                      }
                    }
                  })(
                    i,
                    e,
                    r,
                    n,
                    r.layout.get("text-rotation-alignment"),
                    r.layout.get("text-pitch-alignment"),
                    o
                  ),
                  0 !== r.paint.get("icon-opacity").constantOr(1) &&
                    Wn(
                      e,
                      n,
                      r,
                      i,
                      !1,
                      r.paint.get("icon-translate"),
                      r.paint.get("icon-translate-anchor"),
                      r.layout.get("icon-rotation-alignment"),
                      r.layout.get("icon-pitch-alignment"),
                      r.layout.get("icon-keep-upright"),
                      s,
                      a
                    ),
                  0 !== r.paint.get("text-opacity").constantOr(1) &&
                    Wn(
                      e,
                      n,
                      r,
                      i,
                      !0,
                      r.paint.get("text-translate"),
                      r.paint.get("text-translate-anchor"),
                      r.layout.get("text-rotation-alignment"),
                      r.layout.get("text-pitch-alignment"),
                      r.layout.get("text-keep-upright"),
                      s,
                      a
                    ),
                  n.map.showCollisionBoxes &&
                    (Zn(
                      e,
                      n,
                      r,
                      i,
                      r.paint.get("text-translate"),
                      r.paint.get("text-translate-anchor"),
                      !0
                    ),
                    Zn(
                      e,
                      n,
                      r,
                      i,
                      r.paint.get("icon-translate"),
                      r.paint.get("icon-translate-anchor"),
                      !1
                    ));
              },
              circle: function (e, n, r, i) {
                if ("translucent" !== e.renderPass) return;
                const o = r.paint.get("circle-opacity"),
                  s = r.paint.get("circle-stroke-width"),
                  a = r.paint.get("circle-stroke-opacity"),
                  l = void 0 !== r.layout.get("circle-sort-key").constantOr(1);
                if (
                  0 === o.constantOr(1) &&
                  (0 === s.constantOr(1) || 0 === a.constantOr(1))
                )
                  return;
                const c = e.context,
                  u = c.gl,
                  h = e.depthModeForSublayer(0, t.DepthMode.ReadOnly),
                  p = t.StencilMode.disabled,
                  d = e.colorModeForRenderPass(),
                  f = [];
                for (let m = 0; m < i.length; m++) {
                  const o = i[m],
                    s = n.getTile(o),
                    a = s.getBucket(r);
                  if (!a) continue;
                  const c = a.programConfigurations.get(r.id),
                    u = Sn(r),
                    h = {
                      programConfiguration: c,
                      program: e.useProgram("circle", c, u),
                      layoutVertexBuffer: a.layoutVertexBuffer,
                      indexBuffer: a.indexBuffer,
                      uniformValues: wn(e, o, s, r),
                      tile: s,
                    };
                  if (l) {
                    const e = a.segments.get();
                    for (const n of e)
                      f.push({
                        segments: new t.SegmentVector([n]),
                        sortKey: n.sortKey,
                        state: h,
                      });
                  } else f.push({ segments: a.segments, sortKey: 0, state: h });
                }
                l && f.sort((t, e) => t.sortKey - e.sortKey);
                for (const m of f) {
                  const {
                      programConfiguration: n,
                      program: i,
                      layoutVertexBuffer: o,
                      indexBuffer: s,
                      uniformValues: a,
                      tile: l,
                    } = m.state,
                    f = m.segments;
                  e.terrain &&
                    e.terrain.setupElevationDraw(l, i, {
                      useDepthForOcclusion: !0,
                    }),
                    e.prepareDrawProgram(c, i, l.tileID.toUnwrapped()),
                    i.draw(
                      c,
                      u.TRIANGLES,
                      h,
                      p,
                      d,
                      t.CullFaceMode.disabled,
                      a,
                      r.id,
                      o,
                      s,
                      f,
                      r.paint,
                      e.transform.zoom,
                      n
                    );
                }
              },
              heatmap: function (e, n, r, i) {
                if (0 !== r.paint.get("heatmap-opacity"))
                  if ("offscreen" === e.renderPass) {
                    const o = e.context,
                      s = o.gl,
                      a = t.StencilMode.disabled,
                      l = new t.ColorMode([s.ONE, s.ONE], t.Color.transparent, [
                        !0,
                        !0,
                        !0,
                        !0,
                      ]);
                    !(function (t, e, n) {
                      const r = t.gl;
                      t.activeTexture.set(r.TEXTURE1),
                        t.viewport.set([0, 0, e.width / 4, e.height / 4]);
                      let i = n.heatmapFbo;
                      if (i)
                        r.bindTexture(r.TEXTURE_2D, i.colorAttachment.get()),
                          t.bindFramebuffer.set(i.framebuffer);
                      else {
                        const o = r.createTexture();
                        r.bindTexture(r.TEXTURE_2D, o),
                          r.texParameteri(
                            r.TEXTURE_2D,
                            r.TEXTURE_WRAP_S,
                            r.CLAMP_TO_EDGE
                          ),
                          r.texParameteri(
                            r.TEXTURE_2D,
                            r.TEXTURE_WRAP_T,
                            r.CLAMP_TO_EDGE
                          ),
                          r.texParameteri(
                            r.TEXTURE_2D,
                            r.TEXTURE_MIN_FILTER,
                            r.LINEAR
                          ),
                          r.texParameteri(
                            r.TEXTURE_2D,
                            r.TEXTURE_MAG_FILTER,
                            r.LINEAR
                          ),
                          (i = n.heatmapFbo =
                            t.createFramebuffer(e.width / 4, e.height / 4, !1)),
                          (function (t, e, n, r) {
                            const i = t.gl;
                            i.texImage2D(
                              i.TEXTURE_2D,
                              0,
                              i.RGBA,
                              e.width / 4,
                              e.height / 4,
                              0,
                              i.RGBA,
                              t.extRenderToTextureHalfFloat
                                ? t.extTextureHalfFloat.HALF_FLOAT_OES
                                : i.UNSIGNED_BYTE,
                              null
                            ),
                              r.colorAttachment.set(n);
                          })(t, e, o, i);
                      }
                    })(o, e, r),
                      o.clear({ color: t.Color.transparent });
                    for (let c = 0; c < i.length; c++) {
                      const u = i[c];
                      if (n.hasRenderableParent(u)) continue;
                      const h = n.getTile(u),
                        p = h.getBucket(r);
                      if (!p) continue;
                      const d = p.programConfigurations.get(r.id),
                        f = e.useProgram("heatmap", d),
                        { zoom: m } = e.transform;
                      e.terrain && e.terrain.setupElevationDraw(h, f),
                        e.prepareDrawProgram(o, f, u.toUnwrapped()),
                        f.draw(
                          o,
                          s.TRIANGLES,
                          t.DepthMode.disabled,
                          a,
                          l,
                          t.CullFaceMode.disabled,
                          An(
                            u.projMatrix,
                            h,
                            m,
                            r.paint.get("heatmap-intensity")
                          ),
                          r.id,
                          p.layoutVertexBuffer,
                          p.indexBuffer,
                          p.segments,
                          r.paint,
                          e.transform.zoom,
                          d
                        );
                    }
                    o.viewport.set([0, 0, e.width, e.height]);
                  } else
                    "translucent" === e.renderPass &&
                      (e.context.setColorMode(e.colorModeForRenderPass()),
                      (function (e, n) {
                        const r = e.context,
                          i = r.gl,
                          o = n.heatmapFbo;
                        if (!o) return;
                        r.activeTexture.set(i.TEXTURE0),
                          i.bindTexture(i.TEXTURE_2D, o.colorAttachment.get()),
                          r.activeTexture.set(i.TEXTURE1);
                        let s = n.colorRampTexture;
                        s ||
                          (s = n.colorRampTexture =
                            new t.Texture(r, n.colorRamp, i.RGBA)),
                          s.bind(i.LINEAR, i.CLAMP_TO_EDGE),
                          e
                            .useProgram("heatmapTexture")
                            .draw(
                              r,
                              i.TRIANGLES,
                              t.DepthMode.disabled,
                              t.StencilMode.disabled,
                              e.colorModeForRenderPass(),
                              t.CullFaceMode.disabled,
                              ((t, e, n, r) => ({
                                u_image: 0,
                                u_color_ramp: 1,
                                u_opacity: e.paint.get("heatmap-opacity"),
                              }))(0, n),
                              n.id,
                              e.viewportBuffer,
                              e.quadTriangleIndexBuffer,
                              e.viewportSegments,
                              n.paint,
                              e.transform.zoom
                            );
                      })(e, r));
              },
              line: function (e, n, r, i) {
                if ("translucent" !== e.renderPass) return;
                const o = r.paint.get("line-opacity"),
                  s = r.paint.get("line-width");
                if (0 === o.constantOr(1) || 0 === s.constantOr(1)) return;
                const a = e.depthModeForSublayer(0, t.DepthMode.ReadOnly),
                  l = e.colorModeForRenderPass(),
                  c = r.paint.get("line-dasharray"),
                  u = c.constantOr(1),
                  h = r.layout.get("line-cap"),
                  p = r.paint.get("line-pattern"),
                  d = p.constantOr(1),
                  f = r.paint.get("line-gradient"),
                  m = r.getCrossfadeParameters(),
                  g = d
                    ? "linePattern"
                    : u
                    ? "lineSDF"
                    : f
                    ? "lineGradient"
                    : "line",
                  y = e.context,
                  _ = y.gl;
                for (const v of i) {
                  const i = n.getTile(v);
                  if (d && !i.patternsLoaded()) continue;
                  const o = i.getBucket(r);
                  if (!o) continue;
                  e.prepareDrawTile(v);
                  const s = o.programConfigurations.get(r.id),
                    b = e.useProgram(g, s),
                    x = p.constantOr(null);
                  if (x && i.imageAtlas) {
                    const t = i.imageAtlas,
                      e = t.patternPositions[x.to.toString()],
                      n = t.patternPositions[x.from.toString()];
                    e && n && s.setConstantPatternPositions(e, n);
                  }
                  const w = c.constantOr(null),
                    S = h.constantOr(null);
                  if (!d && w && S && i.lineAtlas) {
                    const t = i.lineAtlas,
                      e = t.getDash(w.to, S),
                      n = t.getDash(w.from, S);
                    e && n && s.setConstantPatternPositions(e, n);
                  }
                  const E = e.terrain ? v.projMatrix : null,
                    T = d
                      ? Mn(e, i, r, m, E)
                      : u
                      ? On(e, i, r, m, E)
                      : f
                      ? Pn(e, i, r, E, o.lineClipsArray.length)
                      : Cn(e, i, r, E);
                  if (d)
                    y.activeTexture.set(_.TEXTURE0),
                      i.imageAtlasTexture.bind(_.LINEAR, _.CLAMP_TO_EDGE),
                      s.updatePaintBuffers(m);
                  else if (u)
                    y.activeTexture.set(_.TEXTURE0),
                      i.lineAtlasTexture.bind(_.LINEAR, _.REPEAT),
                      s.updatePaintBuffers(m);
                  else if (f) {
                    const i = o.gradients[r.id];
                    let s = i.texture;
                    if (r.gradientVersion !== i.version) {
                      let a = 256;
                      if (r.stepInterpolant) {
                        const r = n.getSource().maxzoom,
                          i =
                            v.canonical.z === r
                              ? Math.ceil(
                                  1 << (e.transform.maxZoom - v.canonical.z)
                                )
                              : 1;
                        a = t.clamp(
                          t.nextPowerOfTwo(
                            (o.maxLineLength / t.EXTENT) * 1024 * i
                          ),
                          256,
                          y.maxTextureSize
                        );
                      }
                      (i.gradient = t.renderColorRamp({
                        expression: r.gradientExpression(),
                        evaluationKey: "lineProgress",
                        resolution: a,
                        image: i.gradient || void 0,
                        clips: o.lineClipsArray,
                      })),
                        i.texture
                          ? i.texture.update(i.gradient)
                          : (i.texture = new t.Texture(y, i.gradient, _.RGBA)),
                        (i.version = r.gradientVersion),
                        (s = i.texture);
                    }
                    y.activeTexture.set(_.TEXTURE0),
                      s.bind(
                        r.stepInterpolant ? _.NEAREST : _.LINEAR,
                        _.CLAMP_TO_EDGE
                      );
                  }
                  e.prepareDrawProgram(y, b, v.toUnwrapped()),
                    b.draw(
                      y,
                      _.TRIANGLES,
                      a,
                      e.stencilModeForClipping(v),
                      l,
                      t.CullFaceMode.disabled,
                      T,
                      r.id,
                      o.layoutVertexBuffer,
                      o.indexBuffer,
                      o.segments,
                      r.paint,
                      e.transform.zoom,
                      s,
                      o.layoutVertexBuffer2
                    );
                }
              },
              fill: function (e, n, r, i) {
                const o = r.paint.get("fill-color"),
                  s = r.paint.get("fill-opacity");
                if (0 === s.constantOr(1)) return;
                const a = e.colorModeForRenderPass(),
                  l = r.paint.get("fill-pattern"),
                  c =
                    e.opaquePassEnabledForLayer() &&
                    !l.constantOr(1) &&
                    1 === o.constantOr(t.Color.transparent).a &&
                    1 === s.constantOr(0)
                      ? "opaque"
                      : "translucent";
                if (e.renderPass === c) {
                  const o = e.depthModeForSublayer(
                    1,
                    "opaque" === e.renderPass
                      ? t.DepthMode.ReadWrite
                      : t.DepthMode.ReadOnly
                  );
                  Xn(e, n, r, i, o, a, !1);
                }
                if (
                  "translucent" === e.renderPass &&
                  r.paint.get("fill-antialias")
                ) {
                  const o = e.depthModeForSublayer(
                    r.getPaintProperty("fill-outline-color") ? 2 : 0,
                    t.DepthMode.ReadOnly
                  );
                  Xn(e, n, r, i, o, a, !0);
                }
              },
              "fill-extrusion": function (e, n, r, i) {
                const o = r.paint.get("fill-extrusion-opacity");
                if (0 !== o && "translucent" === e.renderPass) {
                  const s = new t.DepthMode(
                    e.context.gl.LEQUAL,
                    t.DepthMode.ReadWrite,
                    e.depthRangeFor3D
                  );
                  if (
                    1 !== o ||
                    r.paint.get("fill-extrusion-pattern").constantOr(1)
                  )
                    Kn(
                      e,
                      n,
                      r,
                      i,
                      s,
                      t.StencilMode.disabled,
                      t.ColorMode.disabled
                    ),
                      Kn(
                        e,
                        n,
                        r,
                        i,
                        s,
                        e.stencilModeFor3D(),
                        e.colorModeForRenderPass()
                      );
                  else {
                    const o = e.colorModeForRenderPass();
                    Kn(e, n, r, i, s, t.StencilMode.disabled, o);
                  }
                }
              },
              hillshade: function (e, n, r, i) {
                if (
                  "offscreen" !== e.renderPass &&
                  "translucent" !== e.renderPass
                )
                  return;
                const o = e.context,
                  s = e.depthModeForSublayer(0, t.DepthMode.ReadOnly),
                  a = e.colorModeForRenderPass(),
                  l = e.terrain && e.terrain.renderingToTexture,
                  [c, u] =
                    "translucent" !== e.renderPass || l
                      ? [{}, i]
                      : e.stencilConfigForOverlap(i);
                for (const h of u) {
                  const i = n.getTile(h);
                  if (i.needsHillshadePrepare && "offscreen" === e.renderPass)
                    en(e, i, r, s, t.StencilMode.disabled, a);
                  else if ("translucent" === e.renderPass) {
                    const t =
                      l && e.terrain
                        ? e.terrain.stencilModeForRTTOverlap(h)
                        : c[h.overscaledZ];
                    Je(e, h, i, r, s, t, a);
                  }
                }
                o.viewport.set([0, 0, e.width, e.height]);
              },
              raster: function (e, n, r, i, o, s) {
                if ("translucent" !== e.renderPass) return;
                if (0 === r.paint.get("raster-opacity")) return;
                if (!i.length) return;
                const a = e.context,
                  l = a.gl,
                  c = n.getSource(),
                  u = e.useProgram("raster"),
                  h = e.colorModeForRenderPass(),
                  p = e.terrain && e.terrain.renderingToTexture,
                  [d, f] =
                    c instanceof Et || p
                      ? [{}, i]
                      : e.stencilConfigForOverlap(i),
                  m = f[f.length - 1].overscaledZ,
                  g = !e.options.moving;
                for (const y of f) {
                  const i = p
                      ? t.DepthMode.disabled
                      : e.depthModeForSublayer(
                          y.overscaledZ - m,
                          1 === r.paint.get("raster-opacity")
                            ? t.DepthMode.ReadWrite
                            : t.DepthMode.ReadOnly,
                          l.LESS
                        ),
                    o = y.toUnwrapped(),
                    f = n.getTile(y);
                  if (p && (!f || !f.hasData())) continue;
                  const _ = p
                      ? y.projMatrix
                      : e.transform.calculateProjMatrix(o, g),
                    v =
                      e.terrain && p
                        ? e.terrain.stencilModeForRTTOverlap(y)
                        : d[y.overscaledZ],
                    b = s ? 0 : r.paint.get("raster-fade-duration");
                  f.registerFadeDuration(b);
                  const x = n.findLoadedParent(y, 0),
                    w = cn(f, x, n, e.transform, b);
                  let S, E;
                  e.terrain && e.terrain.prepareDrawTile(y);
                  const T =
                    "nearest" === r.paint.get("raster-resampling")
                      ? l.NEAREST
                      : l.LINEAR;
                  a.activeTexture.set(l.TEXTURE0),
                    f.texture.bind(T, l.CLAMP_TO_EDGE, l.LINEAR_MIPMAP_NEAREST),
                    a.activeTexture.set(l.TEXTURE1),
                    x
                      ? (x.texture.bind(
                          T,
                          l.CLAMP_TO_EDGE,
                          l.LINEAR_MIPMAP_NEAREST
                        ),
                        (S = Math.pow(
                          2,
                          x.tileID.overscaledZ - f.tileID.overscaledZ
                        )),
                        (E = [
                          (f.tileID.canonical.x * S) % 1,
                          (f.tileID.canonical.y * S) % 1,
                        ]))
                      : f.texture.bind(
                          T,
                          l.CLAMP_TO_EDGE,
                          l.LINEAR_MIPMAP_NEAREST
                        );
                  const A = Dn(_, E || [0, 0], S || 1, w, r);
                  e.prepareDrawProgram(a, u, o),
                    c instanceof Et
                      ? u.draw(
                          a,
                          l.TRIANGLES,
                          i,
                          t.StencilMode.disabled,
                          h,
                          t.CullFaceMode.disabled,
                          A,
                          r.id,
                          c.boundsBuffer,
                          e.quadTriangleIndexBuffer,
                          c.boundsSegments
                        )
                      : u.draw(
                          a,
                          l.TRIANGLES,
                          i,
                          v,
                          h,
                          t.CullFaceMode.disabled,
                          A,
                          r.id,
                          e.rasterBoundsBuffer,
                          e.quadTriangleIndexBuffer,
                          e.rasterBoundsSegments
                        );
                }
              },
              background: function (e, n, r, i) {
                const o = r.paint.get("background-color"),
                  s = r.paint.get("background-opacity");
                if (0 === s) return;
                const a = e.context,
                  l = a.gl,
                  c = e.transform,
                  u = c.tileSize,
                  h = r.paint.get("background-pattern");
                if (e.isPatternMissing(h)) return;
                const p =
                  !h && 1 === o.a && 1 === s && e.opaquePassEnabledForLayer()
                    ? "opaque"
                    : "translucent";
                if (e.renderPass !== p) return;
                const d = t.StencilMode.disabled,
                  f = e.depthModeForSublayer(
                    0,
                    "opaque" === p
                      ? t.DepthMode.ReadWrite
                      : t.DepthMode.ReadOnly
                  ),
                  m = e.colorModeForRenderPass(),
                  g = e.useProgram(h ? "backgroundPattern" : "background"),
                  y = i || c.coveringTiles({ tileSize: u });
                h &&
                  (a.activeTexture.set(l.TEXTURE0),
                  e.imageManager.bind(e.context));
                const _ = r.getCrossfadeParameters();
                for (const v of y) {
                  const n = v.toUnwrapped(),
                    c = i ? v.projMatrix : e.transform.calculateProjMatrix(n);
                  e.prepareDrawTile(v);
                  const p = h
                    ? Nn(c, s, e, h, { tileID: v, tileSize: u }, _)
                    : Bn(c, s, o);
                  e.prepareDrawProgram(a, g, n),
                    g.draw(
                      a,
                      l.TRIANGLES,
                      f,
                      d,
                      m,
                      t.CullFaceMode.disabled,
                      p,
                      r.id,
                      e.tileExtentBuffer,
                      e.quadTriangleIndexBuffer,
                      e.tileExtentSegments
                    );
                }
              },
              sky: function (e, n, r) {
                const i = r.paint.get("sky-opacity");
                if (0 === i) return;
                const o = e.context,
                  s = r.paint.get("sky-type"),
                  a = new t.DepthMode(
                    o.gl.LEQUAL,
                    t.DepthMode.ReadOnly,
                    [0, 1]
                  ),
                  l = (e.frameCounter / 1e3) % 1;
                "atmosphere" === s
                  ? "offscreen" === e.renderPass
                    ? r.needsSkyboxCapture(e) &&
                      ((function (e, n, r, i) {
                        const o = e.context,
                          s = o.gl;
                        let a = n.skyboxFbo;
                        if (!a) {
                          (a = n.skyboxFbo = o.createFramebuffer(32, 32, !1)),
                            (n.skyboxGeometry = new ur(o)),
                            (n.skyboxTexture = o.gl.createTexture()),
                            s.bindTexture(s.TEXTURE_CUBE_MAP, n.skyboxTexture),
                            s.texParameteri(
                              s.TEXTURE_CUBE_MAP,
                              s.TEXTURE_WRAP_S,
                              s.CLAMP_TO_EDGE
                            ),
                            s.texParameteri(
                              s.TEXTURE_CUBE_MAP,
                              s.TEXTURE_WRAP_T,
                              s.CLAMP_TO_EDGE
                            ),
                            s.texParameteri(
                              s.TEXTURE_CUBE_MAP,
                              s.TEXTURE_MIN_FILTER,
                              s.LINEAR
                            ),
                            s.texParameteri(
                              s.TEXTURE_CUBE_MAP,
                              s.TEXTURE_MAG_FILTER,
                              s.LINEAR
                            );
                          for (let t = 0; t < 6; ++t)
                            s.texImage2D(
                              s.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                              0,
                              s.RGBA,
                              32,
                              32,
                              0,
                              s.RGBA,
                              s.UNSIGNED_BYTE,
                              null
                            );
                        }
                        o.bindFramebuffer.set(a.framebuffer),
                          o.viewport.set([0, 0, 32, 32]);
                        const l = n.getCenter(e, !0),
                          c = e.useProgram("skyboxCapture"),
                          u = new Float64Array(16);
                        t.identity(u),
                          t.rotateY(u, u, 0.5 * -Math.PI),
                          hr(o, n, c, u, l, 0),
                          t.identity(u),
                          t.rotateY(u, u, 0.5 * Math.PI),
                          hr(o, n, c, u, l, 1),
                          t.identity(u),
                          t.rotateX(u, u, 0.5 * -Math.PI),
                          hr(o, n, c, u, l, 2),
                          t.identity(u),
                          t.rotateX(u, u, 0.5 * Math.PI),
                          hr(o, n, c, u, l, 3),
                          t.identity(u),
                          hr(o, n, c, u, l, 4),
                          t.identity(u),
                          t.rotateY(u, u, Math.PI),
                          hr(o, n, c, u, l, 5),
                          o.viewport.set([0, 0, e.width, e.height]);
                      })(e, r),
                      r.markSkyboxValid(e))
                    : "sky" === e.renderPass &&
                      (function (e, n, r, i, o) {
                        const s = e.context,
                          a = s.gl,
                          l = e.transform,
                          c = e.useProgram("skybox");
                        s.activeTexture.set(a.TEXTURE0),
                          a.bindTexture(a.TEXTURE_CUBE_MAP, n.skyboxTexture);
                        const u = ((t, e, n, r, i) => ({
                          u_matrix: t,
                          u_sun_direction: e,
                          u_cubemap: 0,
                          u_opacity: r,
                          u_temporal_offset: i,
                        }))(l.skyboxMatrix, n.getCenter(e, !1), 0, i, o);
                        e.prepareDrawProgram(s, c),
                          c.draw(
                            s,
                            a.TRIANGLES,
                            r,
                            t.StencilMode.disabled,
                            e.colorModeForRenderPass(),
                            t.CullFaceMode.backCW,
                            u,
                            "skybox",
                            n.skyboxGeometry.vertexBuffer,
                            n.skyboxGeometry.indexBuffer,
                            n.skyboxGeometry.segment
                          );
                      })(e, r, a, i, l)
                  : "gradient" === s &&
                    "sky" === e.renderPass &&
                    (function (e, n, r, i, o) {
                      const s = e.context,
                        a = s.gl,
                        l = e.transform,
                        c = e.useProgram("skyboxGradient");
                      n.skyboxGeometry || (n.skyboxGeometry = new ur(s)),
                        s.activeTexture.set(a.TEXTURE0);
                      let u = n.colorRampTexture;
                      u ||
                        (u = n.colorRampTexture =
                          new t.Texture(s, n.colorRamp, a.RGBA)),
                        u.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                      const h = ((e, n, r, i, o) => ({
                        u_matrix: e,
                        u_color_ramp: 0,
                        u_center_direction: n,
                        u_radius: t.degToRad(r),
                        u_opacity: i,
                        u_temporal_offset: o,
                      }))(
                        l.skyboxMatrix,
                        n.getCenter(e, !1),
                        n.paint.get("sky-gradient-radius"),
                        i,
                        o
                      );
                      e.prepareDrawProgram(s, c),
                        c.draw(
                          s,
                          a.TRIANGLES,
                          r,
                          t.StencilMode.disabled,
                          e.colorModeForRenderPass(),
                          t.CullFaceMode.backCW,
                          h,
                          "skyboxGradient",
                          n.skyboxGeometry.vertexBuffer,
                          n.skyboxGeometry.indexBuffer,
                          n.skyboxGeometry.segment
                        );
                    })(e, r, a, i, l);
              },
              debug: function (t, e, n) {
                for (let r = 0; r < n.length; r++) sr(t, e, n[r]);
              },
              custom: function (e, n, r) {
                const i = e.context,
                  o = r.implementation;
                if ("offscreen" === e.renderPass) {
                  const t = o.prerender;
                  t &&
                    (e.setCustomLayerDefaults(),
                    i.setColorMode(e.colorModeForRenderPass()),
                    t.call(o, i.gl, e.transform.customLayerMatrix()),
                    i.setDirty(),
                    e.setBaseState());
                } else if ("translucent" === e.renderPass) {
                  e.setCustomLayerDefaults(),
                    i.setColorMode(e.colorModeForRenderPass()),
                    i.setStencilMode(t.StencilMode.disabled);
                  const n =
                    "3d" === o.renderingMode
                      ? new t.DepthMode(
                          e.context.gl.LEQUAL,
                          t.DepthMode.ReadWrite,
                          e.depthRangeFor3D
                        )
                      : e.depthModeForSublayer(0, t.DepthMode.ReadOnly);
                  i.setDepthMode(n),
                    o.render(i.gl, e.transform.customLayerMatrix()),
                    i.setDirty(),
                    e.setBaseState(),
                    i.bindFramebuffer.set(null);
                }
              },
            };
            class dr {
              constructor(e, n) {
                (this.context = new bt(e)),
                  (this.transform = n),
                  (this._tileTextures = {}),
                  (this.frameCopies = []),
                  (this.loadTimeStamps = []),
                  this.setup(),
                  (this.numSublayers =
                    t.SourceCache.maxUnderzooming +
                    t.SourceCache.maxOverzooming +
                    1),
                  (this.depthEpsilon = 1 / Math.pow(2, 16)),
                  (this.crossTileSymbolIndex = new Le()),
                  (this.gpuTimers = {}),
                  (this.frameCounter = 0);
              }
              updateTerrain(t, e) {
                const n = !!t && !!t.terrain;
                if (!(n || (this._terrain && this._terrain.enabled))) return;
                this._terrain || (this._terrain = new pn(this, t));
                const r = this._terrain;
                (this.transform.elevation = n ? r : null),
                  r.update(t, this.transform, e);
              }
              _updateFog(t) {
                const e = t.fog;
                if (
                  !e ||
                  e.getOpacity(this.transform.pitch) < 1 ||
                  e.properties.get("horizon-blend") < 0.03
                )
                  return void (this.transform.fogCullDistSq = null);
                const [n, r] = e.getFovAdjustedRange(this.transform._fov);
                if (n > r) return void (this.transform.fogCullDistSq = null);
                const i = n + 0.78 * (r - n);
                this.transform.fogCullDistSq = i * i;
              }
              get terrain() {
                return this._terrain && this._terrain.enabled
                  ? this._terrain
                  : null;
              }
              resize(e, n) {
                if (
                  ((this.width = e * t.exported.devicePixelRatio),
                  (this.height = n * t.exported.devicePixelRatio),
                  this.context.viewport.set([0, 0, this.width, this.height]),
                  this.style)
                )
                  for (const t of this.style.order)
                    this.style._layers[t].resize();
              }
              setup() {
                const e = this.context,
                  n = new t.StructArrayLayout2i4();
                n.emplaceBack(0, 0),
                  n.emplaceBack(t.EXTENT, 0),
                  n.emplaceBack(0, t.EXTENT),
                  n.emplaceBack(t.EXTENT, t.EXTENT),
                  (this.tileExtentBuffer = e.createVertexBuffer(
                    n,
                    t.posAttributes.members
                  )),
                  (this.tileExtentSegments = t.SegmentVector.simpleSegment(
                    0,
                    0,
                    4,
                    2
                  ));
                const r = new t.StructArrayLayout2i4();
                r.emplaceBack(0, 0),
                  r.emplaceBack(t.EXTENT, 0),
                  r.emplaceBack(0, t.EXTENT),
                  r.emplaceBack(t.EXTENT, t.EXTENT),
                  (this.debugBuffer = e.createVertexBuffer(
                    r,
                    t.posAttributes.members
                  )),
                  (this.debugSegments = t.SegmentVector.simpleSegment(
                    0,
                    0,
                    4,
                    5
                  ));
                const i = new t.StructArrayLayout4i8();
                i.emplaceBack(0, 0, 0, 0),
                  i.emplaceBack(t.EXTENT, 0, t.EXTENT, 0),
                  i.emplaceBack(0, t.EXTENT, 0, t.EXTENT),
                  i.emplaceBack(t.EXTENT, t.EXTENT, t.EXTENT, t.EXTENT),
                  (this.rasterBoundsBuffer = e.createVertexBuffer(
                    i,
                    St.members
                  )),
                  (this.rasterBoundsSegments = t.SegmentVector.simpleSegment(
                    0,
                    0,
                    4,
                    2
                  ));
                const o = new t.StructArrayLayout2i4();
                o.emplaceBack(-1, -1),
                  o.emplaceBack(1, -1),
                  o.emplaceBack(-1, 1),
                  o.emplaceBack(1, 1),
                  (this.viewportBuffer = e.createVertexBuffer(
                    o,
                    t.posAttributes.members
                  )),
                  (this.viewportSegments = t.SegmentVector.simpleSegment(
                    0,
                    0,
                    4,
                    2
                  ));
                const s = new t.StructArrayLayout1ui2();
                s.emplaceBack(0),
                  s.emplaceBack(1),
                  s.emplaceBack(3),
                  s.emplaceBack(2),
                  s.emplaceBack(0),
                  (this.tileBorderIndexBuffer = e.createIndexBuffer(s));
                const a = new t.StructArrayLayout3ui6();
                a.emplaceBack(0, 1, 2),
                  a.emplaceBack(2, 1, 3),
                  (this.quadTriangleIndexBuffer = e.createIndexBuffer(a)),
                  (this.emptyTexture = new t.Texture(
                    e,
                    { width: 1, height: 1, data: new Uint8Array([0, 0, 0, 0]) },
                    e.gl.RGBA
                  )),
                  (this.identityMat = t.create$1());
                const l = this.context.gl;
                (this.stencilClearMode = new t.StencilMode(
                  { func: l.ALWAYS, mask: 0 },
                  0,
                  255,
                  l.ZERO,
                  l.ZERO,
                  l.ZERO
                )),
                  this.loadTimeStamps.push(t.window.performance.now());
              }
              clearStencil() {
                const e = this.context,
                  n = e.gl;
                (this.nextStencilID = 1),
                  (this.currentStencilSource = void 0),
                  this.useProgram("clippingMask").draw(
                    e,
                    n.TRIANGLES,
                    t.DepthMode.disabled,
                    this.stencilClearMode,
                    t.ColorMode.disabled,
                    t.CullFaceMode.disabled,
                    ln(this.identityMat),
                    "$clipping",
                    this.viewportBuffer,
                    this.quadTriangleIndexBuffer,
                    this.viewportSegments
                  );
              }
              _renderTileClippingMasks(e, n, r) {
                if (
                  !(
                    n &&
                    this.currentStencilSource !== n.id &&
                    e.isTileClipped() &&
                    r &&
                    r.length
                  )
                )
                  return;
                this.currentStencilSource = n.id;
                const i = this.context,
                  o = i.gl;
                this.nextStencilID + r.length > 256 && this.clearStencil(),
                  i.setColorMode(t.ColorMode.disabled),
                  i.setDepthMode(t.DepthMode.disabled);
                const s = this.useProgram("clippingMask");
                this._tileClippingMaskIDs = {};
                for (const a of r) {
                  const e = (this._tileClippingMaskIDs[a.key] = this
                    .nextStencilID++);
                  s.draw(
                    i,
                    o.TRIANGLES,
                    t.DepthMode.disabled,
                    new t.StencilMode(
                      { func: o.ALWAYS, mask: 0 },
                      e,
                      255,
                      o.KEEP,
                      o.KEEP,
                      o.REPLACE
                    ),
                    t.ColorMode.disabled,
                    t.CullFaceMode.disabled,
                    ln(a.projMatrix),
                    "$clipping",
                    this.tileExtentBuffer,
                    this.quadTriangleIndexBuffer,
                    this.tileExtentSegments
                  );
                }
              }
              stencilModeFor3D() {
                (this.currentStencilSource = void 0),
                  this.nextStencilID + 1 > 256 && this.clearStencil();
                const e = this.nextStencilID++,
                  n = this.context.gl;
                return new t.StencilMode(
                  { func: n.NOTEQUAL, mask: 255 },
                  e,
                  255,
                  n.KEEP,
                  n.KEEP,
                  n.REPLACE
                );
              }
              stencilModeForClipping(e) {
                if (this.terrain)
                  return this.terrain.stencilModeForRTTOverlap(e);
                const n = this.context.gl;
                return new t.StencilMode(
                  { func: n.EQUAL, mask: 255 },
                  this._tileClippingMaskIDs[e.key],
                  0,
                  n.KEEP,
                  n.KEEP,
                  n.REPLACE
                );
              }
              stencilConfigForOverlap(e) {
                const n = this.context.gl,
                  r = e.sort((t, e) => e.overscaledZ - t.overscaledZ),
                  i = r[r.length - 1].overscaledZ,
                  o = r[0].overscaledZ - i + 1;
                if (o > 1) {
                  (this.currentStencilSource = void 0),
                    this.nextStencilID + o > 256 && this.clearStencil();
                  const e = {};
                  for (let r = 0; r < o; r++)
                    e[r + i] = new t.StencilMode(
                      { func: n.GEQUAL, mask: 255 },
                      r + this.nextStencilID,
                      255,
                      n.KEEP,
                      n.KEEP,
                      n.REPLACE
                    );
                  return (this.nextStencilID += o), [e, r];
                }
                return [{ [i]: t.StencilMode.disabled }, r];
              }
              colorModeForRenderPass() {
                const e = this.context.gl;
                if (this._showOverdrawInspector) {
                  const n = 1 / 8;
                  return new t.ColorMode(
                    [e.CONSTANT_COLOR, e.ONE],
                    new t.Color(n, n, n, 0),
                    [!0, !0, !0, !0]
                  );
                }
                return "opaque" === this.renderPass
                  ? t.ColorMode.unblended
                  : t.ColorMode.alphaBlended;
              }
              depthModeForSublayer(e, n, r) {
                if (!this.opaquePassEnabledForLayer())
                  return t.DepthMode.disabled;
                const i =
                  1 -
                  ((1 + this.currentLayer) * this.numSublayers + e) *
                    this.depthEpsilon;
                return new t.DepthMode(r || this.context.gl.LEQUAL, n, [i, i]);
              }
              opaquePassEnabledForLayer() {
                return this.currentLayer < this.opaquePassCutoff;
              }
              render(e, n) {
                (this.style = e),
                  (this.options = n),
                  (this.lineAtlas = e.lineAtlas),
                  (this.imageManager = e.imageManager),
                  (this.glyphManager = e.glyphManager),
                  (this.symbolFadeChange = e.placement.symbolFadeChange(
                    t.exported.now()
                  )),
                  this.imageManager.beginFrame();
                const r = this.style.order,
                  i = this.style._sourceCaches;
                for (const t in i) {
                  const e = i[t];
                  e.used && e.prepare(this.context);
                }
                const o = {},
                  s = {},
                  a = {};
                for (const t in i) {
                  const e = i[t];
                  (o[t] = e.getVisibleCoordinates()),
                    (s[t] = o[t].slice().reverse()),
                    (a[t] = e.getVisibleCoordinates(!0).reverse());
                }
                this.opaquePassCutoff = 1 / 0;
                for (let t = 0; t < r.length; t++)
                  if (this.style._layers[r[t]].is3D()) {
                    this.opaquePassCutoff = t;
                    break;
                  }
                if (
                  (this.terrain &&
                    (this.terrain.updateTileBinding(a),
                    (this.opaquePassCutoff = 0)),
                  !t.isMapAuthenticated(this.context.gl))
                )
                  return;
                this.renderPass = "offscreen";
                for (const t of r) {
                  const n = this.style._layers[t],
                    r = e._getLayerSourceCache(n);
                  if (!n.hasOffscreenPass() || n.isHidden(this.transform.zoom))
                    continue;
                  const i = r ? s[r.id] : void 0;
                  ("custom" === n.type || n.isSky() || (i && i.length)) &&
                    this.renderLayer(this, r, n, i);
                }
                (this.depthRangeFor3D = [
                  0,
                  1 -
                    (e.order.length + 2) *
                      this.numSublayers *
                      this.depthEpsilon,
                ]),
                  this.terrain &&
                    (this.style.hasSymbolLayers() ||
                      this.style.hasCircleLayers()) &&
                    this.terrain.drawDepth(),
                  this.context.bindFramebuffer.set(null),
                  this.context.viewport.set([0, 0, this.width, this.height]);
                let l = t.Color.transparent;
                if (
                  (this.style.fog &&
                    (l = this.style.fog.properties.get("color")),
                  this.context.clear({
                    color: n.showOverdrawInspector ? t.Color.black : l,
                    depth: 1,
                  }),
                  this.clearStencil(),
                  (this._showOverdrawInspector = n.showOverdrawInspector),
                  (this.renderPass = "opaque"),
                  !this.terrain)
                )
                  for (
                    this.currentLayer = r.length - 1;
                    this.currentLayer >= 0;
                    this.currentLayer--
                  ) {
                    const t = this.style._layers[r[this.currentLayer]],
                      n = e._getLayerSourceCache(t);
                    if (t.isSky()) continue;
                    const i = n ? s[n.id] : void 0;
                    this._renderTileClippingMasks(t, n, i),
                      this.renderLayer(this, n, t, i);
                  }
                if (
                  ((this.renderPass = "sky"), this.transform.isHorizonVisible())
                )
                  for (
                    this.currentLayer = 0;
                    this.currentLayer < r.length;
                    this.currentLayer++
                  ) {
                    const t = this.style._layers[r[this.currentLayer]],
                      n = e._getLayerSourceCache(t);
                    t.isSky() &&
                      this.renderLayer(this, n, t, n ? s[n.id] : void 0);
                  }
                for (
                  this.renderPass = "translucent", this.currentLayer = 0;
                  this.currentLayer < r.length;

                ) {
                  const t = this.style._layers[r[this.currentLayer]],
                    n = e._getLayerSourceCache(t);
                  if (t.isSky()) {
                    ++this.currentLayer;
                    continue;
                  }
                  if (this.terrain && this.style.isLayerDraped(t)) {
                    if (t.isHidden(this.transform.zoom)) {
                      ++this.currentLayer;
                      continue;
                    }
                    this.currentLayer = this.terrain.renderBatch(
                      this.currentLayer
                    );
                    continue;
                  }
                  const i = n ? ("symbol" === t.type ? a : s)[n.id] : void 0;
                  this._renderTileClippingMasks(t, n, n ? o[n.id] : void 0),
                    this.renderLayer(this, n, t, i),
                    ++this.currentLayer;
                }
                if (
                  (this.terrain && this.terrain.postRender(),
                  this.options.showTileBoundaries ||
                    this.options.showQueryGeometry)
                ) {
                  let n = null;
                  t.values(this.style._layers).forEach((t) => {
                    const r = e._getLayerSourceCache(t);
                    r &&
                      !t.isHidden(this.transform.zoom) &&
                      (!n || n.getSource().maxzoom < r.getSource().maxzoom) &&
                      (n = r);
                  }),
                    n &&
                      this.options.showTileBoundaries &&
                      pr.debug(this, n, n.getVisibleCoordinates());
                }
                this.options.showPadding &&
                  (function (t) {
                    const e = t.transform.padding;
                    rr(t, t.transform.height - (e.top || 0), 3, Qn),
                      rr(t, e.bottom || 0, 3, Jn),
                      ir(t, e.left || 0, 3, tr),
                      ir(t, t.transform.width - (e.right || 0), 3, er);
                    const n = t.transform.centerPoint;
                    !(function (t, e, n, r) {
                      or(t, e - 1, n - 10, 2, 20, r),
                        or(t, e - 10, n - 1, 20, 2, r);
                    })(t, n.x, t.transform.height - n.y, nr);
                  })(this),
                  this.context.setDefault(),
                  (this.frameCounter =
                    (this.frameCounter + 1) % t.MAX_SAFE_INTEGER),
                  this.tileLoaded &&
                    this.options.speedIndexTiming &&
                    (this.loadTimeStamps.push(t.window.performance.now()),
                    this.saveCanvasCopy());
              }
              renderLayer(t, e, n, r) {
                n.isHidden(this.transform.zoom) ||
                  (("background" === n.type ||
                    "sky" === n.type ||
                    "custom" === n.type ||
                    (r && r.length)) &&
                    ((this.id = n.id),
                    this.gpuTimingStart(n),
                    pr[n.type](
                      t,
                      e,
                      n,
                      r,
                      this.style.placement.variableOffsets,
                      this.options.isInitialLoad
                    ),
                    this.gpuTimingEnd()));
              }
              gpuTimingStart(t) {
                if (!this.options.gpuTiming) return;
                const e = this.context.extTimerQuery;
                let n = this.gpuTimers[t.id];
                n ||
                  (n = this.gpuTimers[t.id] =
                    { calls: 0, cpuTime: 0, query: e.createQueryEXT() }),
                  n.calls++,
                  e.beginQueryEXT(e.TIME_ELAPSED_EXT, n.query);
              }
              gpuTimingEnd() {
                if (!this.options.gpuTiming) return;
                const t = this.context.extTimerQuery;
                t.endQueryEXT(t.TIME_ELAPSED_EXT);
              }
              collectGpuTimers() {
                const t = this.gpuTimers;
                return (this.gpuTimers = {}), t;
              }
              queryGpuTimers(t) {
                const e = {};
                for (const n in t) {
                  const r = t[n],
                    i = this.context.extTimerQuery,
                    o = i.getQueryObjectEXT(r.query, i.QUERY_RESULT_EXT) / 1e6;
                  i.deleteQueryEXT(r.query), (e[n] = o);
                }
                return e;
              }
              translatePosMatrix(e, n, r, i, o) {
                if (!r[0] && !r[1]) return e;
                const s = o
                  ? "map" === i
                    ? this.transform.angle
                    : 0
                  : "viewport" === i
                  ? -this.transform.angle
                  : 0;
                if (s) {
                  const t = Math.sin(s),
                    e = Math.cos(s);
                  r = [r[0] * e - r[1] * t, r[0] * t + r[1] * e];
                }
                const a = [
                    o ? r[0] : M(n, r[0], this.transform.zoom),
                    o ? r[1] : M(n, r[1], this.transform.zoom),
                    0,
                  ],
                  l = new Float32Array(16);
                return t.translate(l, e, a), l;
              }
              saveTileTexture(t) {
                const e = this._tileTextures[t.size[0]];
                e ? e.push(t) : (this._tileTextures[t.size[0]] = [t]);
              }
              getTileTexture(t) {
                const e = this._tileTextures[t];
                return e && e.length > 0 ? e.pop() : null;
              }
              isPatternMissing(t) {
                if (!t) return !1;
                if (!t.from || !t.to) return !0;
                const e = this.imageManager.getPattern(t.from.toString()),
                  n = this.imageManager.getPattern(t.to.toString());
                return !e || !n;
              }
              currentGlobalDefines() {
                const t = this.terrain && this.terrain.renderingToTexture,
                  e = this.style && this.style.fog,
                  n = [];
                return (
                  this.terrain &&
                    !this.terrain.renderingToTexture &&
                    n.push("TERRAIN"),
                  e &&
                    !t &&
                    0 !== e.getOpacity(this.transform.pitch) &&
                    n.push("FOG"),
                  t && n.push("RENDER_TO_TEXTURE"),
                  this._showOverdrawInspector && n.push("OVERDRAW_INSPECTOR"),
                  n
                );
              }
              useProgram(t, e, n) {
                this.cache = this.cache || {};
                const r = n || [],
                  i = this.currentGlobalDefines().concat(r),
                  o = fn.cacheKey(t, i, e);
                return (
                  this.cache[o] ||
                    (this.cache[o] = new fn(
                      this.context,
                      t,
                      Xe[t],
                      e,
                      jn[t],
                      i
                    )),
                  this.cache[o]
                );
              }
              setCustomLayerDefaults() {
                this.context.unbindVAO(),
                  this.context.cullFace.setDefault(),
                  this.context.frontFace.setDefault(),
                  this.context.cullFaceSide.setDefault(),
                  this.context.activeTexture.setDefault(),
                  this.context.pixelStoreUnpack.setDefault(),
                  this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                  this.context.pixelStoreUnpackFlipY.setDefault();
              }
              setBaseState() {
                const t = this.context.gl;
                this.context.cullFace.set(!1),
                  this.context.viewport.set([0, 0, this.width, this.height]),
                  this.context.blendEquation.set(t.FUNC_ADD);
              }
              initDebugOverlayCanvas() {
                null == this.debugOverlayCanvas &&
                  ((this.debugOverlayCanvas =
                    t.window.document.createElement("canvas")),
                  (this.debugOverlayCanvas.width = 512),
                  (this.debugOverlayCanvas.height = 512),
                  (this.debugOverlayTexture = new t.Texture(
                    this.context,
                    this.debugOverlayCanvas,
                    this.context.gl.RGBA
                  )));
              }
              destroy() {
                this._terrain && this._terrain.destroy(),
                  this.emptyTexture.destroy(),
                  this.debugOverlayTexture &&
                    this.debugOverlayTexture.destroy();
              }
              prepareDrawTile(t) {
                this.terrain && this.terrain.prepareDrawTile(t);
              }
              prepareDrawProgram(t, e, n) {
                if (this.terrain && this.terrain.renderingToTexture) return;
                const r = this.style.fog;
                if (r) {
                  const i = r.getOpacity(this.transform.pitch);
                  0 !== i &&
                    e.setFogUniformValues(
                      t,
                      ((t, e, n, r) => {
                        const i = e.properties.get("color"),
                          o = (t.frameCounter / 1e3) % 1,
                          s = [i.r / i.a, i.g / i.a, i.b / i.a, r];
                        return {
                          u_fog_matrix: n
                            ? t.transform.calculateFogTileMatrix(n)
                            : t.identityMat,
                          u_fog_range: e.getFovAdjustedRange(t.transform._fov),
                          u_fog_color: s,
                          u_fog_horizon_blend:
                            e.properties.get("horizon-blend"),
                          u_fog_temporal_offset: o,
                        };
                      })(this, r, n, i)
                    );
                }
              }
              setTileLoadedFlag(t) {
                this.tileLoaded = t;
              }
              saveCanvasCopy() {
                this.frameCopies.push(this.canvasCopy()),
                  (this.tileLoaded = !1);
              }
              canvasCopy() {
                const t = this.context.gl,
                  e = t.createTexture();
                return (
                  t.bindTexture(t.TEXTURE_2D, e),
                  t.copyTexImage2D(
                    t.TEXTURE_2D,
                    0,
                    t.RGBA,
                    0,
                    0,
                    t.drawingBufferWidth,
                    t.drawingBufferHeight,
                    0
                  ),
                  e
                );
              }
              getCanvasCopiesAndTimestamps() {
                return {
                  canvasCopies: this.frameCopies,
                  timeStamps: this.loadTimeStamps,
                };
              }
              averageElevationNeedsEasing() {
                if (!this.transform._elevation) return !1;
                const t = this.style && this.style.fog;
                return !!t && 0 !== t.getOpacity(this.transform.pitch);
              }
            }
            class fr {
              constructor(t = 0, e = 0, n = 0, r = 0) {
                if (
                  isNaN(t) ||
                  t < 0 ||
                  isNaN(e) ||
                  e < 0 ||
                  isNaN(n) ||
                  n < 0 ||
                  isNaN(r) ||
                  r < 0
                )
                  throw new Error(
                    "Invalid value for edge-insets, top, bottom, left and right must all be numbers"
                  );
                (this.top = t),
                  (this.bottom = e),
                  (this.left = n),
                  (this.right = r);
              }
              interpolate(e, n, r) {
                return (
                  null != n.top &&
                    null != e.top &&
                    (this.top = t.number(e.top, n.top, r)),
                  null != n.bottom &&
                    null != e.bottom &&
                    (this.bottom = t.number(e.bottom, n.bottom, r)),
                  null != n.left &&
                    null != e.left &&
                    (this.left = t.number(e.left, n.left, r)),
                  null != n.right &&
                    null != e.right &&
                    (this.right = t.number(e.right, n.right, r)),
                  this
                );
              }
              getCenter(e, n) {
                const r = t.clamp((this.left + e - this.right) / 2, 0, e),
                  i = t.clamp((this.top + n - this.bottom) / 2, 0, n);
                return new t.pointGeometry(r, i);
              }
              equals(t) {
                return (
                  this.top === t.top &&
                  this.bottom === t.bottom &&
                  this.left === t.left &&
                  this.right === t.right
                );
              }
              clone() {
                return new fr(this.top, this.bottom, this.left, this.right);
              }
              toJSON() {
                return {
                  top: this.top,
                  bottom: this.bottom,
                  left: this.left,
                  right: this.right,
                };
              }
            }
            function mr(t, e) {
              return [t[4 * e], t[4 * e + 1], t[4 * e + 2], t[4 * e + 3]];
            }
            function gr(t, e, n) {
              (t[4 * e + 0] = n[0]),
                (t[4 * e + 1] = n[1]),
                (t[4 * e + 2] = n[2]),
                (t[4 * e + 3] = n[3]);
            }
            function yr(e, n) {
              const r = mr(e, 3);
              t.fromQuat(e, n), gr(e, 3, r);
            }
            function _r(t, e) {
              gr(t, 3, [e[0], e[1], e[2], 1]);
            }
            function vr(e, n) {
              const r = t.identity$1([]);
              return t.rotateZ$1(r, r, -n), t.rotateX$1(r, r, -e), r;
            }
            function br(e, n) {
              const r = [e[0], e[1], 0],
                i = [n[0], n[1], 0];
              if (t.length(r) >= 1e-15) {
                const e = t.normalize([], r);
                t.scale(i, e, t.dot(i, e)), (n[0] = i[0]), (n[1] = i[1]);
              }
              const o = t.cross([], n, e);
              if (t.len(o) < 1e-15) return null;
              const s = Math.atan2(-o[1], o[0]);
              return vr(
                Math.atan2(Math.sqrt(e[0] * e[0] + e[1] * e[1]), -e[2]),
                s
              );
            }
            class xr {
              constructor(t, e) {
                (this.position = t), (this.orientation = e);
              }
              get position() {
                return this._position;
              }
              set position(e) {
                this._position = this._renderWorldCopies
                  ? (function (e) {
                      if (!e) return;
                      const n = Array.isArray(e)
                        ? new t.MercatorCoordinate(e[0], e[1], e[2])
                        : e;
                      return (n.x = t.wrap(n.x, 0, 1)), n;
                    })(e)
                  : e;
              }
              lookAtPoint(e, n) {
                if (((this.orientation = null), !this.position)) return;
                const r = this._elevation
                    ? this._elevation.getAtPointOrZero(
                        t.MercatorCoordinate.fromLngLat(e)
                      )
                    : 0,
                  i = this.position,
                  o = t.MercatorCoordinate.fromLngLat(e, r),
                  s = [o.x - i.x, o.y - i.y, o.z - i.z];
                n || (n = [0, 0, 1]),
                  (n[2] = Math.abs(n[2])),
                  (this.orientation = br(s, n));
              }
              setPitchBearing(e, n) {
                this.orientation = vr(t.degToRad(e), t.degToRad(-n));
              }
            }
            class wr {
              constructor(e, n) {
                (this._transform = t.identity([])),
                  (this._orientation = t.identity$1([])),
                  n &&
                    ((this._orientation = n),
                    yr(this._transform, this._orientation)),
                  e && _r(this._transform, e);
              }
              get mercatorPosition() {
                const e = this.position;
                return new t.MercatorCoordinate(e[0], e[1], e[2]);
              }
              get position() {
                const t = mr(this._transform, 3);
                return [t[0], t[1], t[2]];
              }
              set position(t) {
                _r(this._transform, t);
              }
              get orientation() {
                return this._orientation;
              }
              set orientation(t) {
                (this._orientation = t), yr(this._transform, this._orientation);
              }
              getPitchBearing() {
                const t = this.forward(),
                  e = this.right();
                return {
                  bearing: Math.atan2(-e[1], e[0]),
                  pitch: Math.atan2(
                    Math.sqrt(t[0] * t[0] + t[1] * t[1]),
                    -t[2]
                  ),
                };
              }
              setPitchBearing(t, e) {
                (this._orientation = vr(t, e)),
                  yr(this._transform, this._orientation);
              }
              forward() {
                const t = mr(this._transform, 2);
                return [-t[0], -t[1], -t[2]];
              }
              up() {
                const t = mr(this._transform, 1);
                return [-t[0], -t[1], -t[2]];
              }
              right() {
                const t = mr(this._transform, 0);
                return [t[0], t[1], t[2]];
              }
              getCameraToWorld(e, n) {
                const r = new Float64Array(16);
                return t.invert(r, this.getWorldToCamera(e, n)), r;
              }
              getWorldToCameraPosition(e, n, r) {
                const i = this.position;
                t.scale(i, i, -e);
                const o = new Float64Array(16);
                return (
                  t.fromScaling(o, [r, r, r]),
                  t.translate(o, o, i),
                  (o[10] *= n),
                  o
                );
              }
              getWorldToCamera(e, n) {
                const r = new Float64Array(16),
                  i = new Float64Array(4),
                  o = this.position;
                return (
                  t.conjugate(i, this._orientation),
                  t.scale(o, o, -e),
                  t.fromQuat(r, i),
                  t.translate(r, r, o),
                  (r[1] *= -1),
                  (r[5] *= -1),
                  (r[9] *= -1),
                  (r[13] *= -1),
                  (r[8] *= n),
                  (r[9] *= n),
                  (r[10] *= n),
                  (r[11] *= n),
                  r
                );
              }
              getCameraToClipPerspective(e, n, r, i) {
                const o = new Float64Array(16);
                return t.perspective(o, e, n, r, i), o;
              }
              getDistanceToElevation(e) {
                const n =
                    0 === e ? 0 : t.mercatorZfromAltitude(e, this.position[1]),
                  r = this.forward();
                return (n - this.position[2]) / r[2];
              }
              clone() {
                return new wr([...this.position], [...this.orientation]);
              }
            }
            class Sr {
              constructor(e, n, r, i, o) {
                (this.tileSize = 512),
                  (this.maxValidLatitude = 85.051129),
                  (this._renderWorldCopies = void 0 === o || o),
                  (this._minZoom = e || 0),
                  (this._maxZoom = n || 22),
                  (this._minPitch = null == r ? 0 : r),
                  (this._maxPitch = null == i ? 60 : i),
                  this.setMaxBounds(),
                  (this.width = 0),
                  (this.height = 0),
                  (this._center = new t.LngLat(0, 0)),
                  (this.zoom = 0),
                  (this.angle = 0),
                  (this._fov = 0.6435011087932844),
                  (this._pitch = 0),
                  (this._unmodified = !0),
                  (this._edgeInsets = new fr()),
                  (this._projMatrixCache = {}),
                  (this._alignedProjMatrixCache = {}),
                  (this._fogTileMatrixCache = {}),
                  (this._camera = new wr()),
                  (this._centerAltitude = 0),
                  (this._averageElevation = 0),
                  (this.cameraElevationReference = "ground"),
                  (this._horizonShift = 0.1);
              }
              clone() {
                const t = new Sr(
                  this._minZoom,
                  this._maxZoom,
                  this._minPitch,
                  this.maxPitch,
                  this._renderWorldCopies
                );
                return (
                  (t._elevation = this._elevation),
                  (t._centerAltitude = this._centerAltitude),
                  (t.tileSize = this.tileSize),
                  (t.latRange = this.latRange),
                  (t.width = this.width),
                  (t.height = this.height),
                  (t.cameraElevationReference = this.cameraElevationReference),
                  (t._center = this._center),
                  t._setZoom(this.zoom),
                  (t._cameraZoom = this._cameraZoom),
                  (t.angle = this.angle),
                  (t._fov = this._fov),
                  (t._pitch = this._pitch),
                  (t._averageElevation = this._averageElevation),
                  (t._unmodified = this._unmodified),
                  (t._edgeInsets = this._edgeInsets.clone()),
                  (t._camera = this._camera.clone()),
                  t._calcMatrices(),
                  (t.freezeTileCoverage = this.freezeTileCoverage),
                  t
                );
              }
              get elevation() {
                return this._elevation;
              }
              set elevation(t) {
                this._elevation !== t &&
                  ((this._elevation = t),
                  t
                    ? this._updateCenterElevation() &&
                      this._updateCameraOnTerrain()
                    : ((this._cameraZoom = null), (this._centerAltitude = 0)),
                  this._calcMatrices());
              }
              updateElevation(t) {
                this._terrainEnabled() &&
                  null == this._cameraZoom &&
                  this._updateCenterElevation() &&
                  this._updateCameraOnTerrain(),
                  t && this._constrainCameraAltitude(),
                  this._calcMatrices();
              }
              get minZoom() {
                return this._minZoom;
              }
              set minZoom(t) {
                this._minZoom !== t &&
                  ((this._minZoom = t), (this.zoom = Math.max(this.zoom, t)));
              }
              get maxZoom() {
                return this._maxZoom;
              }
              set maxZoom(t) {
                this._maxZoom !== t &&
                  ((this._maxZoom = t), (this.zoom = Math.min(this.zoom, t)));
              }
              get minPitch() {
                return this._minPitch;
              }
              set minPitch(t) {
                this._minPitch !== t &&
                  ((this._minPitch = t),
                  (this.pitch = Math.max(this.pitch, t)));
              }
              get maxPitch() {
                return this._maxPitch;
              }
              set maxPitch(t) {
                this._maxPitch !== t &&
                  ((this._maxPitch = t),
                  (this.pitch = Math.min(this.pitch, t)));
              }
              get renderWorldCopies() {
                return this._renderWorldCopies;
              }
              set renderWorldCopies(t) {
                void 0 === t ? (t = !0) : null === t && (t = !1),
                  (this._renderWorldCopies = t);
              }
              get worldSize() {
                return this.tileSize * this.scale;
              }
              get cameraWorldSize() {
                const t = Math.max(
                  this._camera.getDistanceToElevation(this._averageElevation),
                  Number.EPSILON
                );
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(t));
              }
              get pixelsPerMeter() {
                return (
                  t.mercatorZfromAltitude(1, this.center.lat) * this.worldSize
                );
              }
              get cameraPixelsPerMeter() {
                return (
                  t.mercatorZfromAltitude(1, this.center.lat) *
                  this.cameraWorldSize
                );
              }
              get centerOffset() {
                return this.centerPoint._sub(this.size._div(2));
              }
              get size() {
                return new t.pointGeometry(this.width, this.height);
              }
              get bearing() {
                return (-this.angle / Math.PI) * 180;
              }
              set bearing(e) {
                const n = (-t.wrap(e, -180, 180) * Math.PI) / 180;
                var r;
                this.angle !== n &&
                  ((this._unmodified = !1),
                  (this.angle = n),
                  this._calcMatrices(),
                  (this.rotationMatrix =
                    ((r = new t.ARRAY_TYPE(4)),
                    t.ARRAY_TYPE != Float32Array && ((r[1] = 0), (r[2] = 0)),
                    (r[0] = 1),
                    (r[3] = 1),
                    r)),
                  (function (t, e, n) {
                    var r = e[0],
                      i = e[1],
                      o = e[2],
                      s = e[3],
                      a = Math.sin(n),
                      l = Math.cos(n);
                    (t[0] = r * l + o * a),
                      (t[1] = i * l + s * a),
                      (t[2] = r * -a + o * l),
                      (t[3] = i * -a + s * l);
                  })(this.rotationMatrix, this.rotationMatrix, this.angle));
              }
              get pitch() {
                return (this._pitch / Math.PI) * 180;
              }
              set pitch(e) {
                const n =
                  (t.clamp(e, this.minPitch, this.maxPitch) / 180) * Math.PI;
                this._pitch !== n &&
                  ((this._unmodified = !1),
                  (this._pitch = n),
                  this._calcMatrices());
              }
              get fov() {
                return (this._fov / Math.PI) * 180;
              }
              set fov(t) {
                (t = Math.max(0.01, Math.min(60, t))),
                  this._fov !== t &&
                    ((this._unmodified = !1),
                    (this._fov = (t / 180) * Math.PI),
                    this._calcMatrices());
              }
              get averageElevation() {
                return this._averageElevation;
              }
              set averageElevation(t) {
                (this._averageElevation = t), this._calcFogMatrices();
              }
              get zoom() {
                return this._zoom;
              }
              set zoom(t) {
                const e = Math.min(Math.max(t, this.minZoom), this.maxZoom);
                this._zoom !== e &&
                  ((this._unmodified = !1),
                  this._setZoom(e),
                  this._terrainEnabled() && this._updateCameraOnTerrain(),
                  this._constrain(),
                  this._calcMatrices());
              }
              _setZoom(t) {
                (this._zoom = t),
                  (this.scale = this.zoomScale(t)),
                  (this.tileZoom = Math.floor(t)),
                  (this.zoomFraction = t - this.tileZoom);
              }
              _updateCenterElevation() {
                if (!this._elevation) return !1;
                const e = this._elevation.getAtPointOrZero(
                  t.MercatorCoordinate.fromLngLat(this.center),
                  -1
                );
                return -1 === e
                  ? ((this._cameraZoom = null), !1)
                  : ((this._centerAltitude = e), !0);
              }
              _updateCameraOnTerrain() {
                const e = this.cameraToCenterDistance / this.worldSize,
                  n = t.mercatorZfromAltitude(
                    this._centerAltitude,
                    this.center.lat
                  );
                this._cameraZoom = this._zoomFromMercatorZ(n + e);
              }
              sampleAverageElevation() {
                if (!this._elevation) return 0;
                const e = this._elevation,
                  n = [
                    [0.5, 0.2],
                    [0.3, 0.5],
                    [0.5, 0.5],
                    [0.7, 0.5],
                    [0.5, 0.8],
                  ],
                  r = this.horizonLineFromTop();
                let i = 0,
                  o = 0;
                for (let s = 0; s < n.length; s++) {
                  const a = new t.pointGeometry(
                      n[s][0] * this.width,
                      r + n[s][1] * (this.height - r)
                    ),
                    l = e.pointCoordinate(a);
                  if (!l) continue;
                  const c =
                    1 /
                    Math.hypot(
                      l[0] - this._camera.position[0],
                      l[1] - this._camera.position[1]
                    );
                  (i += l[3] * c), (o += c);
                }
                return 0 === o ? NaN : i / o;
              }
              get center() {
                return this._center;
              }
              set center(t) {
                (t.lat === this._center.lat && t.lng === this._center.lng) ||
                  ((this._unmodified = !1),
                  (this._center = t),
                  this._terrainEnabled() &&
                    ("ground" === this.cameraElevationReference
                      ? this._updateCenterElevation()
                        ? this._updateCameraOnTerrain()
                        : (this._cameraZoom = null)
                      : this._updateZoomFromElevation()),
                  this._constrain(),
                  this._calcMatrices());
              }
              _updateZoomFromElevation() {
                if (null == this._cameraZoom || !this._elevation) return;
                const e = this._cameraZoom,
                  n = this._elevation.getAtPointOrZero(
                    t.MercatorCoordinate.fromLngLat(this.center)
                  ),
                  r = t.mercatorZfromAltitude(n, this.center.lat),
                  i = this._mercatorZfromZoom(e),
                  o = this._mercatorZfromZoom(this._maxZoom),
                  s = Math.max(i - r, o);
                this._setZoom(this._zoomFromMercatorZ(s));
              }
              get padding() {
                return this._edgeInsets.toJSON();
              }
              set padding(t) {
                this._edgeInsets.equals(t) ||
                  ((this._unmodified = !1),
                  this._edgeInsets.interpolate(this._edgeInsets, t, 1),
                  this._calcMatrices());
              }
              computeZoomRelativeTo(e) {
                const n = this.rayIntersectionCoordinate(
                  this.pointRayIntersection(this.centerPoint, e.toAltitude())
                );
                let r;
                r =
                  e.z < this._camera.position[2]
                    ? [n.x, n.y, n.z]
                    : [e.x, e.y, e.z];
                const i = t.length(t.sub([], this._camera.position, r));
                return t.clamp(
                  this._zoomFromMercatorZ(i),
                  this._minZoom,
                  this._maxZoom
                );
              }
              setFreeCameraOptions(e) {
                if (!this.height) return;
                if (!e.position && !e.orientation) return;
                this._updateCameraState();
                let n = !1;
                if (
                  (e.orientation &&
                    !t.exactEquals(e.orientation, this._camera.orientation) &&
                    (n = this._setCameraOrientation(e.orientation)),
                  e.position)
                ) {
                  const r = [e.position.x, e.position.y, e.position.z];
                  t.exactEquals$1(r, this._camera.position) ||
                    (this._setCameraPosition(r), (n = !0));
                }
                n && (this._updateStateFromCamera(), this.recenterOnTerrain());
              }
              getFreeCameraOptions() {
                this._updateCameraState();
                const e = this._camera.position,
                  n = new xr();
                return (
                  (n.position = new t.MercatorCoordinate(e[0], e[1], e[2])),
                  (n.orientation = this._camera.orientation),
                  (n._elevation = this.elevation),
                  (n._renderWorldCopies = this._renderWorldCopies),
                  n
                );
              }
              _setCameraOrientation(e) {
                if (!t.length$1(e)) return !1;
                t.normalize$1(e, e);
                const n = t.transformQuat([], [0, 0, -1], e),
                  r = t.transformQuat([], [0, -1, 0], e);
                if (r[2] < 0) return !1;
                const i = br(n, r);
                return !!i && ((this._camera.orientation = i), !0);
              }
              _setCameraPosition(e) {
                const n = this.zoomScale(this.minZoom) * this.tileSize,
                  r = this.zoomScale(this.maxZoom) * this.tileSize,
                  i = this.cameraToCenterDistance;
                (e[2] = t.clamp(e[2], i / r, i / n)),
                  (this._camera.position = e);
              }
              get centerPoint() {
                return this._edgeInsets.getCenter(this.width, this.height);
              }
              get fovAboveCenter() {
                return this._fov * (0.5 + this.centerOffset.y / this.height);
              }
              isPaddingEqual(t) {
                return this._edgeInsets.equals(t);
              }
              interpolatePadding(t, e, n) {
                (this._unmodified = !1),
                  this._edgeInsets.interpolate(t, e, n),
                  this._constrain(),
                  this._calcMatrices();
              }
              coveringZoomLevel(t) {
                const e = (t.roundZoom ? Math.round : Math.floor)(
                  this.zoom + this.scaleZoom(this.tileSize / t.tileSize)
                );
                return Math.max(0, e);
              }
              getVisibleUnwrappedCoordinates(e) {
                const n = [new t.UnwrappedTileID(0, e)];
                if (this._renderWorldCopies) {
                  const r = this.pointCoordinate(new t.pointGeometry(0, 0)),
                    i = this.pointCoordinate(
                      new t.pointGeometry(this.width, 0)
                    ),
                    o = this.pointCoordinate(
                      new t.pointGeometry(this.width, this.height)
                    ),
                    s = this.pointCoordinate(
                      new t.pointGeometry(0, this.height)
                    ),
                    a = Math.floor(Math.min(r.x, i.x, o.x, s.x)),
                    l = Math.floor(Math.max(r.x, i.x, o.x, s.x)),
                    c = 1;
                  for (let u = a - c; u <= l + c; u++)
                    0 !== u && n.push(new t.UnwrappedTileID(u, e));
                }
                return n;
              }
              coveringTiles(e) {
                let n = this.coveringZoomLevel(e);
                const r = n,
                  i = this.elevation && !e.isTerrainDEM;
                if (void 0 !== e.minzoom && n < e.minzoom) return [];
                void 0 !== e.maxzoom && n > e.maxzoom && (n = e.maxzoom);
                const o = t.MercatorCoordinate.fromLngLat(this.center),
                  s = 1 << n,
                  a = [s * o.x, s * o.y, 0],
                  l = d.fromInvProjectionMatrix(
                    this.invProjMatrix,
                    this.worldSize,
                    n
                  ),
                  c = this.pointCoordinate(this.getCameraPoint()),
                  u = s * t.mercatorZfromAltitude(1, this.center.lat),
                  h =
                    this._camera.position[2] /
                    t.mercatorZfromAltitude(1, this.center.lat),
                  p = [s * c.x, s * c.y, h],
                  m =
                    (this.cameraToCenterDistance / e.tileSize) *
                    (e.roundZoom ? 1 : 0.502),
                  g =
                    this.pitch <= 60 &&
                    this._edgeInsets.top <= this._edgeInsets.bottom &&
                    !this._elevation
                      ? n
                      : 0,
                  y =
                    e.isTerrainDEM && this._elevation
                      ? 1e4 * this._elevation.exaggeration()
                      : this._centerAltitude,
                  _ = e.isTerrainDEM
                    ? -y
                    : this._elevation
                    ? this._elevation.getMinElevationBelowMSL()
                    : 0,
                  v = (t) => ({
                    aabb: new f([t * s, 0, _], [(t + 1) * s, s, y]),
                    zoom: 0,
                    x: 0,
                    y: 0,
                    wrap: t,
                    fullyVisible: !1,
                  }),
                  b = [],
                  x = [],
                  w = n,
                  S = e.reparseOverscaled ? r : n,
                  E = (t) => {
                    if (!this._elevation || !t.tileID) return;
                    const e = this._elevation.getMinMaxForTile(t.tileID),
                      n = t.aabb;
                    e
                      ? ((n.min[2] = e.min),
                        (n.max[2] = e.max),
                        (n.center[2] = (n.min[2] + n.max[2]) / 2))
                      : ((t.shouldSplit = C(t)),
                        t.shouldSplit ||
                          (n.min[2] =
                            n.max[2] =
                            n.center[2] =
                              this._centerAltitude));
                  },
                  T = (t) => t * t,
                  A = T((h - this._centerAltitude) * u),
                  C = (t) => {
                    if (t.zoom < g) return !0;
                    if (t.zoom === w) return !1;
                    if (null != t.shouldSplit) return t.shouldSplit;
                    const e = t.aabb.distanceX(p),
                      n = t.aabb.distanceY(p);
                    let r = A;
                    i && (r = T(t.aabb.distanceZ(p) * u));
                    const o = e * e + n * n + r;
                    return (
                      o <
                      T(
                        (1 << (w - t.zoom)) *
                          m *
                          ((t, e) => {
                            if (e * T(0.707) < t) return 1;
                            const n = Math.sqrt(e / t);
                            return (
                              n /
                              (1.4144271570014144 +
                                (Math.pow(1.1, n - 1.4144271570014144 + 1) -
                                  1) /
                                  (1.1 - 1) -
                                1)
                            );
                          })(Math.max(r, A), o)
                      )
                    );
                  };
                if (this._renderWorldCopies)
                  for (let t = 1; t <= 3; t++) b.push(v(-t)), b.push(v(t));
                for (b.push(v(0)); b.length > 0; ) {
                  const r = b.pop(),
                    o = r.x,
                    s = r.y;
                  let c = r.fullyVisible;
                  if (!c) {
                    const t = r.aabb.intersects(l);
                    if (0 === t) continue;
                    c = 2 === t;
                  }
                  if (r.zoom !== w && C(r))
                    for (let e = 0; e < 4; e++) {
                      const n = (o << 1) + (e % 2),
                        a = (s << 1) + (e >> 1),
                        l = {
                          aabb: r.aabb.quadrant(e),
                          zoom: r.zoom + 1,
                          x: n,
                          y: a,
                          wrap: r.wrap,
                          fullyVisible: c,
                          tileID: void 0,
                          shouldSplit: void 0,
                        };
                      i &&
                        ((l.tileID = new t.OverscaledTileID(
                          r.zoom + 1 === w ? S : r.zoom + 1,
                          r.wrap,
                          r.zoom + 1,
                          n,
                          a
                        )),
                        E(l)),
                        b.push(l);
                    }
                  else {
                    const i = r.zoom === w ? S : r.zoom;
                    if (e.minzoom && e.minzoom > i) continue;
                    const l =
                        a[0] -
                        (0.5 + o + (r.wrap << r.zoom)) * (1 << (n - r.zoom)),
                      c = a[1] - 0.5 - s,
                      u = r.tileID
                        ? r.tileID
                        : new t.OverscaledTileID(i, r.wrap, r.zoom, o, s);
                    x.push({ tileID: u, distanceSq: l * l + c * c });
                  }
                }
                if (this.fogCullDistSq) {
                  const e = this.fogCullDistSq;
                  x.splice(
                    0,
                    x.length,
                    ...x.filter((n) => {
                      const r = [0, 0, 0, 1],
                        o = [t.EXTENT, t.EXTENT, 0, 1],
                        s = this.calculateFogTileMatrix(n.tileID.toUnwrapped());
                      t.transformMat4(r, r, s), t.transformMat4(o, o, s);
                      const a = t.getAABBPointSquareDist(r, o);
                      if (0 === a) return !0;
                      let l = !1;
                      const c = this.horizonLineFromTop();
                      if (a > e && 0 !== c) {
                        const e = this.calculateProjMatrix(
                          n.tileID.toUnwrapped()
                        );
                        let r;
                        i &&
                          this._elevation &&
                          (r = this._elevation.getMinMaxForTile(n.tileID)),
                          r || (r = { min: _, max: y });
                        const o = t.furthestTileCorner(this.bearing),
                          s = [o[0] * t.EXTENT, o[1] * t.EXTENT, r.max];
                        t.transformMat4$1(s, s, e),
                          (l = (1 - s[1]) * this.height * 0.5 < c);
                      }
                      return a < e || l;
                    })
                  );
                }
                return x
                  .sort((t, e) => t.distanceSq - e.distanceSq)
                  .map((t) => t.tileID);
              }
              resize(t, e) {
                (this.width = t),
                  (this.height = e),
                  (this.pixelsToGLUnits = [2 / t, -2 / e]),
                  this._constrain(),
                  this._calcMatrices();
              }
              get unmodified() {
                return this._unmodified;
              }
              zoomScale(t) {
                return Math.pow(2, t);
              }
              scaleZoom(t) {
                return Math.log(t) / Math.LN2;
              }
              project(e) {
                const n = t.clamp(
                  e.lat,
                  -this.maxValidLatitude,
                  this.maxValidLatitude
                );
                return new t.pointGeometry(
                  t.mercatorXfromLng(e.lng) * this.worldSize,
                  t.mercatorYfromLat(n) * this.worldSize
                );
              }
              unproject(e) {
                return new t.MercatorCoordinate(
                  e.x / this.worldSize,
                  e.y / this.worldSize
                ).toLngLat();
              }
              get point() {
                return this.project(this.center);
              }
              setLocationAtPoint(e, n) {
                const r = this.pointCoordinate(n),
                  i = this.pointCoordinate(this.centerPoint),
                  o = this.locationCoordinate(e),
                  s = new t.MercatorCoordinate(
                    o.x - (r.x - i.x),
                    o.y - (r.y - i.y)
                  );
                (this.center = this.coordinateLocation(s)),
                  this._renderWorldCopies && (this.center = this.center.wrap());
              }
              setLocation(t) {
                (this.center = this.coordinateLocation(t)),
                  this._renderWorldCopies && (this.center = this.center.wrap());
              }
              locationPoint(t) {
                return this._coordinatePoint(this.locationCoordinate(t), !1);
              }
              locationPoint3D(t) {
                return this._coordinatePoint(this.locationCoordinate(t), !0);
              }
              pointLocation(t) {
                return this.coordinateLocation(this.pointCoordinate(t));
              }
              pointLocation3D(t) {
                return this.coordinateLocation(this.pointCoordinate3D(t));
              }
              locationCoordinate(e) {
                return t.MercatorCoordinate.fromLngLat(e);
              }
              coordinateLocation(t) {
                return t.toLngLat();
              }
              pointRayIntersection(e, n) {
                const r = null != n ? n : this._centerAltitude,
                  i = [e.x, e.y, 0, 1],
                  o = [e.x, e.y, 1, 1];
                t.transformMat4(i, i, this.pixelMatrixInverse),
                  t.transformMat4(o, o, this.pixelMatrixInverse);
                const s = o[3];
                t.scale$2(i, i, 1 / i[3]), t.scale$2(o, o, 1 / s);
                const a = i[2],
                  l = o[2];
                return { p0: i, p1: o, t: a === l ? 0 : (r - a) / (l - a) };
              }
              screenPointToMercatorRay(e) {
                const n = [e.x, e.y, 0, 1],
                  r = [e.x, e.y, 1, 1];
                return (
                  t.transformMat4(n, n, this.pixelMatrixInverse),
                  t.transformMat4(r, r, this.pixelMatrixInverse),
                  t.scale$2(n, n, 1 / n[3]),
                  t.scale$2(r, r, 1 / r[3]),
                  (n[2] =
                    t.mercatorZfromAltitude(n[2], this._center.lat) *
                    this.worldSize),
                  (r[2] =
                    t.mercatorZfromAltitude(r[2], this._center.lat) *
                    this.worldSize),
                  t.scale$2(n, n, 1 / this.worldSize),
                  t.scale$2(r, r, 1 / this.worldSize),
                  new p([n[0], n[1], n[2]], t.normalize([], t.sub([], r, n)))
                );
              }
              rayIntersectionCoordinate(e) {
                const { p0: n, p1: r, t: i } = e,
                  o = t.mercatorZfromAltitude(n[2], this._center.lat),
                  s = t.mercatorZfromAltitude(r[2], this._center.lat);
                return new t.MercatorCoordinate(
                  t.number(n[0], r[0], i) / this.worldSize,
                  t.number(n[1], r[1], i) / this.worldSize,
                  t.number(o, s, i)
                );
              }
              pointCoordinate(e) {
                const n = this.horizonLineFromTop(!1),
                  r = new t.pointGeometry(e.x, Math.max(n, e.y));
                return this.rayIntersectionCoordinate(
                  this.pointRayIntersection(r)
                );
              }
              pointCoordinate3D(e) {
                if (!this.elevation) return this.pointCoordinate(e);
                const n = this.elevation;
                let r = this.elevation.pointCoordinate(e);
                if (r) return new t.MercatorCoordinate(r[0], r[1], r[2]);
                let i = 0,
                  o = this.horizonLineFromTop();
                if (e.y > o) return this.pointCoordinate(e);
                const s = 0.02 * o,
                  a = e.clone();
                for (let l = 0; l < 10 && o - i > s; l++) {
                  a.y = t.number(i, o, 0.66);
                  const e = n.pointCoordinate(a);
                  e ? ((o = a.y), (r = e)) : (i = a.y);
                }
                return r
                  ? new t.MercatorCoordinate(r[0], r[1], r[2])
                  : this.pointCoordinate(e);
              }
              isPointAboveHorizon(t) {
                if (this.elevation) return !this.elevation.pointCoordinate(t);
                {
                  const e = this.horizonLineFromTop();
                  return t.y < e;
                }
              }
              _coordinatePoint(e, n) {
                const r =
                    n && this.elevation
                      ? this.elevation.getAtPointOrZero(e, this._centerAltitude)
                      : this._centerAltitude,
                  i = [
                    e.x * this.worldSize,
                    e.y * this.worldSize,
                    r + e.toAltitude(),
                    1,
                  ];
                return (
                  t.transformMat4(i, i, this.pixelMatrix),
                  i[3] > 0
                    ? new t.pointGeometry(i[0] / i[3], i[1] / i[3])
                    : new t.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE)
                );
              }
              getBounds() {
                return this._terrainEnabled()
                  ? this._getBounds3D()
                  : new t.LngLatBounds()
                      .extend(
                        this.pointLocation(
                          new t.pointGeometry(
                            this._edgeInsets.left,
                            this._edgeInsets.top
                          )
                        )
                      )
                      .extend(
                        this.pointLocation(
                          new t.pointGeometry(
                            this.width - this._edgeInsets.right,
                            this._edgeInsets.top
                          )
                        )
                      )
                      .extend(
                        this.pointLocation(
                          new t.pointGeometry(
                            this.width - this._edgeInsets.right,
                            this.height - this._edgeInsets.bottom
                          )
                        )
                      )
                      .extend(
                        this.pointLocation(
                          new t.pointGeometry(
                            this._edgeInsets.left,
                            this.height - this._edgeInsets.bottom
                          )
                        )
                      );
              }
              _getBounds3D() {
                const e = this.elevation,
                  n = e.visibleDemTiles.reduce(
                    (t, e) => {
                      if (e.dem) {
                        const n = e.dem.tree;
                        (t.min = Math.min(t.min, n.minimums[0])),
                          (t.max = Math.max(t.max, n.maximums[0]));
                      }
                      return t;
                    },
                    { min: Number.MAX_VALUE, max: 0 }
                  );
                (n.min *= e.exaggeration()), (n.max *= e.exaggeration());
                const r = this.horizonLineFromTop();
                return [
                  new t.pointGeometry(0, r),
                  new t.pointGeometry(this.width, r),
                  new t.pointGeometry(this.width, this.height),
                  new t.pointGeometry(0, this.height),
                ].reduce(
                  (t, e) =>
                    t
                      .extend(
                        this.coordinateLocation(
                          this.rayIntersectionCoordinate(
                            this.pointRayIntersection(e, n.min)
                          )
                        )
                      )
                      .extend(
                        this.coordinateLocation(
                          this.rayIntersectionCoordinate(
                            this.pointRayIntersection(e, n.max)
                          )
                        )
                      ),
                  new t.LngLatBounds()
                );
              }
              horizonLineFromTop(t = !0) {
                const e =
                    this.height /
                      2 /
                      Math.tan(this._fov / 2) /
                      Math.tan(Math.max(this._pitch, 0.1)) +
                    this.centerOffset.y,
                  n = this.height / 2 - 0.97 * e;
                return t ? Math.max(0, n) : n;
              }
              getMaxBounds() {
                return this.latRange &&
                  2 === this.latRange.length &&
                  this.lngRange &&
                  2 === this.lngRange.length
                  ? new t.LngLatBounds(
                      [this.lngRange[0], this.latRange[0]],
                      [this.lngRange[1], this.latRange[1]]
                    )
                  : null;
              }
              setMaxBounds(t) {
                t
                  ? ((this.lngRange = [t.getWest(), t.getEast()]),
                    (this.latRange = [t.getSouth(), t.getNorth()]),
                    this._constrain())
                  : ((this.lngRange = null),
                    (this.latRange = [
                      -this.maxValidLatitude,
                      this.maxValidLatitude,
                    ]));
              }
              calculatePosMatrix(e, n) {
                const r = e.canonical,
                  i = n / this.zoomScale(r.z),
                  o = r.x + Math.pow(2, r.z) * e.wrap,
                  s = t.identity(new Float64Array(16));
                return (
                  t.translate(s, s, [o * i, r.y * i, 0]),
                  t.scale$1(s, s, [i / t.EXTENT, i / t.EXTENT, 1]),
                  s
                );
              }
              calculateFogTileMatrix(e) {
                const n = e.key,
                  r = this._fogTileMatrixCache;
                if (r[n]) return r[n];
                const i = this.calculatePosMatrix(e, this.cameraWorldSize);
                return (
                  t.multiply(i, this.worldToFogMatrix, i),
                  (r[n] = new Float32Array(i)),
                  r[n]
                );
              }
              calculateProjMatrix(e, n = !1) {
                const r = e.key,
                  i = n ? this._alignedProjMatrixCache : this._projMatrixCache;
                if (i[r]) return i[r];
                const o = this.calculatePosMatrix(e, this.worldSize);
                return (
                  t.multiply(
                    o,
                    n ? this.alignedProjMatrix : this.projMatrix,
                    o
                  ),
                  (i[r] = new Float32Array(o)),
                  i[r]
                );
              }
              customLayerMatrix() {
                return this.mercatorMatrix.slice();
              }
              recenterOnTerrain() {
                if (!this._elevation) return;
                const e = this._elevation;
                this._updateCameraState();
                const n = this._camera.position,
                  r = this._camera.forward();
                if (n[2] <= 0 || r[2] >= 0) return;
                const i = t.mercatorZfromAltitude(1, this._center.lat);
                (n[2] /= i), (r[2] /= i), t.normalize(r, r);
                const o = e.raycast(n, r, e.exaggeration());
                if (o) {
                  const e = t.scaleAndAdd([], n, r, o),
                    i = new t.MercatorCoordinate(
                      e[0],
                      e[1],
                      t.mercatorZfromAltitude(e[2], t.latFromMercatorY(e[1]))
                    ),
                    s = this._camera.position,
                    a = i.z + t.length([i.x - s[0], i.y - s[1], i.z - s[2]]);
                  (this._cameraZoom = this._zoomFromMercatorZ(a)),
                    (this._centerAltitude = i.toAltitude()),
                    (this._center = i.toLngLat()),
                    this._updateZoomFromElevation(),
                    this._constrain(),
                    this._calcMatrices();
                }
              }
              _constrainCameraAltitude() {
                if (!this._elevation) return;
                const e = this._elevation;
                this._updateCameraState();
                const n = e.getAtPointOrZero(this._camera.mercatorPosition),
                  r =
                    this._minimumHeightOverTerrain() *
                    Math.cos(t.degToRad(this._maxPitch)),
                  i = t.mercatorZfromAltitude(n, this._center.lat),
                  o = this._camera.position[2] - i;
                if (o < r) {
                  const e = t.MercatorCoordinate.fromLngLat(
                      this._center,
                      this._centerAltitude
                    ),
                    n = this._camera.mercatorPosition,
                    i = [e.x - n.x, e.y - n.y, e.z - n.z],
                    s = t.length(i);
                  i[2] -= r - o;
                  const a = t.length(i);
                  if (0 === a) return;
                  t.scale(i, i, s / a),
                    (this._camera.position = [
                      e.x - i[0],
                      e.y - i[1],
                      e.z - i[2],
                    ]),
                    (this._camera.orientation = br(i, this._camera.up())),
                    this._updateStateFromCamera();
                }
              }
              _constrain() {
                if (
                  !this.center ||
                  !this.width ||
                  !this.height ||
                  this._constraining
                )
                  return;
                this._constraining = !0;
                let e,
                  n,
                  r,
                  i,
                  o = -90,
                  s = 90,
                  a = -180,
                  l = 180;
                const c = this.size,
                  u = this._unmodified;
                if (this.latRange) {
                  const n = this.latRange;
                  (o = t.mercatorYfromLat(n[1]) * this.worldSize),
                    (s = t.mercatorYfromLat(n[0]) * this.worldSize),
                    (e = s - o < c.y ? c.y / (s - o) : 0);
                }
                if (this.lngRange) {
                  const e = this.lngRange;
                  (a = t.mercatorXfromLng(e[0]) * this.worldSize),
                    (l = t.mercatorXfromLng(e[1]) * this.worldSize),
                    (n = l - a < c.x ? c.x / (l - a) : 0);
                }
                const h = this.point,
                  p = Math.max(n || 0, e || 0);
                if (p)
                  return (
                    (this.center = this.unproject(
                      new t.pointGeometry(
                        n ? (l + a) / 2 : h.x,
                        e ? (s + o) / 2 : h.y
                      )
                    )),
                    (this.zoom += this.scaleZoom(p)),
                    (this._unmodified = u),
                    void (this._constraining = !1)
                  );
                if (this.latRange) {
                  const t = h.y,
                    e = c.y / 2;
                  t - e < o && (i = o + e), t + e > s && (i = s - e);
                }
                if (this.lngRange) {
                  const t = h.x,
                    e = c.x / 2;
                  t - e < a && (r = a + e), t + e > l && (r = l - e);
                }
                (void 0 === r && void 0 === i) ||
                  (this.center = this.unproject(
                    new t.pointGeometry(
                      void 0 !== r ? r : h.x,
                      void 0 !== i ? i : h.y
                    )
                  )),
                  this._constrainCameraAltitude(),
                  (this._unmodified = u),
                  (this._constraining = !1);
              }
              _minZoomForBounds() {
                const e = (t, e) =>
                  Math.log2(t / (this.tileSize * Math.abs(e[1] - e[0])));
                let n = 0;
                if (this.latRange) {
                  const r = this.latRange;
                  n = e(this.height, [
                    t.mercatorYfromLat(r[0]),
                    t.mercatorYfromLat(r[1]),
                  ]);
                }
                let r = 0;
                if (this.lngRange) {
                  const n = this.lngRange;
                  r = e(this.width, [
                    t.mercatorXfromLng(n[0]),
                    t.mercatorXfromLng(n[1]),
                  ]);
                }
                return Math.max(n, r);
              }
              _maxCameraBoundsDistance() {
                return this._mercatorZfromZoom(this._minZoomForBounds());
              }
              _calcMatrices() {
                if (!this.height) return;
                const e = this.centerOffset;
                this.cameraToCenterDistance =
                  (0.5 / Math.tan(this._fov / 2)) * this.height;
                const n = this.pixelsPerMeter;
                this._updateCameraState();
                const r = Math.PI / 2 + this._pitch,
                  i = this.fovAboveCenter,
                  o = this.elevation
                    ? this.elevation.getMinElevationBelowMSL() * n
                    : 0,
                  s =
                    (this._camera.position[2] * this.worldSize - o) /
                    Math.cos(this._pitch),
                  a =
                    (Math.sin(i) * s) /
                    Math.sin(t.clamp(Math.PI - r - i, 0.01, Math.PI - 0.01)),
                  l = this.point,
                  c = l.x,
                  u = l.y,
                  h = Math.cos(Math.PI / 2 - this._pitch) * a + s,
                  p = Math.min(1.01 * h, s * (1 / this._horizonShift)),
                  d = this.height / 50,
                  f = this._camera.getWorldToCamera(this.worldSize, n),
                  m = this._camera.getCameraToClipPerspective(
                    this._fov,
                    this.width / this.height,
                    d,
                    p
                  );
                (m[8] = (2 * -e.x) / this.width),
                  (m[9] = (2 * e.y) / this.height);
                let g = t.mul$1([], m, f);
                (this.mercatorMatrix = t.scale$1([], g, [
                  this.worldSize,
                  this.worldSize,
                  this.worldSize / n,
                ])),
                  (this.projMatrix = g),
                  (this.invProjMatrix = t.invert(
                    new Float64Array(16),
                    this.projMatrix
                  ));
                const y = new Float32Array(16);
                t.identity(y),
                  t.scale$1(y, y, [1, -1, 1]),
                  t.rotateX(y, y, this._pitch),
                  t.rotateZ(y, y, this.angle);
                const _ = t.perspective(
                    new Float32Array(16),
                    this._fov,
                    this.width / this.height,
                    d,
                    p
                  ),
                  v =
                    (Math.PI / 2 - this._pitch) *
                    (this.height / this._fov) *
                    this._horizonShift;
                (_[8] = (2 * -e.x) / this.width),
                  (_[9] = (2 * (e.y + v)) / this.height),
                  (this.skyboxMatrix = t.multiply(y, _, y));
                const b = (this.width % 2) / 2,
                  x = (this.height % 2) / 2,
                  w = Math.cos(this.angle),
                  S = Math.sin(this.angle),
                  E = c - Math.round(c) + w * b + S * x,
                  T = u - Math.round(u) + w * x + S * b,
                  A = new Float64Array(g);
                if (
                  (t.translate(A, A, [
                    E > 0.5 ? E - 1 : E,
                    T > 0.5 ? T - 1 : T,
                    0,
                  ]),
                  (this.alignedProjMatrix = A),
                  (g = t.create$1()),
                  t.scale$1(g, g, [this.width / 2, -this.height / 2, 1]),
                  t.translate(g, g, [1, -1, 0]),
                  (this.labelPlaneMatrix = g),
                  (g = t.create$1()),
                  t.scale$1(g, g, [1, -1, 1]),
                  t.translate(g, g, [-1, -1, 0]),
                  t.scale$1(g, g, [2 / this.width, 2 / this.height, 1]),
                  (this.glCoordMatrix = g),
                  (this.pixelMatrix = t.multiply(
                    new Float64Array(16),
                    this.labelPlaneMatrix,
                    this.projMatrix
                  )),
                  this._calcFogMatrices(),
                  (g = t.invert(new Float64Array(16), this.pixelMatrix)),
                  !g)
                )
                  throw new Error("failed to invert matrix");
                (this.pixelMatrixInverse = g),
                  (this._projMatrixCache = {}),
                  (this._alignedProjMatrixCache = {});
              }
              _calcFogMatrices() {
                this._fogTileMatrixCache = {};
                const e = this.cameraWorldSize,
                  n = this.cameraPixelsPerMeter,
                  r = this._camera.position,
                  i = 1 / this.height,
                  o = [e, e, n];
                t.scale(o, o, i), t.scale(r, r, -1), t.multiply$1(r, r, o);
                const s = t.create$1();
                t.translate(s, s, r),
                  t.scale$1(s, s, o),
                  (this.mercatorFogMatrix = s),
                  (this.worldToFogMatrix =
                    this._camera.getWorldToCameraPosition(e, n, i));
              }
              _updateCameraState() {
                if (!this.height) return;
                this._camera.setPitchBearing(this._pitch, this.angle);
                const e = this._camera.forward(),
                  n = this.cameraToCenterDistance,
                  r = this.point,
                  i =
                    this._mercatorZfromZoom(
                      this._cameraZoom ? this._cameraZoom : this._zoom
                    ) -
                    t.mercatorZfromAltitude(
                      this._centerAltitude,
                      this.center.lat
                    ),
                  o = this.cameraToCenterDistance / i;
                this._camera.position = [
                  r.x / this.worldSize - (e[0] * n) / o,
                  r.y / this.worldSize - (e[1] * n) / o,
                  t.mercatorZfromAltitude(
                    this._centerAltitude,
                    this._center.lat
                  ) +
                    (-e[2] * n) / o,
                ];
              }
              _translateCameraConstrained(e) {
                const n =
                    this._maxCameraBoundsDistance() * Math.cos(this._pitch),
                  r = e[2];
                let i = 1;
                r > 0 && (i = Math.min((n - this._camera.position[2]) / r, 1)),
                  (this._camera.position = t.scaleAndAdd(
                    [],
                    this._camera.position,
                    e,
                    i
                  )),
                  this._updateStateFromCamera();
              }
              _updateStateFromCamera() {
                const e = this._camera.position,
                  n = this._camera.forward(),
                  { pitch: r, bearing: i } = this._camera.getPitchBearing(),
                  o = t.mercatorZfromAltitude(
                    this._centerAltitude,
                    this.center.lat
                  ),
                  s =
                    this._mercatorZfromZoom(this._maxZoom) *
                    Math.cos(t.degToRad(this._maxPitch)),
                  a = Math.max((e[2] - o) / Math.cos(r), s),
                  l = this._zoomFromMercatorZ(a);
                t.scaleAndAdd(e, e, n, a),
                  (this._pitch = t.clamp(
                    r,
                    t.degToRad(this.minPitch),
                    t.degToRad(this.maxPitch)
                  )),
                  (this.angle = t.wrap(i, -Math.PI, Math.PI)),
                  this._setZoom(t.clamp(l, this._minZoom, this._maxZoom)),
                  this._terrainEnabled() && this._updateCameraOnTerrain(),
                  (this._center = new t.MercatorCoordinate(
                    e[0],
                    e[1],
                    e[2]
                  ).toLngLat()),
                  (this._unmodified = !1),
                  this._constrain(),
                  this._calcMatrices();
              }
              _worldSizeFromZoom(t) {
                return Math.pow(2, t) * this.tileSize;
              }
              _mercatorZfromZoom(t) {
                return this.cameraToCenterDistance / this._worldSizeFromZoom(t);
              }
              _minimumHeightOverTerrain() {
                const t = Math.min(
                  (null != this._cameraZoom ? this._cameraZoom : this._zoom) +
                    2,
                  this._maxZoom
                );
                return this._mercatorZfromZoom(t);
              }
              _zoomFromMercatorZ(t) {
                return this.scaleZoom(
                  this.cameraToCenterDistance / (t * this.tileSize)
                );
              }
              _terrainEnabled() {
                return !!this._elevation;
              }
              isHorizonVisibleForPoints(e, n) {
                const r = Math.min(e.x, n.x),
                  i = Math.max(e.x, n.x),
                  o = Math.min(e.y, n.y),
                  s = Math.max(e.y, n.y),
                  a = [
                    new t.pointGeometry(r, o),
                    new t.pointGeometry(i, s),
                    new t.pointGeometry(r, s),
                    new t.pointGeometry(i, o),
                  ],
                  l = this._renderWorldCopies ? -3 : 0,
                  c = this._renderWorldCopies ? 4 : 1;
                for (const t of a) {
                  const e = this.pointRayIntersection(t);
                  if (e.t < 0) return !0;
                  const n = this.rayIntersectionCoordinate(e);
                  if (n.x < l || n.y < 0 || n.x > c || n.y > 1) return !0;
                }
                return !1;
              }
              isHorizonVisible() {
                return (
                  this.pitch + t.radToDeg(this.fovAboveCenter) > 88 ||
                  this.isHorizonVisibleForPoints(
                    new t.pointGeometry(0, 0),
                    new t.pointGeometry(this.width, this.height)
                  )
                );
              }
              zoomDeltaToMovement(e, n) {
                const r = t.length(t.sub([], this._camera.position, e)),
                  i = this._zoomFromMercatorZ(r) + n;
                return r - this._mercatorZfromZoom(i);
              }
              getCameraPoint() {
                const e =
                  Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                return this.centerPoint.add(new t.pointGeometry(0, e));
              }
            }
            function Er(t, e) {
              let n = !1,
                r = null;
              const i = () => {
                (r = null), n && (t(), (r = setTimeout(i, e)), (n = !1));
              };
              return () => ((n = !0), r || i(), r);
            }
            class Tr {
              constructor(e) {
                (this._hashName = e && encodeURIComponent(e)),
                  t.bindAll(
                    ["_getCurrentHash", "_onHashChange", "_updateHash"],
                    this
                  ),
                  (this._updateHash = Er(
                    this._updateHashUnthrottled.bind(this),
                    300
                  ));
              }
              addTo(e) {
                return (
                  (this._map = e),
                  t.window.addEventListener(
                    "hashchange",
                    this._onHashChange,
                    !1
                  ),
                  this._map.on("moveend", this._updateHash),
                  this
                );
              }
              remove() {
                return (
                  t.window.removeEventListener(
                    "hashchange",
                    this._onHashChange,
                    !1
                  ),
                  this._map.off("moveend", this._updateHash),
                  clearTimeout(this._updateHash()),
                  delete this._map,
                  this
                );
              }
              getHashString(e) {
                const n = this._map.getCenter(),
                  r = Math.round(100 * this._map.getZoom()) / 100,
                  i = Math.ceil(
                    (r * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10
                  ),
                  o = Math.pow(10, i),
                  s = Math.round(n.lng * o) / o,
                  a = Math.round(n.lat * o) / o,
                  l = this._map.getBearing(),
                  c = this._map.getPitch();
                let u = "";
                if (
                  ((u += e ? `/${s}/${a}/${r}` : `${r}/${a}/${s}`),
                  (l || c) && (u += "/" + Math.round(10 * l) / 10),
                  c && (u += `/${Math.round(c)}`),
                  this._hashName)
                ) {
                  const e = this._hashName;
                  let n = !1;
                  const r = t.window.location.hash
                    .slice(1)
                    .split("&")
                    .map((t) => {
                      const r = t.split("=")[0];
                      return r === e ? ((n = !0), `${r}=${u}`) : t;
                    })
                    .filter((t) => t);
                  return n || r.push(`${e}=${u}`), `#${r.join("&")}`;
                }
                return `#${u}`;
              }
              _getCurrentHash() {
                const e = t.window.location.hash.replace("#", "");
                if (this._hashName) {
                  let t;
                  return (
                    e
                      .split("&")
                      .map((t) => t.split("="))
                      .forEach((e) => {
                        e[0] === this._hashName && (t = e);
                      }),
                    ((t && t[1]) || "").split("/")
                  );
                }
                return e.split("/");
              }
              _onHashChange() {
                const t = this._getCurrentHash();
                if (t.length >= 3 && !t.some((t) => isNaN(t))) {
                  const e =
                    this._map.dragRotate.isEnabled() &&
                    this._map.touchZoomRotate.isEnabled()
                      ? +(t[3] || 0)
                      : this._map.getBearing();
                  return (
                    this._map.jumpTo({
                      center: [+t[2], +t[1]],
                      zoom: +t[0],
                      bearing: e,
                      pitch: +(t[4] || 0),
                    }),
                    !0
                  );
                }
                return !1;
              }
              _updateHashUnthrottled() {
                const e = t.window.location.href.replace(
                  /(#.+)?$/,
                  this.getHashString()
                );
                t.window.history.replaceState(t.window.history.state, null, e);
              }
            }
            const Ar = { linearity: 0.3, easing: t.bezier(0, 0, 0.3, 1) },
              Cr = t.extend({ deceleration: 2500, maxSpeed: 1400 }, Ar),
              Pr = t.extend({ deceleration: 20, maxSpeed: 1400 }, Ar),
              Mr = t.extend({ deceleration: 1e3, maxSpeed: 360 }, Ar),
              Or = t.extend({ deceleration: 1e3, maxSpeed: 90 }, Ar);
            class kr {
              constructor(t) {
                (this._map = t), this.clear();
              }
              clear() {
                this._inertiaBuffer = [];
              }
              record(e) {
                this._drainInertiaBuffer(),
                  this._inertiaBuffer.push({
                    time: t.exported.now(),
                    settings: e,
                  });
              }
              _drainInertiaBuffer() {
                const e = this._inertiaBuffer,
                  n = t.exported.now();
                for (; e.length > 0 && n - e[0].time > 160; ) e.shift();
              }
              _onMoveEnd(e) {
                if (
                  (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
                )
                  return;
                const n = {
                  zoom: 0,
                  bearing: 0,
                  pitch: 0,
                  pan: new t.pointGeometry(0, 0),
                  pinchAround: void 0,
                  around: void 0,
                };
                for (const { settings: t } of this._inertiaBuffer)
                  (n.zoom += t.zoomDelta || 0),
                    (n.bearing += t.bearingDelta || 0),
                    (n.pitch += t.pitchDelta || 0),
                    t.panDelta && n.pan._add(t.panDelta),
                    t.around && (n.around = t.around),
                    t.pinchAround && (n.pinchAround = t.pinchAround);
                const r =
                    this._inertiaBuffer[this._inertiaBuffer.length - 1].time -
                    this._inertiaBuffer[0].time,
                  i = {};
                if (n.pan.mag()) {
                  const o = Dr(n.pan.mag(), r, t.extend({}, Cr, e || {}));
                  (i.offset = n.pan.mult(o.amount / n.pan.mag())),
                    (i.center = this._map.transform.center),
                    Ir(i, o);
                }
                if (n.zoom) {
                  const t = Dr(n.zoom, r, Pr);
                  (i.zoom = this._map.transform.zoom + t.amount), Ir(i, t);
                }
                if (n.bearing) {
                  const e = Dr(n.bearing, r, Mr);
                  (i.bearing =
                    this._map.transform.bearing + t.clamp(e.amount, -179, 179)),
                    Ir(i, e);
                }
                if (n.pitch) {
                  const t = Dr(n.pitch, r, Or);
                  (i.pitch = this._map.transform.pitch + t.amount), Ir(i, t);
                }
                if (i.zoom || i.bearing) {
                  const t = void 0 === n.pinchAround ? n.around : n.pinchAround;
                  i.around = t ? this._map.unproject(t) : this._map.getCenter();
                }
                return this.clear(), t.extend(i, { noMoveStart: !0 });
              }
            }
            function Ir(t, e) {
              (!t.duration || t.duration < e.duration) &&
                ((t.duration = e.duration), (t.easing = e.easing));
            }
            function Dr(e, n, r) {
              const { maxSpeed: i, linearity: o, deceleration: s } = r,
                a = t.clamp((e * o) / (n / 1e3), -i, i),
                l = Math.abs(a) / (s * o);
              return {
                easing: r.easing,
                duration: 1e3 * l,
                amount: a * (l / 2),
              };
            }
            class zr extends t.Event {
              preventDefault() {
                this._defaultPrevented = !0;
              }
              get defaultPrevented() {
                return this._defaultPrevented;
              }
              constructor(e, n, r, i = {}) {
                const s = o.mousePos(n.getCanvasContainer(), r),
                  a = n.unproject(s);
                super(
                  e,
                  t.extend({ point: s, lngLat: a, originalEvent: r }, i)
                ),
                  (this._defaultPrevented = !1),
                  (this.target = n);
              }
            }
            class Rr extends t.Event {
              preventDefault() {
                this._defaultPrevented = !0;
              }
              get defaultPrevented() {
                return this._defaultPrevented;
              }
              constructor(e, n, r) {
                const i = "touchend" === e ? r.changedTouches : r.touches,
                  s = o.touchPos(n.getCanvasContainer(), i),
                  a = s.map((t) => n.unproject(t)),
                  l = s.reduce(
                    (t, e, n, r) => t.add(e.div(r.length)),
                    new t.pointGeometry(0, 0)
                  );
                super(e, {
                  points: s,
                  point: l,
                  lngLats: a,
                  lngLat: n.unproject(l),
                  originalEvent: r,
                }),
                  (this._defaultPrevented = !1);
              }
            }
            class Lr extends t.Event {
              preventDefault() {
                this._defaultPrevented = !0;
              }
              get defaultPrevented() {
                return this._defaultPrevented;
              }
              constructor(t, e, n) {
                super(t, { originalEvent: n }), (this._defaultPrevented = !1);
              }
            }
            class Fr {
              constructor(t, e) {
                (this._map = t), (this._clickTolerance = e.clickTolerance);
              }
              reset() {
                delete this._mousedownPos;
              }
              wheel(t) {
                return this._firePreventable(new Lr(t.type, this._map, t));
              }
              mousedown(t, e) {
                return (
                  (this._mousedownPos = e),
                  this._firePreventable(new zr(t.type, this._map, t))
                );
              }
              mouseup(t) {
                this._map.fire(new zr(t.type, this._map, t));
              }
              click(t, e) {
                (this._mousedownPos &&
                  this._mousedownPos.dist(e) >= this._clickTolerance) ||
                  this._map.fire(new zr(t.type, this._map, t));
              }
              dblclick(t) {
                return this._firePreventable(new zr(t.type, this._map, t));
              }
              mouseover(t) {
                this._map.fire(new zr(t.type, this._map, t));
              }
              mouseout(t) {
                this._map.fire(new zr(t.type, this._map, t));
              }
              touchstart(t) {
                return this._firePreventable(new Rr(t.type, this._map, t));
              }
              touchmove(t) {
                this._map.fire(new Rr(t.type, this._map, t));
              }
              touchend(t) {
                this._map.fire(new Rr(t.type, this._map, t));
              }
              touchcancel(t) {
                this._map.fire(new Rr(t.type, this._map, t));
              }
              _firePreventable(t) {
                if ((this._map.fire(t), t.defaultPrevented)) return {};
              }
              isEnabled() {
                return !0;
              }
              isActive() {
                return !1;
              }
              enable() {}
              disable() {}
            }
            class Br {
              constructor(t) {
                this._map = t;
              }
              reset() {
                (this._delayContextMenu = !1), delete this._contextMenuEvent;
              }
              mousemove(t) {
                this._map.fire(new zr(t.type, this._map, t));
              }
              mousedown() {
                this._delayContextMenu = !0;
              }
              mouseup() {
                (this._delayContextMenu = !1),
                  this._contextMenuEvent &&
                    (this._map.fire(
                      new zr("contextmenu", this._map, this._contextMenuEvent)
                    ),
                    delete this._contextMenuEvent);
              }
              contextmenu(t) {
                this._delayContextMenu
                  ? (this._contextMenuEvent = t)
                  : this._map.fire(new zr(t.type, this._map, t)),
                  this._map.listens("contextmenu") && t.preventDefault();
              }
              isEnabled() {
                return !0;
              }
              isActive() {
                return !1;
              }
              enable() {}
              disable() {}
            }
            class Nr {
              constructor(t, e) {
                (this._map = t),
                  (this._el = t.getCanvasContainer()),
                  (this._container = t.getContainer()),
                  (this._clickTolerance = e.clickTolerance || 1);
              }
              isEnabled() {
                return !!this._enabled;
              }
              isActive() {
                return !!this._active;
              }
              enable() {
                this.isEnabled() || (this._enabled = !0);
              }
              disable() {
                this.isEnabled() && (this._enabled = !1);
              }
              mousedown(t, e) {
                this.isEnabled() &&
                  t.shiftKey &&
                  0 === t.button &&
                  (o.disableDrag(),
                  (this._startPos = this._lastPos = e),
                  (this._active = !0));
              }
              mousemoveWindow(t, e) {
                if (!this._active) return;
                const n = e;
                if (
                  this._lastPos.equals(n) ||
                  (!this._box && n.dist(this._startPos) < this._clickTolerance)
                )
                  return;
                const r = this._startPos;
                (this._lastPos = n),
                  this._box ||
                    ((this._box = o.create(
                      "div",
                      "mapboxgl-boxzoom",
                      this._container
                    )),
                    this._container.classList.add("mapboxgl-crosshair"),
                    this._fireEvent("boxzoomstart", t));
                const i = Math.min(r.x, n.x),
                  s = Math.max(r.x, n.x),
                  a = Math.min(r.y, n.y),
                  l = Math.max(r.y, n.y);
                this._map._requestDomTask(() => {
                  this._box &&
                    (o.setTransform(this._box, `translate(${i}px,${a}px)`),
                    (this._box.style.width = s - i + "px"),
                    (this._box.style.height = l - a + "px"));
                });
              }
              mouseupWindow(e, n) {
                if (!this._active) return;
                if (0 !== e.button) return;
                const r = this._startPos,
                  i = n;
                if (
                  (this.reset(), o.suppressClick(), r.x !== i.x || r.y !== i.y)
                )
                  return (
                    this._map.fire(
                      new t.Event("boxzoomend", { originalEvent: e })
                    ),
                    {
                      cameraAnimation: (t) =>
                        t.fitScreenCoordinates(r, i, this._map.getBearing(), {
                          linear: !1,
                        }),
                    }
                  );
                this._fireEvent("boxzoomcancel", e);
              }
              keydown(t) {
                this._active &&
                  27 === t.keyCode &&
                  (this.reset(), this._fireEvent("boxzoomcancel", t));
              }
              reset() {
                (this._active = !1),
                  this._container.classList.remove("mapboxgl-crosshair"),
                  this._box && (o.remove(this._box), (this._box = null)),
                  o.enableDrag(),
                  delete this._startPos,
                  delete this._lastPos;
              }
              _fireEvent(e, n) {
                return this._map.fire(new t.Event(e, { originalEvent: n }));
              }
            }
            function jr(t, e) {
              const n = {};
              for (let r = 0; r < t.length; r++) n[t[r].identifier] = e[r];
              return n;
            }
            class Ur {
              constructor(t) {
                this.reset(), (this.numTouches = t.numTouches);
              }
              reset() {
                delete this.centroid,
                  delete this.startTime,
                  delete this.touches,
                  (this.aborted = !1);
              }
              touchstart(e, n, r) {
                (this.centroid || r.length > this.numTouches) &&
                  (this.aborted = !0),
                  this.aborted ||
                    (void 0 === this.startTime &&
                      (this.startTime = e.timeStamp),
                    r.length === this.numTouches &&
                      ((this.centroid = (function (e) {
                        const n = new t.pointGeometry(0, 0);
                        for (const t of e) n._add(t);
                        return n.div(e.length);
                      })(n)),
                      (this.touches = jr(r, n))));
              }
              touchmove(t, e, n) {
                if (this.aborted || !this.centroid) return;
                const r = jr(n, e);
                for (const i in this.touches) {
                  const t = this.touches[i],
                    e = r[i];
                  (!e || e.dist(t) > 30) && (this.aborted = !0);
                }
              }
              touchend(t, e, n) {
                if (
                  ((!this.centroid || t.timeStamp - this.startTime > 500) &&
                    (this.aborted = !0),
                  0 === n.length)
                ) {
                  const t = !this.aborted && this.centroid;
                  if ((this.reset(), t)) return t;
                }
              }
            }
            class Zr {
              constructor(t) {
                (this.singleTap = new Ur(t)),
                  (this.numTaps = t.numTaps),
                  this.reset();
              }
              reset() {
                (this.lastTime = 1 / 0),
                  delete this.lastTap,
                  (this.count = 0),
                  this.singleTap.reset();
              }
              touchstart(t, e, n) {
                this.singleTap.touchstart(t, e, n);
              }
              touchmove(t, e, n) {
                this.singleTap.touchmove(t, e, n);
              }
              touchend(t, e, n) {
                const r = this.singleTap.touchend(t, e, n);
                if (r) {
                  const e = t.timeStamp - this.lastTime < 500,
                    n = !this.lastTap || this.lastTap.dist(r) < 30;
                  if (
                    ((e && n) || this.reset(),
                    this.count++,
                    (this.lastTime = t.timeStamp),
                    (this.lastTap = r),
                    this.count === this.numTaps)
                  )
                    return this.reset(), r;
                }
              }
            }
            class Vr {
              constructor() {
                (this._zoomIn = new Zr({ numTouches: 1, numTaps: 2 })),
                  (this._zoomOut = new Zr({ numTouches: 2, numTaps: 1 })),
                  this.reset();
              }
              reset() {
                (this._active = !1),
                  this._zoomIn.reset(),
                  this._zoomOut.reset();
              }
              touchstart(t, e, n) {
                this._zoomIn.touchstart(t, e, n),
                  this._zoomOut.touchstart(t, e, n);
              }
              touchmove(t, e, n) {
                this._zoomIn.touchmove(t, e, n),
                  this._zoomOut.touchmove(t, e, n);
              }
              touchend(t, e, n) {
                const r = this._zoomIn.touchend(t, e, n),
                  i = this._zoomOut.touchend(t, e, n);
                return r
                  ? ((this._active = !0),
                    t.preventDefault(),
                    setTimeout(() => this.reset(), 0),
                    {
                      cameraAnimation: (e) =>
                        e.easeTo(
                          {
                            duration: 300,
                            zoom: e.getZoom() + 1,
                            around: e.unproject(r),
                          },
                          { originalEvent: t }
                        ),
                    })
                  : i
                  ? ((this._active = !0),
                    t.preventDefault(),
                    setTimeout(() => this.reset(), 0),
                    {
                      cameraAnimation: (e) =>
                        e.easeTo(
                          {
                            duration: 300,
                            zoom: e.getZoom() - 1,
                            around: e.unproject(i),
                          },
                          { originalEvent: t }
                        ),
                    })
                  : void 0;
              }
              touchcancel() {
                this.reset();
              }
              enable() {
                this._enabled = !0;
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
            }
            const qr = { 0: 1, 2: 2 };
            class $r {
              constructor(t) {
                this.reset(), (this._clickTolerance = t.clickTolerance || 1);
              }
              reset() {
                (this._active = !1),
                  (this._moved = !1),
                  delete this._lastPoint,
                  delete this._eventButton;
              }
              _correctButton(t, e) {
                return !1;
              }
              _move(t, e) {
                return {};
              }
              mousedown(t, e) {
                if (this._lastPoint) return;
                const n = o.mouseButton(t);
                this._correctButton(t, n) &&
                  ((this._lastPoint = e), (this._eventButton = n));
              }
              mousemoveWindow(t, e) {
                const n = this._lastPoint;
                if (n)
                  if (
                    (t.preventDefault(),
                    (function (t, e) {
                      const n = qr[e];
                      return void 0 === t.buttons || (t.buttons & n) !== n;
                    })(t, this._eventButton))
                  )
                    this.reset();
                  else if (this._moved || !(e.dist(n) < this._clickTolerance))
                    return (
                      (this._moved = !0),
                      (this._lastPoint = e),
                      this._move(n, e)
                    );
              }
              mouseupWindow(t) {
                this._lastPoint &&
                  o.mouseButton(t) === this._eventButton &&
                  (this._moved && o.suppressClick(), this.reset());
              }
              enable() {
                this._enabled = !0;
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
            }
            class Gr extends $r {
              mousedown(t, e) {
                super.mousedown(t, e), this._lastPoint && (this._active = !0);
              }
              _correctButton(t, e) {
                return 0 === e && !t.ctrlKey;
              }
              _move(t, e) {
                return { around: e, panDelta: e.sub(t) };
              }
            }
            class Wr extends $r {
              _correctButton(t, e) {
                return (0 === e && t.ctrlKey) || 2 === e;
              }
              _move(t, e) {
                const n = 0.8 * (e.x - t.x);
                if (n) return (this._active = !0), { bearingDelta: n };
              }
              contextmenu(t) {
                t.preventDefault();
              }
            }
            class Hr extends $r {
              _correctButton(t, e) {
                return (0 === e && t.ctrlKey) || 2 === e;
              }
              _move(t, e) {
                const n = -0.5 * (e.y - t.y);
                if (n) return (this._active = !0), { pitchDelta: n };
              }
              contextmenu(t) {
                t.preventDefault();
              }
            }
            class Xr {
              constructor(t) {
                (this._minTouches = 1),
                  (this._clickTolerance = t.clickTolerance || 1),
                  this.reset();
              }
              reset() {
                (this._active = !1),
                  (this._touches = {}),
                  (this._sum = new t.pointGeometry(0, 0));
              }
              touchstart(t, e, n) {
                return this._calculateTransform(t, e, n);
              }
              touchmove(t, e, n) {
                if (this._active && !(n.length < this._minTouches))
                  return t.preventDefault(), this._calculateTransform(t, e, n);
              }
              touchend(t, e, n) {
                this._calculateTransform(t, e, n),
                  this._active && n.length < this._minTouches && this.reset();
              }
              touchcancel() {
                this.reset();
              }
              _calculateTransform(e, n, r) {
                r.length > 0 && (this._active = !0);
                const i = jr(r, n),
                  o = new t.pointGeometry(0, 0),
                  s = new t.pointGeometry(0, 0);
                let a = 0;
                for (const t in i) {
                  const e = i[t],
                    n = this._touches[t];
                  n && (o._add(e), s._add(e.sub(n)), a++, (i[t] = e));
                }
                if (((this._touches = i), a < this._minTouches || !s.mag()))
                  return;
                const l = s.div(a);
                return (
                  this._sum._add(l),
                  this._sum.mag() < this._clickTolerance
                    ? void 0
                    : { around: o.div(a), panDelta: l }
                );
              }
              enable() {
                this._enabled = !0;
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
            }
            class Kr {
              constructor() {
                this.reset();
              }
              reset() {
                (this._active = !1), delete this._firstTwoTouches;
              }
              _start(t) {}
              _move(t, e, n) {
                return {};
              }
              touchstart(t, e, n) {
                this._firstTwoTouches ||
                  n.length < 2 ||
                  ((this._firstTwoTouches = [n[0].identifier, n[1].identifier]),
                  this._start([e[0], e[1]]));
              }
              touchmove(t, e, n) {
                if (!this._firstTwoTouches) return;
                t.preventDefault();
                const [r, i] = this._firstTwoTouches,
                  o = Yr(n, e, r),
                  s = Yr(n, e, i);
                if (!o || !s) return;
                const a = this._aroundCenter ? null : o.add(s).div(2);
                return this._move([o, s], a, t);
              }
              touchend(t, e, n) {
                if (!this._firstTwoTouches) return;
                const [r, i] = this._firstTwoTouches,
                  s = Yr(n, e, r),
                  a = Yr(n, e, i);
                (s && a) || (this._active && o.suppressClick(), this.reset());
              }
              touchcancel() {
                this.reset();
              }
              enable(t) {
                (this._enabled = !0),
                  (this._aroundCenter = !!t && "center" === t.around);
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
            }
            function Yr(t, e, n) {
              for (let r = 0; r < t.length; r++)
                if (t[r].identifier === n) return e[r];
            }
            function Qr(t, e) {
              return Math.log(t / e) / Math.LN2;
            }
            class Jr extends Kr {
              reset() {
                super.reset(),
                  delete this._distance,
                  delete this._startDistance;
              }
              _start(t) {
                this._startDistance = this._distance = t[0].dist(t[1]);
              }
              _move(t, e) {
                const n = this._distance;
                if (
                  ((this._distance = t[0].dist(t[1])),
                  this._active ||
                    !(Math.abs(Qr(this._distance, this._startDistance)) < 0.1))
                )
                  return (
                    (this._active = !0),
                    { zoomDelta: Qr(this._distance, n), pinchAround: e }
                  );
              }
            }
            function ti(t, e) {
              return (180 * t.angleWith(e)) / Math.PI;
            }
            class ei extends Kr {
              reset() {
                super.reset(),
                  delete this._minDiameter,
                  delete this._startVector,
                  delete this._vector;
              }
              _start(t) {
                (this._startVector = this._vector = t[0].sub(t[1])),
                  (this._minDiameter = t[0].dist(t[1]));
              }
              _move(t, e) {
                const n = this._vector;
                if (
                  ((this._vector = t[0].sub(t[1])),
                  this._active || !this._isBelowThreshold(this._vector))
                )
                  return (
                    (this._active = !0),
                    { bearingDelta: ti(this._vector, n), pinchAround: e }
                  );
              }
              _isBelowThreshold(t) {
                this._minDiameter = Math.min(this._minDiameter, t.mag());
                const e = (25 / (Math.PI * this._minDiameter)) * 360,
                  n = ti(t, this._startVector);
                return Math.abs(n) < e;
              }
            }
            function ni(t) {
              return Math.abs(t.y) > Math.abs(t.x);
            }
            class ri extends Kr {
              reset() {
                super.reset(),
                  (this._valid = void 0),
                  delete this._firstMove,
                  delete this._lastPoints;
              }
              _start(t) {
                (this._lastPoints = t),
                  ni(t[0].sub(t[1])) && (this._valid = !1);
              }
              _move(t, e, n) {
                const r = t[0].sub(this._lastPoints[0]),
                  i = t[1].sub(this._lastPoints[1]);
                if (
                  ((this._valid = this.gestureBeginsVertically(
                    r,
                    i,
                    n.timeStamp
                  )),
                  this._valid)
                )
                  return (
                    (this._lastPoints = t),
                    (this._active = !0),
                    { pitchDelta: ((r.y + i.y) / 2) * -0.5 }
                  );
              }
              gestureBeginsVertically(t, e, n) {
                if (void 0 !== this._valid) return this._valid;
                const r = t.mag() >= 2,
                  i = e.mag() >= 2;
                if (!r && !i) return;
                if (!r || !i)
                  return (
                    void 0 === this._firstMove && (this._firstMove = n),
                    n - this._firstMove < 100 && void 0
                  );
                const o = t.y > 0 == e.y > 0;
                return ni(t) && ni(e) && o;
              }
            }
            const ii = { panStep: 100, bearingStep: 15, pitchStep: 10 };
            class oi {
              constructor() {
                const t = ii;
                (this._panStep = t.panStep),
                  (this._bearingStep = t.bearingStep),
                  (this._pitchStep = t.pitchStep),
                  (this._rotationDisabled = !1);
              }
              reset() {
                this._active = !1;
              }
              keydown(t) {
                if (t.altKey || t.ctrlKey || t.metaKey) return;
                let e = 0,
                  n = 0,
                  r = 0,
                  i = 0,
                  o = 0;
                switch (t.keyCode) {
                  case 61:
                  case 107:
                  case 171:
                  case 187:
                    e = 1;
                    break;
                  case 189:
                  case 109:
                  case 173:
                    e = -1;
                    break;
                  case 37:
                    t.shiftKey ? (n = -1) : (t.preventDefault(), (i = -1));
                    break;
                  case 39:
                    t.shiftKey ? (n = 1) : (t.preventDefault(), (i = 1));
                    break;
                  case 38:
                    t.shiftKey ? (r = 1) : (t.preventDefault(), (o = -1));
                    break;
                  case 40:
                    t.shiftKey ? (r = -1) : (t.preventDefault(), (o = 1));
                    break;
                  default:
                    return;
                }
                return (
                  this._rotationDisabled && ((n = 0), (r = 0)),
                  {
                    cameraAnimation: (s) => {
                      const a = s.getZoom();
                      s.easeTo(
                        {
                          duration: 300,
                          easeId: "keyboardHandler",
                          easing: si,
                          zoom: e
                            ? Math.round(a) + e * (t.shiftKey ? 2 : 1)
                            : a,
                          bearing: s.getBearing() + n * this._bearingStep,
                          pitch: s.getPitch() + r * this._pitchStep,
                          offset: [-i * this._panStep, -o * this._panStep],
                          center: s.getCenter(),
                        },
                        { originalEvent: t }
                      );
                    },
                  }
                );
              }
              enable() {
                this._enabled = !0;
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
              disableRotation() {
                this._rotationDisabled = !0;
              }
              enableRotation() {
                this._rotationDisabled = !1;
              }
            }
            function si(t) {
              return t * (2 - t);
            }
            const ai = 4.000244140625;
            class li {
              constructor(e, n) {
                (this._map = e),
                  (this._el = e.getCanvasContainer()),
                  (this._handler = n),
                  (this._delta = 0),
                  (this._defaultZoomRate = 0.01),
                  (this._wheelZoomRate = 0.0022222222222222222),
                  t.bindAll(["_onTimeout"], this);
              }
              setZoomRate(t) {
                this._defaultZoomRate = t;
              }
              setWheelZoomRate(t) {
                this._wheelZoomRate = t;
              }
              isEnabled() {
                return !!this._enabled;
              }
              isActive() {
                return !!this._active || void 0 !== this._finishTimeout;
              }
              isZooming() {
                return !!this._zooming;
              }
              enable(t) {
                this.isEnabled() ||
                  ((this._enabled = !0),
                  (this._aroundCenter = t && "center" === t.around));
              }
              disable() {
                this.isEnabled() && (this._enabled = !1);
              }
              wheel(e) {
                if (!this.isEnabled()) return;
                let n =
                  e.deltaMode === t.window.WheelEvent.DOM_DELTA_LINE
                    ? 40 * e.deltaY
                    : e.deltaY;
                const r = t.exported.now(),
                  i = r - (this._lastWheelEventTime || 0);
                (this._lastWheelEventTime = r),
                  0 !== n && n % ai == 0
                    ? (this._type = "wheel")
                    : 0 !== n && Math.abs(n) < 4
                    ? (this._type = "trackpad")
                    : i > 400
                    ? ((this._type = null),
                      (this._lastValue = n),
                      (this._timeout = setTimeout(this._onTimeout, 40, e)))
                    : this._type ||
                      ((this._type =
                        Math.abs(i * n) < 200 ? "trackpad" : "wheel"),
                      this._timeout &&
                        (clearTimeout(this._timeout),
                        (this._timeout = null),
                        (n += this._lastValue))),
                  e.shiftKey && n && (n /= 4),
                  this._type &&
                    ((this._lastWheelEvent = e),
                    (this._delta -= n),
                    this._active || this._start(e)),
                  e.preventDefault();
              }
              _onTimeout(t) {
                (this._type = "wheel"),
                  (this._delta -= this._lastValue),
                  this._active || this._start(t);
              }
              _start(t) {
                if (!this._delta) return;
                this._frameId && (this._frameId = null),
                  (this._active = !0),
                  this.isZooming() || (this._zooming = !0),
                  this._finishTimeout &&
                    (clearTimeout(this._finishTimeout),
                    delete this._finishTimeout);
                const e = o.mousePos(this._el, t);
                (this._aroundPoint = this._aroundCenter
                  ? this._map.transform.centerPoint
                  : e),
                  (this._aroundCoord = this._map.transform.pointCoordinate3D(
                    this._aroundPoint
                  )),
                  (this._targetZoom = void 0),
                  this._frameId ||
                    ((this._frameId = !0), this._handler._triggerRenderFrame());
              }
              renderFrame() {
                if (!this._frameId) return;
                if (((this._frameId = null), !this.isActive())) return;
                const e = this._map.transform,
                  n = () =>
                    e._terrainEnabled()
                      ? e.computeZoomRelativeTo(this._aroundCoord)
                      : e.zoom;
                if (0 !== this._delta) {
                  const t =
                    "wheel" === this._type && Math.abs(this._delta) > ai
                      ? this._wheelZoomRate
                      : this._defaultZoomRate;
                  let r = 2 / (1 + Math.exp(-Math.abs(this._delta * t)));
                  this._delta < 0 && 0 !== r && (r = 1 / r);
                  const i = n(),
                    o = Math.pow(2, i),
                    s =
                      "number" == typeof this._targetZoom
                        ? e.zoomScale(this._targetZoom)
                        : o;
                  (this._targetZoom = Math.min(
                    e.maxZoom,
                    Math.max(e.minZoom, e.scaleZoom(s * r))
                  )),
                    "wheel" === this._type &&
                      ((this._startZoom = n()),
                      (this._easing = this._smoothOutEasing(200))),
                    (this._delta = 0);
                }
                const r =
                    "number" == typeof this._targetZoom
                      ? this._targetZoom
                      : n(),
                  i = this._startZoom,
                  o = this._easing;
                let s,
                  a = !1;
                if ("wheel" === this._type && i && o) {
                  const e = Math.min(
                      (t.exported.now() - this._lastWheelEventTime) / 200,
                      1
                    ),
                    n = o(e);
                  (s = t.number(i, r, n)),
                    e < 1 ? this._frameId || (this._frameId = !0) : (a = !0);
                } else (s = r), (a = !0);
                return (
                  (this._active = !0),
                  a &&
                    ((this._active = !1),
                    (this._finishTimeout = setTimeout(() => {
                      (this._zooming = !1),
                        this._handler._triggerRenderFrame(),
                        delete this._targetZoom,
                        delete this._finishTimeout;
                    }, 200))),
                  {
                    noInertia: !0,
                    needsRenderFrame: !a,
                    zoomDelta: s - n(),
                    around: this._aroundPoint,
                    aroundCoord: this._aroundCoord,
                    originalEvent: this._lastWheelEvent,
                  }
                );
              }
              _smoothOutEasing(e) {
                let n = t.ease;
                if (this._prevEase) {
                  const e = this._prevEase,
                    r = (t.exported.now() - e.start) / e.duration,
                    i = e.easing(r + 0.01) - e.easing(r),
                    o = (0.27 / Math.sqrt(i * i + 1e-4)) * 0.01,
                    s = Math.sqrt(0.0729 - o * o);
                  n = t.bezier(o, s, 0.25, 1);
                }
                return (
                  (this._prevEase = {
                    start: t.exported.now(),
                    duration: e,
                    easing: n,
                  }),
                  n
                );
              }
              reset() {
                this._active = !1;
              }
            }
            class ci {
              constructor(t, e) {
                (this._clickZoom = t), (this._tapZoom = e);
              }
              enable() {
                this._clickZoom.enable(), this._tapZoom.enable();
              }
              disable() {
                this._clickZoom.disable(), this._tapZoom.disable();
              }
              isEnabled() {
                return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
              }
              isActive() {
                return this._clickZoom.isActive() || this._tapZoom.isActive();
              }
            }
            class ui {
              constructor() {
                this.reset();
              }
              reset() {
                this._active = !1;
              }
              dblclick(t, e) {
                return (
                  t.preventDefault(),
                  {
                    cameraAnimation: (n) => {
                      n.easeTo(
                        {
                          duration: 300,
                          zoom: n.getZoom() + (t.shiftKey ? -1 : 1),
                          around: n.unproject(e),
                        },
                        { originalEvent: t }
                      );
                    },
                  }
                );
              }
              enable() {
                this._enabled = !0;
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
            }
            class hi {
              constructor() {
                (this._tap = new Zr({ numTouches: 1, numTaps: 1 })),
                  this.reset();
              }
              reset() {
                (this._active = !1),
                  delete this._swipePoint,
                  delete this._swipeTouch,
                  delete this._tapTime,
                  this._tap.reset();
              }
              touchstart(t, e, n) {
                this._swipePoint ||
                  (this._tapTime &&
                    t.timeStamp - this._tapTime > 500 &&
                    this.reset(),
                  this._tapTime
                    ? n.length > 0 &&
                      ((this._swipePoint = e[0]),
                      (this._swipeTouch = n[0].identifier))
                    : this._tap.touchstart(t, e, n));
              }
              touchmove(t, e, n) {
                if (this._tapTime) {
                  if (this._swipePoint) {
                    if (n[0].identifier !== this._swipeTouch) return;
                    const r = e[0],
                      i = r.y - this._swipePoint.y;
                    return (
                      (this._swipePoint = r),
                      t.preventDefault(),
                      (this._active = !0),
                      { zoomDelta: i / 128 }
                    );
                  }
                } else this._tap.touchmove(t, e, n);
              }
              touchend(t, e, n) {
                this._tapTime
                  ? this._swipePoint && 0 === n.length && this.reset()
                  : this._tap.touchend(t, e, n) &&
                    (this._tapTime = t.timeStamp);
              }
              touchcancel() {
                this.reset();
              }
              enable() {
                this._enabled = !0;
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
            }
            class pi {
              constructor(t, e, n) {
                (this._el = t), (this._mousePan = e), (this._touchPan = n);
              }
              enable(t) {
                (this._inertiaOptions = t || {}),
                  this._mousePan.enable(),
                  this._touchPan.enable(),
                  this._el.classList.add("mapboxgl-touch-drag-pan");
              }
              disable() {
                this._mousePan.disable(),
                  this._touchPan.disable(),
                  this._el.classList.remove("mapboxgl-touch-drag-pan");
              }
              isEnabled() {
                return this._mousePan.isEnabled() && this._touchPan.isEnabled();
              }
              isActive() {
                return this._mousePan.isActive() || this._touchPan.isActive();
              }
            }
            class di {
              constructor(t, e, n) {
                (this._pitchWithRotate = t.pitchWithRotate),
                  (this._mouseRotate = e),
                  (this._mousePitch = n);
              }
              enable() {
                this._mouseRotate.enable(),
                  this._pitchWithRotate && this._mousePitch.enable();
              }
              disable() {
                this._mouseRotate.disable(), this._mousePitch.disable();
              }
              isEnabled() {
                return (
                  this._mouseRotate.isEnabled() &&
                  (!this._pitchWithRotate || this._mousePitch.isEnabled())
                );
              }
              isActive() {
                return (
                  this._mouseRotate.isActive() || this._mousePitch.isActive()
                );
              }
            }
            class fi {
              constructor(t, e, n, r) {
                (this._el = t),
                  (this._touchZoom = e),
                  (this._touchRotate = n),
                  (this._tapDragZoom = r),
                  (this._rotationDisabled = !1),
                  (this._enabled = !0);
              }
              enable(t) {
                this._touchZoom.enable(t),
                  this._rotationDisabled || this._touchRotate.enable(t),
                  this._tapDragZoom.enable(),
                  this._el.classList.add("mapboxgl-touch-zoom-rotate");
              }
              disable() {
                this._touchZoom.disable(),
                  this._touchRotate.disable(),
                  this._tapDragZoom.disable(),
                  this._el.classList.remove("mapboxgl-touch-zoom-rotate");
              }
              isEnabled() {
                return (
                  this._touchZoom.isEnabled() &&
                  (this._rotationDisabled || this._touchRotate.isEnabled()) &&
                  this._tapDragZoom.isEnabled()
                );
              }
              isActive() {
                return (
                  this._touchZoom.isActive() ||
                  this._touchRotate.isActive() ||
                  this._tapDragZoom.isActive()
                );
              }
              disableRotation() {
                (this._rotationDisabled = !0), this._touchRotate.disable();
              }
              enableRotation() {
                (this._rotationDisabled = !1),
                  this._touchZoom.isEnabled() && this._touchRotate.enable();
              }
            }
            const mi = (t) => t.zoom || t.drag || t.pitch || t.rotate;
            class gi extends t.Event {}
            class yi {
              constructor() {
                (this.constants = [1, 1, 0.01]), (this.radius = 0);
              }
              setup(e, n) {
                const r = t.sub([], n, e);
                this.radius = t.length(
                  r[2] < 0 ? t.div([], r, this.constants) : [r[0], r[1], 0]
                );
              }
              projectRay(e) {
                t.div(e, e, this.constants),
                  t.normalize(e, e),
                  t.mul$2(e, e, this.constants);
                const n = t.scale([], e, this.radius);
                if (n[2] > 0) {
                  const e = t.scale([], [0, 0, 1], t.dot(n, [0, 0, 1])),
                    r = t.scale(
                      [],
                      t.normalize([], [n[0], n[1], 0]),
                      this.radius
                    ),
                    i = t.add(
                      [],
                      n,
                      t.scale([], t.sub([], t.add([], r, e), n), 2)
                    );
                  (n[0] = i[0]), (n[1] = i[1]);
                }
                return n;
              }
            }
            function _i(t) {
              return (
                (t.panDelta && t.panDelta.mag()) ||
                t.zoomDelta ||
                t.bearingDelta ||
                t.pitchDelta
              );
            }
            class vi {
              constructor(e, n) {
                (this._map = e),
                  (this._el = this._map.getCanvasContainer()),
                  (this._handlers = []),
                  (this._handlersById = {}),
                  (this._changes = []),
                  (this._inertia = new kr(e)),
                  (this._bearingSnap = n.bearingSnap),
                  (this._previousActiveHandlers = {}),
                  (this._trackingEllipsoid = new yi()),
                  (this._dragOrigin = null),
                  (this._eventsInProgress = {}),
                  this._addDefaultHandlers(n),
                  t.bindAll(["handleEvent", "handleWindowEvent"], this);
                const r = this._el;
                this._listeners = [
                  [r, "touchstart", { passive: !0 }],
                  [r, "touchmove", { passive: !1 }],
                  [r, "touchend", void 0],
                  [r, "touchcancel", void 0],
                  [r, "mousedown", void 0],
                  [r, "mousemove", void 0],
                  [r, "mouseup", void 0],
                  [t.window.document, "mousemove", { capture: !0 }],
                  [t.window.document, "mouseup", void 0],
                  [r, "mouseover", void 0],
                  [r, "mouseout", void 0],
                  [r, "dblclick", void 0],
                  [r, "click", void 0],
                  [r, "keydown", { capture: !1 }],
                  [r, "keyup", void 0],
                  [r, "wheel", { passive: !1 }],
                  [r, "contextmenu", void 0],
                  [t.window, "blur", void 0],
                ];
                for (const [i, s, a] of this._listeners)
                  o.addEventListener(
                    i,
                    s,
                    i === t.window.document
                      ? this.handleWindowEvent
                      : this.handleEvent,
                    a
                  );
              }
              destroy() {
                for (const [e, n, r] of this._listeners)
                  o.removeEventListener(
                    e,
                    n,
                    e === t.window.document
                      ? this.handleWindowEvent
                      : this.handleEvent,
                    r
                  );
              }
              _addDefaultHandlers(t) {
                const e = this._map,
                  n = e.getCanvasContainer();
                this._add("mapEvent", new Fr(e, t));
                const r = (e.boxZoom = new Nr(e, t));
                this._add("boxZoom", r);
                const i = new Vr(),
                  o = new ui();
                (e.doubleClickZoom = new ci(o, i)),
                  this._add("tapZoom", i),
                  this._add("clickZoom", o);
                const s = new hi();
                this._add("tapDragZoom", s);
                const a = (e.touchPitch = new ri());
                this._add("touchPitch", a);
                const l = new Wr(t),
                  c = new Hr(t);
                (e.dragRotate = new di(t, l, c)),
                  this._add("mouseRotate", l, ["mousePitch"]),
                  this._add("mousePitch", c, ["mouseRotate"]);
                const u = new Gr(t),
                  h = new Xr(t);
                (e.dragPan = new pi(n, u, h)),
                  this._add("mousePan", u),
                  this._add("touchPan", h, ["touchZoom", "touchRotate"]);
                const p = new ei(),
                  d = new Jr();
                (e.touchZoomRotate = new fi(n, d, p, s)),
                  this._add("touchRotate", p, ["touchPan", "touchZoom"]),
                  this._add("touchZoom", d, ["touchPan", "touchRotate"]),
                  this._add("blockableMapEvent", new Br(e));
                const f = (e.scrollZoom = new li(e, this));
                this._add("scrollZoom", f, ["mousePan"]);
                const m = (e.keyboard = new oi());
                this._add("keyboard", m);
                for (const g of [
                  "boxZoom",
                  "doubleClickZoom",
                  "tapDragZoom",
                  "touchPitch",
                  "dragRotate",
                  "dragPan",
                  "touchZoomRotate",
                  "scrollZoom",
                  "keyboard",
                ])
                  t.interactive && t[g] && e[g].enable(t[g]);
              }
              _add(t, e, n) {
                this._handlers.push({ handlerName: t, handler: e, allowed: n }),
                  (this._handlersById[t] = e);
              }
              stop(t) {
                if (!this._updatingCamera) {
                  for (const { handler: t } of this._handlers) t.reset();
                  this._inertia.clear(),
                    this._fireEvents({}, {}, t),
                    (this._changes = []);
                }
              }
              isActive() {
                for (const { handler: t } of this._handlers)
                  if (t.isActive()) return !0;
                return !1;
              }
              isZooming() {
                return (
                  !!this._eventsInProgress.zoom ||
                  this._map.scrollZoom.isZooming()
                );
              }
              isRotating() {
                return !!this._eventsInProgress.rotate;
              }
              isMoving() {
                return Boolean(mi(this._eventsInProgress)) || this.isZooming();
              }
              _blockedByActive(t, e, n) {
                for (const r in t)
                  if (r !== n && (!e || e.indexOf(r) < 0)) return !0;
                return !1;
              }
              handleWindowEvent(t) {
                this.handleEvent(t, `${t.type}Window`);
              }
              _getMapTouches(t) {
                const e = [];
                for (const n of t) this._el.contains(n.target) && e.push(n);
                return e;
              }
              handleEvent(t, e) {
                if ("blur" === t.type) return void this.stop(!0);
                this._updatingCamera = !0;
                const n = "renderFrame" === t.type,
                  r = n ? void 0 : t,
                  i = { needsRenderFrame: !1 },
                  s = {},
                  a = {},
                  l = t.touches ? this._getMapTouches(t.touches) : void 0,
                  c = l
                    ? o.touchPos(this._el, l)
                    : n
                    ? void 0
                    : o.mousePos(this._el, t);
                for (const { handlerName: o, handler: p, allowed: d } of this
                  ._handlers) {
                  if (!p.isEnabled()) continue;
                  let n;
                  this._blockedByActive(a, d, o)
                    ? p.reset()
                    : p[e || t.type] &&
                      ((n = p[e || t.type](t, c, l)),
                      this.mergeHandlerResult(i, s, n, o, r),
                      n && n.needsRenderFrame && this._triggerRenderFrame()),
                    (n || p.isActive()) && (a[o] = p);
                }
                const u = {};
                for (const o in this._previousActiveHandlers)
                  a[o] || (u[o] = r);
                (this._previousActiveHandlers = a),
                  (Object.keys(u).length || _i(i)) &&
                    (this._changes.push([i, s, u]), this._triggerRenderFrame()),
                  (Object.keys(a).length || _i(i)) && this._map._stop(!0),
                  (this._updatingCamera = !1);
                const { cameraAnimation: h } = i;
                h &&
                  (this._inertia.clear(),
                  this._fireEvents({}, {}, !0),
                  (this._changes = []),
                  h(this._map));
              }
              mergeHandlerResult(e, n, r, i, o) {
                if (!r) return;
                t.extend(e, r);
                const s = {
                  handlerName: i,
                  originalEvent: r.originalEvent || o,
                };
                void 0 !== r.zoomDelta && (n.zoom = s),
                  void 0 !== r.panDelta && (n.drag = s),
                  void 0 !== r.pitchDelta && (n.pitch = s),
                  void 0 !== r.bearingDelta && (n.rotate = s);
              }
              _applyChanges() {
                const e = {},
                  n = {},
                  r = {};
                for (const [i, o, s] of this._changes)
                  i.panDelta &&
                    (e.panDelta = (
                      e.panDelta || new t.pointGeometry(0, 0)
                    )._add(i.panDelta)),
                    i.zoomDelta &&
                      (e.zoomDelta = (e.zoomDelta || 0) + i.zoomDelta),
                    i.bearingDelta &&
                      (e.bearingDelta = (e.bearingDelta || 0) + i.bearingDelta),
                    i.pitchDelta &&
                      (e.pitchDelta = (e.pitchDelta || 0) + i.pitchDelta),
                    void 0 !== i.around && (e.around = i.around),
                    void 0 !== i.aroundCoord && (e.aroundCoord = i.aroundCoord),
                    void 0 !== i.pinchAround && (e.pinchAround = i.pinchAround),
                    i.noInertia && (e.noInertia = i.noInertia),
                    t.extend(n, o),
                    t.extend(r, s);
                this._updateMapTransform(e, n, r), (this._changes = []);
              }
              _updateMapTransform(e, n, r) {
                const i = this._map,
                  o = i.transform,
                  s = (t) => [t.x, t.y, t.z];
                if (
                  ((t) => {
                    const e = this._eventsInProgress.drag;
                    return e && !this._handlersById[e.handlerName].isActive();
                  })() &&
                  !_i(e)
                ) {
                  const t = o.zoom;
                  (o.cameraElevationReference = "sea"),
                    o.recenterOnTerrain(),
                    (o.cameraElevationReference = "ground"),
                    t !== o.zoom && this._map._update(!0);
                }
                if (!_i(e)) return this._fireEvents(n, r, !0);
                let {
                  panDelta: a,
                  zoomDelta: l,
                  bearingDelta: c,
                  pitchDelta: u,
                  around: h,
                  aroundCoord: p,
                  pinchAround: d,
                } = e;
                void 0 !== d && (h = d),
                  ((t) => n.drag && !this._eventsInProgress.drag)() &&
                    h &&
                    ((this._dragOrigin = s(o.pointCoordinate3D(h))),
                    this._trackingEllipsoid.setup(
                      o._camera.position,
                      this._dragOrigin
                    )),
                  (o.cameraElevationReference = "sea"),
                  i._stop(!0),
                  (h = h || i.transform.centerPoint),
                  c && (o.bearing += c),
                  u && (o.pitch += u),
                  o._updateCameraState();
                const f = [0, 0, 0];
                if (a) {
                  const t = o.screenPointToMercatorRay(h),
                    e = o.screenPointToMercatorRay(h.sub(a)),
                    n = this._trackingEllipsoid.projectRay(t.dir),
                    r = this._trackingEllipsoid.projectRay(e.dir);
                  (f[0] = r[0] - n[0]), (f[1] = r[1] - n[1]);
                }
                const m = o.zoom,
                  g = [0, 0, 0];
                if (l) {
                  const e = s(p || o.pointCoordinate3D(h)),
                    n = {
                      dir: t.normalize([], t.sub([], e, o._camera.position)),
                    },
                    r = o.screenPointToMercatorRay(o.centerPoint);
                  if (n.dir[2] < 0) {
                    const i = t.altitudeFromMercatorZ(e[2], e[1]),
                      a = o.rayIntersectionCoordinate(
                        o.pointRayIntersection(o.centerPoint, i)
                      ),
                      c =
                        o.zoomDeltaToMovement(s(a), l) * (r.dir[2] / n.dir[2]);
                    t.scale(g, n.dir, c);
                  } else if (o._terrainEnabled()) {
                    const r = o.zoomDeltaToMovement(e, l);
                    t.scale(g, n.dir, r);
                  }
                }
                const y = t.add(f, f, g);
                o._translateCameraConstrained(y),
                  l && Math.abs(o.zoom - m) > 1e-4 && o.recenterOnTerrain(),
                  (o.cameraElevationReference = "ground"),
                  this._map._update(),
                  e.noInertia || this._inertia.record(e),
                  this._fireEvents(n, r, !0);
              }
              _fireEvents(e, n, r) {
                const i = mi(this._eventsInProgress),
                  o = mi(e),
                  s = {};
                for (const t in e) {
                  const { originalEvent: n } = e[t];
                  this._eventsInProgress[t] || (s[`${t}start`] = n),
                    (this._eventsInProgress[t] = e[t]);
                }
                !i && o && this._fireEvent("movestart", o.originalEvent);
                for (const t in s) this._fireEvent(t, s[t]);
                o && this._fireEvent("move", o.originalEvent);
                for (const t in e) {
                  const { originalEvent: n } = e[t];
                  this._fireEvent(t, n);
                }
                const a = {};
                let l;
                for (const t in this._eventsInProgress) {
                  const { handlerName: e, originalEvent: r } =
                    this._eventsInProgress[t];
                  this._handlersById[e].isActive() ||
                    (delete this._eventsInProgress[t],
                    (l = n[e] || r),
                    (a[`${t}end`] = l));
                }
                for (const t in a) this._fireEvent(t, a[t]);
                const c = mi(this._eventsInProgress);
                if (r && (i || o) && !c) {
                  this._updatingCamera = !0;
                  const e = this._inertia._onMoveEnd(
                      this._map.dragPan._inertiaOptions
                    ),
                    n = (t) =>
                      0 !== t &&
                      -this._bearingSnap < t &&
                      t < this._bearingSnap;
                  e
                    ? (n(e.bearing || this._map.getBearing()) &&
                        (e.bearing = 0),
                      this._map.easeTo(e, { originalEvent: l }))
                    : (this._map.fire(
                        new t.Event("moveend", { originalEvent: l })
                      ),
                      n(this._map.getBearing()) && this._map.resetNorth()),
                    (this._updatingCamera = !1);
                }
              }
              _fireEvent(e, n) {
                this._map.fire(new t.Event(e, n ? { originalEvent: n } : {}));
              }
              _requestFrame() {
                return (
                  this._map.triggerRepaint(),
                  this._map._renderTaskQueue.add((t) => {
                    delete this._frameId,
                      this.handleEvent(new gi("renderFrame", { timeStamp: t })),
                      this._applyChanges();
                  })
                );
              }
              _triggerRenderFrame() {
                void 0 === this._frameId &&
                  (this._frameId = this._requestFrame());
              }
            }
            class bi extends t.Evented {
              constructor(e, n) {
                super(),
                  (this._moving = !1),
                  (this._zooming = !1),
                  (this.transform = e),
                  (this._bearingSnap = n.bearingSnap),
                  t.bindAll(["_renderFrameCallback"], this);
              }
              getCenter() {
                return new t.LngLat(
                  this.transform.center.lng,
                  this.transform.center.lat
                );
              }
              setCenter(t, e) {
                return this.jumpTo({ center: t }, e);
              }
              panBy(e, n, r) {
                return (
                  (e = t.pointGeometry.convert(e).mult(-1)),
                  this.panTo(
                    this.transform.center,
                    t.extend({ offset: e }, n),
                    r
                  )
                );
              }
              panTo(e, n, r) {
                return this.easeTo(t.extend({ center: e }, n), r);
              }
              getZoom() {
                return this.transform.zoom;
              }
              setZoom(t, e) {
                return this.jumpTo({ zoom: t }, e), this;
              }
              zoomTo(e, n, r) {
                return this.easeTo(t.extend({ zoom: e }, n), r);
              }
              zoomIn(t, e) {
                return this.zoomTo(this.getZoom() + 1, t, e), this;
              }
              zoomOut(t, e) {
                return this.zoomTo(this.getZoom() - 1, t, e), this;
              }
              getBearing() {
                return this.transform.bearing;
              }
              setBearing(t, e) {
                return this.jumpTo({ bearing: t }, e), this;
              }
              getPadding() {
                return this.transform.padding;
              }
              setPadding(t, e) {
                return this.jumpTo({ padding: t }, e), this;
              }
              rotateTo(e, n, r) {
                return this.easeTo(t.extend({ bearing: e }, n), r);
              }
              resetNorth(e, n) {
                return (
                  this.rotateTo(0, t.extend({ duration: 1e3 }, e), n), this
                );
              }
              resetNorthPitch(e, n) {
                return (
                  this.easeTo(
                    t.extend({ bearing: 0, pitch: 0, duration: 1e3 }, e),
                    n
                  ),
                  this
                );
              }
              snapToNorth(t, e) {
                return Math.abs(this.getBearing()) < this._bearingSnap
                  ? this.resetNorth(t, e)
                  : this;
              }
              getPitch() {
                return this.transform.pitch;
              }
              setPitch(t, e) {
                return this.jumpTo({ pitch: t }, e), this;
              }
              cameraForBounds(e, n) {
                e = t.LngLatBounds.convert(e);
                const r = (n && n.bearing) || 0;
                return this._cameraForBoxAndBearing(
                  e.getNorthWest(),
                  e.getSouthEast(),
                  r,
                  n
                );
              }
              _extendCameraOptions(e) {
                const n = { top: 0, bottom: 0, right: 0, left: 0 };
                if (
                  "number" ==
                  typeof (e = t.extend(
                    {
                      padding: n,
                      offset: [0, 0],
                      maxZoom: this.transform.maxZoom,
                    },
                    e
                  )).padding
                ) {
                  const t = e.padding;
                  e.padding = { top: t, bottom: t, right: t, left: t };
                }
                return (e.padding = t.extend(n, e.padding)), e;
              }
              _cameraForBoxAndBearing(e, n, r, i) {
                const o = this._extendCameraOptions(i),
                  s = this.transform,
                  a = s.padding,
                  l = s.project(t.LngLat.convert(e)),
                  c = s.project(t.LngLat.convert(n)),
                  u = l.rotate(-t.degToRad(r)),
                  h = c.rotate(-t.degToRad(r)),
                  p = new t.pointGeometry(
                    Math.max(u.x, h.x),
                    Math.max(u.y, h.y)
                  ),
                  d = new t.pointGeometry(
                    Math.min(u.x, h.x),
                    Math.min(u.y, h.y)
                  ),
                  f = p.sub(d),
                  m =
                    (s.width -
                      (a.left + a.right + o.padding.left + o.padding.right)) /
                    f.x,
                  g =
                    (s.height -
                      (a.top + a.bottom + o.padding.top + o.padding.bottom)) /
                    f.y;
                if (g < 0 || m < 0)
                  return void t.warnOnce(
                    "Map cannot fit within canvas with the given bounds, padding, and/or offset."
                  );
                const y = Math.min(
                    s.scaleZoom(s.scale * Math.min(m, g)),
                    o.maxZoom
                  ),
                  _ =
                    "number" == typeof o.offset.x
                      ? new t.pointGeometry(o.offset.x, o.offset.y)
                      : t.pointGeometry.convert(o.offset),
                  v = new t.pointGeometry(
                    (o.padding.left - o.padding.right) / 2,
                    (o.padding.top - o.padding.bottom) / 2
                  ).rotate((r * Math.PI) / 180),
                  b = _.add(v).mult(s.scale / s.zoomScale(y));
                return {
                  center: s.unproject(l.add(c).div(2).sub(b)),
                  zoom: y,
                  bearing: r,
                };
              }
              _cameraForBox(e, n, r, i, o) {
                const s = this._extendCameraOptions(o);
                (r = r || 0),
                  (i = i || 0),
                  (e = t.LngLat.convert(e)),
                  (n = t.LngLat.convert(n));
                const a = this.transform.clone();
                a.padding = s.padding;
                const l = this.getFreeCameraOptions(),
                  c = new t.LngLat(
                    0.5 * (e.lng + n.lng),
                    0.5 * (e.lat + n.lat)
                  ),
                  u = 0.5 * (r + i);
                if (a._camera.position[2] < t.mercatorZfromAltitude(u, c.lat))
                  return void t.warnOnce(
                    "Map cannot fit within canvas with the given bounds, padding, and/or offset."
                  );
                l.lookAtPoint(c), a.setFreeCameraOptions(l);
                const h = t.MercatorCoordinate.fromLngLat(e),
                  p = t.MercatorCoordinate.fromLngLat(n),
                  m = a.pointRayIntersection(a.centerPoint, u),
                  g = [(y = a.rayIntersectionCoordinate(m)).x, y.y, y.z];
                var y;
                const _ = a.screenPointToMercatorRay(a.centerPoint);
                let v,
                  b = 0;
                do {
                  const n = Math.floor(a.zoom),
                    o = 1 << n,
                    s = Math.min(o * h.x, o * p.x),
                    l = Math.min(o * h.y, o * p.y),
                    c = Math.max(o * h.x, o * p.x),
                    u = Math.max(o * h.y, o * p.y),
                    m = new f([s, l, r], [c, u, i]),
                    y = d.fromInvProjectionMatrix(
                      a.invProjMatrix,
                      a.worldSize,
                      n
                    );
                  if (2 !== m.intersects(y)) {
                    v &&
                      ((a._camera.position = t.scaleAndAdd(
                        [],
                        a._camera.position,
                        _.dir,
                        -v
                      )),
                      a._updateStateFromCamera());
                    break;
                  }
                  const b = t.sub([], a._camera.position, g);
                  (v = 0.5 * t.length(b)),
                    (a._camera.position = t.scaleAndAdd(
                      [],
                      a._camera.position,
                      _.dir,
                      v
                    ));
                  try {
                    a._updateStateFromCamera();
                  } catch (e) {
                    return void t.warnOnce(
                      "Map cannot fit within canvas with the given bounds, padding, and/or offset."
                    );
                  }
                } while (++b < 10);
                return {
                  center: a.center,
                  zoom: a.zoom,
                  bearing: a.bearing,
                  pitch: a.pitch,
                };
              }
              fitBounds(t, e, n) {
                return this._fitInternal(this.cameraForBounds(t, e), e, n);
              }
              _raycastElevationBox(e, n) {
                const r = this.transform.elevation;
                if (!r) return;
                const i = new t.pointGeometry(e.x, n.y),
                  o = new t.pointGeometry(n.x, e.y),
                  s = r.pointCoordinate(e);
                if (!s) return;
                const a = r.pointCoordinate(n);
                if (!a) return;
                const l = r.pointCoordinate(i);
                if (!l) return;
                const c = r.pointCoordinate(o);
                if (!c) return;
                const u = new t.MercatorCoordinate(s[0], s[1]).toLngLat(),
                  h = new t.MercatorCoordinate(a[0], a[1]).toLngLat(),
                  p = new t.MercatorCoordinate(l[0], l[1]).toLngLat(),
                  d = new t.MercatorCoordinate(c[0], c[1]).toLngLat(),
                  f = Math.min(u.lng, Math.min(h.lng, Math.min(p.lng, d.lng))),
                  m = Math.min(u.lat, Math.min(h.lat, Math.min(p.lat, d.lat))),
                  g = Math.max(u.lng, Math.max(h.lng, Math.max(p.lng, d.lng))),
                  y = Math.max(u.lat, Math.max(h.lat, Math.max(p.lat, d.lat))),
                  _ = Math.min(s[3], Math.min(a[3], Math.min(l[3], c[3]))),
                  v = Math.max(s[3], Math.max(a[3], Math.max(l[3], c[3])));
                return {
                  minLngLat: new t.LngLat(f, m),
                  maxLngLat: new t.LngLat(g, y),
                  minAltitude: _,
                  maxAltitude: v,
                };
              }
              fitScreenCoordinates(e, n, r, i, o) {
                let s, a, l, c;
                const u = t.pointGeometry.convert(e),
                  h = t.pointGeometry.convert(n),
                  p = this._raycastElevationBox(u, h);
                if (p)
                  (s = p.minLngLat),
                    (a = p.maxLngLat),
                    (l = p.minAltitude),
                    (c = p.maxAltitude);
                else {
                  if (this.transform.isHorizonVisibleForPoints(u, h))
                    return this;
                  (s = this.transform.pointLocation(u)),
                    (a = this.transform.pointLocation(h));
                }
                return this._fitInternal(
                  0 === this.transform.pitch
                    ? this._cameraForBoxAndBearing(
                        this.transform.pointLocation(
                          t.pointGeometry.convert(e)
                        ),
                        this.transform.pointLocation(
                          t.pointGeometry.convert(n)
                        ),
                        r,
                        i
                      )
                    : this._cameraForBox(s, a, l, c, i),
                  i,
                  o
                );
              }
              _fitInternal(e, n, r) {
                return e
                  ? (delete (n = t.extend(e, n)).padding,
                    n.linear ? this.easeTo(n, r) : this.flyTo(n, r))
                  : this;
              }
              jumpTo(e, n) {
                this.stop();
                const r = this.transform;
                let i = !1,
                  o = !1,
                  s = !1;
                return (
                  "zoom" in e &&
                    r.zoom !== +e.zoom &&
                    ((i = !0), (r.zoom = +e.zoom)),
                  void 0 !== e.center &&
                    (r.center = t.LngLat.convert(e.center)),
                  "bearing" in e &&
                    r.bearing !== +e.bearing &&
                    ((o = !0), (r.bearing = +e.bearing)),
                  "pitch" in e &&
                    r.pitch !== +e.pitch &&
                    ((s = !0), (r.pitch = +e.pitch)),
                  null == e.padding ||
                    r.isPaddingEqual(e.padding) ||
                    (r.padding = e.padding),
                  this.fire(new t.Event("movestart", n)).fire(
                    new t.Event("move", n)
                  ),
                  i &&
                    this.fire(new t.Event("zoomstart", n))
                      .fire(new t.Event("zoom", n))
                      .fire(new t.Event("zoomend", n)),
                  o &&
                    this.fire(new t.Event("rotatestart", n))
                      .fire(new t.Event("rotate", n))
                      .fire(new t.Event("rotateend", n)),
                  s &&
                    this.fire(new t.Event("pitchstart", n))
                      .fire(new t.Event("pitch", n))
                      .fire(new t.Event("pitchend", n)),
                  this.fire(new t.Event("moveend", n))
                );
              }
              getFreeCameraOptions() {
                return this.transform.getFreeCameraOptions();
              }
              setFreeCameraOptions(e, n) {
                this.stop();
                const r = this.transform,
                  i = r.zoom,
                  o = r.pitch,
                  s = r.bearing;
                r.setFreeCameraOptions(e);
                const a = i !== r.zoom,
                  l = o !== r.pitch,
                  c = s !== r.bearing;
                return (
                  this.fire(new t.Event("movestart", n)).fire(
                    new t.Event("move", n)
                  ),
                  a &&
                    this.fire(new t.Event("zoomstart", n))
                      .fire(new t.Event("zoom", n))
                      .fire(new t.Event("zoomend", n)),
                  c &&
                    this.fire(new t.Event("rotatestart", n))
                      .fire(new t.Event("rotate", n))
                      .fire(new t.Event("rotateend", n)),
                  l &&
                    this.fire(new t.Event("pitchstart", n))
                      .fire(new t.Event("pitch", n))
                      .fire(new t.Event("pitchend", n)),
                  this.fire(new t.Event("moveend", n)),
                  this
                );
              }
              easeTo(e, n) {
                this._stop(!1, e.easeId),
                  (!1 ===
                    (e = t.extend(
                      { offset: [0, 0], duration: 500, easing: t.ease },
                      e
                    )).animate ||
                    (!e.essential && t.exported.prefersReducedMotion)) &&
                    (e.duration = 0);
                const r = this.transform,
                  i = this.getZoom(),
                  o = this.getBearing(),
                  s = this.getPitch(),
                  a = this.getPadding(),
                  l = "zoom" in e ? +e.zoom : i,
                  c = "bearing" in e ? this._normalizeBearing(e.bearing, o) : o,
                  u = "pitch" in e ? +e.pitch : s,
                  h = "padding" in e ? e.padding : r.padding,
                  p = t.pointGeometry.convert(e.offset);
                let d = r.centerPoint.add(p);
                const f = r.pointLocation(d),
                  m = t.LngLat.convert(e.center || f);
                this._normalizeCenter(m);
                const g = r.project(f),
                  y = r.project(m).sub(g),
                  _ = r.zoomScale(l - i);
                let v, b;
                e.around &&
                  ((v = t.LngLat.convert(e.around)), (b = r.locationPoint(v)));
                const x = {
                  moving: this._moving,
                  zooming: this._zooming,
                  rotating: this._rotating,
                  pitching: this._pitching,
                };
                return (
                  (this._zooming = this._zooming || l !== i),
                  (this._rotating = this._rotating || o !== c),
                  (this._pitching = this._pitching || u !== s),
                  (this._padding = !r.isPaddingEqual(h)),
                  (this._easeId = e.easeId),
                  this._prepareEase(n, e.noMoveStart, x),
                  this._ease(
                    (e) => {
                      if (
                        (this._zooming && (r.zoom = t.number(i, l, e)),
                        this._rotating && (r.bearing = t.number(o, c, e)),
                        this._pitching && (r.pitch = t.number(s, u, e)),
                        this._padding &&
                          (r.interpolatePadding(a, h, e),
                          (d = r.centerPoint.add(p))),
                        v)
                      )
                        r.setLocationAtPoint(v, b);
                      else {
                        const t = r.zoomScale(r.zoom - i),
                          n = l > i ? Math.min(2, _) : Math.max(0.5, _),
                          o = Math.pow(n, 1 - e),
                          s = r.unproject(g.add(y.mult(e * o)).mult(t));
                        r.setLocationAtPoint(
                          r.renderWorldCopies ? s.wrap() : s,
                          d
                        );
                      }
                      this._fireMoveEvents(n);
                    },
                    (t) => {
                      r.recenterOnTerrain(), this._afterEase(n, t);
                    },
                    e
                  ),
                  this
                );
              }
              _prepareEase(e, n, r = {}) {
                (this._moving = !0),
                  (this.transform.cameraElevationReference = "sea"),
                  n || r.moving || this.fire(new t.Event("movestart", e)),
                  this._zooming &&
                    !r.zooming &&
                    this.fire(new t.Event("zoomstart", e)),
                  this._rotating &&
                    !r.rotating &&
                    this.fire(new t.Event("rotatestart", e)),
                  this._pitching &&
                    !r.pitching &&
                    this.fire(new t.Event("pitchstart", e));
              }
              _fireMoveEvents(e) {
                this.fire(new t.Event("move", e)),
                  this._zooming && this.fire(new t.Event("zoom", e)),
                  this._rotating && this.fire(new t.Event("rotate", e)),
                  this._pitching && this.fire(new t.Event("pitch", e));
              }
              _afterEase(e, n) {
                if (this._easeId && n && this._easeId === n) return;
                delete this._easeId,
                  (this.transform.cameraElevationReference = "ground");
                const r = this._zooming,
                  i = this._rotating,
                  o = this._pitching;
                (this._moving = !1),
                  (this._zooming = !1),
                  (this._rotating = !1),
                  (this._pitching = !1),
                  (this._padding = !1),
                  r && this.fire(new t.Event("zoomend", e)),
                  i && this.fire(new t.Event("rotateend", e)),
                  o && this.fire(new t.Event("pitchend", e)),
                  this.fire(new t.Event("moveend", e));
              }
              flyTo(e, n) {
                if (!e.essential && t.exported.prefersReducedMotion) {
                  const r = t.pick(e, [
                    "center",
                    "zoom",
                    "bearing",
                    "pitch",
                    "around",
                  ]);
                  return this.jumpTo(r, n);
                }
                this.stop(),
                  (e = t.extend(
                    { offset: [0, 0], speed: 1.2, curve: 1.42, easing: t.ease },
                    e
                  ));
                const r = this.transform,
                  i = this.getZoom(),
                  o = this.getBearing(),
                  s = this.getPitch(),
                  a = this.getPadding(),
                  l = "zoom" in e ? t.clamp(+e.zoom, r.minZoom, r.maxZoom) : i,
                  c = "bearing" in e ? this._normalizeBearing(e.bearing, o) : o,
                  u = "pitch" in e ? +e.pitch : s,
                  h = "padding" in e ? e.padding : r.padding,
                  p = r.zoomScale(l - i),
                  d = t.pointGeometry.convert(e.offset);
                let f = r.centerPoint.add(d);
                const m = r.pointLocation(f),
                  g = t.LngLat.convert(e.center || m);
                this._normalizeCenter(g);
                const y = r.project(m),
                  _ = r.project(g).sub(y);
                let v = e.curve;
                const b = Math.max(r.width, r.height),
                  x = b / p,
                  w = _.mag();
                if ("minZoom" in e) {
                  const n = t.clamp(
                      Math.min(e.minZoom, i, l),
                      r.minZoom,
                      r.maxZoom
                    ),
                    o = b / r.zoomScale(n - i);
                  v = Math.sqrt((o / w) * 2);
                }
                const S = v * v;
                function E(t) {
                  const e =
                    (x * x - b * b + (t ? -1 : 1) * S * S * w * w) /
                    (2 * (t ? x : b) * S * w);
                  return Math.log(Math.sqrt(e * e + 1) - e);
                }
                function T(t) {
                  return (Math.exp(t) - Math.exp(-t)) / 2;
                }
                function A(t) {
                  return (Math.exp(t) + Math.exp(-t)) / 2;
                }
                const C = E(0);
                let P = function (t) {
                    return A(C) / A(C + v * t);
                  },
                  M = function (t) {
                    return (
                      (b * ((A(C) * (T((e = C + v * t)) / A(e)) - T(C)) / S)) /
                      w
                    );
                    var e;
                  },
                  O = (E(1) - C) / v;
                if (Math.abs(w) < 1e-6 || !isFinite(O)) {
                  if (Math.abs(b - x) < 1e-6) return this.easeTo(e, n);
                  const t = x < b ? -1 : 1;
                  (O = Math.abs(Math.log(x / b)) / v),
                    (M = function () {
                      return 0;
                    }),
                    (P = function (e) {
                      return Math.exp(t * v * e);
                    });
                }
                return (
                  (e.duration =
                    "duration" in e
                      ? +e.duration
                      : (1e3 * O) /
                        ("screenSpeed" in e ? +e.screenSpeed / v : +e.speed)),
                  e.maxDuration &&
                    e.duration > e.maxDuration &&
                    (e.duration = 0),
                  (this._zooming = !0),
                  (this._rotating = o !== c),
                  (this._pitching = u !== s),
                  (this._padding = !r.isPaddingEqual(h)),
                  this._prepareEase(n, !1),
                  this._ease(
                    (e) => {
                      const p = e * O,
                        m = 1 / P(p);
                      (r.zoom = 1 === e ? l : i + r.scaleZoom(m)),
                        this._rotating && (r.bearing = t.number(o, c, e)),
                        this._pitching && (r.pitch = t.number(s, u, e)),
                        this._padding &&
                          (r.interpolatePadding(a, h, e),
                          (f = r.centerPoint.add(d)));
                      const v =
                        1 === e ? g : r.unproject(y.add(_.mult(M(p))).mult(m));
                      r.setLocationAtPoint(
                        r.renderWorldCopies ? v.wrap() : v,
                        f
                      ),
                        r._updateCenterElevation(),
                        this._fireMoveEvents(n);
                    },
                    () => this._afterEase(n),
                    e
                  ),
                  this
                );
              }
              isEasing() {
                return !!this._easeFrameId;
              }
              stop() {
                return this._stop();
              }
              _stop(t, e) {
                if (
                  (this._easeFrameId &&
                    (this._cancelRenderFrame(this._easeFrameId),
                    delete this._easeFrameId,
                    delete this._onEaseFrame),
                  this._onEaseEnd)
                ) {
                  const t = this._onEaseEnd;
                  delete this._onEaseEnd, t.call(this, e);
                }
                if (!t) {
                  const t = this.handlers;
                  t && t.stop(!1);
                }
                return this;
              }
              _ease(e, n, r) {
                !1 === r.animate || 0 === r.duration
                  ? (e(1), n())
                  : ((this._easeStart = t.exported.now()),
                    (this._easeOptions = r),
                    (this._onEaseFrame = e),
                    (this._onEaseEnd = n),
                    (this._easeFrameId = this._requestRenderFrame(
                      this._renderFrameCallback
                    )));
              }
              _renderFrameCallback() {
                const e = Math.min(
                  (t.exported.now() - this._easeStart) /
                    this._easeOptions.duration,
                  1
                );
                this._onEaseFrame(this._easeOptions.easing(e)),
                  e < 1
                    ? (this._easeFrameId = this._requestRenderFrame(
                        this._renderFrameCallback
                      ))
                    : this.stop();
              }
              _normalizeBearing(e, n) {
                e = t.wrap(e, -180, 180);
                const r = Math.abs(e - n);
                return (
                  Math.abs(e - 360 - n) < r && (e -= 360),
                  Math.abs(e + 360 - n) < r && (e += 360),
                  e
                );
              }
              _normalizeCenter(t) {
                const e = this.transform;
                if (!e.renderWorldCopies || e.lngRange) return;
                const n = t.lng - e.center.lng;
                t.lng += n > 180 ? -360 : n < -180 ? 360 : 0;
              }
            }
            class xi {
              constructor(e = {}) {
                (this.options = e),
                  t.bindAll(
                    [
                      "_toggleAttribution",
                      "_updateEditLink",
                      "_updateData",
                      "_updateCompact",
                    ],
                    this
                  );
              }
              getDefaultPosition() {
                return "bottom-right";
              }
              onAdd(t) {
                const e = this.options && this.options.compact;
                return (
                  (this._map = t),
                  (this._container = o.create(
                    "div",
                    "mapboxgl-ctrl mapboxgl-ctrl-attrib"
                  )),
                  (this._compactButton = o.create(
                    "button",
                    "mapboxgl-ctrl-attrib-button",
                    this._container
                  )),
                  (this._compactButton.type = "button"),
                  this._compactButton.addEventListener(
                    "click",
                    this._toggleAttribution
                  ),
                  this._setElementTitle(
                    this._compactButton,
                    "ToggleAttribution"
                  ),
                  (this._innerContainer = o.create(
                    "div",
                    "mapboxgl-ctrl-attrib-inner",
                    this._container
                  )),
                  this._innerContainer.setAttribute("role", "list"),
                  e && this._container.classList.add("mapboxgl-compact"),
                  this._updateAttributions(),
                  this._updateEditLink(),
                  this._map.on("styledata", this._updateData),
                  this._map.on("sourcedata", this._updateData),
                  this._map.on("moveend", this._updateEditLink),
                  void 0 === e &&
                    (this._map.on("resize", this._updateCompact),
                    this._updateCompact()),
                  this._container
                );
              }
              onRemove() {
                o.remove(this._container),
                  this._map.off("styledata", this._updateData),
                  this._map.off("sourcedata", this._updateData),
                  this._map.off("moveend", this._updateEditLink),
                  this._map.off("resize", this._updateCompact),
                  (this._map = void 0),
                  (this._attribHTML = void 0);
              }
              _setElementTitle(t, e) {
                const n = this._map._getUIString(`AttributionControl.${e}`);
                (t.title = n), t.setAttribute("aria-label", n);
              }
              _toggleAttribution() {
                this._container.classList.contains("mapboxgl-compact-show")
                  ? (this._container.classList.remove("mapboxgl-compact-show"),
                    this._compactButton.setAttribute("aria-pressed", "false"))
                  : (this._container.classList.add("mapboxgl-compact-show"),
                    this._compactButton.setAttribute("aria-pressed", "true"));
              }
              _updateEditLink() {
                let e = this._editLink;
                e ||
                  (e = this._editLink =
                    this._container.querySelector(".mapbox-improve-map"));
                const n = [
                  { key: "owner", value: this.styleOwner },
                  { key: "id", value: this.styleId },
                  {
                    key: "access_token",
                    value:
                      this._map._requestManager._customAccessToken ||
                      t.config.ACCESS_TOKEN,
                  },
                ];
                if (e) {
                  const r = n.reduce(
                    (t, e, r) => (
                      e.value &&
                        (t += `${e.key}=${e.value}${
                          r < n.length - 1 ? "&" : ""
                        }`),
                      t
                    ),
                    "?"
                  );
                  (e.href = `${t.config.FEEDBACK_URL}/${r}${
                    this._map._hash ? this._map._hash.getHashString(!0) : ""
                  }`),
                    (e.rel = "noopener nofollow"),
                    this._setElementTitle(e, "MapFeedback");
                }
              }
              _updateData(t) {
                !t ||
                  ("metadata" !== t.sourceDataType &&
                    "visibility" !== t.sourceDataType &&
                    "style" !== t.dataType) ||
                  (this._updateAttributions(), this._updateEditLink());
              }
              _updateAttributions() {
                if (!this._map.style) return;
                let t = [];
                if (
                  (this.options.customAttribution &&
                    (Array.isArray(this.options.customAttribution)
                      ? (t = t.concat(
                          this.options.customAttribution.map((t) =>
                            "string" != typeof t ? "" : t
                          )
                        ))
                      : "string" == typeof this.options.customAttribution &&
                        t.push(this.options.customAttribution)),
                  this._map.style.stylesheet)
                ) {
                  const t = this._map.style.stylesheet;
                  (this.styleOwner = t.owner), (this.styleId = t.id);
                }
                const e = this._map.style._sourceCaches;
                for (const r in e) {
                  const n = e[r];
                  if (n.used) {
                    const e = n.getSource();
                    e.attribution &&
                      t.indexOf(e.attribution) < 0 &&
                      t.push(e.attribution);
                  }
                }
                t.sort((t, e) => t.length - e.length),
                  (t = t.filter((e, n) => {
                    for (let r = n + 1; r < t.length; r++)
                      if (t[r].indexOf(e) >= 0) return !1;
                    return !0;
                  }));
                const n = t.join(" | ");
                n !== this._attribHTML &&
                  ((this._attribHTML = n),
                  t.length
                    ? ((this._innerContainer.innerHTML = n),
                      this._container.classList.remove("mapboxgl-attrib-empty"))
                    : this._container.classList.add("mapboxgl-attrib-empty"),
                  (this._editLink = null));
              }
              _updateCompact() {
                this._map.getCanvasContainer().offsetWidth <= 640
                  ? this._container.classList.add("mapboxgl-compact")
                  : this._container.classList.remove(
                      "mapboxgl-compact",
                      "mapboxgl-compact-show"
                    );
              }
            }
            class wi {
              constructor() {
                t.bindAll(["_updateLogo"], this),
                  t.bindAll(["_updateCompact"], this);
              }
              onAdd(t) {
                (this._map = t),
                  (this._container = o.create("div", "mapboxgl-ctrl"));
                const e = o.create("a", "mapboxgl-ctrl-logo");
                return (
                  (e.target = "_blank"),
                  (e.rel = "noopener nofollow"),
                  (e.href = "https://www.mapbox.com/"),
                  e.setAttribute(
                    "aria-label",
                    this._map._getUIString("LogoControl.Title")
                  ),
                  e.setAttribute("rel", "noopener nofollow"),
                  this._container.appendChild(e),
                  (this._container.style.display = "none"),
                  this._map.on("sourcedata", this._updateLogo),
                  this._updateLogo(),
                  this._map.on("resize", this._updateCompact),
                  this._updateCompact(),
                  this._container
                );
              }
              onRemove() {
                o.remove(this._container),
                  this._map.off("sourcedata", this._updateLogo),
                  this._map.off("resize", this._updateCompact);
              }
              getDefaultPosition() {
                return "bottom-left";
              }
              _updateLogo(t) {
                (t && "metadata" !== t.sourceDataType) ||
                  (this._container.style.display = this._logoRequired()
                    ? "block"
                    : "none");
              }
              _logoRequired() {
                if (!this._map.style) return !0;
                const t = this._map.style._sourceCaches;
                if (0 === Object.entries(t).length) return !0;
                for (const e in t) {
                  const n = t[e].getSource();
                  if (n.hasOwnProperty("mapbox_logo") && !n.mapbox_logo)
                    return !1;
                }
                return !0;
              }
              _updateCompact() {
                const t = this._container.children;
                if (t.length) {
                  const e = t[0];
                  this._map.getCanvasContainer().offsetWidth < 250
                    ? e.classList.add("mapboxgl-compact")
                    : e.classList.remove("mapboxgl-compact");
                }
              }
            }
            class Si {
              constructor() {
                (this._queue = []),
                  (this._id = 0),
                  (this._cleared = !1),
                  (this._currentlyRunning = !1);
              }
              add(t) {
                const e = ++this._id;
                return (
                  this._queue.push({ callback: t, id: e, cancelled: !1 }), e
                );
              }
              remove(t) {
                const e = this._currentlyRunning,
                  n = e ? this._queue.concat(e) : this._queue;
                for (const r of n)
                  if (r.id === t) return void (r.cancelled = !0);
              }
              run(t = 0) {
                const e = (this._currentlyRunning = this._queue);
                this._queue = [];
                for (const n of e)
                  if (!n.cancelled && (n.callback(t), this._cleared)) break;
                (this._cleared = !1), (this._currentlyRunning = !1);
              }
              clear() {
                this._currentlyRunning && (this._cleared = !0),
                  (this._queue = []);
              }
            }
            function Ei(e, n, r) {
              if (((e = new t.LngLat(e.lng, e.lat)), n)) {
                const i = new t.LngLat(e.lng - 360, e.lat),
                  o = new t.LngLat(e.lng + 360, e.lat),
                  s = 360 * Math.ceil(Math.abs(e.lng - r.center.lng) / 360),
                  a = r.locationPoint(e).distSqr(n),
                  l = n.x < 0 || n.y < 0 || n.x > r.width || n.y > r.height;
                r.locationPoint(i).distSqr(n) < a &&
                (l || Math.abs(i.lng - r.center.lng) < s)
                  ? (e = i)
                  : r.locationPoint(o).distSqr(n) < a &&
                    (l || Math.abs(o.lng - r.center.lng) < s) &&
                    (e = o);
              }
              for (; Math.abs(e.lng - r.center.lng) > 180; ) {
                const t = r.locationPoint(e);
                if (t.x >= 0 && t.y >= 0 && t.x <= r.width && t.y <= r.height)
                  break;
                e.lng > r.center.lng ? (e.lng -= 360) : (e.lng += 360);
              }
              return e;
            }
            const Ti = {
              center: "translate(-50%,-50%)",
              top: "translate(-50%,0)",
              "top-left": "translate(0,0)",
              "top-right": "translate(-100%,0)",
              bottom: "translate(-50%,-100%)",
              "bottom-left": "translate(0,-100%)",
              "bottom-right": "translate(-100%,-100%)",
              left: "translate(0,-50%)",
              right: "translate(-100%,-50%)",
            };
            function Ai(t, e, n) {
              const r = t.classList;
              for (const i in Ti) r.remove(`mapboxgl-${n}-anchor-${i}`);
              r.add(`mapboxgl-${n}-anchor-${e}`);
            }
            class Ci extends t.Evented {
              constructor(e, n) {
                if (
                  (super(),
                  (e instanceof t.window.HTMLElement || n) &&
                    (e = t.extend({ element: e }, n)),
                  t.bindAll(
                    [
                      "_update",
                      "_onMove",
                      "_onUp",
                      "_addDragHandler",
                      "_onMapClick",
                      "_onKeyPress",
                      "_clearFadeTimer",
                    ],
                    this
                  ),
                  (this._anchor = (e && e.anchor) || "center"),
                  (this._color = (e && e.color) || "#3FB1CE"),
                  (this._scale = (e && e.scale) || 1),
                  (this._draggable = (e && e.draggable) || !1),
                  (this._clickTolerance = (e && e.clickTolerance) || 0),
                  (this._isDragging = !1),
                  (this._state = "inactive"),
                  (this._rotation = (e && e.rotation) || 0),
                  (this._rotationAlignment =
                    (e && e.rotationAlignment) || "auto"),
                  (this._pitchAlignment =
                    e && e.pitchAlignment && "auto" !== e.pitchAlignment
                      ? e.pitchAlignment
                      : this._rotationAlignment),
                  e && e.element)
                )
                  (this._element = e.element),
                    (this._offset = t.pointGeometry.convert(
                      (e && e.offset) || [0, 0]
                    ));
                else {
                  (this._defaultMarker = !0),
                    (this._element = o.create("div")),
                    this._element.setAttribute("aria-label", "Map marker");
                  const n = o.createNS("http://www.w3.org/2000/svg", "svg"),
                    r = 41,
                    i = 27;
                  n.setAttributeNS(null, "display", "block"),
                    n.setAttributeNS(null, "height", `${r}px`),
                    n.setAttributeNS(null, "width", `${i}px`),
                    n.setAttributeNS(null, "viewBox", `0 0 ${i} ${r}`);
                  const s = o.createNS("http://www.w3.org/2000/svg", "g");
                  s.setAttributeNS(null, "stroke", "none"),
                    s.setAttributeNS(null, "stroke-width", "1"),
                    s.setAttributeNS(null, "fill", "none"),
                    s.setAttributeNS(null, "fill-rule", "evenodd");
                  const a = o.createNS("http://www.w3.org/2000/svg", "g");
                  a.setAttributeNS(null, "fill-rule", "nonzero");
                  const l = o.createNS("http://www.w3.org/2000/svg", "g");
                  l.setAttributeNS(null, "transform", "translate(3.0, 29.0)"),
                    l.setAttributeNS(null, "fill", "#000000");
                  const c = [
                    { rx: "10.5", ry: "5.25002273" },
                    { rx: "10.5", ry: "5.25002273" },
                    { rx: "9.5", ry: "4.77275007" },
                    { rx: "8.5", ry: "4.29549936" },
                    { rx: "7.5", ry: "3.81822308" },
                    { rx: "6.5", ry: "3.34094679" },
                    { rx: "5.5", ry: "2.86367051" },
                    { rx: "4.5", ry: "2.38636864" },
                  ];
                  for (const t of c) {
                    const e = o.createNS(
                      "http://www.w3.org/2000/svg",
                      "ellipse"
                    );
                    e.setAttributeNS(null, "opacity", "0.04"),
                      e.setAttributeNS(null, "cx", "10.5"),
                      e.setAttributeNS(null, "cy", "5.80029008"),
                      e.setAttributeNS(null, "rx", t.rx),
                      e.setAttributeNS(null, "ry", t.ry),
                      l.appendChild(e);
                  }
                  const u = o.createNS("http://www.w3.org/2000/svg", "g");
                  u.setAttributeNS(null, "fill", this._color);
                  const h = o.createNS("http://www.w3.org/2000/svg", "path");
                  h.setAttributeNS(
                    null,
                    "d",
                    "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"
                  ),
                    u.appendChild(h);
                  const p = o.createNS("http://www.w3.org/2000/svg", "g");
                  p.setAttributeNS(null, "opacity", "0.25"),
                    p.setAttributeNS(null, "fill", "#000000");
                  const d = o.createNS("http://www.w3.org/2000/svg", "path");
                  d.setAttributeNS(
                    null,
                    "d",
                    "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"
                  ),
                    p.appendChild(d);
                  const f = o.createNS("http://www.w3.org/2000/svg", "g");
                  f.setAttributeNS(null, "transform", "translate(6.0, 7.0)"),
                    f.setAttributeNS(null, "fill", "#FFFFFF");
                  const m = o.createNS("http://www.w3.org/2000/svg", "g");
                  m.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
                  const g = o.createNS("http://www.w3.org/2000/svg", "circle");
                  g.setAttributeNS(null, "fill", "#000000"),
                    g.setAttributeNS(null, "opacity", "0.25"),
                    g.setAttributeNS(null, "cx", "5.5"),
                    g.setAttributeNS(null, "cy", "5.5"),
                    g.setAttributeNS(null, "r", "5.4999962");
                  const y = o.createNS("http://www.w3.org/2000/svg", "circle");
                  y.setAttributeNS(null, "fill", "#FFFFFF"),
                    y.setAttributeNS(null, "cx", "5.5"),
                    y.setAttributeNS(null, "cy", "5.5"),
                    y.setAttributeNS(null, "r", "5.4999962"),
                    m.appendChild(g),
                    m.appendChild(y),
                    a.appendChild(l),
                    a.appendChild(u),
                    a.appendChild(p),
                    a.appendChild(f),
                    a.appendChild(m),
                    n.appendChild(a),
                    n.setAttributeNS(null, "height", r * this._scale + "px"),
                    n.setAttributeNS(null, "width", i * this._scale + "px"),
                    this._element.appendChild(n),
                    (this._offset = t.pointGeometry.convert(
                      (e && e.offset) || [0, -14]
                    ));
                }
                this._element.classList.add("mapboxgl-marker"),
                  this._element.addEventListener("dragstart", (t) => {
                    t.preventDefault();
                  }),
                  this._element.addEventListener("mousedown", (t) => {
                    t.preventDefault();
                  }),
                  Ai(this._element, this._anchor, "marker"),
                  (this._popup = null);
              }
              addTo(t) {
                return (
                  this.remove(),
                  (this._map = t),
                  t.getCanvasContainer().appendChild(this._element),
                  t.on("move", this._update),
                  t.on("moveend", this._update),
                  t.on("remove", this._clearFadeTimer),
                  t._addMarker(this),
                  this.setDraggable(this._draggable),
                  this._update(),
                  this._map.on("click", this._onMapClick),
                  this
                );
              }
              remove() {
                return (
                  this._map &&
                    (this._map.off("click", this._onMapClick),
                    this._map.off("move", this._update),
                    this._map.off("moveend", this._update),
                    this._map.off("mousedown", this._addDragHandler),
                    this._map.off("touchstart", this._addDragHandler),
                    this._map.off("mouseup", this._onUp),
                    this._map.off("touchend", this._onUp),
                    this._map.off("mousemove", this._onMove),
                    this._map.off("touchmove", this._onMove),
                    this._map.off("remove", this._clearFadeTimer),
                    this._map._removeMarker(this),
                    delete this._map),
                  this._clearFadeTimer(),
                  o.remove(this._element),
                  this._popup && this._popup.remove(),
                  this
                );
              }
              getLngLat() {
                return this._lngLat;
              }
              setLngLat(e) {
                return (
                  (this._lngLat = t.LngLat.convert(e)),
                  (this._pos = null),
                  this._popup && this._popup.setLngLat(this._lngLat),
                  this._update(),
                  this
                );
              }
              getElement() {
                return this._element;
              }
              setPopup(t) {
                if (
                  (this._popup &&
                    (this._popup.remove(),
                    (this._popup = null),
                    this._element.removeEventListener(
                      "keypress",
                      this._onKeyPress
                    ),
                    this._originalTabIndex ||
                      this._element.removeAttribute("tabindex")),
                  t)
                ) {
                  if (!("offset" in t.options)) {
                    const e = 38.1,
                      n = 13.5,
                      r = Math.sqrt(Math.pow(n, 2) / 2);
                    t.options.offset = this._defaultMarker
                      ? {
                          top: [0, 0],
                          "top-left": [0, 0],
                          "top-right": [0, 0],
                          bottom: [0, -e],
                          "bottom-left": [r, -1 * (e - n + r)],
                          "bottom-right": [-r, -1 * (e - n + r)],
                          left: [n, -1 * (e - n)],
                          right: [-n, -1 * (e - n)],
                        }
                      : this._offset;
                  }
                  (this._popup = t),
                    this._lngLat && this._popup.setLngLat(this._lngLat),
                    (this._originalTabIndex =
                      this._element.getAttribute("tabindex")),
                    this._originalTabIndex ||
                      this._element.setAttribute("tabindex", "0"),
                    this._element.addEventListener(
                      "keypress",
                      this._onKeyPress
                    );
                }
                return this;
              }
              _onKeyPress(t) {
                const e = t.code,
                  n = t.charCode || t.keyCode;
                ("Space" !== e && "Enter" !== e && 32 !== n && 13 !== n) ||
                  this.togglePopup();
              }
              _onMapClick(t) {
                const e = t.originalEvent.target,
                  n = this._element;
                this._popup && (e === n || n.contains(e)) && this.togglePopup();
              }
              getPopup() {
                return this._popup;
              }
              togglePopup() {
                const t = this._popup;
                return t
                  ? (t.isOpen() ? t.remove() : t.addTo(this._map), this)
                  : this;
              }
              _evaluateOpacity() {
                const t = this._pos
                  ? this._pos.sub(this._transformedOffset())
                  : null;
                if (!this._withinScreenBounds(t))
                  return void this._clearFadeTimer();
                const e = this._map.unproject(t);
                let n = !1;
                if (this._map.getTerrain()) {
                  const t = this._map.getFreeCameraOptions();
                  if (t.position) {
                    const r = t.position.toLngLat();
                    n = r.distanceTo(e) < 0.9 * r.distanceTo(this._lngLat);
                  }
                }
                const r = (1 - this._map._queryFogOpacity(e)) * (n ? 0.2 : 1);
                (this._element.style.opacity = `${r}`),
                  this._popup && this._popup._setOpacity(`${r}`),
                  (this._fadeTimer = null);
              }
              _clearFadeTimer() {
                this._fadeTimer &&
                  (clearTimeout(this._fadeTimer), (this._fadeTimer = null));
              }
              _withinScreenBounds(t) {
                const e = this._map.transform;
                return (
                  !!t && t.x >= 0 && t.x < e.width && t.y >= 0 && t.y < e.height
                );
              }
              _update(t) {
                if (!this._map) return;
                this._map.transform.renderWorldCopies &&
                  (this._lngLat = Ei(
                    this._lngLat,
                    this._pos,
                    this._map.transform
                  )),
                  (this._pos = this._map
                    .project(this._lngLat)
                    ._add(this._transformedOffset()));
                let e = "";
                "viewport" === this._rotationAlignment ||
                "auto" === this._rotationAlignment
                  ? (e = `rotateZ(${this._rotation}deg)`)
                  : "map" === this._rotationAlignment &&
                    (e = `rotateZ(${
                      this._rotation - this._map.getBearing()
                    }deg)`);
                let n = "";
                "viewport" === this._pitchAlignment ||
                "auto" === this._pitchAlignment
                  ? (n = "rotateX(0deg)")
                  : "map" === this._pitchAlignment &&
                    (n = `rotateX(${this._map.getPitch()}deg)`),
                  (t && "moveend" !== t.type) ||
                    (this._pos = this._pos.round()),
                  this._map._requestDomTask(() => {
                    this._map &&
                      (this._element &&
                        this._pos &&
                        this._anchor &&
                        o.setTransform(
                          this._element,
                          `${Ti[this._anchor]} translate(${this._pos.x}px, ${
                            this._pos.y
                          }px) ${n} ${e}`
                        ),
                      (!this._map.getTerrain() && !this._map.getFog()) ||
                        this._fadeTimer ||
                        (this._fadeTimer = setTimeout(
                          this._evaluateOpacity.bind(this),
                          60
                        )));
                  });
              }
              _transformedOffset() {
                if (!this._defaultMarker) return this._offset;
                const t = this._map.transform,
                  e = this._offset.mult(this._scale);
                return (
                  "map" === this._rotationAlignment && e._rotate(t.angle),
                  "map" === this._pitchAlignment && (e.y *= Math.cos(t._pitch)),
                  e
                );
              }
              getOffset() {
                return this._offset;
              }
              setOffset(e) {
                return (
                  (this._offset = t.pointGeometry.convert(e)),
                  this._update(),
                  this
                );
              }
              _onMove(e) {
                if (!this._isDragging) {
                  const t = this._clickTolerance || this._map._clickTolerance;
                  this._isDragging = e.point.dist(this._pointerdownPos) >= t;
                }
                this._isDragging &&
                  ((this._pos = e.point.sub(this._positionDelta)),
                  (this._lngLat = this._map.unproject(this._pos)),
                  this.setLngLat(this._lngLat),
                  (this._element.style.pointerEvents = "none"),
                  "pending" === this._state &&
                    ((this._state = "active"),
                    this.fire(new t.Event("dragstart"))),
                  this.fire(new t.Event("drag")));
              }
              _onUp() {
                (this._element.style.pointerEvents = "auto"),
                  (this._positionDelta = null),
                  (this._pointerdownPos = null),
                  (this._isDragging = !1),
                  this._map.off("mousemove", this._onMove),
                  this._map.off("touchmove", this._onMove),
                  "active" === this._state && this.fire(new t.Event("dragend")),
                  (this._state = "inactive");
              }
              _addDragHandler(t) {
                this._element.contains(t.originalEvent.target) &&
                  (t.preventDefault(),
                  (this._positionDelta = t.point
                    .sub(this._pos)
                    .add(this._transformedOffset())),
                  (this._pointerdownPos = t.point),
                  (this._state = "pending"),
                  this._map.on("mousemove", this._onMove),
                  this._map.on("touchmove", this._onMove),
                  this._map.once("mouseup", this._onUp),
                  this._map.once("touchend", this._onUp));
              }
              setDraggable(t) {
                return (
                  (this._draggable = !!t),
                  this._map &&
                    (t
                      ? (this._map.on("mousedown", this._addDragHandler),
                        this._map.on("touchstart", this._addDragHandler))
                      : (this._map.off("mousedown", this._addDragHandler),
                        this._map.off("touchstart", this._addDragHandler))),
                  this
                );
              }
              isDraggable() {
                return this._draggable;
              }
              setRotation(t) {
                return (this._rotation = t || 0), this._update(), this;
              }
              getRotation() {
                return this._rotation;
              }
              setRotationAlignment(t) {
                return (
                  (this._rotationAlignment = t || "auto"), this._update(), this
                );
              }
              getRotationAlignment() {
                return this._rotationAlignment;
              }
              setPitchAlignment(t) {
                return (
                  (this._pitchAlignment =
                    t && "auto" !== t ? t : this._rotationAlignment),
                  this._update(),
                  this
                );
              }
              getPitchAlignment() {
                return this._pitchAlignment;
              }
            }
            class Pi {
              constructor(t) {
                this.jumpTo(t);
              }
              getValue(e) {
                if (e <= this._startTime) return this._start;
                if (e >= this._endTime) return this._end;
                const n = t.easeCubicInOut(
                  (e - this._startTime) / (this._endTime - this._startTime)
                );
                return this._start * (1 - n) + this._end * n;
              }
              isEasing(t) {
                return t >= this._startTime && t <= this._endTime;
              }
              jumpTo(t) {
                (this._startTime = -1 / 0),
                  (this._endTime = -1 / 0),
                  (this._start = t),
                  (this._end = t);
              }
              easeTo(t, e, n) {
                (this._start = this.getValue(e)),
                  (this._end = t),
                  (this._startTime = e),
                  (this._endTime = e + n);
              }
            }
            const Mi = {
                "AttributionControl.ToggleAttribution": "Toggle attribution",
                "AttributionControl.MapFeedback": "Map feedback",
                "FullscreenControl.Enter": "Enter fullscreen",
                "FullscreenControl.Exit": "Exit fullscreen",
                "GeolocateControl.FindMyLocation": "Find my location",
                "GeolocateControl.LocationNotAvailable":
                  "Location not available",
                "LogoControl.Title": "Mapbox logo",
                "NavigationControl.ResetBearing": "Reset bearing to north",
                "NavigationControl.ZoomIn": "Zoom in",
                "NavigationControl.ZoomOut": "Zoom out",
                "ScaleControl.Feet": "ft",
                "ScaleControl.Meters": "m",
                "ScaleControl.Kilometers": "km",
                "ScaleControl.Miles": "mi",
                "ScaleControl.NauticalMiles": "nm",
              },
              {
                HTMLImageElement: Oi,
                HTMLElement: ki,
                ImageBitmap: Ii,
              } = t.window,
              Di = {
                center: [0, 0],
                zoom: 0,
                bearing: 0,
                pitch: 0,
                minZoom: -2,
                maxZoom: 22,
                minPitch: 0,
                maxPitch: 85,
                interactive: !0,
                scrollZoom: !0,
                boxZoom: !0,
                dragRotate: !0,
                dragPan: !0,
                keyboard: !0,
                doubleClickZoom: !0,
                touchZoomRotate: !0,
                touchPitch: !0,
                bearingSnap: 7,
                clickTolerance: 3,
                pitchWithRotate: !0,
                hash: !1,
                attributionControl: !0,
                failIfMajorPerformanceCaveat: !1,
                preserveDrawingBuffer: !1,
                trackResize: !0,
                optimizeForTerrain: !0,
                renderWorldCopies: !0,
                refreshExpiredTiles: !0,
                maxTileCacheSize: null,
                localIdeographFontFamily: "sans-serif",
                localFontFamily: null,
                transformRequest: null,
                accessToken: null,
                fadeDuration: 300,
                crossSourceCollisions: !0,
              };
            function zi(t) {
              t.parentNode && t.parentNode.removeChild(t);
            }
            const Ri = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
            class Li {
              constructor(e, n, r = !1) {
                (this._clickTolerance = 10),
                  (this.element = n),
                  (this.mouseRotate = new Wr({
                    clickTolerance: e.dragRotate._mouseRotate._clickTolerance,
                  })),
                  (this.map = e),
                  r &&
                    (this.mousePitch = new Hr({
                      clickTolerance: e.dragRotate._mousePitch._clickTolerance,
                    })),
                  t.bindAll(
                    [
                      "mousedown",
                      "mousemove",
                      "mouseup",
                      "touchstart",
                      "touchmove",
                      "touchend",
                      "reset",
                    ],
                    this
                  ),
                  o.addEventListener(n, "mousedown", this.mousedown),
                  o.addEventListener(n, "touchstart", this.touchstart, {
                    passive: !1,
                  }),
                  o.addEventListener(n, "touchmove", this.touchmove),
                  o.addEventListener(n, "touchend", this.touchend),
                  o.addEventListener(n, "touchcancel", this.reset);
              }
              down(t, e) {
                this.mouseRotate.mousedown(t, e),
                  this.mousePitch && this.mousePitch.mousedown(t, e),
                  o.disableDrag();
              }
              move(t, e) {
                const n = this.map,
                  r = this.mouseRotate.mousemoveWindow(t, e);
                if (
                  (r &&
                    r.bearingDelta &&
                    n.setBearing(n.getBearing() + r.bearingDelta),
                  this.mousePitch)
                ) {
                  const r = this.mousePitch.mousemoveWindow(t, e);
                  r && r.pitchDelta && n.setPitch(n.getPitch() + r.pitchDelta);
                }
              }
              off() {
                const t = this.element;
                o.removeEventListener(t, "mousedown", this.mousedown),
                  o.removeEventListener(t, "touchstart", this.touchstart, {
                    passive: !1,
                  }),
                  o.removeEventListener(t, "touchmove", this.touchmove),
                  o.removeEventListener(t, "touchend", this.touchend),
                  o.removeEventListener(t, "touchcancel", this.reset),
                  this.offTemp();
              }
              offTemp() {
                o.enableDrag(),
                  o.removeEventListener(t.window, "mousemove", this.mousemove),
                  o.removeEventListener(t.window, "mouseup", this.mouseup);
              }
              mousedown(e) {
                this.down(
                  t.extend({}, e, {
                    ctrlKey: !0,
                    preventDefault: () => e.preventDefault(),
                  }),
                  o.mousePos(this.element, e)
                ),
                  o.addEventListener(t.window, "mousemove", this.mousemove),
                  o.addEventListener(t.window, "mouseup", this.mouseup);
              }
              mousemove(t) {
                this.move(t, o.mousePos(this.element, t));
              }
              mouseup(t) {
                this.mouseRotate.mouseupWindow(t),
                  this.mousePitch && this.mousePitch.mouseupWindow(t),
                  this.offTemp();
              }
              touchstart(t) {
                1 !== t.targetTouches.length
                  ? this.reset()
                  : ((this._startPos = this._lastPos =
                      o.touchPos(this.element, t.targetTouches)[0]),
                    this.down(
                      {
                        type: "mousedown",
                        button: 0,
                        ctrlKey: !0,
                        preventDefault: () => t.preventDefault(),
                      },
                      this._startPos
                    ));
              }
              touchmove(t) {
                1 !== t.targetTouches.length
                  ? this.reset()
                  : ((this._lastPos = o.touchPos(
                      this.element,
                      t.targetTouches
                    )[0]),
                    this.move(
                      { preventDefault: () => t.preventDefault() },
                      this._lastPos
                    ));
              }
              touchend(t) {
                0 === t.targetTouches.length &&
                  this._startPos &&
                  this._lastPos &&
                  this._startPos.dist(this._lastPos) < this._clickTolerance &&
                  this.element.click(),
                  this.reset();
              }
              reset() {
                this.mouseRotate.reset(),
                  this.mousePitch && this.mousePitch.reset(),
                  delete this._startPos,
                  delete this._lastPos,
                  this.offTemp();
              }
            }
            const Fi = {
              positionOptions: {
                enableHighAccuracy: !1,
                maximumAge: 0,
                timeout: 6e3,
              },
              fitBoundsOptions: { maxZoom: 15 },
              trackUserLocation: !1,
              showAccuracyCircle: !0,
              showUserLocation: !0,
              showUserHeading: !1,
            };
            let Bi,
              Ni = 0,
              ji = !1;
            const Ui = { maxWidth: 100, unit: "metric" };
            function Zi(t, e, n) {
              const r = (n && n.maxWidth) || 100,
                i = t._container.clientHeight / 2,
                o = t.unproject([0, i]),
                s = t.unproject([r, i]),
                a = o.distanceTo(s);
              if (n && "imperial" === n.unit) {
                const n = 3.2808 * a;
                n > 5280
                  ? Vi(e, r, n / 5280, t._getUIString("ScaleControl.Miles"), t)
                  : Vi(e, r, n, t._getUIString("ScaleControl.Feet"), t);
              } else n && "nautical" === n.unit ? Vi(e, r, a / 1852, t._getUIString("ScaleControl.NauticalMiles"), t) : a >= 1e3 ? Vi(e, r, a / 1e3, t._getUIString("ScaleControl.Kilometers"), t) : Vi(e, r, a, t._getUIString("ScaleControl.Meters"), t);
            }
            function Vi(t, e, n, r, i) {
              const o = (function (t) {
                  const e = Math.pow(10, `${Math.floor(t)}`.length - 1);
                  let n = t / e;
                  return (
                    (n =
                      n >= 10
                        ? 10
                        : n >= 5
                        ? 5
                        : n >= 3
                        ? 3
                        : n >= 2
                        ? 2
                        : n >= 1
                        ? 1
                        : (function (t) {
                            const e = Math.pow(
                              10,
                              Math.ceil(-Math.log(t) / Math.LN10)
                            );
                            return Math.round(t * e) / e;
                          })(n)),
                    e * n
                  );
                })(n),
                s = o / n;
              i._requestDomTask(() => {
                (t.style.width = e * s + "px"),
                  (t.innerHTML = `${o}&nbsp;${r}`);
              });
            }
            const qi = {
                closeButton: !0,
                closeOnClick: !0,
                focusAfterOpen: !0,
                className: "",
                maxWidth: "240px",
              },
              $i = [
                "a[href]",
                "[tabindex]:not([tabindex='-1'])",
                "[contenteditable]:not([contenteditable='false'])",
                "button:not([disabled])",
                "input:not([disabled])",
                "select:not([disabled])",
                "textarea:not([disabled])",
              ].join(", ");
            function Gi(e) {
              if (e) {
                if ("number" == typeof e) {
                  const n = Math.round(Math.sqrt(0.5 * Math.pow(e, 2)));
                  return {
                    center: new t.pointGeometry(0, 0),
                    top: new t.pointGeometry(0, e),
                    "top-left": new t.pointGeometry(n, n),
                    "top-right": new t.pointGeometry(-n, n),
                    bottom: new t.pointGeometry(0, -e),
                    "bottom-left": new t.pointGeometry(n, -n),
                    "bottom-right": new t.pointGeometry(-n, -n),
                    left: new t.pointGeometry(e, 0),
                    right: new t.pointGeometry(-e, 0),
                  };
                }
                if (e instanceof t.pointGeometry || Array.isArray(e)) {
                  const n = t.pointGeometry.convert(e);
                  return {
                    center: n,
                    top: n,
                    "top-left": n,
                    "top-right": n,
                    bottom: n,
                    "bottom-left": n,
                    "bottom-right": n,
                    left: n,
                    right: n,
                  };
                }
                return {
                  center: t.pointGeometry.convert(e.center || [0, 0]),
                  top: t.pointGeometry.convert(e.top || [0, 0]),
                  "top-left": t.pointGeometry.convert(e["top-left"] || [0, 0]),
                  "top-right": t.pointGeometry.convert(
                    e["top-right"] || [0, 0]
                  ),
                  bottom: t.pointGeometry.convert(e.bottom || [0, 0]),
                  "bottom-left": t.pointGeometry.convert(
                    e["bottom-left"] || [0, 0]
                  ),
                  "bottom-right": t.pointGeometry.convert(
                    e["bottom-right"] || [0, 0]
                  ),
                  left: t.pointGeometry.convert(e.left || [0, 0]),
                  right: t.pointGeometry.convert(e.right || [0, 0]),
                };
              }
              return Gi(new t.pointGeometry(0, 0));
            }
            const Wi = {
              version: t.version,
              supported: e,
              setRTLTextPlugin: t.setRTLTextPlugin,
              getRTLTextPluginStatus: t.getRTLTextPluginStatus,
              Map: class extends bi {
                constructor(e) {
                  if (
                    null != (e = t.extend({}, Di, e)).minZoom &&
                    null != e.maxZoom &&
                    e.minZoom > e.maxZoom
                  )
                    throw new Error(
                      "maxZoom must be greater than or equal to minZoom"
                    );
                  if (
                    null != e.minPitch &&
                    null != e.maxPitch &&
                    e.minPitch > e.maxPitch
                  )
                    throw new Error(
                      "maxPitch must be greater than or equal to minPitch"
                    );
                  if (null != e.minPitch && e.minPitch < 0)
                    throw new Error(
                      "minPitch must be greater than or equal to 0"
                    );
                  if (null != e.maxPitch && e.maxPitch > 85)
                    throw new Error(
                      "maxPitch must be less than or equal to 85"
                    );
                  if (
                    (super(
                      new Sr(
                        e.minZoom,
                        e.maxZoom,
                        e.minPitch,
                        e.maxPitch,
                        e.renderWorldCopies
                      ),
                      e
                    ),
                    (this._interactive = e.interactive),
                    (this._maxTileCacheSize = e.maxTileCacheSize),
                    (this._failIfMajorPerformanceCaveat =
                      e.failIfMajorPerformanceCaveat),
                    (this._preserveDrawingBuffer = e.preserveDrawingBuffer),
                    (this._antialias = e.antialias),
                    (this._trackResize = e.trackResize),
                    (this._bearingSnap = e.bearingSnap),
                    (this._refreshExpiredTiles = e.refreshExpiredTiles),
                    (this._fadeDuration = e.fadeDuration),
                    (this._isInitialLoad = !0),
                    (this._crossSourceCollisions = e.crossSourceCollisions),
                    (this._crossFadingFactor = 1),
                    (this._collectResourceTiming = e.collectResourceTiming),
                    (this._optimizeForTerrain = e.optimizeForTerrain),
                    (this._renderTaskQueue = new Si()),
                    (this._domRenderTaskQueue = new Si()),
                    (this._controls = []),
                    (this._markers = []),
                    (this._mapId = t.uniqueId()),
                    (this._locale = t.extend({}, Mi, e.locale)),
                    (this._clickTolerance = e.clickTolerance),
                    (this._averageElevationLastSampledAt = -1 / 0),
                    (this._averageElevation = new Pi(0)),
                    (this._requestManager = new t.RequestManager(
                      e.transformRequest,
                      e.accessToken,
                      e.testMode
                    )),
                    (this._silenceAuthErrors = !!e.testMode),
                    "string" == typeof e.container)
                  ) {
                    if (
                      ((this._container = t.window.document.getElementById(
                        e.container
                      )),
                      !this._container)
                    )
                      throw new Error(`Container '${e.container}' not found.`);
                  } else {
                    if (!(e.container instanceof ki))
                      throw new Error(
                        "Invalid type: 'container' must be a String or HTMLElement."
                      );
                    this._container = e.container;
                  }
                  if (
                    (e.maxBounds && this.setMaxBounds(e.maxBounds),
                    t.bindAll(
                      [
                        "_onWindowOnline",
                        "_onWindowResize",
                        "_onMapScroll",
                        "_contextLost",
                        "_contextRestored",
                      ],
                      this
                    ),
                    this._setupContainer(),
                    this._setupPainter(),
                    void 0 === this.painter)
                  )
                    throw new Error("Failed to initialize WebGL.");
                  this.on("move", () => this._update(!1)),
                    this.on("moveend", () => this._update(!1)),
                    this.on("zoom", () => this._update(!0)),
                    void 0 !== t.window &&
                      (t.window.addEventListener(
                        "online",
                        this._onWindowOnline,
                        !1
                      ),
                      t.window.addEventListener(
                        "resize",
                        this._onWindowResize,
                        !1
                      ),
                      t.window.addEventListener(
                        "orientationchange",
                        this._onWindowResize,
                        !1
                      ),
                      t.window.addEventListener(
                        "webkitfullscreenchange",
                        this._onWindowResize,
                        !1
                      )),
                    (this.handlers = new vi(this, e)),
                    (this._hash =
                      e.hash &&
                      new Tr(
                        ("string" == typeof e.hash && e.hash) || void 0
                      ).addTo(this)),
                    (this._hash && this._hash._onHashChange()) ||
                      (this.jumpTo({
                        center: e.center,
                        zoom: e.zoom,
                        bearing: e.bearing,
                        pitch: e.pitch,
                      }),
                      e.bounds &&
                        (this.resize(),
                        this.fitBounds(
                          e.bounds,
                          t.extend({}, e.fitBoundsOptions, { duration: 0 })
                        ))),
                    this.resize(),
                    (this._localFontFamily = e.localFontFamily),
                    (this._localIdeographFontFamily =
                      e.localIdeographFontFamily),
                    e.style &&
                      this.setStyle(e.style, {
                        localFontFamily: this._localFontFamily,
                        localIdeographFontFamily:
                          this._localIdeographFontFamily,
                      }),
                    e.attributionControl &&
                      this.addControl(
                        new xi({ customAttribution: e.customAttribution })
                      ),
                    (this._logoControl = new wi()),
                    this.addControl(this._logoControl, e.logoPosition),
                    this.on("style.load", () => {
                      this.transform.unmodified &&
                        this.jumpTo(this.style.stylesheet);
                    }),
                    this.on("data", (e) => {
                      this._update("style" === e.dataType),
                        this.fire(new t.Event(`${e.dataType}data`, e));
                    }),
                    this.on("dataloading", (e) => {
                      this.fire(new t.Event(`${e.dataType}dataloading`, e));
                    });
                }
                _getMapId() {
                  return this._mapId;
                }
                addControl(e, n) {
                  if (
                    (void 0 === n &&
                      (n = e.getDefaultPosition
                        ? e.getDefaultPosition()
                        : "top-right"),
                    !e || !e.onAdd)
                  )
                    return this.fire(
                      new t.ErrorEvent(
                        new Error(
                          "Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods."
                        )
                      )
                    );
                  const r = e.onAdd(this);
                  this._controls.push(e);
                  const i = this._controlPositions[n];
                  return (
                    -1 !== n.indexOf("bottom")
                      ? i.insertBefore(r, i.firstChild)
                      : i.appendChild(r),
                    this
                  );
                }
                removeControl(e) {
                  if (!e || !e.onRemove)
                    return this.fire(
                      new t.ErrorEvent(
                        new Error(
                          "Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods."
                        )
                      )
                    );
                  const n = this._controls.indexOf(e);
                  return (
                    n > -1 && this._controls.splice(n, 1),
                    e.onRemove(this),
                    this
                  );
                }
                hasControl(t) {
                  return this._controls.indexOf(t) > -1;
                }
                getContainer() {
                  return this._container;
                }
                getCanvasContainer() {
                  return this._canvasContainer;
                }
                getCanvas() {
                  return this._canvas;
                }
                resize(e) {
                  const n = this._containerDimensions(),
                    r = n[0],
                    i = n[1];
                  this._resizeCanvas(r, i),
                    this.transform.resize(r, i),
                    this.painter.resize(r, i);
                  const o = !this._moving;
                  return (
                    o &&
                      (this.stop(),
                      this.fire(new t.Event("movestart", e)).fire(
                        new t.Event("move", e)
                      )),
                    this.fire(new t.Event("resize", e)),
                    o && this.fire(new t.Event("moveend", e)),
                    this
                  );
                }
                getBounds() {
                  return this.transform.getBounds();
                }
                getMaxBounds() {
                  return this.transform.getMaxBounds();
                }
                setMaxBounds(e) {
                  return (
                    this.transform.setMaxBounds(t.LngLatBounds.convert(e)),
                    this._update()
                  );
                }
                setMinZoom(t) {
                  if (
                    (t = null == t ? -2 : t) >= -2 &&
                    t <= this.transform.maxZoom
                  )
                    return (
                      (this.transform.minZoom = t),
                      this._update(),
                      this.getZoom() < t && this.setZoom(t),
                      this
                    );
                  throw new Error(
                    "minZoom must be between -2 and the current maxZoom, inclusive"
                  );
                }
                getMinZoom() {
                  return this.transform.minZoom;
                }
                setMaxZoom(t) {
                  if ((t = null == t ? 22 : t) >= this.transform.minZoom)
                    return (
                      (this.transform.maxZoom = t),
                      this._update(),
                      this.getZoom() > t && this.setZoom(t),
                      this
                    );
                  throw new Error(
                    "maxZoom must be greater than the current minZoom"
                  );
                }
                getMaxZoom() {
                  return this.transform.maxZoom;
                }
                setMinPitch(t) {
                  if ((t = null == t ? 0 : t) < 0)
                    throw new Error(
                      "minPitch must be greater than or equal to 0"
                    );
                  if (t >= 0 && t <= this.transform.maxPitch)
                    return (
                      (this.transform.minPitch = t),
                      this._update(),
                      this.getPitch() < t && this.setPitch(t),
                      this
                    );
                  throw new Error(
                    "minPitch must be between 0 and the current maxPitch, inclusive"
                  );
                }
                getMinPitch() {
                  return this.transform.minPitch;
                }
                setMaxPitch(t) {
                  if ((t = null == t ? 85 : t) > 85)
                    throw new Error(
                      "maxPitch must be less than or equal to 85"
                    );
                  if (t >= this.transform.minPitch)
                    return (
                      (this.transform.maxPitch = t),
                      this._update(),
                      this.getPitch() > t && this.setPitch(t),
                      this
                    );
                  throw new Error(
                    "maxPitch must be greater than the current minPitch"
                  );
                }
                getMaxPitch() {
                  return this.transform.maxPitch;
                }
                getRenderWorldCopies() {
                  return this.transform.renderWorldCopies;
                }
                setRenderWorldCopies(t) {
                  return (this.transform.renderWorldCopies = t), this._update();
                }
                project(e) {
                  return this.transform.locationPoint3D(t.LngLat.convert(e));
                }
                unproject(e) {
                  return this.transform.pointLocation3D(
                    t.pointGeometry.convert(e)
                  );
                }
                isMoving() {
                  return (
                    this._moving || (this.handlers && this.handlers.isMoving())
                  );
                }
                isZooming() {
                  return (
                    this._zooming ||
                    (this.handlers && this.handlers.isZooming())
                  );
                }
                isRotating() {
                  return (
                    this._rotating ||
                    (this.handlers && this.handlers.isRotating())
                  );
                }
                _createDelegatedListener(t, e, n) {
                  if ("mouseenter" === t || "mouseover" === t) {
                    let r = !1;
                    const i = (i) => {
                      const o = this.getLayer(e)
                        ? this.queryRenderedFeatures(i.point, { layers: [e] })
                        : [];
                      o.length
                        ? r ||
                          ((r = !0),
                          n.call(
                            this,
                            new zr(t, this, i.originalEvent, { features: o })
                          ))
                        : (r = !1);
                    };
                    return {
                      layer: e,
                      listener: n,
                      delegates: {
                        mousemove: i,
                        mouseout: () => {
                          r = !1;
                        },
                      },
                    };
                  }
                  if ("mouseleave" === t || "mouseout" === t) {
                    let r = !1;
                    const i = (i) => {
                        (this.getLayer(e)
                          ? this.queryRenderedFeatures(i.point, { layers: [e] })
                          : []
                        ).length
                          ? (r = !0)
                          : r &&
                            ((r = !1),
                            n.call(this, new zr(t, this, i.originalEvent)));
                      },
                      o = (e) => {
                        r &&
                          ((r = !1),
                          n.call(this, new zr(t, this, e.originalEvent)));
                      };
                    return {
                      layer: e,
                      listener: n,
                      delegates: { mousemove: i, mouseout: o },
                    };
                  }
                  {
                    const r = (t) => {
                      const r = this.getLayer(e)
                        ? this.queryRenderedFeatures(t.point, { layers: [e] })
                        : [];
                      r.length &&
                        ((t.features = r), n.call(this, t), delete t.features);
                    };
                    return { layer: e, listener: n, delegates: { [t]: r } };
                  }
                }
                on(t, e, n) {
                  if (void 0 === n) return super.on(t, e);
                  const r = this._createDelegatedListener(t, e, n);
                  (this._delegatedListeners = this._delegatedListeners || {}),
                    (this._delegatedListeners[t] =
                      this._delegatedListeners[t] || []),
                    this._delegatedListeners[t].push(r);
                  for (const i in r.delegates) this.on(i, r.delegates[i]);
                  return this;
                }
                once(t, e, n) {
                  if (void 0 === n) return super.once(t, e);
                  const r = this._createDelegatedListener(t, e, n);
                  for (const i in r.delegates) this.once(i, r.delegates[i]);
                  return this;
                }
                off(t, e, n) {
                  return void 0 === n
                    ? super.off(t, e)
                    : (this._delegatedListeners &&
                        this._delegatedListeners[t] &&
                        ((r) => {
                          const i = this._delegatedListeners[t];
                          for (let t = 0; t < i.length; t++) {
                            const r = i[t];
                            if (r.layer === e && r.listener === n) {
                              for (const t in r.delegates)
                                this.off(t, r.delegates[t]);
                              return i.splice(t, 1), this;
                            }
                          }
                        })(),
                      this);
                }
                queryRenderedFeatures(e, n) {
                  return this.style
                    ? (void 0 !== n ||
                        void 0 === e ||
                        e instanceof t.pointGeometry ||
                        Array.isArray(e) ||
                        ((n = e), (e = void 0)),
                      this.style.queryRenderedFeatures(
                        (e = e || [
                          [0, 0],
                          [this.transform.width, this.transform.height],
                        ]),
                        (n = n || {}),
                        this.transform
                      ))
                    : [];
                }
                querySourceFeatures(t, e) {
                  return this.style.querySourceFeatures(t, e);
                }
                queryTerrainElevation(e, n) {
                  const r = this.transform.elevation;
                  return r
                    ? ((n = t.extend({}, { exaggerated: !0 }, n)),
                      r.getAtPoint(
                        t.MercatorCoordinate.fromLngLat(e),
                        null,
                        n.exaggerated
                      ))
                    : null;
                }
                setStyle(e, n) {
                  return !1 !==
                    (n = t.extend(
                      {},
                      {
                        localIdeographFontFamily:
                          this._localIdeographFontFamily,
                        localFontFamily: this._localFontFamily,
                      },
                      n
                    )).diff &&
                    n.localIdeographFontFamily ===
                      this._localIdeographFontFamily &&
                    n.localFontFamily === this._localFontFamily &&
                    this.style &&
                    e
                    ? (this._diffStyle(e, n), this)
                    : ((this._localIdeographFontFamily =
                        n.localIdeographFontFamily),
                      (this._localFontFamily = n.localFontFamily),
                      this._updateStyle(e, n));
                }
                _getUIString(t) {
                  const e = this._locale[t];
                  if (null == e) throw new Error(`Missing UI string '${t}'`);
                  return e;
                }
                _updateStyle(t, e) {
                  return (
                    this.style &&
                      (this.style.setEventedParent(null),
                      this.style._remove(),
                      delete this.style),
                    t &&
                      ((this.style = new Ze(this, e || {})),
                      this.style.setEventedParent(this, { style: this.style }),
                      "string" == typeof t
                        ? this.style.loadURL(t)
                        : this.style.loadJSON(t)),
                    this._updateTerrain(),
                    this
                  );
                }
                _lazyInitEmptyStyle() {
                  this.style ||
                    ((this.style = new Ze(this, {})),
                    this.style.setEventedParent(this, { style: this.style }),
                    this.style.loadEmpty());
                }
                _diffStyle(e, n) {
                  if ("string" == typeof e) {
                    const r = this._requestManager.normalizeStyleURL(e),
                      i = this._requestManager.transformRequest(
                        r,
                        t.ResourceType.Style
                      );
                    t.getJSON(i, (e, r) => {
                      e
                        ? this.fire(new t.ErrorEvent(e))
                        : r && this._updateDiff(r, n);
                    });
                  } else "object" == typeof e && this._updateDiff(e, n);
                }
                _updateDiff(e, n) {
                  try {
                    this.style.setState(e) && this._update(!0);
                  } catch (r) {
                    t.warnOnce(
                      `Unable to perform style diff: ${
                        r.message || r.error || r
                      }.  Rebuilding the style from scratch.`
                    ),
                      this._updateStyle(e, n);
                  }
                }
                getStyle() {
                  if (this.style) return this.style.serialize();
                }
                isStyleLoaded() {
                  return this.style
                    ? this.style.loaded()
                    : t.warnOnce("There is no style added to the map.");
                }
                addSource(t, e) {
                  return (
                    this._lazyInitEmptyStyle(),
                    this.style.addSource(t, e),
                    this._update(!0)
                  );
                }
                isSourceLoaded(e) {
                  const n = this.style && this.style._getSourceCaches(e);
                  if (0 !== n.length) return n.every((t) => t.loaded());
                  this.fire(
                    new t.ErrorEvent(
                      new Error(`There is no source with ID '${e}'`)
                    )
                  );
                }
                areTilesLoaded() {
                  const t = this.style && this.style._sourceCaches;
                  for (const e in t) {
                    const n = t[e]._tiles;
                    for (const t in n) {
                      const e = n[t];
                      if ("loaded" !== e.state && "errored" !== e.state)
                        return !1;
                    }
                  }
                  return !0;
                }
                addSourceType(t, e, n) {
                  return (
                    this._lazyInitEmptyStyle(),
                    this.style.addSourceType(t, e, n)
                  );
                }
                removeSource(t) {
                  return (
                    this.style.removeSource(t),
                    this._updateTerrain(),
                    this._update(!0)
                  );
                }
                getSource(t) {
                  return this.style.getSource(t);
                }
                addImage(
                  e,
                  n,
                  {
                    pixelRatio: r = 1,
                    sdf: i = !1,
                    stretchX: o,
                    stretchY: s,
                    content: a,
                  } = {}
                ) {
                  if (
                    (this._lazyInitEmptyStyle(),
                    n instanceof Oi || (Ii && n instanceof Ii))
                  ) {
                    const {
                      width: l,
                      height: c,
                      data: u,
                    } = t.exported.getImageData(n);
                    this.style.addImage(e, {
                      data: new t.RGBAImage({ width: l, height: c }, u),
                      pixelRatio: r,
                      stretchX: o,
                      stretchY: s,
                      content: a,
                      sdf: i,
                      version: 0,
                    });
                  } else {
                    if (void 0 === n.width || void 0 === n.height)
                      return this.fire(
                        new t.ErrorEvent(
                          new Error(
                            "Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"
                          )
                        )
                      );
                    {
                      const { width: l, height: c, data: u } = n,
                        h = n;
                      this.style.addImage(e, {
                        data: new t.RGBAImage(
                          { width: l, height: c },
                          new Uint8Array(u)
                        ),
                        pixelRatio: r,
                        stretchX: o,
                        stretchY: s,
                        content: a,
                        sdf: i,
                        version: 0,
                        userImage: h,
                      }),
                        h.onAdd && h.onAdd(this, e);
                    }
                  }
                }
                updateImage(e, n) {
                  const r = this.style.getImage(e);
                  if (!r)
                    return this.fire(
                      new t.ErrorEvent(
                        new Error(
                          "The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead."
                        )
                      )
                    );
                  const i =
                      n instanceof Oi || (Ii && n instanceof Ii)
                        ? t.exported.getImageData(n)
                        : n,
                    { width: o, height: s, data: a } = i;
                  return void 0 === o || void 0 === s
                    ? this.fire(
                        new t.ErrorEvent(
                          new Error(
                            "Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"
                          )
                        )
                      )
                    : o !== r.data.width || s !== r.data.height
                    ? this.fire(
                        new t.ErrorEvent(
                          new Error(
                            "The width and height of the updated image must be that same as the previous version of the image"
                          )
                        )
                      )
                    : (r.data.replace(
                        a,
                        !(n instanceof Oi || (Ii && n instanceof Ii))
                      ),
                      void this.style.updateImage(e, r));
                }
                hasImage(e) {
                  return e
                    ? !!this.style.getImage(e)
                    : (this.fire(
                        new t.ErrorEvent(new Error("Missing required image id"))
                      ),
                      !1);
                }
                removeImage(t) {
                  this.style.removeImage(t);
                }
                loadImage(e, n) {
                  t.getImage(
                    this._requestManager.transformRequest(
                      e,
                      t.ResourceType.Image
                    ),
                    (e, r) => {
                      n(e, r instanceof Oi ? t.exported.getImageData(r) : r);
                    }
                  );
                }
                listImages() {
                  return this.style.listImages();
                }
                addLayer(t, e) {
                  return (
                    this._lazyInitEmptyStyle(),
                    this.style.addLayer(t, e),
                    this._update(!0)
                  );
                }
                moveLayer(t, e) {
                  return this.style.moveLayer(t, e), this._update(!0);
                }
                removeLayer(t) {
                  return this.style.removeLayer(t), this._update(!0);
                }
                getLayer(t) {
                  return this.style.getLayer(t);
                }
                setLayerZoomRange(t, e, n) {
                  return (
                    this.style.setLayerZoomRange(t, e, n), this._update(!0)
                  );
                }
                setFilter(t, e, n = {}) {
                  return this.style.setFilter(t, e, n), this._update(!0);
                }
                getFilter(t) {
                  return this.style.getFilter(t);
                }
                setPaintProperty(t, e, n, r = {}) {
                  return (
                    this.style.setPaintProperty(t, e, n, r), this._update(!0)
                  );
                }
                getPaintProperty(t, e) {
                  return this.style.getPaintProperty(t, e);
                }
                setLayoutProperty(t, e, n, r = {}) {
                  return (
                    this.style.setLayoutProperty(t, e, n, r), this._update(!0)
                  );
                }
                getLayoutProperty(t, e) {
                  return this.style.getLayoutProperty(t, e);
                }
                setLight(t, e = {}) {
                  return (
                    this._lazyInitEmptyStyle(),
                    this.style.setLight(t, e),
                    this._update(!0)
                  );
                }
                getLight() {
                  return this.style.getLight();
                }
                setTerrain(t) {
                  return (
                    this._lazyInitEmptyStyle(),
                    this.style.setTerrain(t),
                    (this._averageElevationLastSampledAt = -1 / 0),
                    this._update(!0)
                  );
                }
                getTerrain() {
                  return this.style ? this.style.getTerrain() : null;
                }
                setFog(t) {
                  return (
                    this._lazyInitEmptyStyle(),
                    this.style.setFog(t),
                    this._update(!0)
                  );
                }
                getFog() {
                  return this.style ? this.style.getFog() : null;
                }
                _queryFogOpacity(e) {
                  return this.style && this.style.fog
                    ? this.style.fog.getOpacityAtLatLng(
                        t.LngLat.convert(e),
                        this.transform
                      )
                    : 0;
                }
                setFeatureState(t, e) {
                  return this.style.setFeatureState(t, e), this._update();
                }
                removeFeatureState(t, e) {
                  return this.style.removeFeatureState(t, e), this._update();
                }
                getFeatureState(t) {
                  return this.style.getFeatureState(t);
                }
                _containerDimensions() {
                  let t = 0,
                    e = 0;
                  return (
                    this._container &&
                      ((t = this._container.clientWidth || 400),
                      (e = this._container.clientHeight || 300)),
                    [t, e]
                  );
                }
                _detectMissingCSS() {
                  "rgb(250, 128, 114)" !==
                    t.window
                      .getComputedStyle(this._missingCSSCanary)
                      .getPropertyValue("background-color") &&
                    t.warnOnce(
                      "This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/."
                    );
                }
                _setupContainer() {
                  const t = this._container;
                  t.classList.add("mapboxgl-map"),
                    ((this._missingCSSCanary = o.create(
                      "div",
                      "mapboxgl-canary",
                      t
                    )).style.visibility = "hidden"),
                    this._detectMissingCSS();
                  const e = (this._canvasContainer = o.create(
                    "div",
                    "mapboxgl-canvas-container",
                    t
                  ));
                  this._interactive && e.classList.add("mapboxgl-interactive"),
                    (this._canvas = o.create("canvas", "mapboxgl-canvas", e)),
                    this._canvas.addEventListener(
                      "webglcontextlost",
                      this._contextLost,
                      !1
                    ),
                    this._canvas.addEventListener(
                      "webglcontextrestored",
                      this._contextRestored,
                      !1
                    ),
                    this._canvas.setAttribute("tabindex", "0"),
                    this._canvas.setAttribute("aria-label", "Map"),
                    this._canvas.setAttribute("role", "region");
                  const n = this._containerDimensions();
                  this._resizeCanvas(n[0], n[1]);
                  const r = (this._controlContainer = o.create(
                      "div",
                      "mapboxgl-control-container",
                      t
                    )),
                    i = (this._controlPositions = {});
                  [
                    "top-left",
                    "top-right",
                    "bottom-left",
                    "bottom-right",
                  ].forEach((t) => {
                    i[t] = o.create("div", `mapboxgl-ctrl-${t}`, r);
                  }),
                    this._container.addEventListener(
                      "scroll",
                      this._onMapScroll,
                      !1
                    );
                }
                _resizeCanvas(e, n) {
                  const r = t.exported.devicePixelRatio || 1;
                  (this._canvas.width = r * e),
                    (this._canvas.height = r * n),
                    (this._canvas.style.width = `${e}px`),
                    (this._canvas.style.height = `${n}px`);
                }
                _addMarker(t) {
                  this._markers.push(t);
                }
                _removeMarker(t) {
                  const e = this._markers.indexOf(t);
                  -1 !== e && this._markers.splice(e, 1);
                }
                _setupPainter() {
                  const n = t.extend({}, e.webGLContextAttributes, {
                      failIfMajorPerformanceCaveat:
                        this._failIfMajorPerformanceCaveat,
                      preserveDrawingBuffer: this._preserveDrawingBuffer,
                      antialias: this._antialias || !1,
                    }),
                    r =
                      this._canvas.getContext("webgl", n) ||
                      this._canvas.getContext("experimental-webgl", n);
                  r
                    ? (t.storeAuthState(r, !0),
                      (this.painter = new dr(r, this.transform)),
                      this.on("data", (t) => {
                        "source" === t.dataType &&
                          this.painter.setTileLoadedFlag(!0);
                      }),
                      t.exported$1.testSupport(r))
                    : this.fire(
                        new t.ErrorEvent(
                          new Error("Failed to initialize WebGL")
                        )
                      );
                }
                _contextLost(e) {
                  e.preventDefault(),
                    this._frame && (this._frame.cancel(), (this._frame = null)),
                    this.fire(
                      new t.Event("webglcontextlost", { originalEvent: e })
                    );
                }
                _contextRestored(e) {
                  this._setupPainter(),
                    this.resize(),
                    this._update(),
                    this.fire(
                      new t.Event("webglcontextrestored", { originalEvent: e })
                    );
                }
                _onMapScroll(t) {
                  if (t.target === this._container)
                    return (
                      (this._container.scrollTop = 0),
                      (this._container.scrollLeft = 0),
                      !1
                    );
                }
                loaded() {
                  return (
                    !this._styleDirty &&
                    !this._sourcesDirty &&
                    !!this.style &&
                    this.style.loaded()
                  );
                }
                _update(t) {
                  return this.style
                    ? ((this._styleDirty = this._styleDirty || t),
                      (this._sourcesDirty = !0),
                      this.triggerRepaint(),
                      this)
                    : this;
                }
                _requestRenderFrame(t) {
                  return this._update(), this._renderTaskQueue.add(t);
                }
                _cancelRenderFrame(t) {
                  this._renderTaskQueue.remove(t);
                }
                _requestDomTask(t) {
                  !this.isMoving() && this.loaded()
                    ? t()
                    : this._domRenderTaskQueue.add(t);
                }
                _render(e) {
                  let n;
                  const r = this.painter.context.extTimerQuery,
                    i = t.exported.now();
                  this.listens("gpu-timing-frame") &&
                    ((n = r.createQueryEXT()),
                    r.beginQueryEXT(r.TIME_ELAPSED_EXT, n));
                  let o = this._updateAverageElevation(i);
                  if (
                    (this.painter.context.setDirty(),
                    this.painter.setBaseState(),
                    this._renderTaskQueue.run(e),
                    this._domRenderTaskQueue.run(e),
                    this._removed)
                  )
                    return;
                  let s = !1;
                  const a = this._isInitialLoad ? 0 : this._fadeDuration;
                  if (this.style && this._styleDirty) {
                    this._styleDirty = !1;
                    const e = this.transform.zoom,
                      n = t.exported.now();
                    this.style.zoomHistory.update(e, n);
                    const r = new t.EvaluationParameters(e, {
                        now: n,
                        fadeDuration: a,
                        zoomHistory: this.style.zoomHistory,
                        transition: this.style.getTransition(),
                      }),
                      i = r.crossFadingFactor();
                    (1 === i && i === this._crossFadingFactor) ||
                      ((s = !0), (this._crossFadingFactor = i)),
                      this.style.update(r);
                  }
                  if (
                    (this.style &&
                      this.style.fog &&
                      this.style.fog.hasTransition() &&
                      ((this.style._markersNeedUpdate = !0),
                      (this._sourcesDirty = !0)),
                    this.style &&
                      this._sourcesDirty &&
                      ((this._sourcesDirty = !1),
                      this.painter._updateFog(this.style),
                      this._updateTerrain(),
                      this.style._updateSources(this.transform)),
                    (this._placementDirty =
                      this.style &&
                      this.style._updatePlacement(
                        this.painter.transform,
                        this.showCollisionBoxes,
                        a,
                        this._crossSourceCollisions
                      )),
                    this.painter.render(this.style, {
                      showTileBoundaries: this.showTileBoundaries,
                      showTerrainWireframe: this.showTerrainWireframe,
                      showOverdrawInspector: this._showOverdrawInspector,
                      showQueryGeometry: !!this._showQueryGeometry,
                      rotating: this.isRotating(),
                      zooming: this.isZooming(),
                      moving: this.isMoving(),
                      fadeDuration: a,
                      isInitialLoad: this._isInitialLoad,
                      showPadding: this.showPadding,
                      gpuTiming: !!this.listens("gpu-timing-layer"),
                      speedIndexTiming: this.speedIndexTiming,
                    }),
                    this.fire(new t.Event("render")),
                    this.loaded() &&
                      !this._loaded &&
                      ((this._loaded = !0), this.fire(new t.Event("load"))),
                    this.style &&
                      (this.style.hasTransitions() || s) &&
                      (this._styleDirty = !0),
                    this.style &&
                      !this._placementDirty &&
                      this.style._releaseSymbolFadeTiles(),
                    this.listens("gpu-timing-frame"))
                  ) {
                    const e = t.exported.now() - i;
                    r.endQueryEXT(r.TIME_ELAPSED_EXT, n),
                      setTimeout(() => {
                        const i =
                          r.getQueryObjectEXT(n, r.QUERY_RESULT_EXT) / 1e6;
                        r.deleteQueryEXT(n),
                          this.fire(
                            new t.Event("gpu-timing-frame", {
                              cpuTime: e,
                              gpuTime: i,
                            })
                          );
                      }, 50);
                  }
                  if (this.listens("gpu-timing-layer")) {
                    const e = this.painter.collectGpuTimers();
                    setTimeout(() => {
                      const n = this.painter.queryGpuTimers(e);
                      this.fire(
                        new t.Event("gpu-timing-layer", { layerTimes: n })
                      );
                    }, 50);
                  }
                  const l =
                    this._sourcesDirty ||
                    this._styleDirty ||
                    this._placementDirty ||
                    o;
                  if (l || this._repaint) this.triggerRepaint();
                  else {
                    const e = !this.isMoving() && this.loaded();
                    if ((e && (o = this._updateAverageElevation(i, !0)), o))
                      this.triggerRepaint();
                    else if (
                      (this._triggerFrame(!1),
                      e &&
                        (this.fire(new t.Event("idle")),
                        (this._isInitialLoad = !1),
                        this.speedIndexTiming))
                    ) {
                      const e = this._calculateSpeedIndex();
                      this.fire(
                        new t.Event("speedindexcompleted", { speedIndex: e })
                      ),
                        (this.speedIndexTiming = !1);
                    }
                  }
                  return (
                    !this._loaded ||
                      this._fullyLoaded ||
                      l ||
                      ((this._fullyLoaded = !0), this._authenticate()),
                    this
                  );
                }
                _updateAverageElevation(t, e = !1) {
                  const n = (t) => (
                    (this.transform.averageElevation = t), this._update(!1), !0
                  );
                  if (!this.painter.averageElevationNeedsEasing())
                    return 0 !== this.transform.averageElevation && n(0);
                  if (
                    (e || t - this._averageElevationLastSampledAt > 500) &&
                    !this._averageElevation.isEasing(t)
                  ) {
                    const e = this.transform.averageElevation;
                    let r = this.transform.sampleAverageElevation();
                    isNaN(r)
                      ? (r = 0)
                      : (this._averageElevationLastSampledAt = t);
                    const i = Math.abs(e - r);
                    if (i > 1) {
                      if (this._isInitialLoad)
                        return this._averageElevation.jumpTo(r), n(r);
                      this._averageElevation.easeTo(r, t, 300);
                    } else if (i > 1e-4)
                      return this._averageElevation.jumpTo(r), n(r);
                  }
                  return (
                    !!this._averageElevation.isEasing(t) &&
                    n(this._averageElevation.getValue(t))
                  );
                }
                _authenticate() {
                  t.getMapSessionAPI(
                    this._getMapId(),
                    this._requestManager._skuToken,
                    this._requestManager._customAccessToken,
                    (e) => {
                      if (
                        e &&
                        (e.message === t.AUTH_ERR_MSG || 401 === e.status)
                      ) {
                        const e = this.painter.context.gl;
                        t.storeAuthState(e, !1),
                          this._logoControl instanceof wi &&
                            this._logoControl._updateLogo(),
                          e &&
                            e.clear(
                              e.DEPTH_BUFFER_BIT |
                                e.COLOR_BUFFER_BIT |
                                e.STENCIL_BUFFER_BIT
                            ),
                          this._silenceAuthErrors ||
                            this.fire(
                              new t.ErrorEvent(
                                new Error(
                                  "A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/"
                                )
                              )
                            );
                      }
                    }
                  ),
                    t.postMapLoadEvent(
                      this._getMapId(),
                      this._requestManager._skuToken,
                      this._requestManager._customAccessToken,
                      () => {}
                    );
                }
                _updateTerrain() {
                  this.painter.updateTerrain(
                    this.style,
                    this.isMoving() || this.isRotating() || this.isZooming()
                  );
                }
                _calculateSpeedIndex() {
                  const t = this.painter.canvasCopy(),
                    e = this.painter.getCanvasCopiesAndTimestamps();
                  e.timeStamps.push(performance.now());
                  const n = this.painter.context.gl,
                    r = n.createFramebuffer();
                  function i(t) {
                    n.framebufferTexture2D(
                      n.FRAMEBUFFER,
                      n.COLOR_ATTACHMENT0,
                      n.TEXTURE_2D,
                      t,
                      0
                    );
                    const e = new Uint8Array(
                      n.drawingBufferWidth * n.drawingBufferHeight * 4
                    );
                    return (
                      n.readPixels(
                        0,
                        0,
                        n.drawingBufferWidth,
                        n.drawingBufferHeight,
                        n.RGBA,
                        n.UNSIGNED_BYTE,
                        e
                      ),
                      e
                    );
                  }
                  return (
                    n.bindFramebuffer(n.FRAMEBUFFER, r),
                    this._canvasPixelComparison(
                      i(t),
                      e.canvasCopies.map(i),
                      e.timeStamps
                    )
                  );
                }
                _canvasPixelComparison(t, e, n) {
                  let r = n[1] - n[0];
                  const i = t.length / 4;
                  for (let o = 0; o < e.length; o++) {
                    const s = e[o];
                    let a = 0;
                    for (let e = 0; e < s.length; e += 4)
                      s[e] === t[e] &&
                        s[e + 1] === t[e + 1] &&
                        s[e + 2] === t[e + 2] &&
                        s[e + 3] === t[e + 3] &&
                        (a += 1);
                    r += (n[o + 2] - n[o + 1]) * (1 - a / i);
                  }
                  return r;
                }
                remove() {
                  this._hash && this._hash.remove();
                  for (const t of this._controls) t.onRemove(this);
                  (this._controls = []),
                    this._frame && (this._frame.cancel(), (this._frame = null)),
                    this._renderTaskQueue.clear(),
                    this._domRenderTaskQueue.clear(),
                    this.painter.destroy(),
                    this.handlers.destroy(),
                    delete this.handlers,
                    this.setStyle(null),
                    void 0 !== t.window &&
                      (t.window.removeEventListener(
                        "resize",
                        this._onWindowResize,
                        !1
                      ),
                      t.window.removeEventListener(
                        "orientationchange",
                        this._onWindowResize,
                        !1
                      ),
                      t.window.removeEventListener(
                        "webkitfullscreenchange",
                        this._onWindowResize,
                        !1
                      ),
                      t.window.removeEventListener(
                        "online",
                        this._onWindowOnline,
                        !1
                      ));
                  const e =
                    this.painter.context.gl.getExtension("WEBGL_lose_context");
                  e && e.loseContext(),
                    zi(this._canvasContainer),
                    zi(this._controlContainer),
                    zi(this._missingCSSCanary),
                    this._container.classList.remove("mapboxgl-map"),
                    t.removeAuthState(this.painter.context.gl),
                    (this._removed = !0),
                    this.fire(new t.Event("remove"));
                }
                triggerRepaint() {
                  this._triggerFrame(!0);
                }
                _triggerFrame(e) {
                  (this._renderNextFrame = this._renderNextFrame || e),
                    this.style &&
                      !this._frame &&
                      (this._frame = t.exported.frame((t) => {
                        const e = !!this._renderNextFrame;
                        (this._frame = null),
                          (this._renderNextFrame = null),
                          e && this._render(t);
                      }));
                }
                _onWindowOnline() {
                  this._update();
                }
                _onWindowResize(t) {
                  this._trackResize &&
                    this.resize({ originalEvent: t })._update();
                }
                get showTileBoundaries() {
                  return !!this._showTileBoundaries;
                }
                set showTileBoundaries(t) {
                  this._showTileBoundaries !== t &&
                    ((this._showTileBoundaries = t), this._update());
                }
                get showTerrainWireframe() {
                  return !!this._showTerrainWireframe;
                }
                set showTerrainWireframe(t) {
                  this._showTerrainWireframe !== t &&
                    ((this._showTerrainWireframe = t), this._update());
                }
                get speedIndexTiming() {
                  return !!this._speedIndexTiming;
                }
                set speedIndexTiming(t) {
                  this._speedIndexTiming !== t &&
                    ((this._speedIndexTiming = t), this._update());
                }
                get showPadding() {
                  return !!this._showPadding;
                }
                set showPadding(t) {
                  this._showPadding !== t &&
                    ((this._showPadding = t), this._update());
                }
                get showCollisionBoxes() {
                  return !!this._showCollisionBoxes;
                }
                set showCollisionBoxes(t) {
                  this._showCollisionBoxes !== t &&
                    ((this._showCollisionBoxes = t),
                    t ? this.style._generateCollisionBoxes() : this._update());
                }
                get showOverdrawInspector() {
                  return !!this._showOverdrawInspector;
                }
                set showOverdrawInspector(t) {
                  this._showOverdrawInspector !== t &&
                    ((this._showOverdrawInspector = t), this._update());
                }
                get repaint() {
                  return !!this._repaint;
                }
                set repaint(t) {
                  this._repaint !== t &&
                    ((this._repaint = t), this.triggerRepaint());
                }
                get vertices() {
                  return !!this._vertices;
                }
                set vertices(t) {
                  (this._vertices = t), this._update();
                }
                _setCacheLimits(e, n) {
                  t.setCacheLimits(e, n);
                }
                get version() {
                  return t.version;
                }
              },
              NavigationControl: class {
                constructor(e) {
                  (this.options = t.extend({}, Ri, e)),
                    (this._container = o.create(
                      "div",
                      "mapboxgl-ctrl mapboxgl-ctrl-group"
                    )),
                    this._container.addEventListener("contextmenu", (t) =>
                      t.preventDefault()
                    ),
                    this.options.showZoom &&
                      (t.bindAll(
                        ["_setButtonTitle", "_updateZoomButtons"],
                        this
                      ),
                      (this._zoomInButton = this._createButton(
                        "mapboxgl-ctrl-zoom-in",
                        (t) => this._map.zoomIn({}, { originalEvent: t })
                      )),
                      o
                        .create(
                          "span",
                          "mapboxgl-ctrl-icon",
                          this._zoomInButton
                        )
                        .setAttribute("aria-hidden", !0),
                      (this._zoomOutButton = this._createButton(
                        "mapboxgl-ctrl-zoom-out",
                        (t) => this._map.zoomOut({}, { originalEvent: t })
                      )),
                      o
                        .create(
                          "span",
                          "mapboxgl-ctrl-icon",
                          this._zoomOutButton
                        )
                        .setAttribute("aria-hidden", !0)),
                    this.options.showCompass &&
                      (t.bindAll(["_rotateCompassArrow"], this),
                      (this._compass = this._createButton(
                        "mapboxgl-ctrl-compass",
                        (t) => {
                          this.options.visualizePitch
                            ? this._map.resetNorthPitch(
                                {},
                                { originalEvent: t }
                              )
                            : this._map.resetNorth({}, { originalEvent: t });
                        }
                      )),
                      (this._compassIcon = o.create(
                        "span",
                        "mapboxgl-ctrl-icon",
                        this._compass
                      )),
                      this._compassIcon.setAttribute("aria-hidden", !0));
                }
                _updateZoomButtons() {
                  const t = this._map.getZoom(),
                    e = t === this._map.getMaxZoom(),
                    n = t === this._map.getMinZoom();
                  (this._zoomInButton.disabled = e),
                    (this._zoomOutButton.disabled = n),
                    this._zoomInButton.setAttribute(
                      "aria-disabled",
                      e.toString()
                    ),
                    this._zoomOutButton.setAttribute(
                      "aria-disabled",
                      n.toString()
                    );
                }
                _rotateCompassArrow() {
                  const t = this.options.visualizePitch
                    ? `scale(${
                        1 /
                        Math.pow(
                          Math.cos(this._map.transform.pitch * (Math.PI / 180)),
                          0.5
                        )
                      }) rotateX(${this._map.transform.pitch}deg) rotateZ(${
                        this._map.transform.angle * (180 / Math.PI)
                      }deg)`
                    : `rotate(${
                        this._map.transform.angle * (180 / Math.PI)
                      }deg)`;
                  this._map._requestDomTask(() => {
                    this._compassIcon &&
                      (this._compassIcon.style.transform = t);
                  });
                }
                onAdd(t) {
                  return (
                    (this._map = t),
                    this.options.showZoom &&
                      (this._setButtonTitle(this._zoomInButton, "ZoomIn"),
                      this._setButtonTitle(this._zoomOutButton, "ZoomOut"),
                      this._map.on("zoom", this._updateZoomButtons),
                      this._updateZoomButtons()),
                    this.options.showCompass &&
                      (this._setButtonTitle(this._compass, "ResetBearing"),
                      this.options.visualizePitch &&
                        this._map.on("pitch", this._rotateCompassArrow),
                      this._map.on("rotate", this._rotateCompassArrow),
                      this._rotateCompassArrow(),
                      (this._handler = new Li(
                        this._map,
                        this._compass,
                        this.options.visualizePitch
                      ))),
                    this._container
                  );
                }
                onRemove() {
                  o.remove(this._container),
                    this.options.showZoom &&
                      this._map.off("zoom", this._updateZoomButtons),
                    this.options.showCompass &&
                      (this.options.visualizePitch &&
                        this._map.off("pitch", this._rotateCompassArrow),
                      this._map.off("rotate", this._rotateCompassArrow),
                      this._handler.off(),
                      delete this._handler),
                    delete this._map;
                }
                _createButton(t, e) {
                  const n = o.create("button", t, this._container);
                  return (n.type = "button"), n.addEventListener("click", e), n;
                }
                _setButtonTitle(t, e) {
                  const n = this._map._getUIString(`NavigationControl.${e}`);
                  (t.title = n), t.setAttribute("aria-label", n);
                }
              },
              GeolocateControl: class extends t.Evented {
                constructor(e) {
                  super(),
                    (this.options = t.extend({}, Fi, e)),
                    t.bindAll(
                      [
                        "_onSuccess",
                        "_onError",
                        "_onZoom",
                        "_finish",
                        "_setupUI",
                        "_updateCamera",
                        "_updateMarker",
                        "_updateMarkerRotation",
                      ],
                      this
                    ),
                    (this._onDeviceOrientationListener =
                      this._onDeviceOrientation.bind(this)),
                    (this._updateMarkerRotationThrottled = Er(
                      this._updateMarkerRotation,
                      20
                    ));
                }
                onAdd(e) {
                  var n;
                  return (
                    (this._map = e),
                    (this._container = o.create(
                      "div",
                      "mapboxgl-ctrl mapboxgl-ctrl-group"
                    )),
                    (n = this._setupUI),
                    void 0 !== Bi
                      ? n(Bi)
                      : void 0 !== t.window.navigator.permissions
                      ? t.window.navigator.permissions
                          .query({ name: "geolocation" })
                          .then((t) => {
                            (Bi = "denied" !== t.state), n(Bi);
                          })
                      : ((Bi = !!t.window.navigator.geolocation), n(Bi)),
                    this._container
                  );
                }
                onRemove() {
                  void 0 !== this._geolocationWatchID &&
                    (t.window.navigator.geolocation.clearWatch(
                      this._geolocationWatchID
                    ),
                    (this._geolocationWatchID = void 0)),
                    this.options.showUserLocation &&
                      this._userLocationDotMarker &&
                      this._userLocationDotMarker.remove(),
                    this.options.showAccuracyCircle &&
                      this._accuracyCircleMarker &&
                      this._accuracyCircleMarker.remove(),
                    o.remove(this._container),
                    this._map.off("zoom", this._onZoom),
                    (this._map = void 0),
                    (Ni = 0),
                    (ji = !1);
                }
                _isOutOfMapMaxBounds(t) {
                  const e = this._map.getMaxBounds(),
                    n = t.coords;
                  return (
                    e &&
                    (n.longitude < e.getWest() ||
                      n.longitude > e.getEast() ||
                      n.latitude < e.getSouth() ||
                      n.latitude > e.getNorth())
                  );
                }
                _setErrorState() {
                  switch (this._watchState) {
                    case "WAITING_ACTIVE":
                      (this._watchState = "ACTIVE_ERROR"),
                        this._geolocateButton.classList.remove(
                          "mapboxgl-ctrl-geolocate-active"
                        ),
                        this._geolocateButton.classList.add(
                          "mapboxgl-ctrl-geolocate-active-error"
                        );
                      break;
                    case "ACTIVE_LOCK":
                      (this._watchState = "ACTIVE_ERROR"),
                        this._geolocateButton.classList.remove(
                          "mapboxgl-ctrl-geolocate-active"
                        ),
                        this._geolocateButton.classList.add(
                          "mapboxgl-ctrl-geolocate-active-error"
                        ),
                        this._geolocateButton.classList.add(
                          "mapboxgl-ctrl-geolocate-waiting"
                        );
                      break;
                    case "BACKGROUND":
                      (this._watchState = "BACKGROUND_ERROR"),
                        this._geolocateButton.classList.remove(
                          "mapboxgl-ctrl-geolocate-background"
                        ),
                        this._geolocateButton.classList.add(
                          "mapboxgl-ctrl-geolocate-background-error"
                        ),
                        this._geolocateButton.classList.add(
                          "mapboxgl-ctrl-geolocate-waiting"
                        );
                  }
                }
                _onSuccess(e) {
                  if (this._map) {
                    if (this._isOutOfMapMaxBounds(e))
                      return (
                        this._setErrorState(),
                        this.fire(new t.Event("outofmaxbounds", e)),
                        this._updateMarker(),
                        void this._finish()
                      );
                    if (this.options.trackUserLocation)
                      switch (
                        ((this._lastKnownPosition = e), this._watchState)
                      ) {
                        case "WAITING_ACTIVE":
                        case "ACTIVE_LOCK":
                        case "ACTIVE_ERROR":
                          (this._watchState = "ACTIVE_LOCK"),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-waiting"
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-active-error"
                            ),
                            this._geolocateButton.classList.add(
                              "mapboxgl-ctrl-geolocate-active"
                            );
                          break;
                        case "BACKGROUND":
                        case "BACKGROUND_ERROR":
                          (this._watchState = "BACKGROUND"),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-waiting"
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-background-error"
                            ),
                            this._geolocateButton.classList.add(
                              "mapboxgl-ctrl-geolocate-background"
                            );
                      }
                    this.options.showUserLocation &&
                      "OFF" !== this._watchState &&
                      this._updateMarker(e),
                      (this.options.trackUserLocation &&
                        "ACTIVE_LOCK" !== this._watchState) ||
                        this._updateCamera(e),
                      this.options.showUserLocation &&
                        this._dotElement.classList.remove(
                          "mapboxgl-user-location-dot-stale"
                        ),
                      this.fire(new t.Event("geolocate", e)),
                      this._finish();
                  }
                }
                _updateCamera(e) {
                  const n = new t.LngLat(e.coords.longitude, e.coords.latitude),
                    r = e.coords.accuracy,
                    i = this._map.getBearing(),
                    o = t.extend({ bearing: i }, this.options.fitBoundsOptions);
                  this._map.fitBounds(n.toBounds(r), o, {
                    geolocateSource: !0,
                  });
                }
                _updateMarker(e) {
                  if (e) {
                    const n = new t.LngLat(
                      e.coords.longitude,
                      e.coords.latitude
                    );
                    this._accuracyCircleMarker.setLngLat(n).addTo(this._map),
                      this._userLocationDotMarker.setLngLat(n).addTo(this._map),
                      (this._accuracy = e.coords.accuracy),
                      this.options.showUserLocation &&
                        this.options.showAccuracyCircle &&
                        this._updateCircleRadius();
                  } else
                    this._userLocationDotMarker.remove(),
                      this._accuracyCircleMarker.remove();
                }
                _updateCircleRadius() {
                  const t = this._map._container.clientHeight / 2,
                    e = this._map.unproject([0, t]),
                    n = this._map.unproject([100, t]),
                    r = e.distanceTo(n) / 100,
                    i = Math.ceil((2 * this._accuracy) / r);
                  (this._circleElement.style.width = `${i}px`),
                    (this._circleElement.style.height = `${i}px`);
                }
                _onZoom() {
                  this.options.showUserLocation &&
                    this.options.showAccuracyCircle &&
                    this._updateCircleRadius();
                }
                _updateMarkerRotation() {
                  this._userLocationDotMarker &&
                  "number" == typeof this._heading
                    ? (this._userLocationDotMarker.setRotation(this._heading),
                      this._dotElement.classList.add(
                        "mapboxgl-user-location-show-heading"
                      ))
                    : (this._dotElement.classList.remove(
                        "mapboxgl-user-location-show-heading"
                      ),
                      this._userLocationDotMarker.setRotation(0));
                }
                _onError(e) {
                  if (this._map) {
                    if (this.options.trackUserLocation)
                      if (1 === e.code) {
                        (this._watchState = "OFF"),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-waiting"
                          ),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-active"
                          ),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-active-error"
                          ),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-background"
                          ),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-background-error"
                          ),
                          (this._geolocateButton.disabled = !0);
                        const t = this._map._getUIString(
                          "GeolocateControl.LocationNotAvailable"
                        );
                        (this._geolocateButton.title = t),
                          this._geolocateButton.setAttribute("aria-label", t),
                          void 0 !== this._geolocationWatchID &&
                            this._clearWatch();
                      } else {
                        if (3 === e.code && ji) return;
                        this._setErrorState();
                      }
                    "OFF" !== this._watchState &&
                      this.options.showUserLocation &&
                      this._dotElement.classList.add(
                        "mapboxgl-user-location-dot-stale"
                      ),
                      this.fire(new t.Event("error", e)),
                      this._finish();
                  }
                }
                _finish() {
                  this._timeoutId && clearTimeout(this._timeoutId),
                    (this._timeoutId = void 0);
                }
                _setupUI(e) {
                  if (
                    (this._container.addEventListener("contextmenu", (t) =>
                      t.preventDefault()
                    ),
                    (this._geolocateButton = o.create(
                      "button",
                      "mapboxgl-ctrl-geolocate",
                      this._container
                    )),
                    o
                      .create(
                        "span",
                        "mapboxgl-ctrl-icon",
                        this._geolocateButton
                      )
                      .setAttribute("aria-hidden", !0),
                    (this._geolocateButton.type = "button"),
                    !1 === e)
                  ) {
                    t.warnOnce(
                      "Geolocation support is not available so the GeolocateControl will be disabled."
                    );
                    const e = this._map._getUIString(
                      "GeolocateControl.LocationNotAvailable"
                    );
                    (this._geolocateButton.disabled = !0),
                      (this._geolocateButton.title = e),
                      this._geolocateButton.setAttribute("aria-label", e);
                  } else {
                    const t = this._map._getUIString(
                      "GeolocateControl.FindMyLocation"
                    );
                    (this._geolocateButton.title = t),
                      this._geolocateButton.setAttribute("aria-label", t);
                  }
                  this.options.trackUserLocation &&
                    (this._geolocateButton.setAttribute(
                      "aria-pressed",
                      "false"
                    ),
                    (this._watchState = "OFF")),
                    this.options.showUserLocation &&
                      ((this._dotElement = o.create(
                        "div",
                        "mapboxgl-user-location"
                      )),
                      this._dotElement.appendChild(
                        o.create("div", "mapboxgl-user-location-dot")
                      ),
                      this._dotElement.appendChild(
                        o.create("div", "mapboxgl-user-location-heading")
                      ),
                      (this._userLocationDotMarker = new Ci({
                        element: this._dotElement,
                        rotationAlignment: "map",
                        pitchAlignment: "map",
                      })),
                      (this._circleElement = o.create(
                        "div",
                        "mapboxgl-user-location-accuracy-circle"
                      )),
                      (this._accuracyCircleMarker = new Ci({
                        element: this._circleElement,
                        pitchAlignment: "map",
                      })),
                      this.options.trackUserLocation &&
                        (this._watchState = "OFF"),
                      this._map.on("zoom", this._onZoom)),
                    this._geolocateButton.addEventListener(
                      "click",
                      this.trigger.bind(this)
                    ),
                    (this._setup = !0),
                    this.options.trackUserLocation &&
                      this._map.on("movestart", (e) => {
                        e.geolocateSource ||
                          "ACTIVE_LOCK" !== this._watchState ||
                          (e.originalEvent &&
                            "resize" === e.originalEvent.type) ||
                          ((this._watchState = "BACKGROUND"),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-background"
                          ),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-active"
                          ),
                          this.fire(new t.Event("trackuserlocationend")));
                      });
                }
                _onDeviceOrientation(t) {
                  this._userLocationDotMarker &&
                    (t.webkitCompassHeading
                      ? (this._heading = t.webkitCompassHeading)
                      : !0 === t.absolute && (this._heading = -1 * t.alpha),
                    this._updateMarkerRotationThrottled());
                }
                trigger() {
                  if (!this._setup)
                    return (
                      t.warnOnce(
                        "Geolocate control triggered before added to a map"
                      ),
                      !1
                    );
                  if (this.options.trackUserLocation) {
                    switch (this._watchState) {
                      case "OFF":
                        (this._watchState = "WAITING_ACTIVE"),
                          this.fire(new t.Event("trackuserlocationstart"));
                        break;
                      case "WAITING_ACTIVE":
                      case "ACTIVE_LOCK":
                      case "ACTIVE_ERROR":
                      case "BACKGROUND_ERROR":
                        Ni--,
                          (ji = !1),
                          (this._watchState = "OFF"),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-waiting"
                          ),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-active"
                          ),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-active-error"
                          ),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-background"
                          ),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-background-error"
                          ),
                          this.fire(new t.Event("trackuserlocationend"));
                        break;
                      case "BACKGROUND":
                        (this._watchState = "ACTIVE_LOCK"),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-background"
                          ),
                          this._lastKnownPosition &&
                            this._updateCamera(this._lastKnownPosition),
                          this.fire(new t.Event("trackuserlocationstart"));
                    }
                    switch (this._watchState) {
                      case "WAITING_ACTIVE":
                        this._geolocateButton.classList.add(
                          "mapboxgl-ctrl-geolocate-waiting"
                        ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-active"
                          );
                        break;
                      case "ACTIVE_LOCK":
                        this._geolocateButton.classList.add(
                          "mapboxgl-ctrl-geolocate-active"
                        );
                        break;
                      case "ACTIVE_ERROR":
                        this._geolocateButton.classList.add(
                          "mapboxgl-ctrl-geolocate-waiting"
                        ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-active-error"
                          );
                        break;
                      case "BACKGROUND":
                        this._geolocateButton.classList.add(
                          "mapboxgl-ctrl-geolocate-background"
                        );
                        break;
                      case "BACKGROUND_ERROR":
                        this._geolocateButton.classList.add(
                          "mapboxgl-ctrl-geolocate-waiting"
                        ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-background-error"
                          );
                    }
                    if (
                      "OFF" === this._watchState &&
                      void 0 !== this._geolocationWatchID
                    )
                      this._clearWatch();
                    else if (void 0 === this._geolocationWatchID) {
                      let e;
                      this._geolocateButton.classList.add(
                        "mapboxgl-ctrl-geolocate-waiting"
                      ),
                        this._geolocateButton.setAttribute(
                          "aria-pressed",
                          "true"
                        ),
                        Ni++,
                        Ni > 1
                          ? ((e = { maximumAge: 6e5, timeout: 0 }), (ji = !0))
                          : ((e = this.options.positionOptions), (ji = !1)),
                        (this._geolocationWatchID =
                          t.window.navigator.geolocation.watchPosition(
                            this._onSuccess,
                            this._onError,
                            e
                          )),
                        this.options.showUserHeading &&
                          this._addDeviceOrientationListener();
                    }
                  } else
                    t.window.navigator.geolocation.getCurrentPosition(
                      this._onSuccess,
                      this._onError,
                      this.options.positionOptions
                    ),
                      (this._timeoutId = setTimeout(this._finish, 1e4));
                  return !0;
                }
                _addDeviceOrientationListener() {
                  const e = () => {
                    t.window.addEventListener(
                      "ondeviceorientationabsolute" in t.window
                        ? "deviceorientationabsolute"
                        : "deviceorientation",
                      this._onDeviceOrientationListener
                    );
                  };
                  void 0 !== t.window.DeviceMotionEvent &&
                  "function" ==
                    typeof t.window.DeviceMotionEvent.requestPermission
                    ? DeviceOrientationEvent.requestPermission()
                        .then((t) => {
                          "granted" === t && e();
                        })
                        .catch(console.error)
                    : e();
                }
                _clearWatch() {
                  t.window.navigator.geolocation.clearWatch(
                    this._geolocationWatchID
                  ),
                    t.window.removeEventListener(
                      "deviceorientation",
                      this._onDeviceOrientationListener
                    ),
                    t.window.removeEventListener(
                      "deviceorientationabsolute",
                      this._onDeviceOrientationListener
                    ),
                    (this._geolocationWatchID = void 0),
                    this._geolocateButton.classList.remove(
                      "mapboxgl-ctrl-geolocate-waiting"
                    ),
                    this._geolocateButton.setAttribute("aria-pressed", "false"),
                    this.options.showUserLocation && this._updateMarker(null);
                }
              },
              AttributionControl: xi,
              ScaleControl: class {
                constructor(e) {
                  (this.options = t.extend({}, Ui, e)),
                    t.bindAll(["_onMove", "setUnit"], this);
                }
                getDefaultPosition() {
                  return "bottom-left";
                }
                _onMove() {
                  Zi(this._map, this._container, this.options);
                }
                onAdd(t) {
                  return (
                    (this._map = t),
                    (this._container = o.create(
                      "div",
                      "mapboxgl-ctrl mapboxgl-ctrl-scale",
                      t.getContainer()
                    )),
                    this._map.on("move", this._onMove),
                    this._onMove(),
                    this._container
                  );
                }
                onRemove() {
                  o.remove(this._container),
                    this._map.off("move", this._onMove),
                    (this._map = void 0);
                }
                setUnit(t) {
                  (this.options.unit = t),
                    Zi(this._map, this._container, this.options);
                }
              },
              FullscreenControl: class {
                constructor(e) {
                  (this._fullscreen = !1),
                    e &&
                      e.container &&
                      (e.container instanceof t.window.HTMLElement
                        ? (this._container = e.container)
                        : t.warnOnce(
                            "Full screen control 'container' must be a DOM element."
                          )),
                    t.bindAll(["_onClickFullscreen", "_changeIcon"], this),
                    "onfullscreenchange" in t.window.document
                      ? (this._fullscreenchange = "fullscreenchange")
                      : "onwebkitfullscreenchange" in t.window.document &&
                        (this._fullscreenchange = "webkitfullscreenchange");
                }
                onAdd(e) {
                  return (
                    (this._map = e),
                    this._container ||
                      (this._container = this._map.getContainer()),
                    (this._controlContainer = o.create(
                      "div",
                      "mapboxgl-ctrl mapboxgl-ctrl-group"
                    )),
                    this._checkFullscreenSupport()
                      ? this._setupUI()
                      : ((this._controlContainer.style.display = "none"),
                        t.warnOnce(
                          "This device does not support fullscreen mode."
                        )),
                    this._controlContainer
                  );
                }
                onRemove() {
                  o.remove(this._controlContainer),
                    (this._map = null),
                    t.window.document.removeEventListener(
                      this._fullscreenchange,
                      this._changeIcon
                    );
                }
                _checkFullscreenSupport() {
                  return !(
                    !t.window.document.fullscreenEnabled &&
                    !t.window.document.webkitFullscreenEnabled
                  );
                }
                _setupUI() {
                  const e = (this._fullscreenButton = o.create(
                    "button",
                    "mapboxgl-ctrl-fullscreen",
                    this._controlContainer
                  ));
                  o
                    .create("span", "mapboxgl-ctrl-icon", e)
                    .setAttribute("aria-hidden", !0),
                    (e.type = "button"),
                    this._updateTitle(),
                    this._fullscreenButton.addEventListener(
                      "click",
                      this._onClickFullscreen
                    ),
                    t.window.document.addEventListener(
                      this._fullscreenchange,
                      this._changeIcon
                    );
                }
                _updateTitle() {
                  const t = this._getTitle();
                  this._fullscreenButton.setAttribute("aria-label", t),
                    (this._fullscreenButton.title = t);
                }
                _getTitle() {
                  return this._map._getUIString(
                    this._isFullscreen()
                      ? "FullscreenControl.Exit"
                      : "FullscreenControl.Enter"
                  );
                }
                _isFullscreen() {
                  return this._fullscreen;
                }
                _changeIcon() {
                  ((t.window.document.fullscreenElement ||
                    t.window.document.webkitFullscreenElement) ===
                    this._container) !==
                    this._fullscreen &&
                    ((this._fullscreen = !this._fullscreen),
                    this._fullscreenButton.classList.toggle(
                      "mapboxgl-ctrl-shrink"
                    ),
                    this._fullscreenButton.classList.toggle(
                      "mapboxgl-ctrl-fullscreen"
                    ),
                    this._updateTitle());
                }
                _onClickFullscreen() {
                  this._isFullscreen()
                    ? t.window.document.exitFullscreen
                      ? t.window.document.exitFullscreen()
                      : t.window.document.webkitCancelFullScreen &&
                        t.window.document.webkitCancelFullScreen()
                    : this._container.requestFullscreen
                    ? this._container.requestFullscreen()
                    : this._container.webkitRequestFullscreen &&
                      this._container.webkitRequestFullscreen();
                }
              },
              Popup: class extends t.Evented {
                constructor(e) {
                  super(),
                    (this.options = t.extend(Object.create(qi), e)),
                    t.bindAll(
                      [
                        "_update",
                        "_onClose",
                        "remove",
                        "_onMouseMove",
                        "_onMouseUp",
                        "_onDrag",
                      ],
                      this
                    );
                }
                addTo(e) {
                  return (
                    this._map && this.remove(),
                    (this._map = e),
                    this.options.closeOnClick &&
                      this._map.on("click", this._onClose),
                    this.options.closeOnMove &&
                      this._map.on("move", this._onClose),
                    this._map.on("remove", this.remove),
                    this._update(),
                    this._focusFirstElement(),
                    this._trackPointer
                      ? (this._map.on("mousemove", this._onMouseMove),
                        this._map.on("mouseup", this._onMouseUp),
                        this._container &&
                          this._container.classList.add(
                            "mapboxgl-popup-track-pointer"
                          ),
                        this._map._canvasContainer.classList.add(
                          "mapboxgl-track-pointer"
                        ))
                      : this._map.on("move", this._update),
                    this.fire(new t.Event("open")),
                    this
                  );
                }
                isOpen() {
                  return !!this._map;
                }
                remove() {
                  return (
                    this._content && o.remove(this._content),
                    this._container &&
                      (o.remove(this._container), delete this._container),
                    this._map &&
                      (this._map.off("move", this._update),
                      this._map.off("move", this._onClose),
                      this._map.off("click", this._onClose),
                      this._map.off("remove", this.remove),
                      this._map.off("mousemove", this._onMouseMove),
                      this._map.off("mouseup", this._onMouseUp),
                      this._map.off("drag", this._onDrag),
                      delete this._map),
                    this.fire(new t.Event("close")),
                    this
                  );
                }
                getLngLat() {
                  return this._lngLat;
                }
                setLngLat(e) {
                  return (
                    (this._lngLat = t.LngLat.convert(e)),
                    (this._pos = null),
                    (this._trackPointer = !1),
                    this._update(),
                    this._map &&
                      (this._map.on("move", this._update),
                      this._map.off("mousemove", this._onMouseMove),
                      this._container &&
                        this._container.classList.remove(
                          "mapboxgl-popup-track-pointer"
                        ),
                      this._map._canvasContainer.classList.remove(
                        "mapboxgl-track-pointer"
                      )),
                    this
                  );
                }
                trackPointer() {
                  return (
                    (this._trackPointer = !0),
                    (this._pos = null),
                    this._update(),
                    this._map &&
                      (this._map.off("move", this._update),
                      this._map.on("mousemove", this._onMouseMove),
                      this._map.on("drag", this._onDrag),
                      this._container &&
                        this._container.classList.add(
                          "mapboxgl-popup-track-pointer"
                        ),
                      this._map._canvasContainer.classList.add(
                        "mapboxgl-track-pointer"
                      )),
                    this
                  );
                }
                getElement() {
                  return this._container;
                }
                setText(e) {
                  return this.setDOMContent(
                    t.window.document.createTextNode(e)
                  );
                }
                setHTML(e) {
                  const n = t.window.document.createDocumentFragment(),
                    r = t.window.document.createElement("body");
                  let i;
                  for (r.innerHTML = e; (i = r.firstChild), i; )
                    n.appendChild(i);
                  return this.setDOMContent(n);
                }
                getMaxWidth() {
                  return this._container && this._container.style.maxWidth;
                }
                setMaxWidth(t) {
                  return (this.options.maxWidth = t), this._update(), this;
                }
                setDOMContent(t) {
                  if (this._content)
                    for (; this._content.hasChildNodes(); )
                      this._content.firstChild &&
                        this._content.removeChild(this._content.firstChild);
                  else
                    this._content = o.create(
                      "div",
                      "mapboxgl-popup-content",
                      this._container
                    );
                  return (
                    this._content.appendChild(t),
                    this._createCloseButton(),
                    this._update(),
                    this._focusFirstElement(),
                    this
                  );
                }
                addClassName(t) {
                  this._container && this._container.classList.add(t);
                }
                removeClassName(t) {
                  this._container && this._container.classList.remove(t);
                }
                setOffset(t) {
                  return (this.options.offset = t), this._update(), this;
                }
                toggleClassName(t) {
                  if (this._container)
                    return this._container.classList.toggle(t);
                }
                _createCloseButton() {
                  this.options.closeButton &&
                    ((this._closeButton = o.create(
                      "button",
                      "mapboxgl-popup-close-button",
                      this._content
                    )),
                    (this._closeButton.type = "button"),
                    this._closeButton.setAttribute("aria-label", "Close popup"),
                    (this._closeButton.innerHTML = "&#215;"),
                    this._closeButton.addEventListener("click", this._onClose));
                }
                _onMouseUp(t) {
                  this._update(t.point);
                }
                _onMouseMove(t) {
                  this._update(t.point);
                }
                _onDrag(t) {
                  this._update(t.point);
                }
                _update(t) {
                  if (
                    !this._map ||
                    (!this._lngLat && !this._trackPointer) ||
                    !this._content
                  )
                    return;
                  if (
                    (this._container ||
                      ((this._container = o.create(
                        "div",
                        "mapboxgl-popup",
                        this._map.getContainer()
                      )),
                      (this._tip = o.create(
                        "div",
                        "mapboxgl-popup-tip",
                        this._container
                      )),
                      this._container.appendChild(this._content),
                      this.options.className &&
                        this.options.className
                          .split(" ")
                          .forEach((t) => this._container.classList.add(t)),
                      this._trackPointer &&
                        this._container.classList.add(
                          "mapboxgl-popup-track-pointer"
                        )),
                    this.options.maxWidth &&
                      this._container.style.maxWidth !==
                        this.options.maxWidth &&
                      (this._container.style.maxWidth = this.options.maxWidth),
                    this._map.transform.renderWorldCopies &&
                      !this._trackPointer &&
                      (this._lngLat = Ei(
                        this._lngLat,
                        this._pos,
                        this._map.transform
                      )),
                    this._trackPointer && !t)
                  )
                    return;
                  const e = (this._pos =
                    this._trackPointer && t
                      ? t
                      : this._map.project(this._lngLat));
                  let n = this.options.anchor;
                  const r = Gi(this.options.offset);
                  if (!n) {
                    const t = this._container.offsetWidth,
                      i = this._container.offsetHeight;
                    let o;
                    (o =
                      e.y + r.bottom.y < i
                        ? ["top"]
                        : e.y > this._map.transform.height - i
                        ? ["bottom"]
                        : []),
                      e.x < t / 2
                        ? o.push("left")
                        : e.x > this._map.transform.width - t / 2 &&
                          o.push("right"),
                      (n = 0 === o.length ? "bottom" : o.join("-"));
                  }
                  const i = e.add(r[n]).round();
                  this._map._requestDomTask(() => {
                    this._container &&
                      n &&
                      (o.setTransform(
                        this._container,
                        `${Ti[n]} translate(${i.x}px,${i.y}px)`
                      ),
                      Ai(this._container, n, "popup"));
                  });
                }
                _focusFirstElement() {
                  if (!this.options.focusAfterOpen || !this._container) return;
                  const t = this._container.querySelector($i);
                  t && t.focus();
                }
                _onClose() {
                  this.remove();
                }
                _setOpacity(t) {
                  this._content && (this._content.style.opacity = t),
                    this._tip && (this._tip.style.opacity = t);
                }
              },
              Marker: Ci,
              Style: Ze,
              LngLat: t.LngLat,
              LngLatBounds: t.LngLatBounds,
              Point: t.pointGeometry,
              MercatorCoordinate: t.MercatorCoordinate,
              FreeCameraOptions: xr,
              Evented: t.Evented,
              config: t.config,
              prewarm: function () {
                Rt().acquire(It);
              },
              clearPrewarmedResources: function () {
                const t = zt;
                t &&
                  (t.isPreloaded() && 1 === t.numActive()
                    ? (t.release(It), (zt = null))
                    : console.warn(
                        "Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"
                      ));
              },
              get accessToken() {
                return t.config.ACCESS_TOKEN;
              },
              set accessToken(e) {
                t.config.ACCESS_TOKEN = e;
              },
              get baseApiUrl() {
                return t.config.API_URL;
              },
              set baseApiUrl(e) {
                t.config.API_URL = e;
              },
              get workerCount() {
                return Dt.workerCount;
              },
              set workerCount(t) {
                Dt.workerCount = t;
              },
              get maxParallelImageRequests() {
                return t.config.MAX_PARALLEL_IMAGE_REQUESTS;
              },
              set maxParallelImageRequests(e) {
                t.config.MAX_PARALLEL_IMAGE_REQUESTS = e;
              },
              clearStorage(e) {
                t.clearTileCache(e);
              },
              workerUrl: "",
              workerClass: null,
              setNow: t.exported.setNow,
              restoreNow: t.exported.restoreNow,
            };
            return Wi;
          }),
          n
        );
      })();
    },
    2568: function (t, e, n) {
      !(function () {
        var e = n(71012),
          r = n(40487).utf8,
          i = n(48738),
          o = n(40487).bin,
          s = function (t, n) {
            t.constructor == String
              ? (t =
                  n && "binary" === n.encoding
                    ? o.stringToBytes(t)
                    : r.stringToBytes(t))
              : i(t)
              ? (t = Array.prototype.slice.call(t, 0))
              : Array.isArray(t) ||
                t.constructor === Uint8Array ||
                (t = t.toString());
            for (
              var a = e.bytesToWords(t),
                l = 8 * t.length,
                c = 1732584193,
                u = -271733879,
                h = -1732584194,
                p = 271733878,
                d = 0;
              d < a.length;
              d++
            )
              a[d] =
                (16711935 & ((a[d] << 8) | (a[d] >>> 24))) |
                (4278255360 & ((a[d] << 24) | (a[d] >>> 8)));
            (a[l >>> 5] |= 128 << l % 32),
              (a[14 + (((l + 64) >>> 9) << 4)] = l);
            var f = s._ff,
              m = s._gg,
              g = s._hh,
              y = s._ii;
            for (d = 0; d < a.length; d += 16) {
              var _ = c,
                v = u,
                b = h,
                x = p;
              (c = f(c, u, h, p, a[d + 0], 7, -680876936)),
                (p = f(p, c, u, h, a[d + 1], 12, -389564586)),
                (h = f(h, p, c, u, a[d + 2], 17, 606105819)),
                (u = f(u, h, p, c, a[d + 3], 22, -1044525330)),
                (c = f(c, u, h, p, a[d + 4], 7, -176418897)),
                (p = f(p, c, u, h, a[d + 5], 12, 1200080426)),
                (h = f(h, p, c, u, a[d + 6], 17, -1473231341)),
                (u = f(u, h, p, c, a[d + 7], 22, -45705983)),
                (c = f(c, u, h, p, a[d + 8], 7, 1770035416)),
                (p = f(p, c, u, h, a[d + 9], 12, -1958414417)),
                (h = f(h, p, c, u, a[d + 10], 17, -42063)),
                (u = f(u, h, p, c, a[d + 11], 22, -1990404162)),
                (c = f(c, u, h, p, a[d + 12], 7, 1804603682)),
                (p = f(p, c, u, h, a[d + 13], 12, -40341101)),
                (h = f(h, p, c, u, a[d + 14], 17, -1502002290)),
                (c = m(
                  c,
                  (u = f(u, h, p, c, a[d + 15], 22, 1236535329)),
                  h,
                  p,
                  a[d + 1],
                  5,
                  -165796510
                )),
                (p = m(p, c, u, h, a[d + 6], 9, -1069501632)),
                (h = m(h, p, c, u, a[d + 11], 14, 643717713)),
                (u = m(u, h, p, c, a[d + 0], 20, -373897302)),
                (c = m(c, u, h, p, a[d + 5], 5, -701558691)),
                (p = m(p, c, u, h, a[d + 10], 9, 38016083)),
                (h = m(h, p, c, u, a[d + 15], 14, -660478335)),
                (u = m(u, h, p, c, a[d + 4], 20, -405537848)),
                (c = m(c, u, h, p, a[d + 9], 5, 568446438)),
                (p = m(p, c, u, h, a[d + 14], 9, -1019803690)),
                (h = m(h, p, c, u, a[d + 3], 14, -187363961)),
                (u = m(u, h, p, c, a[d + 8], 20, 1163531501)),
                (c = m(c, u, h, p, a[d + 13], 5, -1444681467)),
                (p = m(p, c, u, h, a[d + 2], 9, -51403784)),
                (h = m(h, p, c, u, a[d + 7], 14, 1735328473)),
                (c = g(
                  c,
                  (u = m(u, h, p, c, a[d + 12], 20, -1926607734)),
                  h,
                  p,
                  a[d + 5],
                  4,
                  -378558
                )),
                (p = g(p, c, u, h, a[d + 8], 11, -2022574463)),
                (h = g(h, p, c, u, a[d + 11], 16, 1839030562)),
                (u = g(u, h, p, c, a[d + 14], 23, -35309556)),
                (c = g(c, u, h, p, a[d + 1], 4, -1530992060)),
                (p = g(p, c, u, h, a[d + 4], 11, 1272893353)),
                (h = g(h, p, c, u, a[d + 7], 16, -155497632)),
                (u = g(u, h, p, c, a[d + 10], 23, -1094730640)),
                (c = g(c, u, h, p, a[d + 13], 4, 681279174)),
                (p = g(p, c, u, h, a[d + 0], 11, -358537222)),
                (h = g(h, p, c, u, a[d + 3], 16, -722521979)),
                (u = g(u, h, p, c, a[d + 6], 23, 76029189)),
                (c = g(c, u, h, p, a[d + 9], 4, -640364487)),
                (p = g(p, c, u, h, a[d + 12], 11, -421815835)),
                (h = g(h, p, c, u, a[d + 15], 16, 530742520)),
                (c = y(
                  c,
                  (u = g(u, h, p, c, a[d + 2], 23, -995338651)),
                  h,
                  p,
                  a[d + 0],
                  6,
                  -198630844
                )),
                (p = y(p, c, u, h, a[d + 7], 10, 1126891415)),
                (h = y(h, p, c, u, a[d + 14], 15, -1416354905)),
                (u = y(u, h, p, c, a[d + 5], 21, -57434055)),
                (c = y(c, u, h, p, a[d + 12], 6, 1700485571)),
                (p = y(p, c, u, h, a[d + 3], 10, -1894986606)),
                (h = y(h, p, c, u, a[d + 10], 15, -1051523)),
                (u = y(u, h, p, c, a[d + 1], 21, -2054922799)),
                (c = y(c, u, h, p, a[d + 8], 6, 1873313359)),
                (p = y(p, c, u, h, a[d + 15], 10, -30611744)),
                (h = y(h, p, c, u, a[d + 6], 15, -1560198380)),
                (u = y(u, h, p, c, a[d + 13], 21, 1309151649)),
                (c = y(c, u, h, p, a[d + 4], 6, -145523070)),
                (p = y(p, c, u, h, a[d + 11], 10, -1120210379)),
                (h = y(h, p, c, u, a[d + 2], 15, 718787259)),
                (u = y(u, h, p, c, a[d + 9], 21, -343485551)),
                (c = (c + _) >>> 0),
                (u = (u + v) >>> 0),
                (h = (h + b) >>> 0),
                (p = (p + x) >>> 0);
            }
            return e.endian([c, u, h, p]);
          };
        (s._ff = function (t, e, n, r, i, o, s) {
          var a = t + ((e & n) | (~e & r)) + (i >>> 0) + s;
          return ((a << o) | (a >>> (32 - o))) + e;
        }),
          (s._gg = function (t, e, n, r, i, o, s) {
            var a = t + ((e & r) | (n & ~r)) + (i >>> 0) + s;
            return ((a << o) | (a >>> (32 - o))) + e;
          }),
          (s._hh = function (t, e, n, r, i, o, s) {
            var a = t + (e ^ n ^ r) + (i >>> 0) + s;
            return ((a << o) | (a >>> (32 - o))) + e;
          }),
          (s._ii = function (t, e, n, r, i, o, s) {
            var a = t + (n ^ (e | ~r)) + (i >>> 0) + s;
            return ((a << o) | (a >>> (32 - o))) + e;
          }),
          (s._blocksize = 16),
          (s._digestsize = 16),
          (t.exports = function (t, n) {
            if (void 0 === t || null === t)
              throw new Error("Illegal argument " + t);
            var r = e.wordsToBytes(s(t, n));
            return n && n.asBytes
              ? r
              : n && n.asString
              ? o.bytesToString(r)
              : e.bytesToHex(r);
          });
      })();
    },
    23837: function (t, e, n) {
      (window.__NEXT_P = window.__NEXT_P || []).push([
        "/_app",
        function () {
          return n(72843);
        },
      ]);
    },
    6329: function (t) {
      "use strict";
      t.exports = function (t) {
        t = Object.assign({ onlyFirst: !1 }, t);
        var e = [
          "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
          "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))",
        ].join("|");
        return new RegExp(e, t.onlyFirst ? void 0 : "g");
      };
    },
    72843: function (t, e, n) {
      "use strict";
      n.r(e),
        n.d(e, {
          default: function () {
            return zt;
          },
        });
      var r = {};
      n.r(r),
        n.d(r, {
          addTrackers: function () {
            return dt;
          },
          default: function () {
            return At;
          },
          event: function () {
            return xt;
          },
          exception: function () {
            return wt;
          },
          ga: function () {
            return mt;
          },
          initialize: function () {
            return ft;
          },
          modalview: function () {
            return vt;
          },
          outboundLink: function () {
            return Et;
          },
          pageview: function () {
            return _t;
          },
          plugin: function () {
            return St;
          },
          send: function () {
            return yt;
          },
          set: function () {
            return gt;
          },
          testModeAPI: function () {
            return Tt;
          },
          timing: function () {
            return bt;
          },
        });
      var i = n(26042),
        o = n(85893),
        s = (n(32816), n(67294));
      var a = (t = { debug: !0 }) => {
        var e;
        if ("undefined" === typeof window) return;
        const n = (function (t = "auto") {
          return "auto" === t
            ? (function () {
                try {
                  const t = "production";
                  return "development" === t || "test" === t;
                } catch (t) {
                  return !1;
                }
              })()
              ? "development"
              : "production"
            : t;
        })(t.mode);
        window.va ||
          (window.va = function (...t) {
            (window.vaq = window.vaq || []).push(t);
          }),
          t.beforeSend &&
            (null == (e = window.va) ||
              e.call(window, "beforeSend", t.beforeSend));
        const r =
          "development" === n
            ? "https://cdn.vercel-insights.com/v1/script.debug.js"
            : "/_vercel/insights/script.js";
        if (document.head.querySelector(`script[src*="${r}"]`)) return;
        const i = document.createElement("script");
        (i.src = r),
          (i.defer = !0),
          i.setAttribute("data-sdkn", "@vercel/analytics"),
          i.setAttribute("data-sdkv", "0.1.11"),
          "development" === n &&
            !1 === t.debug &&
            i.setAttribute("data-debug", "false"),
          document.head.appendChild(i);
      };
      function l({ beforeSend: t, debug: e = !0, mode: n = "auto" }) {
        return (
          (0, s.useEffect)(() => {
            a({ beforeSend: t, debug: e, mode: n });
          }, [t, e, n]),
          null
        );
      }
      var c = n(9008),
        u = n.n(c),
        h = n(11163),
        p = n(88767),
        d = n(76915),
        f = n(25617);
      function m(t) {
        return (
          (m =
            "function" === typeof Symbol && "symbol" === typeof Symbol.iterator
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t &&
                    "function" === typeof Symbol &&
                    t.constructor === Symbol &&
                    t !== Symbol.prototype
                    ? "symbol"
                    : typeof t;
                }),
          m(t)
        );
      }
      function g(t, e) {
        if (!(t instanceof e))
          throw new TypeError("Cannot call a class as a function");
      }
      function y(t, e) {
        for (var n = 0; n < e.length; n++) {
          var r = e[n];
          (r.enumerable = r.enumerable || !1),
            (r.configurable = !0),
            "value" in r && (r.writable = !0),
            Object.defineProperty(t, r.key, r);
        }
      }
      function _(t, e) {
        return !e || ("object" !== m(e) && "function" !== typeof e) ? b(t) : e;
      }
      function v(t) {
        return (
          (v = Object.setPrototypeOf
            ? Object.getPrototypeOf
            : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t);
              }),
          v(t)
        );
      }
      function b(t) {
        if (void 0 === t)
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        return t;
      }
      function x(t, e) {
        return (
          (x =
            Object.setPrototypeOf ||
            function (t, e) {
              return (t.__proto__ = e), t;
            }),
          x(t, e)
        );
      }
      function w(t, e, n) {
        return (
          e in t
            ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (t[e] = n),
          t
        );
      }
      var S = (function (t) {
        function e() {
          var t, n;
          g(this, e);
          for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)
            i[o] = arguments[o];
          return (
            w(
              b((n = _(this, (t = v(e)).call.apply(t, [this].concat(i))))),
              "state",
              { bootstrapped: !1 }
            ),
            w(b(n), "_unsubscribe", void 0),
            w(b(n), "handlePersistorState", function () {
              n.props.persistor.getState().bootstrapped &&
                (n.props.onBeforeLift
                  ? Promise.resolve(n.props.onBeforeLift()).finally(
                      function () {
                        return n.setState({ bootstrapped: !0 });
                      }
                    )
                  : n.setState({ bootstrapped: !0 }),
                n._unsubscribe && n._unsubscribe());
            }),
            n
          );
        }
        var n, r, i;
        return (
          (function (t, e) {
            if ("function" !== typeof e && null !== e)
              throw new TypeError(
                "Super expression must either be null or a function"
              );
            (t.prototype = Object.create(e && e.prototype, {
              constructor: { value: t, writable: !0, configurable: !0 },
            })),
              e && x(t, e);
          })(e, t),
          (n = e),
          (r = [
            {
              key: "componentDidMount",
              value: function () {
                (this._unsubscribe = this.props.persistor.subscribe(
                  this.handlePersistorState
                )),
                  this.handlePersistorState();
              },
            },
            {
              key: "componentWillUnmount",
              value: function () {
                this._unsubscribe && this._unsubscribe();
              },
            },
            {
              key: "render",
              value: function () {
                return "function" === typeof this.props.children
                  ? this.props.children(this.state.bootstrapped)
                  : this.state.bootstrapped
                  ? this.props.children
                  : this.props.loading;
              },
            },
          ]) && y(n.prototype, r),
          i && y(n, i),
          e
        );
      })(s.PureComponent);
      w(S, "defaultProps", { children: null, loading: null });
      var E = n(40782),
        T = n(65654),
        A = n(45697),
        C = n.n(A);
      function P(t) {
        console.warn("[react-ga]", t);
      }
      function M(t) {
        return (
          (M =
            "function" === typeof Symbol && "symbol" === typeof Symbol.iterator
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t &&
                    "function" === typeof Symbol &&
                    t.constructor === Symbol &&
                    t !== Symbol.prototype
                    ? "symbol"
                    : typeof t;
                }),
          M(t)
        );
      }
      function O(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function k(t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? O(Object(n), !0).forEach(function (e) {
                j(t, e, n[e]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
            : O(Object(n)).forEach(function (e) {
                Object.defineProperty(
                  t,
                  e,
                  Object.getOwnPropertyDescriptor(n, e)
                );
              });
        }
        return t;
      }
      function I(t, e) {
        if (null == t) return {};
        var n,
          r,
          i = (function (t, e) {
            if (null == t) return {};
            var n,
              r,
              i = {},
              o = Object.keys(t);
            for (r = 0; r < o.length; r++)
              (n = o[r]), e.indexOf(n) >= 0 || (i[n] = t[n]);
            return i;
          })(t, e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(t);
          for (r = 0; r < o.length; r++)
            (n = o[r]),
              e.indexOf(n) >= 0 ||
                (Object.prototype.propertyIsEnumerable.call(t, n) &&
                  (i[n] = t[n]));
        }
        return i;
      }
      function D(t, e) {
        if (!(t instanceof e))
          throw new TypeError("Cannot call a class as a function");
      }
      function z(t, e) {
        for (var n = 0; n < e.length; n++) {
          var r = e[n];
          (r.enumerable = r.enumerable || !1),
            (r.configurable = !0),
            "value" in r && (r.writable = !0),
            Object.defineProperty(t, r.key, r);
        }
      }
      function R(t, e) {
        return (
          (R =
            Object.setPrototypeOf ||
            function (t, e) {
              return (t.__proto__ = e), t;
            }),
          R(t, e)
        );
      }
      function L(t) {
        var e = (function () {
          if ("undefined" === typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" === typeof Proxy) return !0;
          try {
            return (
              Date.prototype.toString.call(
                Reflect.construct(Date, [], function () {})
              ),
              !0
            );
          } catch (t) {
            return !1;
          }
        })();
        return function () {
          var n,
            r = N(t);
          if (e) {
            var i = N(this).constructor;
            n = Reflect.construct(r, arguments, i);
          } else n = r.apply(this, arguments);
          return F(this, n);
        };
      }
      function F(t, e) {
        return !e || ("object" !== M(e) && "function" !== typeof e) ? B(t) : e;
      }
      function B(t) {
        if (void 0 === t)
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        return t;
      }
      function N(t) {
        return (
          (N = Object.setPrototypeOf
            ? Object.getPrototypeOf
            : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t);
              }),
          N(t)
        );
      }
      function j(t, e, n) {
        return (
          e in t
            ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (t[e] = n),
          t
        );
      }
      var U = "_blank",
        Z = (function (t) {
          !(function (t, e) {
            if ("function" !== typeof e && null !== e)
              throw new TypeError(
                "Super expression must either be null or a function"
              );
            (t.prototype = Object.create(e && e.prototype, {
              constructor: { value: t, writable: !0, configurable: !0 },
            })),
              e && R(t, e);
          })(o, t);
          var e,
            n,
            r,
            i = L(o);
          function o() {
            var t;
            D(this, o);
            for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
              n[r] = arguments[r];
            return (
              j(
                B((t = i.call.apply(i, [this].concat(n)))),
                "handleClick",
                function (e) {
                  var n = t.props,
                    r = n.target,
                    i = n.eventLabel,
                    s = n.to,
                    a = n.onClick,
                    l = n.trackerNames,
                    c = { label: i },
                    u = r !== U,
                    h = !(
                      e.ctrlKey ||
                      e.shiftKey ||
                      e.metaKey ||
                      1 === e.button
                    );
                  u && h
                    ? (e.preventDefault(),
                      o.trackLink(
                        c,
                        function () {
                          window.location.href = s;
                        },
                        l
                      ))
                    : o.trackLink(c, function () {}, l),
                    a && a(e);
                }
              ),
              t
            );
          }
          return (
            (e = o),
            (n = [
              {
                key: "render",
                value: function () {
                  var t = this.props,
                    e = t.to,
                    n = t.target,
                    r = k(
                      k({}, I(t, ["to", "target"])),
                      {},
                      { target: n, href: e, onClick: this.handleClick }
                    );
                  return (
                    n === U &&
                      (r.rel = ""
                        .concat(r.rel ? r.rel : "", " noopener noreferrer")
                        .trim()),
                    delete r.eventLabel,
                    delete r.trackerNames,
                    s.createElement("a", r)
                  );
                },
              },
            ]) && z(e.prototype, n),
            r && z(e, r),
            o
          );
        })(s.Component);
      j(Z, "trackLink", function () {
        P("ga tracking not enabled");
      }),
        (Z.propTypes = {
          eventLabel: C().string.isRequired,
          target: C().string,
          to: C().string,
          onClick: C().func,
          trackerNames: C().arrayOf(C().string),
        }),
        (Z.defaultProps = {
          target: null,
          to: null,
          onClick: null,
          trackerNames: null,
        });
      function V(t) {
        return "string" === typeof (e = t) && -1 !== e.indexOf("@")
          ? (P("This arg looks like an email address, redacting."),
            "REDACTED (Potential Email Address)")
          : t;
        var e;
      }
      function q(t) {
        return t && t.toString().replace(/^\s+|\s+$/g, "");
      }
      var $ =
        /^(a|an|and|as|at|but|by|en|for|if|in|nor|of|on|or|per|the|to|vs?\.?|via)$/i;
      function G(t) {
        return q(t).replace(
          /[A-Za-z0-9\u00C0-\u00FF]+[^\s-]*/g,
          function (t, e, n) {
            return e > 0 &&
              e + t.length !== n.length &&
              t.search($) > -1 &&
              ":" !== n.charAt(e - 2) &&
              ("-" !== n.charAt(e + t.length) || "-" === n.charAt(e - 1)) &&
              n.charAt(e - 1).search(/[^\s-]/) < 0
              ? t.toLowerCase()
              : t.substr(1).search(/[A-Z]|\../) > -1
              ? t
              : t.charAt(0).toUpperCase() + t.substr(1);
          }
        );
      }
      var W = !1;
      function H(t) {
        console.info("[react-ga]", t);
      }
      var X = [],
        K = {
          calls: X,
          ga: function () {
            for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
              e[n] = arguments[n];
            X.push([].concat(e));
          },
          resetCalls: function () {
            X.length = 0;
          },
        };
      function Y(t, e) {
        if (null == t) return {};
        var n,
          r,
          i = (function (t, e) {
            if (null == t) return {};
            var n,
              r,
              i = {},
              o = Object.keys(t);
            for (r = 0; r < o.length; r++)
              (n = o[r]), e.indexOf(n) >= 0 || (i[n] = t[n]);
            return i;
          })(t, e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(t);
          for (r = 0; r < o.length; r++)
            (n = o[r]),
              e.indexOf(n) >= 0 ||
                (Object.prototype.propertyIsEnumerable.call(t, n) &&
                  (i[n] = t[n]));
        }
        return i;
      }
      function Q(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function J(t, e, n) {
        return (
          e in t
            ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (t[e] = n),
          t
        );
      }
      function tt(t) {
        return (
          (tt =
            "function" === typeof Symbol && "symbol" === typeof Symbol.iterator
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t &&
                    "function" === typeof Symbol &&
                    t.constructor === Symbol &&
                    t !== Symbol.prototype
                    ? "symbol"
                    : typeof t;
                }),
          tt(t)
        );
      }
      function et(t) {
        return (
          (function (t) {
            if (Array.isArray(t)) return nt(t);
          })(t) ||
          (function (t) {
            if ("undefined" !== typeof Symbol && Symbol.iterator in Object(t))
              return Array.from(t);
          })(t) ||
          (function (t, e) {
            if (!t) return;
            if ("string" === typeof t) return nt(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            "Object" === n && t.constructor && (n = t.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(t);
            if (
              "Arguments" === n ||
              /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
            )
              return nt(t, e);
          })(t) ||
          (function () {
            throw new TypeError(
              "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
            );
          })()
        );
      }
      function nt(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
        return r;
      }
      var rt = "undefined" === typeof window || "undefined" === typeof document,
        it = !1,
        ot = !0,
        st = !1,
        at = !0,
        lt = !0,
        ct = function () {
          var t;
          return st
            ? K.ga.apply(K, arguments)
            : !rt &&
                (window.ga
                  ? (t = window).ga.apply(t, arguments)
                  : P(
                      "ReactGA.initialize must be called first or GoogleAnalytics should be loaded manually"
                    ));
        };
      function ut(t) {
        return (function () {
          var t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : "",
            e =
              !(arguments.length > 2 && void 0 !== arguments[2]) ||
              arguments[2],
            n = t || "";
          return (
            (arguments.length > 1 ? arguments[1] : void 0) && (n = G(t)),
            e && (n = V(n)),
            n
          );
        })(t, ot, lt);
      }
      function ht(t) {
        for (
          var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1;
          r < e;
          r++
        )
          n[r - 1] = arguments[r];
        var i = n[0];
        "string" === typeof i
          ? ((!at && Array.isArray(t)) || ct.apply(void 0, n),
            Array.isArray(t) &&
              t.forEach(function (t) {
                ct.apply(
                  void 0,
                  et(["".concat(t, ".").concat(i)].concat(n.slice(1)))
                );
              }))
          : P("ga command must be a string");
      }
      function pt(t, e) {
        t
          ? (e &&
              (e.debug && !0 === e.debug && (it = !0),
              !1 === e.titleCase && (ot = !1),
              !1 === e.redactEmail && (lt = !1),
              e.useExistingGa)) ||
            (e && e.gaOptions
              ? ct("create", t, e.gaOptions)
              : ct("create", t, "auto"))
          : P("gaTrackingID is required in initialize()");
      }
      function dt(t, e) {
        return (
          Array.isArray(t)
            ? t.forEach(function (t) {
                "object" === tt(t)
                  ? pt(t.trackingId, t)
                  : P("All configs must be an object");
              })
            : pt(t, e),
          !0
        );
      }
      function ft(t, e) {
        if (e && !0 === e.testMode) st = !0;
        else {
          if (rt) return;
          (e && !0 === e.standardImplementation) ||
            (function (t) {
              if (!W) {
                W = !0;
                var e = "https://www.google-analytics.com/analytics.js";
                t && t.gaAddress
                  ? (e = t.gaAddress)
                  : t &&
                    t.debug &&
                    (e = "https://www.google-analytics.com/analytics_debug.js");
                var n,
                  r,
                  i,
                  o,
                  s,
                  a,
                  l,
                  c = t && t.onerror;
                (n = window),
                  (r = document),
                  (i = "script"),
                  (o = e),
                  (s = "ga"),
                  (n.GoogleAnalyticsObject = s),
                  (n.ga =
                    n.ga ||
                    function () {
                      (n.ga.q = n.ga.q || []).push(arguments);
                    }),
                  (n.ga.l = 1 * new Date()),
                  (a = r.createElement(i)),
                  (l = r.getElementsByTagName(i)[0]),
                  (a.async = 1),
                  (a.src = o),
                  (a.onerror = c),
                  l.parentNode.insertBefore(a, l);
              }
            })(e);
        }
        (at =
          !e ||
          "boolean" !== typeof e.alwaysSendToDefaultTracker ||
          e.alwaysSendToDefaultTracker),
          dt(t, e);
      }
      function mt() {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
          e[n] = arguments[n];
        return (
          e.length > 0 &&
            (ct.apply(void 0, e),
            it &&
              (H("called ga('arguments');"),
              H("with arguments: ".concat(JSON.stringify(e))))),
          window.ga
        );
      }
      function gt(t, e) {
        t
          ? "object" === tt(t)
            ? (0 === Object.keys(t).length &&
                P("empty `fieldsObject` given to .set()"),
              ht(e, "set", t),
              it &&
                (H("called ga('set', fieldsObject);"),
                H("with fieldsObject: ".concat(JSON.stringify(t)))))
            : P("Expected `fieldsObject` arg to be an Object")
          : P("`fieldsObject` is required in .set()");
      }
      function yt(t, e) {
        ht(e, "send", t),
          it &&
            (H("called ga('send', fieldObject);"),
            H("with fieldObject: ".concat(JSON.stringify(t))),
            H("with trackers: ".concat(JSON.stringify(e))));
      }
      function _t(t, e, n) {
        if (t) {
          var r = q(t);
          if ("" !== r) {
            var i = {};
            if (
              (n && (i.title = n),
              ht(
                e,
                "send",
                (function (t) {
                  for (var e = 1; e < arguments.length; e++) {
                    var n = null != arguments[e] ? arguments[e] : {};
                    e % 2
                      ? Q(Object(n), !0).forEach(function (e) {
                          J(t, e, n[e]);
                        })
                      : Object.getOwnPropertyDescriptors
                      ? Object.defineProperties(
                          t,
                          Object.getOwnPropertyDescriptors(n)
                        )
                      : Q(Object(n)).forEach(function (e) {
                          Object.defineProperty(
                            t,
                            e,
                            Object.getOwnPropertyDescriptor(n, e)
                          );
                        });
                  }
                  return t;
                })({ hitType: "pageview", page: r }, i)
              ),
              it)
            ) {
              H("called ga('send', 'pageview', path);");
              var o = "";
              n && (o = " and title: ".concat(n)),
                H("with path: ".concat(r).concat(o));
            }
          } else P("path cannot be an empty string in .pageview()");
        } else P("path is required in .pageview()");
      }
      function vt(t, e) {
        if (t) {
          var n,
            r = "/" === (n = q(t)).substring(0, 1) ? n.substring(1) : n;
          if ("" !== r) {
            var i = "/modal/".concat(r);
            ht(e, "send", "pageview", i),
              it &&
                (H("called ga('send', 'pageview', path);"),
                H("with path: ".concat(i)));
          } else
            P(
              "modalName cannot be an empty string or a single / in .modalview()"
            );
        } else P("modalName is required in .modalview(modalName)");
      }
      function bt() {
        var t =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          e = t.category,
          n = t.variable,
          r = t.value,
          i = t.label,
          o = arguments.length > 1 ? arguments[1] : void 0;
        if (e && n && "number" === typeof r) {
          var s = {
            hitType: "timing",
            timingCategory: ut(e),
            timingVar: ut(n),
            timingValue: r,
          };
          i && (s.timingLabel = ut(i)), yt(s, o);
        } else
          P(
            "args.category, args.variable AND args.value are required in timing() AND args.value has to be a number"
          );
      }
      function xt() {
        var t =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          e = t.category,
          n = t.action,
          r = t.label,
          i = t.value,
          o = t.nonInteraction,
          s = t.transport,
          a = Y(t, [
            "category",
            "action",
            "label",
            "value",
            "nonInteraction",
            "transport",
          ]),
          l = arguments.length > 1 ? arguments[1] : void 0;
        if (e && n) {
          var c = {
            hitType: "event",
            eventCategory: ut(e),
            eventAction: ut(n),
          };
          r && (c.eventLabel = ut(r)),
            "undefined" !== typeof i &&
              ("number" !== typeof i
                ? P("Expected `args.value` arg to be a Number.")
                : (c.eventValue = i)),
            "undefined" !== typeof o &&
              ("boolean" !== typeof o
                ? P("`args.nonInteraction` must be a boolean.")
                : (c.nonInteraction = o)),
            "undefined" !== typeof s &&
              ("string" !== typeof s
                ? P("`args.transport` must be a string.")
                : (-1 === ["beacon", "xhr", "image"].indexOf(s) &&
                    P(
                      "`args.transport` must be either one of these values: `beacon`, `xhr` or `image`"
                    ),
                  (c.transport = s))),
            Object.keys(a)
              .filter(function (t) {
                return "dimension" === t.substr(0, "dimension".length);
              })
              .forEach(function (t) {
                c[t] = a[t];
              }),
            Object.keys(a)
              .filter(function (t) {
                return "metric" === t.substr(0, "metric".length);
              })
              .forEach(function (t) {
                c[t] = a[t];
              }),
            yt(c, l);
        } else P("args.category AND args.action are required in event()");
      }
      function wt(t, e) {
        var n = t.description,
          r = t.fatal,
          i = { hitType: "exception" };
        n && (i.exDescription = ut(n)),
          "undefined" !== typeof r &&
            ("boolean" !== typeof r
              ? P("`args.fatal` must be a boolean.")
              : (i.exFatal = r)),
          yt(i, e);
      }
      var St = {
        require: function (t, e, n) {
          if (t) {
            var r = q(t);
            if ("" !== r) {
              var i = n ? "".concat(n, ".require") : "require";
              if (e) {
                if ("object" !== tt(e))
                  return void P("Expected `options` arg to be an Object");
                0 === Object.keys(e).length &&
                  P("Empty `options` given to .require()"),
                  mt(i, r, e),
                  it &&
                    H(
                      "called ga('require', '"
                        .concat(r, "', ")
                        .concat(JSON.stringify(e))
                    );
              } else
                mt(i, r), it && H("called ga('require', '".concat(r, "');"));
            } else P("`name` cannot be an empty string in .require()");
          } else P("`name` is required in .require()");
        },
        execute: function (t, e) {
          for (
            var n,
              r,
              i = arguments.length,
              o = new Array(i > 2 ? i - 2 : 0),
              s = 2;
            s < i;
            s++
          )
            o[s - 2] = arguments[s];
          if (
            (1 === o.length ? (n = o[0]) : ((r = o[0]), (n = o[1])),
            "string" !== typeof t)
          )
            P("Expected `pluginName` arg to be a String.");
          else if ("string" !== typeof e)
            P("Expected `action` arg to be a String.");
          else {
            var a = "".concat(t, ":").concat(e);
            (n = n || null),
              r && n
                ? (mt(a, r, n),
                  it &&
                    (H("called ga('".concat(a, "');")),
                    H(
                      'actionType: "'
                        .concat(r, '" with payload: ')
                        .concat(JSON.stringify(n))
                    )))
                : n
                ? (mt(a, n),
                  it &&
                    (H("called ga('".concat(a, "');")),
                    H("with payload: ".concat(JSON.stringify(n)))))
                : (mt(a), it && H("called ga('".concat(a, "');")));
          }
        },
      };
      function Et(t, e, n) {
        if ("function" === typeof e)
          if (t && t.label) {
            var r = {
                hitType: "event",
                eventCategory: "Outbound",
                eventAction: "Click",
                eventLabel: ut(t.label),
              },
              i = !1,
              o = setTimeout(function () {
                (i = !0), e();
              }, 250);
            (r.hitCallback = function () {
              clearTimeout(o), i || e();
            }),
              yt(r, n);
          } else P("args.label is required in outboundLink()");
        else P("hitCallback function is required");
      }
      var Tt = K,
        At = {
          initialize: ft,
          ga: mt,
          set: gt,
          send: yt,
          pageview: _t,
          modalview: vt,
          timing: bt,
          event: xt,
          exception: wt,
          plugin: St,
          outboundLink: Et,
          testModeAPI: K,
        };
      function Ct(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function Pt(t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? Ct(Object(n), !0).forEach(function (e) {
                Mt(t, e, n[e]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
            : Ct(Object(n)).forEach(function (e) {
                Object.defineProperty(
                  t,
                  e,
                  Object.getOwnPropertyDescriptor(n, e)
                );
              });
        }
        return t;
      }
      function Mt(t, e, n) {
        return (
          e in t
            ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (t[e] = n),
          t
        );
      }
      (Z.origTrackLink = Z.trackLink), (Z.trackLink = Et);
      var Ot = Z,
        kt = Pt(Pt({}, r), {}, { OutboundLink: Ot }),
        It = n(1785),
        Dt = n.n(It);
      n(7727);
      function zt(t) {
        var e = t.Component,
          n = t.pageProps,
          r = (0, h.useRouter)(),
          a = (r.pathname, r.asPath),
          c = e.Layout || Rt,
          m = e.LayoutClassName || "",
          g = s.useRef();
        return (
          g.current || (g.current = new p.QueryClient()),
          d.h.dispatch((0, T.jl)()),
          s.useEffect(function () {
            kt.initialize("UA-207598494-1"),
              kt.pageview(a),
              Dt().initialize({ gtmId: "G-4ZP48312XT" });
          }, []),
          (0, o.jsx)(p.QueryClientProvider, {
            client: g.current,
            children: (0, o.jsx)(p.Hydrate, {
              state: n.dehydratedState,
              children: (0, o.jsx)(f.zt, {
                store: d.h,
                children: (0, o.jsx)(S, {
                  persistor: d.h.__persistor,
                  loading: !1,
                  children: function () {
                    return (0, o.jsxs)(s.Fragment, {
                      children: [
                        (0, o.jsx)(u(), {
                          children: (0, o.jsx)("meta", {
                            name: "viewport",
                            content:
                              "width=device-width, initial-scale=1.0, maximum-scale=5.0",
                          }),
                        }),
                        (0, o.jsx)(E.Ix, { hideProgressBar: !0 }),
                        (0, o.jsxs)(c, {
                          className: m,
                          children: [
                            (0, o.jsx)(e, (0, i.Z)({}, n)),
                            (0, o.jsx)(l, {}),
                          ],
                        }),
                      ],
                    });
                  },
                }),
              }),
            }),
          })
        );
      }
      var Rt = function (t) {
        var e = t.children;
        return (0, o.jsx)(s.Fragment, { children: e });
      };
    },
    65654: function (t, e, n) {
      "use strict";
      n.d(e, {
        jl: function () {
          return l;
        },
        kS: function () {
          return u;
        },
        x4: function () {
          return c;
        },
      });
      var r = n(47568),
        i = n(20414),
        o = (n(80129), n(21232)),
        s = n(62709),
        a = n(84910),
        l = function () {
          return function (t) {
            return new Promise(function (e, n) {
              return o.Z.get("/auth/verify")
                .then(function (t) {
                  return t.data;
                })
                .then(function (n) {
                  return t((0, s.No)(n)), e(n);
                })
                .catch(function (e) {
                  return t((0, s.No)(e)), n(e);
                });
            });
          };
        },
        c = function (t) {
          return function (e) {
            return new Promise(function (n, l) {
              return o.Z.get(
                "https://api.bluepagespro.com/sanctum/csrf-cookie"
              ).then(function () {
                return o.Z.post("/auth/login", t)
                  .then(function (t) {
                    return t.data;
                  })
                  .then(
                    (function () {
                      var t = (0, r.Z)(function (t) {
                        return (0, i.__generator)(this, function (r) {
                          switch (r.label) {
                            case 0:
                              return [4, e((0, s.eU)(t))];
                            case 1:
                              return (
                                r.sent(),
                                [
                                  4,
                                  e(
                                    (0, a.c)({
                                      status: "success",
                                      message: "Successfully logged in",
                                    })
                                  ),
                                ]
                              );
                            case 2:
                              return r.sent(), [2, n(t)];
                          }
                        });
                      });
                      return function (e) {
                        return t.apply(this, arguments);
                      };
                    })()
                  )
                  .catch(
                    (function () {
                      var t = (0, r.Z)(function (t) {
                        return (0, i.__generator)(this, function (n) {
                          switch (n.label) {
                            case 0:
                              return [
                                4,
                                e(
                                  (0, a.c)({
                                    status: "error",
                                    message: t.response.data.message,
                                  })
                                ),
                              ];
                            case 1:
                              return n.sent(), [2, l(t)];
                          }
                        });
                      });
                      return function (e) {
                        return t.apply(this, arguments);
                      };
                    })()
                  );
              });
            });
          };
        },
        u = function () {
          return function (t) {
            return new Promise(function (e, n) {
              return o.Z.post("/auth/logout")
                .then(function (t) {
                  return t.data;
                })
                .then(
                  (function () {
                    var n = (0, r.Z)(function (n) {
                      return (0, i.__generator)(this, function (r) {
                        switch (r.label) {
                          case 0:
                            return [4, t((0, s.bg)(n))];
                          case 1:
                            return (
                              r.sent(),
                              [
                                4,
                                t(
                                  (0, a.c)({
                                    status: "success",
                                    message: "Successfully logged out",
                                  })
                                ),
                              ]
                            );
                          case 2:
                            return r.sent(), [2, e(n)];
                        }
                      });
                    });
                    return function (t) {
                      return n.apply(this, arguments);
                    };
                  })()
                )
                .catch(
                  (function () {
                    var e = (0, r.Z)(function (e) {
                      return (0, i.__generator)(this, function (r) {
                        switch (r.label) {
                          case 0:
                            return [4, t((0, s.bg)())];
                          case 1:
                            return r.sent(), [2, n(e.response.data.message)];
                        }
                      });
                    });
                    return function (t) {
                      return e.apply(this, arguments);
                    };
                  })()
                );
            });
          };
        };
    },
    76915: function (t, e, n) {
      "use strict";
      n.d(e, {
        h: function () {
          return ct;
        },
      });
      var r = n(45217),
        i = n(28500),
        o = "persist:",
        s = "persist/FLUSH",
        a = "persist/REHYDRATE",
        l = "persist/PAUSE",
        c = "persist/PERSIST",
        u = "persist/PURGE",
        h = "persist/REGISTER";
      function p(t) {
        return (
          (p =
            "function" === typeof Symbol && "symbol" === typeof Symbol.iterator
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t &&
                    "function" === typeof Symbol &&
                    t.constructor === Symbol &&
                    t !== Symbol.prototype
                    ? "symbol"
                    : typeof t;
                }),
          p(t)
        );
      }
      function d(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function f(t, e, n) {
        return (
          e in t
            ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (t[e] = n),
          t
        );
      }
      function m(t, e, n, r) {
        r.debug;
        var i = (function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = null != arguments[e] ? arguments[e] : {};
            e % 2
              ? d(n, !0).forEach(function (e) {
                  f(t, e, n[e]);
                })
              : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
              : d(n).forEach(function (e) {
                  Object.defineProperty(
                    t,
                    e,
                    Object.getOwnPropertyDescriptor(n, e)
                  );
                });
          }
          return t;
        })({}, n);
        return (
          t &&
            "object" === p(t) &&
            Object.keys(t).forEach(function (r) {
              "_persist" !== r && e[r] === n[r] && (i[r] = t[r]);
            }),
          i
        );
      }
      function g(t) {
        var e,
          n = t.blacklist || null,
          r = t.whitelist || null,
          i = t.transforms || [],
          s = t.throttle || 0,
          a = "".concat(void 0 !== t.keyPrefix ? t.keyPrefix : o).concat(t.key),
          l = t.storage;
        e =
          !1 === t.serialize
            ? function (t) {
                return t;
              }
            : "function" === typeof t.serialize
            ? t.serialize
            : y;
        var c = t.writeFailHandler || null,
          u = {},
          h = {},
          p = [],
          d = null,
          f = null;
        function m() {
          if (0 === p.length) return d && clearInterval(d), void (d = null);
          var t = p.shift(),
            n = i.reduce(function (e, n) {
              return n.in(e, t, u);
            }, u[t]);
          if (void 0 !== n)
            try {
              h[t] = e(n);
            } catch (r) {
              console.error(
                "redux-persist/createPersistoid: error serializing state",
                r
              );
            }
          else delete h[t];
          0 === p.length &&
            (Object.keys(h).forEach(function (t) {
              void 0 === u[t] && delete h[t];
            }),
            (f = l.setItem(a, e(h)).catch(_)));
        }
        function g(t) {
          return (
            (!r || -1 !== r.indexOf(t) || "_persist" === t) &&
            (!n || -1 === n.indexOf(t))
          );
        }
        function _(t) {
          c && c(t);
        }
        return {
          update: function (t) {
            Object.keys(t).forEach(function (e) {
              g(e) && u[e] !== t[e] && -1 === p.indexOf(e) && p.push(e);
            }),
              Object.keys(u).forEach(function (e) {
                void 0 === t[e] &&
                  g(e) &&
                  -1 === p.indexOf(e) &&
                  void 0 !== u[e] &&
                  p.push(e);
              }),
              null === d && (d = setInterval(m, s)),
              (u = t);
          },
          flush: function () {
            for (; 0 !== p.length; ) m();
            return f || Promise.resolve();
          },
        };
      }
      function y(t) {
        return JSON.stringify(t);
      }
      function _(t) {
        var e,
          n = t.transforms || [],
          r = "".concat(void 0 !== t.keyPrefix ? t.keyPrefix : o).concat(t.key),
          i = t.storage;
        t.debug;
        return (
          (e =
            !1 === t.deserialize
              ? function (t) {
                  return t;
                }
              : "function" === typeof t.deserialize
              ? t.deserialize
              : v),
          i.getItem(r).then(function (t) {
            if (t)
              try {
                var r = {},
                  i = e(t);
                return (
                  Object.keys(i).forEach(function (t) {
                    r[t] = n.reduceRight(function (e, n) {
                      return n.out(e, t, i);
                    }, e(i[t]));
                  }),
                  r
                );
              } catch (o) {
                throw o;
              }
          })
        );
      }
      function v(t) {
        return JSON.parse(t);
      }
      function b(t) {
        0;
      }
      function x(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function w(t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? x(n, !0).forEach(function (e) {
                S(t, e, n[e]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
            : x(n).forEach(function (e) {
                Object.defineProperty(
                  t,
                  e,
                  Object.getOwnPropertyDescriptor(n, e)
                );
              });
        }
        return t;
      }
      function S(t, e, n) {
        return (
          e in t
            ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (t[e] = n),
          t
        );
      }
      function E(t, e) {
        if (null == t) return {};
        var n,
          r,
          i = (function (t, e) {
            if (null == t) return {};
            var n,
              r,
              i = {},
              o = Object.keys(t);
            for (r = 0; r < o.length; r++)
              (n = o[r]), e.indexOf(n) >= 0 || (i[n] = t[n]);
            return i;
          })(t, e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(t);
          for (r = 0; r < o.length; r++)
            (n = o[r]),
              e.indexOf(n) >= 0 ||
                (Object.prototype.propertyIsEnumerable.call(t, n) &&
                  (i[n] = t[n]));
        }
        return i;
      }
      function T(t, e) {
        var n = void 0 !== t.version ? t.version : -1,
          r = (t.debug, void 0 === t.stateReconciler ? m : t.stateReconciler),
          i = t.getStoredState || _,
          h = void 0 !== t.timeout ? t.timeout : 5e3,
          p = null,
          d = !1,
          f = !0,
          y = function (t) {
            return t._persist.rehydrated && p && !f && p.update(t), t;
          };
        return function (m, _) {
          var v = m || {},
            x = v._persist,
            S = E(v, ["_persist"]);
          if (_.type === c) {
            var T = !1,
              A = function (e, n) {
                T || (_.rehydrate(t.key, e, n), (T = !0));
              };
            if (
              (h &&
                setTimeout(function () {
                  !T &&
                    A(
                      void 0,
                      new Error(
                        'redux-persist: persist timed out for persist key "'.concat(
                          t.key,
                          '"'
                        )
                      )
                    );
                }, h),
              (f = !1),
              p || (p = g(t)),
              x)
            )
              return w({}, e(S, _), { _persist: x });
            if (
              "function" !== typeof _.rehydrate ||
              "function" !== typeof _.register
            )
              throw new Error(
                "redux-persist: either rehydrate or register is not a function on the PERSIST action. This can happen if the action is being replayed. This is an unexplored use case, please open an issue and we will figure out a resolution."
              );
            return (
              _.register(t.key),
              i(t).then(
                function (e) {
                  (
                    t.migrate ||
                    function (t, e) {
                      return Promise.resolve(t);
                    }
                  )(e, n).then(
                    function (t) {
                      A(t);
                    },
                    function (t) {
                      A(void 0, t);
                    }
                  );
                },
                function (t) {
                  A(void 0, t);
                }
              ),
              w({}, e(S, _), { _persist: { version: n, rehydrated: !1 } })
            );
          }
          if (_.type === u)
            return (
              (d = !0),
              _.result(
                (function (t) {
                  var e = t.storage,
                    n = ""
                      .concat(void 0 !== t.keyPrefix ? t.keyPrefix : o)
                      .concat(t.key);
                  return e.removeItem(n, b);
                })(t)
              ),
              w({}, e(S, _), { _persist: x })
            );
          if (_.type === s)
            return _.result(p && p.flush()), w({}, e(S, _), { _persist: x });
          if (_.type === l) f = !0;
          else if (_.type === a) {
            if (d) return w({}, S, { _persist: w({}, x, { rehydrated: !0 }) });
            if (_.key === t.key) {
              var C = e(S, _),
                P = _.payload,
                M = w({}, !1 !== r && void 0 !== P ? r(P, m, C, t) : C, {
                  _persist: w({}, x, { rehydrated: !0 }),
                });
              return y(M);
            }
          }
          if (!x) return e(m, _);
          var O = e(S, _);
          return O === S ? m : y(w({}, O, { _persist: x }));
        };
      }
      function A(t) {
        return (
          (function (t) {
            if (Array.isArray(t)) {
              for (var e = 0, n = new Array(t.length); e < t.length; e++)
                n[e] = t[e];
              return n;
            }
          })(t) ||
          (function (t) {
            if (
              Symbol.iterator in Object(t) ||
              "[object Arguments]" === Object.prototype.toString.call(t)
            )
              return Array.from(t);
          })(t) ||
          (function () {
            throw new TypeError(
              "Invalid attempt to spread non-iterable instance"
            );
          })()
        );
      }
      function C(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function P(t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? C(n, !0).forEach(function (e) {
                M(t, e, n[e]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
            : C(n).forEach(function (e) {
                Object.defineProperty(
                  t,
                  e,
                  Object.getOwnPropertyDescriptor(n, e)
                );
              });
        }
        return t;
      }
      function M(t, e, n) {
        return (
          e in t
            ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (t[e] = n),
          t
        );
      }
      var O = { registry: [], bootstrapped: !1 },
        k = function () {
          var t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : O,
            e = arguments.length > 1 ? arguments[1] : void 0;
          switch (e.type) {
            case h:
              return P({}, t, { registry: [].concat(A(t.registry), [e.key]) });
            case a:
              var n = t.registry.indexOf(e.key),
                r = A(t.registry);
              return (
                r.splice(n, 1),
                P({}, t, { registry: r, bootstrapped: 0 === r.length })
              );
            default:
              return t;
          }
        };
      var I = n(26042),
        D = n(69396),
        z = {
          categories: [],
          category: {
            category_id: 0,
            name: "",
            slug: "",
            iconUrl: "",
            status: 0,
          },
          masterFile: { status: [] },
        };
      var R = {
        offers: [],
        offer: {
          offer_id: 0,
          label: "",
          title: "",
          slug: "",
          subTitle: "",
          price: "",
          discountedPrice: "",
          description: "",
          content: "",
          imageUrl: "",
          bannerUrl: "",
          formEmbeddedCode: "",
          hasDiscount: "",
          status: 0,
          listings: [],
        },
        masterFile: { listings: [], status: [] },
        popup: { deleteOffer: { show: !1, offer_id: 0, title: "" } },
      };
      var L = {
        posts: [],
        post: {
          post_id: 0,
          title: "",
          description: "",
          offerHeading: "",
          offerSubHeading: "",
          offerUrl: "",
          downloadUrl: "",
          couponCode: "",
          videoUrl: "",
          videoEmbedCode: "",
          imageUrl: "",
          isFeatured: "",
          status: "",
        },
        masterFile: { tier: [], status: [] },
        popup: { deletePost: { show: !1, post_id: 0, title: "" } },
      };
      var F = n(70293),
        B = {
          user_id: 0,
          username: "",
          firstName: "",
          lastName: "",
          email: "",
          roles: [],
          dashboard: { mode: "light" },
        };
      var N = n(85893),
        j = (n(67294), n(27856)),
        U = n.n(j),
        Z = n(83208),
        V = { show: !1, status: "", message: "" };
      var q = {
        listings: [],
        markers: [],
        filter: {
          location_id: "",
          title: "",
          keyword: "",
          postalCode: "",
          category: [],
          latitude: "",
          longitude: "",
          mapBounds: {},
          ignoreMapBounds: !1,
          page: 1,
        },
        searchHistory: { location: [] },
        pagination: { hasMore: !1, totalPages: 1 },
        totalListings: 0,
        isLoading: !1,
        selectedListing: void 0,
        filterFormSubmitting: !1,
        viewport: {
          latitude: 37.0902,
          longitude: -97.7129,
          width: "100%",
          height: "100%",
          zoom: 3.6,
        },
        dataBounds: void 0,
      };
      var $ = {
        popup: {
          financingCalculator: {
            show: !1,
            loanAmount: 0,
            loanOption: { label: "", value: "" },
          },
        },
      };
      var G = {
        offers: [],
        popup: { redeemFinancingSolution: { show: !1, post_id: 0 } },
      };
      var W = {
        listing: { listing_id: 0 },
        listings: [],
        masterFile: {
          tier: [],
          category: [],
          country: [],
          isTrial: [],
          status: [],
          financingStatus: [],
          businessHours: [],
        },
      };
      var H = {
        offer: { offer_id: 0 },
        offers: [],
        inbox: {
          submission: {
            message: { submission_id: 0, comments: [] },
            messages: [],
            selectedMessages: [],
            totalMessages: 0,
            totalPages: 0,
            hasMore: !1,
          },
          filter: { label: [] },
        },
        masterFile: {},
      };
      var X = {
        inbox: {
          submission: {
            message: { submission_id: 0, comments: [] },
            messages: [],
            selectedMessages: [],
            totalMessages: 0,
            totalPages: 0,
            hasMore: !1,
          },
          filter: { label: [] },
        },
      };
      var K = {
        inbox: {
          submission: {
            message: { submission_id: 0, comments: [] },
            messages: [],
            selectedMessages: [],
            totalMessages: 0,
            totalPages: 0,
            hasMore: !1,
          },
          filter: { label: [] },
        },
      };
      var Y = {
        step: { current: 1, completed: 1 },
        steps: {
          free: { business: 1, category: 2, location: 3 },
          "pro-lite": {
            business: 1,
            category: 2,
            financing: 3,
            video: 4,
            location: 5,
            payment: 6,
          },
          pro: {
            business: 1,
            category: 2,
            banner: 3,
            financing: 4,
            offer: 5,
            social: 6,
            projects: 7,
            video: 8,
            location: 9,
            payment: 10,
          },
        },
        listing: { listing_id: 0, title: "" },
        masterFile: { category: [], country: [], businessHours: [] },
      };
      var Q = {
        tier: "",
        step: { current: 1, completed: 1 },
        steps: {
          free: { account: 1, business: 2, category: 3, location: 4 },
          pro: {
            account: 1,
            business: 2,
            category: 3,
            offer: 4,
            social: 5,
            banner: 6,
            projects: 7,
            video: 8,
            location: 9,
          },
          "pro-lite": {
            account: 1,
            business: 2,
            category: 3,
            offer: 4,
            video: 5,
            location: 6,
          },
        },
        listing: { listing_id: 0, title: "" },
        masterFile: { category: [], country: [], businessHours: [] },
      };
      var J = n(29815),
        tt = { location: [] };
      n(99338);
      var et = n(31046),
        nt = {
          listings: {
            filterFormSubmitting: !1,
            dataBounds: void 0,
            selectedListing: void 0,
            viewport: {
              latitude: 37.0902,
              longitude: -97.7129,
              width: "100%",
              height: "100%",
              zoom: 3.6,
            },
          },
          promotions: { popupScheduleDemo: !1 },
        };
      var rt = (0, r.combineReducers)({
          adminListingCategory: function () {
            var t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : z,
              e = arguments.length > 1 ? arguments[1] : void 0,
              n = e.type,
              r = e.payload;
            switch (n) {
              case "category/showList":
                return (0, D.Z)((0, I.Z)({}, t), {
                  categories: r.map(function (t) {
                    return {
                      category_id: t.category_id,
                      name: t.name,
                      slug: t.slug,
                      iconUrl: t.icon_url,
                      markerIconUrl: t.marker_icon_url,
                      status: t.status,
                    };
                  }),
                });
              case "category/setDetail":
                return (0, D.Z)((0, I.Z)({}, t), {
                  category: {
                    category_id: r.category_id,
                    name: r.name,
                    slug: r.slug,
                    iconUrl: r.icon_url,
                    status: r.status,
                  },
                });
              case "category/resetDetail":
                return (0, D.Z)((0, I.Z)({}, t), { category: z.category });
              case "category/masterfile/setData":
                return (0, D.Z)((0, I.Z)({}, t), {
                  masterFile: (0, I.Z)({}, t.masterFile, r),
                });
              case "category/masterfile/resetData":
                return (0, D.Z)((0, I.Z)({}, t), { masterFile: z.masterFile });
              default:
                return t;
            }
          },
          adminListingOffer: function () {
            var t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : R,
              e = arguments.length > 1 ? arguments[1] : void 0,
              n = e.type,
              r = e.payload;
            switch (n) {
              case "offer/showList":
                return (0, D.Z)((0, I.Z)({}, t), {
                  offers: r.map(function (t) {
                    var e;
                    return {
                      offer_id: t.offer_id,
                      label: null !== (e = t.label) && void 0 !== e ? e : "N/A",
                      title: t.title,
                      type: t.type,
                      description: t.description,
                      status: t.status,
                    };
                  }),
                });
              case "offer/setDetail":
                return (0, D.Z)((0, I.Z)({}, t), {
                  offer: {
                    offer_id: r.offer_id,
                    label: r.label,
                    title: r.title,
                    slug: r.slug,
                    type: r.type,
                    subTitle: r.sub_title,
                    price: r.price,
                    discountedPrice: r.discounted_price,
                    description: r.description,
                    content: r.content,
                    imageUrl: r.image_url,
                    bannerUrl: r.banner_url,
                    formEmbeddedCode: r.form_embedded_code,
                    hasDiscount: r.has_discount,
                    status: r.status,
                    listings: r.listings,
                  },
                });
              case "offer/resetDetail":
                return (0, D.Z)((0, I.Z)({}, t), { offer: R.offer });
              case "offer/masterfile/setData":
                return (0, D.Z)((0, I.Z)({}, t), {
                  masterFile: (0, I.Z)({}, t.masterFile, r),
                });
              case "offer/masterfile/clearListingData":
                return (0, D.Z)((0, I.Z)({}, t), {
                  masterFile: (0, D.Z)((0, I.Z)({}, t.masterFile), {
                    listings: R.masterFile.listings,
                  }),
                });
              case "offer/masterfile/resetData":
                return (0, D.Z)((0, I.Z)({}, t), { masterFile: R.masterFile });
              case "popup/deleteOffer":
                var i = R.popup.deleteOffer;
                return (
                  !0 === r.show &&
                    (i = { show: !0, offer_id: r.offer_id, title: r.title }),
                  (0, D.Z)((0, I.Z)({}, t), {
                    popup: (0, D.Z)((0, I.Z)({}, t.popup), { deleteOffer: i }),
                  })
                );
              default:
                return t;
            }
          },
          adminMemberPage: function () {
            var t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : L,
              e = arguments.length > 1 ? arguments[1] : void 0,
              n = e.type,
              r = e.payload;
            switch (n) {
              case "post/showList":
                return (0, D.Z)((0, I.Z)({}, t), {
                  posts: r.map(function (t) {
                    return {
                      post_id: t.post_id,
                      title: t.title,
                      description: t.description,
                      offerHeading: t.offer_heading,
                      offerSubHeading: t.offer_subheading,
                      offerUrl: t.offer_url,
                      downloadUrl: t.download_url,
                      couponCode: t.coupon_code,
                      imageUrl: t.image_url,
                      isFeatured: t.is_featured,
                      status: t.status,
                    };
                  }),
                });
              case "post/resetList":
                return (0, D.Z)((0, I.Z)({}, t), { posts: L.posts });
              case "post/setDetail":
                return (0, D.Z)((0, I.Z)({}, t), {
                  post: {
                    post_id: r.post_id,
                    title: r.title,
                    description: r.description,
                    offerHeading: r.offer_heading,
                    offerSubHeading: r.offer_subheading,
                    offerUrl: r.offer_url,
                    downloadUrl: r.download_url,
                    couponCode: r.coupon_code,
                    videoUrl: r.video_url,
                    videoEmbedCode: r.video_embed_code,
                    imageUrl: r.image_url,
                    isFeatured: r.is_featured,
                    status: r.status,
                    tiers: r.tiers,
                  },
                });
              case "post/resetDetail":
                return (0, D.Z)((0, I.Z)({}, t), { post: L.post });
              case "post/masterfile/setData":
                return (0, D.Z)((0, I.Z)({}, t), {
                  masterFile: (0, I.Z)({}, t.masterFile, r),
                });
              case "post/masterfile/resetData":
                return (0, D.Z)((0, I.Z)({}, t), { masterFile: L.masterFile });
              case "popup/deletePost":
                var i = L.popup.deletePost;
                return (
                  !0 === r.show &&
                    (i = { show: !0, post_id: r.post_id, title: r.title }),
                  (0, D.Z)((0, I.Z)({}, t), {
                    popup: (0, D.Z)((0, I.Z)({}, t.popup), { deletePost: i }),
                  })
                );
              default:
                return t;
            }
          },
          user: function () {
            var t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : B,
              e = arguments.length > 1 ? arguments[1] : void 0,
              n = e.type,
              r = e.payload;
            switch (n) {
              case "auth/verify":
                return void 0 ==
                  (null === r || void 0 === r ? void 0 : r.user_id)
                  ? (0, D.Z)((0, I.Z)({}, B), {
                      postalCode: r.postal_code,
                      country: r.country,
                    })
                  : (0, D.Z)((0, I.Z)({}, t), {
                      user_id: r.user_id,
                      username: r.username,
                      firstName: r.first_name,
                      lastName: r.last_name,
                      email: r.email,
                      roles: r.roles,
                      avatarUrl: r.avatar_url,
                      postalCode: r.postal_code,
                      country: r.country,
                      isEmailVerified: r.is_email_verified,
                      status: r.status,
                      dashboard: { mode: "light" },
                    });
              case "auth/login":
                return (0, D.Z)((0, I.Z)({}, t), {
                  user_id: r.user_id,
                  username: r.username,
                  firstName: r.first_name,
                  lastName: r.last_name,
                  email: r.email,
                  roles: r.roles,
                  avatarUrl: r.avatar_url,
                  postalCode: r.postal_code,
                  country: r.country,
                  isEmailVerified: r.is_email_verified,
                  status: r.status,
                });
              case "auth/logout":
                return F.Z.remove("XSRF-TOKEN"), B;
              case "user/setDetail":
                return (0, D.Z)((0, I.Z)({}, t), {
                  user_id: r.user_id || t.user_id,
                  username: r.username || t.username,
                  firstName: r.first_name || t.firstName,
                  lastName: r.last_name || t.lastName,
                  email: r.email || t.email,
                });
              case "dashboard/setMode":
                return (0, D.Z)((0, I.Z)({}, t), {
                  dashboard: (0, D.Z)((0, I.Z)({}, t.dashboard), { mode: r }),
                });
              default:
                return t;
            }
          },
          notification: function () {
            var t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : V,
              e = arguments.length > 1 ? arguments[1] : void 0,
              n = e.type,
              r = e.payload;
            switch (n) {
              case Z.e:
                var i = r.message;
                return (
                  "object" == typeof i
                    ? ((i = "<ul>"),
                      (i += Object.values(r.message)
                        .map(function (t) {
                          return "<li>".concat(t, "</li>");
                        })
                        .flat()
                        .join("")),
                      (i += "</ul>"))
                    : "string" == typeof i && (i = "<p>".concat(i, "</p>")),
                  (0, D.Z)((0, I.Z)({}, t), {
                    show: !0,
                    status: r.status,
                    message: (0, N.jsx)("div", {
                      dangerouslySetInnerHTML: { __html: U().sanitize(i) },
                    }),
                  })
                );
              case Z.Z:
                return V;
              default:
                return t;
            }
          },
          listings: function () {
            var t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : q,
              e = arguments.length > 1 ? arguments[1] : void 0,
              n = e.type,
              r = e.payload;
            switch (n) {
              case "listings/setList":
                return (0, D.Z)((0, I.Z)({}, t), {
                  listings: r.paginator.data,
                  markers: r.markers,
                  pagination: { totalPages: r.paginator.total_pages },
                  totalListings: r.paginator.total,
                });
              case "listings/setFilter":
                return (0, D.Z)((0, I.Z)({}, t), {
                  filter: (0, I.Z)({}, t.filter, r),
                });
              case "listings/setLoading":
                return (0, D.Z)((0, I.Z)({}, t), { isLoading: r });
              case "listings/setSelectedListing":
                return (0, D.Z)((0, I.Z)({}, t), { selectedListing: r });
              case "listings/setFilterFormSubmitting":
                return (0, D.Z)((0, I.Z)({}, t), { filterFormSubmitting: r });
              case "map/setViewport":
                return (0, D.Z)((0, I.Z)({}, t), {
                  viewport: (0, I.Z)({}, t.viewport, r),
                });
              case "map/setDatabounds":
                return (0, D.Z)((0, I.Z)({}, t), { dataBounds: r });
              case "map/resetViewport":
                return (0, D.Z)((0, I.Z)({}, t), { viewport: q.viewport });
              default:
                return t;
            }
          },
          listing: function () {
            var t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : $,
              e = arguments.length > 1 ? arguments[1] : void 0,
              n = e.type,
              r = e.payload;
            if ("listing/popup/financingCalculator" === n) {
              var i = $.popup.financingCalculator;
              return (
                !0 === r.show &&
                  (i = {
                    show: !0,
                    loanAmount: r.loanAmount,
                    loanOption: {
                      label: r.loanOption.label,
                      value: r.loanOption.value,
                    },
                  }),
                (0, D.Z)((0, I.Z)({}, t), {
                  popup: (0, D.Z)((0, I.Z)({}, t.popup), {
                    financingCalculator: i,
                  }),
                })
              );
            }
            return t;
          },
          member: function () {
            var t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : G,
              e = arguments.length > 1 ? arguments[1] : void 0,
              n = e.type,
              r = e.payload;
            switch (n) {
              case "offer/showList":
                return (0, D.Z)((0, I.Z)({}, t), {
                  offers: r.map(function (t) {
                    var e, n, r, i, o;
                    return {
                      post_id: t.post_id,
                      title: t.title,
                      description: t.description,
                      offerHeading:
                        null !== (e = t.offer_heading) && void 0 !== e ? e : "",
                      offerSubHeading:
                        null !== (n = t.offer_subheading) && void 0 !== n
                          ? n
                          : "",
                      offerUrl:
                        null !== (r = t.offer_url) && void 0 !== r ? r : "",
                      downloadUrl:
                        null !== (i = t.download_url) && void 0 !== i ? i : "",
                      couponCode:
                        null !== (o = t.coupon_code) && void 0 !== o ? o : "",
                      imageUrl: t.image_url,
                    };
                  }),
                });
              case "offer/resetList":
                return (0, D.Z)((0, I.Z)({}, t), { offers: G.offers });
              case "popup/financingSolution/redeem":
                var i = G.popup.redeemFinancingSolution;
                return (
                  !0 === r.show &&
                    (i = { show: !0, post_id: r.post_id, title: r.title }),
                  (0, D.Z)((0, I.Z)({}, t), {
                    popup: (0, D.Z)((0, I.Z)({}, t.popup), {
                      redeemFinancingSolution: i,
                    }),
                  })
                );
              default:
                return t;
            }
          },
          memberListing: function () {
            var t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : W,
              e = arguments.length > 1 ? arguments[1] : void 0,
              n = e.type,
              r = e.payload;
            switch (n) {
              case "member/listing/setList":
                return (0, D.Z)((0, I.Z)({}, t), {
                  listings: r.map(function (t) {
                    return {
                      listing_id: t.listing_id,
                      tier_id: t.tier_id,
                      tier: t.tier,
                      title: t.title,
                      email: t.email,
                      phoneNumber: t.phone_number,
                      logoUrl: t.logo_url,
                      status: t.status,
                      step: { isFinished: t.step.is_finished },
                    };
                  }),
                });
              case "member/listing/setDetail":
                return (0, D.Z)((0, I.Z)({}, t), {
                  listing: {
                    listing_id: r.listing_id,
                    title: r.title,
                    tier: r.tier,
                    logoUrl: r.logo_url,
                    step: { isFinished: r.step.is_finished },
                  },
                });
              case "member/listing/clearDetail":
                return (0, D.Z)((0, I.Z)({}, t), { listing: W.listing });
              case "member/listing/masterfile/setData":
                return (0, D.Z)((0, I.Z)({}, t), {
                  masterFile: {
                    tier: r.tier,
                    category: r.category,
                    country: r.country,
                    businessHours: r.business_hours,
                  },
                });
              default:
                return t;
            }
          },
          memberListingOffer: function () {
            var t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : H,
              e = arguments.length > 1 ? arguments[1] : void 0,
              n = e.type,
              r = e.payload;
            switch (n) {
              case "member/listing/offer/setList":
                return (0, D.Z)((0, I.Z)({}, t), {
                  offers: r.map(function (t) {
                    return {
                      offer_id: t.offer_id,
                      title: t.title,
                      slug: t.slug,
                      price: t.price,
                      description: t.description,
                      imageUrl: t.image_url,
                      status: t.status,
                      createdAt: t.created_at,
                    };
                  }),
                });
              case "member/listing/offer/setDetail":
                return (0, D.Z)((0, I.Z)({}, t), {
                  offer: {
                    offer_id: r.offer_id,
                    title: r.title,
                    slug: r.slug,
                    subTitle: r.sub_title,
                    price: r.price,
                    discountedPrice: r.discounted_price,
                    description: r.description,
                    content: r.content,
                    imageUrl: r.image_url,
                    bannerUrl: r.banner_url,
                    hasDiscount: r.has_discount,
                    status: r.status,
                    createdAt: r.created_at,
                  },
                });
              case "member/listing/offer/submission/list/setList":
                return (0, D.Z)((0, I.Z)({}, t), {
                  inbox: (0, D.Z)((0, I.Z)({}, t.inbox), {
                    submission: (0, D.Z)((0, I.Z)({}, t.inbox.submission), {
                      totalMessages: r.pagination.total_submissions,
                      totalPages: r.pagination.total_pages,
                      hasMore: r.pagination.has_more,
                      messages: r.submissions.map(function (t) {
                        return {
                          submission_id: t.submission_id,
                          firstName: t.first_name,
                          lastName: t.last_name,
                          phoneNumber: t.phone_number,
                          email: t.email,
                          isNew: t.is_new,
                          isImportant: t.is_important,
                          isTrash: t.is_trash,
                          status: t.status,
                          createdAt: t.created_at,
                          labels: t.labels.map(function (t) {
                            return {
                              label_id: t.label_id,
                              name: t.name,
                              color: t.color,
                            };
                          }),
                        };
                      }),
                    }),
                    filter: (0, D.Z)((0, I.Z)({}, t.inbox.filter), {
                      label: r.filter.labels,
                    }),
                  }),
                });
              case "member/listing/offer/submission/list/setSelectedList":
                return (0, D.Z)((0, I.Z)({}, t), {
                  inbox: (0, D.Z)((0, I.Z)({}, t.inbox), {
                    submission: (0, D.Z)((0, I.Z)({}, t.inbox.submission), {
                      selectedMessages: r,
                    }),
                  }),
                });
              case "member/listing/offer/submission/list/setRead":
                return (0, D.Z)((0, I.Z)({}, t), {
                  inbox: (0, D.Z)((0, I.Z)({}, t.inbox), {
                    submission: (0, D.Z)((0, I.Z)({}, t.inbox.submission), {
                      messages: t.inbox.submission.messages.map(function (t) {
                        var e = t.isNew;
                        return (
                          r.includes(t.submission_id) && (e = !1),
                          (0, D.Z)((0, I.Z)({}, t), { isNew: e })
                        );
                      }),
                    }),
                  }),
                });
              case "member/listing/offer/submission/list/setImportant":
                return (0, D.Z)((0, I.Z)({}, t), {
                  inbox: (0, D.Z)((0, I.Z)({}, t.inbox), {
                    submission: (0, D.Z)((0, I.Z)({}, t.inbox.submission), {
                      messages: t.inbox.submission.messages.map(function (t) {
                        var e = t.isImportant;
                        return (
                          t.submission_id == r && (e = !t.isImportant),
                          (0, D.Z)((0, I.Z)({}, t), { isImportant: e })
                        );
                      }),
                    }),
                  }),
                });
              case "member/listing/offer/submission/setDetail":
                return (0, D.Z)((0, I.Z)({}, t), {
                  inbox: (0, D.Z)((0, I.Z)({}, t.inbox), {
                    submission: (0, D.Z)((0, I.Z)({}, t.inbox.submission), {
                      message: (0, D.Z)(
                        (0, I.Z)({}, t.inbox.submission.message),
                        {
                          submission_id: r.submission_id,
                          firstName: r.first_name,
                          lastName: r.last_name,
                          phoneNumber: r.phone_number,
                          email: r.email,
                          isImportant: r.is_important,
                        }
                      ),
                    }),
                  }),
                });
              case "member/listing/offer/submission/comment/setList":
                return (0, D.Z)((0, I.Z)({}, t), {
                  inbox: (0, D.Z)((0, I.Z)({}, t.inbox), {
                    submission: (0, D.Z)((0, I.Z)({}, t.inbox.submission), {
                      message: (0, D.Z)(
                        (0, I.Z)({}, t.inbox.submission.message),
                        {
                          comments: r.map(function (t) {
                            return {
                              comment_id: t.comment_id,
                              name: t.name,
                              message: t.message,
                              messageRaw: t.message_raw,
                              createdAt: t.created_at,
                            };
                          }),
                        }
                      ),
                    }),
                  }),
                });
              case "member/listing/offer/clearList":
                return (0, D.Z)((0, I.Z)({}, t), { offers: H.offers });
              case "member/listing/offer/clearDetail":
                return (0, D.Z)((0, I.Z)({}, t), { offer: H.offer });
              case "member/listing/offer/clearSelectedList":
                return (0, D.Z)((0, I.Z)({}, t), {
                  inbox: (0, D.Z)((0, I.Z)({}, t.inbox), {
                    submission: (0, D.Z)((0, I.Z)({}, t.inbox.submission), {
                      selectedMessages: H.inbox.submission.selectedMessages,
                    }),
                  }),
                });
              case "member/listing/offer/masterfile/setData":
                return (0, D.Z)((0, I.Z)({}, t), { masterFile: {} });
              default:
                return t;
            }
          },
          memberListingConsultation: function () {
            var t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : X,
              e = arguments.length > 1 ? arguments[1] : void 0,
              n = e.type,
              r = e.payload;
            switch (n) {
              case "member/listing/consultation/submission/list/setList":
                return (0, D.Z)((0, I.Z)({}, t), {
                  inbox: (0, D.Z)((0, I.Z)({}, t.inbox), {
                    submission: (0, D.Z)((0, I.Z)({}, t.inbox.submission), {
                      totalMessages: r.pagination.total_submissions,
                      totalPages: r.pagination.total_pages,
                      hasMore: r.pagination.has_more,
                      messages: r.submissions.map(function (t) {
                        return {
                          submission_id: t.submission_id,
                          firstName: t.first_name,
                          lastName: t.last_name,
                          phoneNumber: t.phone_number,
                          email: t.email,
                          interestedInFinancing: t.interested_in_financing,
                          isNew: t.is_new,
                          isImportant: t.is_important,
                          isTrash: t.is_trash,
                          createdAt: t.created_at,
                          labels: t.labels.map(function (t) {
                            return {
                              label_id: t.label_id,
                              name: t.name,
                              color: t.color,
                            };
                          }),
                        };
                      }),
                    }),
                    filter: (0, D.Z)((0, I.Z)({}, t.inbox.filter), {
                      label: r.filter.labels,
                    }),
                  }),
                });
              case "member/listing/consultation/submission/list/setSelectedList":
                return (0, D.Z)((0, I.Z)({}, t), {
                  inbox: (0, D.Z)((0, I.Z)({}, t.inbox), {
                    submission: (0, D.Z)((0, I.Z)({}, t.inbox.submission), {
                      selectedMessages: r,
                    }),
                  }),
                });
              case "member/listing/consultation/submission/list/setRead":
                return (0, D.Z)((0, I.Z)({}, t), {
                  inbox: (0, D.Z)((0, I.Z)({}, t.inbox), {
                    submission: (0, D.Z)((0, I.Z)({}, t.inbox.submission), {
                      messages: t.inbox.submission.messages.map(function (t) {
                        var e = t.isNew;
                        return (
                          r.includes(t.submission_id) && (e = !1),
                          (0, D.Z)((0, I.Z)({}, t), { isNew: e })
                        );
                      }),
                    }),
                  }),
                });
              case "member/listing/consultation/submission/list/setImportant":
                return (0, D.Z)((0, I.Z)({}, t), {
                  inbox: (0, D.Z)((0, I.Z)({}, t.inbox), {
                    submission: (0, D.Z)((0, I.Z)({}, t.inbox.submission), {
                      messages: t.inbox.submission.messages.map(function (t) {
                        var e = t.isImportant;
                        return (
                          t.submission_id == r && (e = !t.isImportant),
                          (0, D.Z)((0, I.Z)({}, t), { isImportant: e })
                        );
                      }),
                    }),
                  }),
                });
              case "member/listing/consultation/submission/setDetail":
                return (0, D.Z)((0, I.Z)({}, t), {
                  inbox: (0, D.Z)((0, I.Z)({}, t.inbox), {
                    submission: (0, D.Z)((0, I.Z)({}, t.inbox.submission), {
                      message: (0, D.Z)(
                        (0, I.Z)({}, t.inbox.submission.message),
                        {
                          submission_id: r.submission_id,
                          firstName: r.first_name,
                          lastName: r.last_name,
                          phoneNumber: r.phone_number,
                          email: r.email,
                          isImportant: r.is_important,
                        }
                      ),
                    }),
                  }),
                });
              case "member/listing/consultation/submission/comment/setList":
                return (0, D.Z)((0, I.Z)({}, t), {
                  inbox: (0, D.Z)((0, I.Z)({}, t.inbox), {
                    submission: (0, D.Z)((0, I.Z)({}, t.inbox.submission), {
                      message: (0, D.Z)(
                        (0, I.Z)({}, t.inbox.submission.message),
                        {
                          comments: r.map(function (t) {
                            return {
                              comment_id: t.comment_id,
                              name: t.name,
                              message: t.message,
                              messageRaw: t.message_raw,
                              createdAt: t.created_at,
                            };
                          }),
                        }
                      ),
                    }),
                  }),
                });
              case "member/listing/consultation/clearSelectedList":
                return (0, D.Z)((0, I.Z)({}, t), {
                  inbox: (0, D.Z)((0, I.Z)({}, t.inbox), {
                    submission: (0, D.Z)((0, I.Z)({}, t.inbox.submission), {
                      selectedMessages: X.inbox.submission.selectedMessages,
                    }),
                  }),
                });
              default:
                return t;
            }
          },
          memberListingFinancing: function () {
            var t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : K,
              e = arguments.length > 1 ? arguments[1] : void 0,
              n = e.type,
              r = e.payload;
            switch (n) {
              case "member/listing/financing/submission/list/setList":
                return (0, D.Z)((0, I.Z)({}, t), {
                  inbox: (0, D.Z)((0, I.Z)({}, t.inbox), {
                    submission: (0, D.Z)((0, I.Z)({}, t.inbox.submission), {
                      totalMessages: r.pagination.total_submissions,
                      totalPages: r.pagination.total_pages,
                      hasMore: r.pagination.has_more,
                      messages: r.submissions.map(function (t) {
                        return {
                          submission_id: t.submission_id,
                          firstName: t.first_name,
                          lastName: t.last_name,
                          phoneNumber: t.phone_number,
                          email: t.email,
                          isNew: t.is_new,
                          isImportant: t.is_important,
                          isTrash: t.is_trash,
                          status: t.status,
                          createdAt: t.created_at,
                          labels: t.labels.map(function (t) {
                            return {
                              label_id: t.label_id,
                              name: t.name,
                              color: t.color,
                            };
                          }),
                        };
                      }),
                    }),
                    filter: (0, D.Z)((0, I.Z)({}, t.inbox.filter), {
                      label: r.filter.labels,
                    }),
                  }),
                });
              case "member/listing/financing/submission/list/setSelectedList":
                return (0, D.Z)((0, I.Z)({}, t), {
                  inbox: (0, D.Z)((0, I.Z)({}, t.inbox), {
                    submission: (0, D.Z)((0, I.Z)({}, t.inbox.submission), {
                      selectedMessages: r,
                    }),
                  }),
                });
              case "member/listing/financing/submission/list/setRead":
                return (0, D.Z)((0, I.Z)({}, t), {
                  inbox: (0, D.Z)((0, I.Z)({}, t.inbox), {
                    submission: (0, D.Z)((0, I.Z)({}, t.inbox.submission), {
                      messages: t.inbox.submission.messages.map(function (t) {
                        var e = t.isNew;
                        return (
                          r.includes(t.submission_id) && (e = !1),
                          (0, D.Z)((0, I.Z)({}, t), { isNew: e })
                        );
                      }),
                    }),
                  }),
                });
              case "member/listing/financing/submission/list/setImportant":
                return (0, D.Z)((0, I.Z)({}, t), {
                  inbox: (0, D.Z)((0, I.Z)({}, t.inbox), {
                    submission: (0, D.Z)((0, I.Z)({}, t.inbox.submission), {
                      messages: t.inbox.submission.messages.map(function (t) {
                        var e = t.isImportant;
                        return (
                          t.submission_id == r && (e = !t.isImportant),
                          (0, D.Z)((0, I.Z)({}, t), { isImportant: e })
                        );
                      }),
                    }),
                  }),
                });
              case "member/listing/financing/submission/setDetail":
                return (0, D.Z)((0, I.Z)({}, t), {
                  inbox: (0, D.Z)((0, I.Z)({}, t.inbox), {
                    submission: (0, D.Z)((0, I.Z)({}, t.inbox.submission), {
                      message: (0, D.Z)(
                        (0, I.Z)({}, t.inbox.submission.message),
                        {
                          submission_id: r.submission_id,
                          firstName: r.first_name,
                          lastName: r.last_name,
                          phoneNumber: r.phone_number,
                          email: r.email,
                          isImportant: r.is_important,
                        }
                      ),
                    }),
                  }),
                });
              case "member/listing/financing/submission/comment/setList":
                return (0, D.Z)((0, I.Z)({}, t), {
                  inbox: (0, D.Z)((0, I.Z)({}, t.inbox), {
                    submission: (0, D.Z)((0, I.Z)({}, t.inbox.submission), {
                      message: (0, D.Z)(
                        (0, I.Z)({}, t.inbox.submission.message),
                        {
                          comments: r.map(function (t) {
                            return {
                              comment_id: t.comment_id,
                              name: t.name,
                              message: t.message,
                              messageRaw: t.message_raw,
                              createdAt: t.created_at,
                            };
                          }),
                        }
                      ),
                    }),
                  }),
                });
              case "member/listing/financing/clearSelectedList":
                return (0, D.Z)((0, I.Z)({}, t), {
                  inbox: (0, D.Z)((0, I.Z)({}, t.inbox), {
                    submission: (0, D.Z)((0, I.Z)({}, t.inbox.submission), {
                      selectedMessages: K.inbox.submission.selectedMessages,
                    }),
                  }),
                });
              default:
                return t;
            }
          },
          memberListingStep: function () {
            var t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : Y,
              e = arguments.length > 1 ? arguments[1] : void 0,
              n = e.type,
              r = e.payload;
            switch (n) {
              case "member/listing/step/setDetail":
                return (0, D.Z)((0, I.Z)({}, t), { step: r });
              case "member/listing/step/setCurrentDetail":
                return (0, D.Z)((0, I.Z)({}, t), {
                  step: (0, D.Z)((0, I.Z)({}, t.step), { current: r }),
                });
              case "member/listing/step/setStepCompletedDetail":
                return (0, D.Z)((0, I.Z)({}, t), {
                  step: (0, D.Z)((0, I.Z)({}, t.step), { completed: r }),
                });
              case "member/listing/step/listing/setListingDetail":
                var i, o, s, a, l, c, u;
                return (0, D.Z)((0, I.Z)({}, t), {
                  listing: {
                    listing_id: r.listing_id,
                    tier: {
                      tier_id: r.tier.tier_id,
                      name: r.tier.name,
                      slug: r.tier.slug,
                    },
                    title: r.title,
                    content: r.content,
                    phoneNumber: r.phone_number,
                    email: r.email,
                    offerInformation: r.offer_information,
                    businessHours: r.business_hours,
                    websiteUrl: r.url.website_url,
                    facebookUrl: r.url.facebook_url,
                    linkedinUrl: r.url.linkedin_url,
                    instagramUrl: r.url.instagram_url,
                    tiktokUrl: r.url.tiktok_url,
                    twitterUrl: r.url.twitter_url,
                    yelpUrl: r.url.yelp_url,
                    googleMyBusinessUrl: r.url.google_my_business_url,
                    pinterestUrl: r.url.pinterest_url,
                    youtubeUrl: r.url.youtube_url,
                    financingUrl: r.url.financing_url,
                    bannerDescription: r.banner_description,
                    banner: r.banner_url,
                    bannerColor: r.banner_color,
                    media: r.media.map(function (t) {
                      return {
                        media_id: t.media_id,
                        title: t.title,
                        imageUrl: t.image_url,
                        position: t.position,
                      };
                    }),
                    externalVideoUrl: r.external_video_url,
                    video: r.video_url,
                    location: r.location.map(function (t) {
                      return {
                        location_id: t.location_id,
                        country_id: t.country_id,
                        state_id: t.state_id,
                        city_id: t.city_id,
                        phoneNumber: t.phone_number,
                        addressLineOne: t.address_line_1,
                        markerContent: t.marker_content,
                        postalCode: t.postal_code,
                        latitude: t.latitude,
                        longitude: t.longitude,
                      };
                    }),
                    logo: r.logo_url,
                    category: r.category.map(function (t) {
                      return t.category_id;
                    }),
                    hasDiscount: !!r.has_discount,
                    freeOffer: {
                      offer_id:
                        null === (i = r.free_offer) || void 0 === i
                          ? void 0
                          : i.offer_id,
                      title:
                        null === (o = r.free_offer) || void 0 === o
                          ? void 0
                          : o.title,
                    },
                    paidOffer: {
                      offer_id:
                        null === (s = r.paid_offer) || void 0 === s
                          ? void 0
                          : s.offer_id,
                      title:
                        null === (a = r.paid_offer) || void 0 === a
                          ? void 0
                          : a.title,
                      subtitle:
                        null === (l = r.paid_offer) || void 0 === l
                          ? void 0
                          : l.sub_title,
                      price:
                        null === (c = r.paid_offer) || void 0 === c
                          ? void 0
                          : c.price,
                      description:
                        null === (u = r.paid_offer) || void 0 === u
                          ? void 0
                          : u.description,
                    },
                  },
                });
              case "member/listing/step/listing/resetDetail":
                return (0, D.Z)((0, I.Z)({}, t), { listing: Y.listing });
              case "member/listing/step/listing/masterfile/setData":
                return (0, D.Z)((0, I.Z)({}, t), {
                  masterFile: {
                    category: r.category,
                    country: r.country,
                    businessHours: r.business_hours,
                  },
                });
              case "member/listing/step/listing/masterfile/setOfferData":
                return (0, D.Z)((0, I.Z)({}, t), {
                  masterFile: (0, D.Z)((0, I.Z)({}, t.masterFile), {
                    offers: r,
                  }),
                });
              case "member/listing/step/listing/masterfile/resetData":
                return (0, D.Z)((0, I.Z)({}, t), { masterFile: Y.masterFile });
              default:
                return t;
            }
          },
          memberRegistration: function () {
            var t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : Q,
              e = arguments.length > 1 ? arguments[1] : void 0,
              n = e.type,
              r = e.payload;
            switch (n) {
              case "member/registration/tier/setDetail":
                return (0, D.Z)((0, I.Z)({}, t), { tier: r });
              case "member/registration/step/setDetail":
                return (0, D.Z)((0, I.Z)({}, t), { step: r });
              case "member/registration/step/setCurrentDetail":
                return (0, D.Z)((0, I.Z)({}, t), {
                  step: (0, D.Z)((0, I.Z)({}, t.step), { current: r }),
                });
              case "member/registration/step/setStepCompletedDetail":
                return (0, D.Z)((0, I.Z)({}, t), {
                  step: (0, D.Z)((0, I.Z)({}, t.step), { completed: r }),
                });
              case "member/registration/listing/setListingDetail":
                return (0, D.Z)((0, I.Z)({}, t), {
                  listing: {
                    listing_id: r.listing_id,
                    title: r.title,
                    content: r.content,
                    phoneNumber: r.phone_number,
                    email: r.email,
                    offerInformation: r.offer_information,
                    businessHours: r.business_hours,
                    websiteUrl: r.url.website_url,
                    facebookUrl: r.url.facebook_url,
                    linkedinUrl: r.url.linkedin_url,
                    instagramUrl: r.url.instagram_url,
                    tiktokUrl: r.url.tiktok_url,
                    twitterUrl: r.url.twitter_url,
                    yelpUrl: r.url.yelp_url,
                    googleMyBusinessUrl: r.url.google_my_business_url,
                    pinterestUrl: r.url.pinterest_url,
                    youtubeUrl: r.url.youtube_url,
                    financingUrl: r.url.financing_url,
                    bannerDescription: r.banner_description,
                    banner: r.banner_url,
                    bannerColor: r.banner_color,
                    media: r.media.map(function (t) {
                      return {
                        media_id: t.media_id,
                        title: t.title,
                        imageUrl: t.image_url,
                        position: t.position,
                      };
                    }),
                    externalVideoUrl: r.external_video_url,
                    video: r.video_url,
                    location: r.location.map(function (t) {
                      return {
                        location_id: t.location_id,
                        country_id: t.country_id,
                        state_id: t.state_id,
                        city_id: t.city_id,
                        phoneNumber: t.phone_number,
                        addressLineOne: t.address_line_1,
                        markerContent: t.marker_content,
                        postalCode: t.postal_code,
                        latitude: t.latitude,
                        longitude: t.longitude,
                      };
                    }),
                    logo: r.logo_url,
                    category: r.category.map(function (t) {
                      return t.category_id;
                    }),
                    hasDiscount: !!r.has_discount,
                  },
                });
              case "member/registration/listing/resetDetail":
                return (0, D.Z)((0, I.Z)({}, t), { listing: Q.listing });
              case "member/registration/listing/masterfile/setData":
                return (0, D.Z)((0, I.Z)({}, t), {
                  masterFile: {
                    category: r.category,
                    country: r.country,
                    businessHours: r.business_hours,
                  },
                });
              case "member/registration/listing/masterfile/resetData":
                return (0, D.Z)((0, I.Z)({}, t), { masterFile: Q.masterFile });
              default:
                return t;
            }
          },
          searchHistory: function () {
            var t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : tt,
              e = arguments.length > 1 ? arguments[1] : void 0,
              n = e.type,
              r = e.payload;
            if ("location/setHistory" === n) {
              var i = t.location;
              return (
                (i = i.filter(function (t) {
                  return t.location_id != r.location_id;
                })).length >= 4 && i.shift(),
                (0, D.Z)((0, I.Z)({}, t), { location: (0, J.Z)(i).concat([r]) })
              );
            }
            return t;
          },
          pageState: function () {
            var t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : nt,
              e = arguments.length > 1 ? arguments[1] : void 0,
              n = e.type,
              r = e.payload;
            switch (n) {
              case et.Qc:
                return (0, D.Z)((0, I.Z)({}, t), {
                  listings: (0, D.Z)((0, I.Z)({}, t.listings), {
                    filterFormSubmitting: r,
                  }),
                });
              case et.ai:
                return (0, D.Z)((0, I.Z)({}, t), {
                  listings: (0, D.Z)((0, I.Z)({}, t.listings), {
                    dataBounds: r,
                  }),
                });
              case et.uu:
                return (0, D.Z)((0, I.Z)({}, t), {
                  listings: (0, D.Z)((0, I.Z)({}, t.listings), {
                    selectedListing: r,
                  }),
                });
              case et.qF:
                return (0, D.Z)((0, I.Z)({}, t), {
                  listings: (0, D.Z)((0, I.Z)({}, t.listings), {
                    selectedListing: void 0,
                  }),
                });
              case et.L5:
                return (0, D.Z)((0, I.Z)({}, t), {
                  listings: (0, D.Z)((0, I.Z)({}, t.listings), {
                    viewport: (0, I.Z)({}, t.listings.viewport, r),
                  }),
                });
              case et.Fi:
                return (0, D.Z)((0, I.Z)({}, t), {
                  listings: (0, D.Z)((0, I.Z)({}, t.listings), {
                    viewport: {
                      latitude: 37.0902,
                      longitude: -97.7129,
                      width: "100%",
                      height: "100%",
                      zoom: 3.6,
                    },
                  }),
                });
              case et.PX:
                return (0, D.Z)((0, I.Z)({}, t), {
                  promotions: { popupScheduleDemo: !0 },
                });
              case et.Hj:
                return (0, D.Z)((0, I.Z)({}, t), {
                  promotions: { popupScheduleDemo: !1 },
                });
              default:
                return t;
            }
          },
        }),
        it = function () {
          return T(
            {
              key: "nextjs",
              whitelist: ["user", "searchHistory"],
              storage: n(76734).Z,
            },
            rt
          );
        };
      function ot(t) {
        return function (e) {
          var n = e.dispatch,
            r = e.getState;
          return function (e) {
            return function (i) {
              return "function" === typeof i ? i(n, r, t) : e(i);
            };
          };
        };
      }
      var st = ot();
      st.withExtraArgument = ot;
      var at = st,
        lt = (0, r.applyMiddleware)(at),
        ct = (function () {
          var t = (0, i.Uo)({ trace: !0, traceLimit: 25 }),
            e = (0, r.createStore)(it(), t(lt));
          return (
            (e.__persistor = (function (t, e, n) {
              var i = n || !1,
                o = (0, r.createStore)(
                  k,
                  O,
                  e && e.enhancer ? e.enhancer : void 0
                ),
                p = function (t) {
                  o.dispatch({ type: h, key: t });
                },
                d = function (e, n, r) {
                  var s = { type: a, payload: n, err: r, key: e };
                  t.dispatch(s),
                    o.dispatch(s),
                    i && f.getState().bootstrapped && (i(), (i = !1));
                },
                f = P({}, o, {
                  purge: function () {
                    var e = [];
                    return (
                      t.dispatch({
                        type: u,
                        result: function (t) {
                          e.push(t);
                        },
                      }),
                      Promise.all(e)
                    );
                  },
                  flush: function () {
                    var e = [];
                    return (
                      t.dispatch({
                        type: s,
                        result: function (t) {
                          e.push(t);
                        },
                      }),
                      Promise.all(e)
                    );
                  },
                  pause: function () {
                    t.dispatch({ type: l });
                  },
                  persist: function () {
                    t.dispatch({ type: c, register: p, rehydrate: d });
                  },
                });
              return (e && e.manualPersist) || f.persist(), f;
            })(e)),
            e
          );
        })();
    },
    84910: function (t, e, n) {
      "use strict";
      n.d(e, {
        c: function () {
          return i;
        },
        y: function () {
          return o;
        },
      });
      var r = n(83208);
      function i(t) {
        return { type: r.e, payload: t };
      }
      function o() {
        return { type: r.Z };
      }
    },
    83208: function (t, e, n) {
      "use strict";
      n.d(e, {
        Z: function () {
          return i;
        },
        e: function () {
          return r;
        },
      });
      var r = "SHOW_NOTIFICATION",
        i = "HIDE_NOTIFICATION";
    },
    31046: function (t, e, n) {
      "use strict";
      n.d(e, {
        Fi: function () {
          return l;
        },
        Hj: function () {
          return u;
        },
        L5: function () {
          return a;
        },
        PX: function () {
          return c;
        },
        Qc: function () {
          return r;
        },
        ai: function () {
          return i;
        },
        qF: function () {
          return s;
        },
        uu: function () {
          return o;
        },
      });
      var r = "LISTINGS_UPDATE_FILTER_FORM_SUBMITTING",
        i = "LISTINGS_UPDATE_DATABOUNDS",
        o = "LISTINGS_OPEN_SELECTED_LISTING",
        s = "LISTINGS_CLOSE_SELECTED_LISTING",
        a = "LISTINGS_UPDATE_VIEWPORT",
        l = "LISTINGS_RESET_VIEWPORT",
        c = "PROMOTIONS_OPEN_POPUP_SCHEDULE_DEMO",
        u = "PROMOTIONS_CLOSE_POPUP_SCHEDULE_DEMO";
    },
    62709: function (t, e, n) {
      "use strict";
      function r(t) {
        return { type: "auth/verify", payload: t };
      }
      function i(t) {
        return { type: "auth/login", payload: t };
      }
      function o() {
        return { type: "auth/logout" };
      }
      n.d(e, {
        No: function () {
          return r;
        },
        bg: function () {
          return o;
        },
        eU: function () {
          return i;
        },
      });
    },
    70293: function (t, e, n) {
      "use strict";
      n.d(e, {
        Z: function () {
          return c;
        },
      });
      var r = n(51438),
        i = n(52951),
        o = n(76489);
      function s(t, e) {
        void 0 === e && (e = {});
        var n = (function (t) {
          if (t && "j" === t[0] && ":" === t[1]) return t.substr(2);
          return t;
        })(t);
        if (
          (function (t, e) {
            return (
              "undefined" === typeof e &&
                (e = !t || ("{" !== t[0] && "[" !== t[0] && '"' !== t[0])),
              !e
            );
          })(n, e.doNotParse)
        )
          try {
            return JSON.parse(n);
          } catch (r) {}
        return t;
      }
      var a = function () {
          return (
            (a =
              Object.assign ||
              function (t) {
                for (var e, n = 1, r = arguments.length; n < r; n++)
                  for (var i in (e = arguments[n]))
                    Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
                return t;
              }),
            a.apply(this, arguments)
          );
        },
        l = new ((function () {
          function t(t, e) {
            var n = this;
            (this.changeListeners = []),
              (this.HAS_DOCUMENT_COOKIE = !1),
              (this.cookies = (function (t, e) {
                return "string" === typeof t
                  ? o.Q(t, e)
                  : "object" === typeof t && null !== t
                  ? t
                  : {};
              })(t, e)),
              new Promise(function () {
                n.HAS_DOCUMENT_COOKIE =
                  "object" === typeof document &&
                  "string" === typeof document.cookie;
              }).catch(function () {});
          }
          return (
            (t.prototype._updateBrowserValues = function (t) {
              this.HAS_DOCUMENT_COOKIE &&
                (this.cookies = o.Q(document.cookie, t));
            }),
            (t.prototype._emitChange = function (t) {
              for (var e = 0; e < this.changeListeners.length; ++e)
                this.changeListeners[e](t);
            }),
            (t.prototype.get = function (t, e, n) {
              return (
                void 0 === e && (e = {}),
                this._updateBrowserValues(n),
                s(this.cookies[t], e)
              );
            }),
            (t.prototype.getAll = function (t, e) {
              void 0 === t && (t = {}), this._updateBrowserValues(e);
              var n = {};
              for (var r in this.cookies) n[r] = s(this.cookies[r], t);
              return n;
            }),
            (t.prototype.set = function (t, e, n) {
              var r;
              "object" === typeof e && (e = JSON.stringify(e)),
                (this.cookies = a(a({}, this.cookies), (((r = {})[t] = e), r))),
                this.HAS_DOCUMENT_COOKIE && (document.cookie = o.q(t, e, n)),
                this._emitChange({ name: t, value: e, options: n });
            }),
            (t.prototype.remove = function (t, e) {
              var n = (e = a(a({}, e), {
                expires: new Date(1970, 1, 1, 0, 0, 1),
                maxAge: 0,
              }));
              (this.cookies = a({}, this.cookies)),
                delete this.cookies[t],
                this.HAS_DOCUMENT_COOKIE && (document.cookie = o.q(t, "", n)),
                this._emitChange({ name: t, value: void 0, options: e });
            }),
            (t.prototype.addChangeListener = function (t) {
              this.changeListeners.push(t);
            }),
            (t.prototype.removeChangeListener = function (t) {
              var e = this.changeListeners.indexOf(t);
              e >= 0 && this.changeListeners.splice(e, 1);
            }),
            t
          );
        })())(),
        c = new ((function () {
          function t() {
            (0, r.Z)(this, t);
          }
          return (
            (0, i.Z)(t, [
              {
                key: "get",
                value: function (t) {
                  return l.get(t);
                },
              },
              {
                key: "getAll",
                value: function () {
                  return l.getAll();
                },
              },
              {
                key: "set",
                value: function (t, e, n) {
                  l.set(t, e, n);
                },
              },
              {
                key: "remove",
                value: function (t) {
                  l.remove(t);
                },
              },
            ]),
            t
          );
        })())();
    },
    21232: function (t, e, n) {
      "use strict";
      var r = n(47568),
        i = n(20414),
        o = n(9669),
        s = n.n(o),
        a = (n(70293), n(76915)),
        l = n(84910),
        c = n(62709);
      (s().defaults.baseURL = "https://api.bluepagespro.com/api"),
        (s().defaults.withCredentials = !0),
        (s().defaults.headers.common.Accept = "application/json"),
        (s().defaults.headers.common["X-Requested-With"] = "XMLHttpRequest"),
        s().interceptors.response.use(
          function (t) {
            return t;
          },
          (function () {
            var t = (0, r.Z)(function (t) {
              var e;
              return (0, i.__generator)(this, function (n) {
                switch (n.label) {
                  case 0:
                    return [401, 403, 419].includes(
                      null === t ||
                        void 0 === t ||
                        null === (e = t.response) ||
                        void 0 === e
                        ? void 0
                        : e.status
                    )
                      ? [
                          4,
                          a.h.dispatch(
                            (0, l.c)({
                              status: "error",
                              message: "Session expired, please log in again.",
                            })
                          ),
                        ]
                      : [3, 3];
                  case 1:
                    return n.sent(), [4, a.h.dispatch((0, c.bg)())];
                  case 2:
                    n.sent(), (n.label = 3);
                  case 3:
                    return [2, Promise.reject(t)];
                }
              });
            });
            return function (e) {
              return t.apply(this, arguments);
            };
          })()
        ),
        (e.Z = s());
    },
    21876: function (t) {
      !(function () {
        var e = {
            675: function (t, e) {
              "use strict";
              (e.byteLength = function (t) {
                var e = l(t),
                  n = e[0],
                  r = e[1];
                return (3 * (n + r)) / 4 - r;
              }),
                (e.toByteArray = function (t) {
                  var e,
                    n,
                    o = l(t),
                    s = o[0],
                    a = o[1],
                    c = new i(
                      (function (t, e, n) {
                        return (3 * (e + n)) / 4 - n;
                      })(0, s, a)
                    ),
                    u = 0,
                    h = a > 0 ? s - 4 : s;
                  for (n = 0; n < h; n += 4)
                    (e =
                      (r[t.charCodeAt(n)] << 18) |
                      (r[t.charCodeAt(n + 1)] << 12) |
                      (r[t.charCodeAt(n + 2)] << 6) |
                      r[t.charCodeAt(n + 3)]),
                      (c[u++] = (e >> 16) & 255),
                      (c[u++] = (e >> 8) & 255),
                      (c[u++] = 255 & e);
                  2 === a &&
                    ((e =
                      (r[t.charCodeAt(n)] << 2) |
                      (r[t.charCodeAt(n + 1)] >> 4)),
                    (c[u++] = 255 & e));
                  1 === a &&
                    ((e =
                      (r[t.charCodeAt(n)] << 10) |
                      (r[t.charCodeAt(n + 1)] << 4) |
                      (r[t.charCodeAt(n + 2)] >> 2)),
                    (c[u++] = (e >> 8) & 255),
                    (c[u++] = 255 & e));
                  return c;
                }),
                (e.fromByteArray = function (t) {
                  for (
                    var e,
                      r = t.length,
                      i = r % 3,
                      o = [],
                      s = 16383,
                      a = 0,
                      l = r - i;
                    a < l;
                    a += s
                  )
                    o.push(u(t, a, a + s > l ? l : a + s));
                  1 === i
                    ? ((e = t[r - 1]),
                      o.push(n[e >> 2] + n[(e << 4) & 63] + "=="))
                    : 2 === i &&
                      ((e = (t[r - 2] << 8) + t[r - 1]),
                      o.push(
                        n[e >> 10] + n[(e >> 4) & 63] + n[(e << 2) & 63] + "="
                      ));
                  return o.join("");
                });
              for (
                var n = [],
                  r = [],
                  i = "undefined" !== typeof Uint8Array ? Uint8Array : Array,
                  o =
                    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                  s = 0,
                  a = o.length;
                s < a;
                ++s
              )
                (n[s] = o[s]), (r[o.charCodeAt(s)] = s);
              function l(t) {
                var e = t.length;
                if (e % 4 > 0)
                  throw new Error(
                    "Invalid string. Length must be a multiple of 4"
                  );
                var n = t.indexOf("=");
                return -1 === n && (n = e), [n, n === e ? 0 : 4 - (n % 4)];
              }
              function c(t) {
                return (
                  n[(t >> 18) & 63] +
                  n[(t >> 12) & 63] +
                  n[(t >> 6) & 63] +
                  n[63 & t]
                );
              }
              function u(t, e, n) {
                for (var r, i = [], o = e; o < n; o += 3)
                  (r =
                    ((t[o] << 16) & 16711680) +
                    ((t[o + 1] << 8) & 65280) +
                    (255 & t[o + 2])),
                    i.push(c(r));
                return i.join("");
              }
              (r["-".charCodeAt(0)] = 62), (r["_".charCodeAt(0)] = 63);
            },
            72: function (t, e, n) {
              "use strict";
              var r = n(675),
                i = n(783),
                o =
                  "function" === typeof Symbol &&
                  "function" === typeof Symbol.for
                    ? Symbol.for("nodejs.util.inspect.custom")
                    : null;
              (e.Buffer = l),
                (e.SlowBuffer = function (t) {
                  +t != t && (t = 0);
                  return l.alloc(+t);
                }),
                (e.INSPECT_MAX_BYTES = 50);
              var s = 2147483647;
              function a(t) {
                if (t > s)
                  throw new RangeError(
                    'The value "' + t + '" is invalid for option "size"'
                  );
                var e = new Uint8Array(t);
                return Object.setPrototypeOf(e, l.prototype), e;
              }
              function l(t, e, n) {
                if ("number" === typeof t) {
                  if ("string" === typeof e)
                    throw new TypeError(
                      'The "string" argument must be of type string. Received type number'
                    );
                  return h(t);
                }
                return c(t, e, n);
              }
              function c(t, e, n) {
                if ("string" === typeof t)
                  return (function (t, e) {
                    ("string" === typeof e && "" !== e) || (e = "utf8");
                    if (!l.isEncoding(e))
                      throw new TypeError("Unknown encoding: " + e);
                    var n = 0 | m(t, e),
                      r = a(n),
                      i = r.write(t, e);
                    i !== n && (r = r.slice(0, i));
                    return r;
                  })(t, e);
                if (ArrayBuffer.isView(t)) return p(t);
                if (null == t)
                  throw new TypeError(
                    "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                      typeof t
                  );
                if (Z(t, ArrayBuffer) || (t && Z(t.buffer, ArrayBuffer)))
                  return d(t, e, n);
                if (
                  "undefined" !== typeof SharedArrayBuffer &&
                  (Z(t, SharedArrayBuffer) ||
                    (t && Z(t.buffer, SharedArrayBuffer)))
                )
                  return d(t, e, n);
                if ("number" === typeof t)
                  throw new TypeError(
                    'The "value" argument must not be of type number. Received type number'
                  );
                var r = t.valueOf && t.valueOf();
                if (null != r && r !== t) return l.from(r, e, n);
                var i = (function (t) {
                  if (l.isBuffer(t)) {
                    var e = 0 | f(t.length),
                      n = a(e);
                    return 0 === n.length || t.copy(n, 0, 0, e), n;
                  }
                  if (void 0 !== t.length)
                    return "number" !== typeof t.length || V(t.length)
                      ? a(0)
                      : p(t);
                  if ("Buffer" === t.type && Array.isArray(t.data))
                    return p(t.data);
                })(t);
                if (i) return i;
                if (
                  "undefined" !== typeof Symbol &&
                  null != Symbol.toPrimitive &&
                  "function" === typeof t[Symbol.toPrimitive]
                )
                  return l.from(t[Symbol.toPrimitive]("string"), e, n);
                throw new TypeError(
                  "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                    typeof t
                );
              }
              function u(t) {
                if ("number" !== typeof t)
                  throw new TypeError('"size" argument must be of type number');
                if (t < 0)
                  throw new RangeError(
                    'The value "' + t + '" is invalid for option "size"'
                  );
              }
              function h(t) {
                return u(t), a(t < 0 ? 0 : 0 | f(t));
              }
              function p(t) {
                for (
                  var e = t.length < 0 ? 0 : 0 | f(t.length), n = a(e), r = 0;
                  r < e;
                  r += 1
                )
                  n[r] = 255 & t[r];
                return n;
              }
              function d(t, e, n) {
                if (e < 0 || t.byteLength < e)
                  throw new RangeError('"offset" is outside of buffer bounds');
                if (t.byteLength < e + (n || 0))
                  throw new RangeError('"length" is outside of buffer bounds');
                var r;
                return (
                  (r =
                    void 0 === e && void 0 === n
                      ? new Uint8Array(t)
                      : void 0 === n
                      ? new Uint8Array(t, e)
                      : new Uint8Array(t, e, n)),
                  Object.setPrototypeOf(r, l.prototype),
                  r
                );
              }
              function f(t) {
                if (t >= s)
                  throw new RangeError(
                    "Attempt to allocate Buffer larger than maximum size: 0x" +
                      s.toString(16) +
                      " bytes"
                  );
                return 0 | t;
              }
              function m(t, e) {
                if (l.isBuffer(t)) return t.length;
                if (ArrayBuffer.isView(t) || Z(t, ArrayBuffer))
                  return t.byteLength;
                if ("string" !== typeof t)
                  throw new TypeError(
                    'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
                      typeof t
                  );
                var n = t.length,
                  r = arguments.length > 2 && !0 === arguments[2];
                if (!r && 0 === n) return 0;
                for (var i = !1; ; )
                  switch (e) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                      return n;
                    case "utf8":
                    case "utf-8":
                      return N(t).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return 2 * n;
                    case "hex":
                      return n >>> 1;
                    case "base64":
                      return j(t).length;
                    default:
                      if (i) return r ? -1 : N(t).length;
                      (e = ("" + e).toLowerCase()), (i = !0);
                  }
              }
              function g(t, e, n) {
                var r = !1;
                if (((void 0 === e || e < 0) && (e = 0), e > this.length))
                  return "";
                if (
                  ((void 0 === n || n > this.length) && (n = this.length),
                  n <= 0)
                )
                  return "";
                if ((n >>>= 0) <= (e >>>= 0)) return "";
                for (t || (t = "utf8"); ; )
                  switch (t) {
                    case "hex":
                      return k(this, e, n);
                    case "utf8":
                    case "utf-8":
                      return C(this, e, n);
                    case "ascii":
                      return M(this, e, n);
                    case "latin1":
                    case "binary":
                      return O(this, e, n);
                    case "base64":
                      return A(this, e, n);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return I(this, e, n);
                    default:
                      if (r) throw new TypeError("Unknown encoding: " + t);
                      (t = (t + "").toLowerCase()), (r = !0);
                  }
              }
              function y(t, e, n) {
                var r = t[e];
                (t[e] = t[n]), (t[n] = r);
              }
              function _(t, e, n, r, i) {
                if (0 === t.length) return -1;
                if (
                  ("string" === typeof n
                    ? ((r = n), (n = 0))
                    : n > 2147483647
                    ? (n = 2147483647)
                    : n < -2147483648 && (n = -2147483648),
                  V((n = +n)) && (n = i ? 0 : t.length - 1),
                  n < 0 && (n = t.length + n),
                  n >= t.length)
                ) {
                  if (i) return -1;
                  n = t.length - 1;
                } else if (n < 0) {
                  if (!i) return -1;
                  n = 0;
                }
                if (
                  ("string" === typeof e && (e = l.from(e, r)), l.isBuffer(e))
                )
                  return 0 === e.length ? -1 : v(t, e, n, r, i);
                if ("number" === typeof e)
                  return (
                    (e &= 255),
                    "function" === typeof Uint8Array.prototype.indexOf
                      ? i
                        ? Uint8Array.prototype.indexOf.call(t, e, n)
                        : Uint8Array.prototype.lastIndexOf.call(t, e, n)
                      : v(t, [e], n, r, i)
                  );
                throw new TypeError("val must be string, number or Buffer");
              }
              function v(t, e, n, r, i) {
                var o,
                  s = 1,
                  a = t.length,
                  l = e.length;
                if (
                  void 0 !== r &&
                  ("ucs2" === (r = String(r).toLowerCase()) ||
                    "ucs-2" === r ||
                    "utf16le" === r ||
                    "utf-16le" === r)
                ) {
                  if (t.length < 2 || e.length < 2) return -1;
                  (s = 2), (a /= 2), (l /= 2), (n /= 2);
                }
                function c(t, e) {
                  return 1 === s ? t[e] : t.readUInt16BE(e * s);
                }
                if (i) {
                  var u = -1;
                  for (o = n; o < a; o++)
                    if (c(t, o) === c(e, -1 === u ? 0 : o - u)) {
                      if ((-1 === u && (u = o), o - u + 1 === l)) return u * s;
                    } else -1 !== u && (o -= o - u), (u = -1);
                } else
                  for (n + l > a && (n = a - l), o = n; o >= 0; o--) {
                    for (var h = !0, p = 0; p < l; p++)
                      if (c(t, o + p) !== c(e, p)) {
                        h = !1;
                        break;
                      }
                    if (h) return o;
                  }
                return -1;
              }
              function b(t, e, n, r) {
                n = Number(n) || 0;
                var i = t.length - n;
                r ? (r = Number(r)) > i && (r = i) : (r = i);
                var o = e.length;
                r > o / 2 && (r = o / 2);
                for (var s = 0; s < r; ++s) {
                  var a = parseInt(e.substr(2 * s, 2), 16);
                  if (V(a)) return s;
                  t[n + s] = a;
                }
                return s;
              }
              function x(t, e, n, r) {
                return U(N(e, t.length - n), t, n, r);
              }
              function w(t, e, n, r) {
                return U(
                  (function (t) {
                    for (var e = [], n = 0; n < t.length; ++n)
                      e.push(255 & t.charCodeAt(n));
                    return e;
                  })(e),
                  t,
                  n,
                  r
                );
              }
              function S(t, e, n, r) {
                return w(t, e, n, r);
              }
              function E(t, e, n, r) {
                return U(j(e), t, n, r);
              }
              function T(t, e, n, r) {
                return U(
                  (function (t, e) {
                    for (
                      var n, r, i, o = [], s = 0;
                      s < t.length && !((e -= 2) < 0);
                      ++s
                    )
                      (r = (n = t.charCodeAt(s)) >> 8),
                        (i = n % 256),
                        o.push(i),
                        o.push(r);
                    return o;
                  })(e, t.length - n),
                  t,
                  n,
                  r
                );
              }
              function A(t, e, n) {
                return 0 === e && n === t.length
                  ? r.fromByteArray(t)
                  : r.fromByteArray(t.slice(e, n));
              }
              function C(t, e, n) {
                n = Math.min(t.length, n);
                for (var r = [], i = e; i < n; ) {
                  var o,
                    s,
                    a,
                    l,
                    c = t[i],
                    u = null,
                    h = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1;
                  if (i + h <= n)
                    switch (h) {
                      case 1:
                        c < 128 && (u = c);
                        break;
                      case 2:
                        128 === (192 & (o = t[i + 1])) &&
                          (l = ((31 & c) << 6) | (63 & o)) > 127 &&
                          (u = l);
                        break;
                      case 3:
                        (o = t[i + 1]),
                          (s = t[i + 2]),
                          128 === (192 & o) &&
                            128 === (192 & s) &&
                            (l =
                              ((15 & c) << 12) | ((63 & o) << 6) | (63 & s)) >
                              2047 &&
                            (l < 55296 || l > 57343) &&
                            (u = l);
                        break;
                      case 4:
                        (o = t[i + 1]),
                          (s = t[i + 2]),
                          (a = t[i + 3]),
                          128 === (192 & o) &&
                            128 === (192 & s) &&
                            128 === (192 & a) &&
                            (l =
                              ((15 & c) << 18) |
                              ((63 & o) << 12) |
                              ((63 & s) << 6) |
                              (63 & a)) > 65535 &&
                            l < 1114112 &&
                            (u = l);
                    }
                  null === u
                    ? ((u = 65533), (h = 1))
                    : u > 65535 &&
                      ((u -= 65536),
                      r.push(((u >>> 10) & 1023) | 55296),
                      (u = 56320 | (1023 & u))),
                    r.push(u),
                    (i += h);
                }
                return P(r);
              }
              (e.kMaxLength = s),
                (l.TYPED_ARRAY_SUPPORT = (function () {
                  try {
                    var t = new Uint8Array(1),
                      e = {
                        foo: function () {
                          return 42;
                        },
                      };
                    return (
                      Object.setPrototypeOf(e, Uint8Array.prototype),
                      Object.setPrototypeOf(t, e),
                      42 === t.foo()
                    );
                  } catch (t) {
                    return !1;
                  }
                })()),
                l.TYPED_ARRAY_SUPPORT ||
                  "undefined" === typeof console ||
                  "function" !== typeof console.error ||
                  console.error(
                    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
                  ),
                Object.defineProperty(l.prototype, "parent", {
                  enumerable: !0,
                  get: function () {
                    if (l.isBuffer(this)) return this.buffer;
                  },
                }),
                Object.defineProperty(l.prototype, "offset", {
                  enumerable: !0,
                  get: function () {
                    if (l.isBuffer(this)) return this.byteOffset;
                  },
                }),
                (l.poolSize = 8192),
                (l.from = function (t, e, n) {
                  return c(t, e, n);
                }),
                Object.setPrototypeOf(l.prototype, Uint8Array.prototype),
                Object.setPrototypeOf(l, Uint8Array),
                (l.alloc = function (t, e, n) {
                  return (function (t, e, n) {
                    return (
                      u(t),
                      t <= 0
                        ? a(t)
                        : void 0 !== e
                        ? "string" === typeof n
                          ? a(t).fill(e, n)
                          : a(t).fill(e)
                        : a(t)
                    );
                  })(t, e, n);
                }),
                (l.allocUnsafe = function (t) {
                  return h(t);
                }),
                (l.allocUnsafeSlow = function (t) {
                  return h(t);
                }),
                (l.isBuffer = function (t) {
                  return null != t && !0 === t._isBuffer && t !== l.prototype;
                }),
                (l.compare = function (t, e) {
                  if (
                    (Z(t, Uint8Array) &&
                      (t = l.from(t, t.offset, t.byteLength)),
                    Z(e, Uint8Array) && (e = l.from(e, e.offset, e.byteLength)),
                    !l.isBuffer(t) || !l.isBuffer(e))
                  )
                    throw new TypeError(
                      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
                    );
                  if (t === e) return 0;
                  for (
                    var n = t.length, r = e.length, i = 0, o = Math.min(n, r);
                    i < o;
                    ++i
                  )
                    if (t[i] !== e[i]) {
                      (n = t[i]), (r = e[i]);
                      break;
                    }
                  return n < r ? -1 : r < n ? 1 : 0;
                }),
                (l.isEncoding = function (t) {
                  switch (String(t).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return !0;
                    default:
                      return !1;
                  }
                }),
                (l.concat = function (t, e) {
                  if (!Array.isArray(t))
                    throw new TypeError(
                      '"list" argument must be an Array of Buffers'
                    );
                  if (0 === t.length) return l.alloc(0);
                  var n;
                  if (void 0 === e)
                    for (e = 0, n = 0; n < t.length; ++n) e += t[n].length;
                  var r = l.allocUnsafe(e),
                    i = 0;
                  for (n = 0; n < t.length; ++n) {
                    var o = t[n];
                    if ((Z(o, Uint8Array) && (o = l.from(o)), !l.isBuffer(o)))
                      throw new TypeError(
                        '"list" argument must be an Array of Buffers'
                      );
                    o.copy(r, i), (i += o.length);
                  }
                  return r;
                }),
                (l.byteLength = m),
                (l.prototype._isBuffer = !0),
                (l.prototype.swap16 = function () {
                  var t = this.length;
                  if (t % 2 !== 0)
                    throw new RangeError(
                      "Buffer size must be a multiple of 16-bits"
                    );
                  for (var e = 0; e < t; e += 2) y(this, e, e + 1);
                  return this;
                }),
                (l.prototype.swap32 = function () {
                  var t = this.length;
                  if (t % 4 !== 0)
                    throw new RangeError(
                      "Buffer size must be a multiple of 32-bits"
                    );
                  for (var e = 0; e < t; e += 4)
                    y(this, e, e + 3), y(this, e + 1, e + 2);
                  return this;
                }),
                (l.prototype.swap64 = function () {
                  var t = this.length;
                  if (t % 8 !== 0)
                    throw new RangeError(
                      "Buffer size must be a multiple of 64-bits"
                    );
                  for (var e = 0; e < t; e += 8)
                    y(this, e, e + 7),
                      y(this, e + 1, e + 6),
                      y(this, e + 2, e + 5),
                      y(this, e + 3, e + 4);
                  return this;
                }),
                (l.prototype.toString = function () {
                  var t = this.length;
                  return 0 === t
                    ? ""
                    : 0 === arguments.length
                    ? C(this, 0, t)
                    : g.apply(this, arguments);
                }),
                (l.prototype.toLocaleString = l.prototype.toString),
                (l.prototype.equals = function (t) {
                  if (!l.isBuffer(t))
                    throw new TypeError("Argument must be a Buffer");
                  return this === t || 0 === l.compare(this, t);
                }),
                (l.prototype.inspect = function () {
                  var t = "",
                    n = e.INSPECT_MAX_BYTES;
                  return (
                    (t = this.toString("hex", 0, n)
                      .replace(/(.{2})/g, "$1 ")
                      .trim()),
                    this.length > n && (t += " ... "),
                    "<Buffer " + t + ">"
                  );
                }),
                o && (l.prototype[o] = l.prototype.inspect),
                (l.prototype.compare = function (t, e, n, r, i) {
                  if (
                    (Z(t, Uint8Array) &&
                      (t = l.from(t, t.offset, t.byteLength)),
                    !l.isBuffer(t))
                  )
                    throw new TypeError(
                      'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                        typeof t
                    );
                  if (
                    (void 0 === e && (e = 0),
                    void 0 === n && (n = t ? t.length : 0),
                    void 0 === r && (r = 0),
                    void 0 === i && (i = this.length),
                    e < 0 || n > t.length || r < 0 || i > this.length)
                  )
                    throw new RangeError("out of range index");
                  if (r >= i && e >= n) return 0;
                  if (r >= i) return -1;
                  if (e >= n) return 1;
                  if (this === t) return 0;
                  for (
                    var o = (i >>>= 0) - (r >>>= 0),
                      s = (n >>>= 0) - (e >>>= 0),
                      a = Math.min(o, s),
                      c = this.slice(r, i),
                      u = t.slice(e, n),
                      h = 0;
                    h < a;
                    ++h
                  )
                    if (c[h] !== u[h]) {
                      (o = c[h]), (s = u[h]);
                      break;
                    }
                  return o < s ? -1 : s < o ? 1 : 0;
                }),
                (l.prototype.includes = function (t, e, n) {
                  return -1 !== this.indexOf(t, e, n);
                }),
                (l.prototype.indexOf = function (t, e, n) {
                  return _(this, t, e, n, !0);
                }),
                (l.prototype.lastIndexOf = function (t, e, n) {
                  return _(this, t, e, n, !1);
                }),
                (l.prototype.write = function (t, e, n, r) {
                  if (void 0 === e) (r = "utf8"), (n = this.length), (e = 0);
                  else if (void 0 === n && "string" === typeof e)
                    (r = e), (n = this.length), (e = 0);
                  else {
                    if (!isFinite(e))
                      throw new Error(
                        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                      );
                    (e >>>= 0),
                      isFinite(n)
                        ? ((n >>>= 0), void 0 === r && (r = "utf8"))
                        : ((r = n), (n = void 0));
                  }
                  var i = this.length - e;
                  if (
                    ((void 0 === n || n > i) && (n = i),
                    (t.length > 0 && (n < 0 || e < 0)) || e > this.length)
                  )
                    throw new RangeError(
                      "Attempt to write outside buffer bounds"
                    );
                  r || (r = "utf8");
                  for (var o = !1; ; )
                    switch (r) {
                      case "hex":
                        return b(this, t, e, n);
                      case "utf8":
                      case "utf-8":
                        return x(this, t, e, n);
                      case "ascii":
                        return w(this, t, e, n);
                      case "latin1":
                      case "binary":
                        return S(this, t, e, n);
                      case "base64":
                        return E(this, t, e, n);
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return T(this, t, e, n);
                      default:
                        if (o) throw new TypeError("Unknown encoding: " + r);
                        (r = ("" + r).toLowerCase()), (o = !0);
                    }
                }),
                (l.prototype.toJSON = function () {
                  return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0),
                  };
                });
              function P(t) {
                var e = t.length;
                if (e <= 4096) return String.fromCharCode.apply(String, t);
                for (var n = "", r = 0; r < e; )
                  n += String.fromCharCode.apply(
                    String,
                    t.slice(r, (r += 4096))
                  );
                return n;
              }
              function M(t, e, n) {
                var r = "";
                n = Math.min(t.length, n);
                for (var i = e; i < n; ++i)
                  r += String.fromCharCode(127 & t[i]);
                return r;
              }
              function O(t, e, n) {
                var r = "";
                n = Math.min(t.length, n);
                for (var i = e; i < n; ++i) r += String.fromCharCode(t[i]);
                return r;
              }
              function k(t, e, n) {
                var r = t.length;
                (!e || e < 0) && (e = 0), (!n || n < 0 || n > r) && (n = r);
                for (var i = "", o = e; o < n; ++o) i += q[t[o]];
                return i;
              }
              function I(t, e, n) {
                for (var r = t.slice(e, n), i = "", o = 0; o < r.length; o += 2)
                  i += String.fromCharCode(r[o] + 256 * r[o + 1]);
                return i;
              }
              function D(t, e, n) {
                if (t % 1 !== 0 || t < 0)
                  throw new RangeError("offset is not uint");
                if (t + e > n)
                  throw new RangeError("Trying to access beyond buffer length");
              }
              function z(t, e, n, r, i, o) {
                if (!l.isBuffer(t))
                  throw new TypeError(
                    '"buffer" argument must be a Buffer instance'
                  );
                if (e > i || e < o)
                  throw new RangeError('"value" argument is out of bounds');
                if (n + r > t.length)
                  throw new RangeError("Index out of range");
              }
              function R(t, e, n, r, i, o) {
                if (n + r > t.length)
                  throw new RangeError("Index out of range");
                if (n < 0) throw new RangeError("Index out of range");
              }
              function L(t, e, n, r, o) {
                return (
                  (e = +e),
                  (n >>>= 0),
                  o || R(t, 0, n, 4),
                  i.write(t, e, n, r, 23, 4),
                  n + 4
                );
              }
              function F(t, e, n, r, o) {
                return (
                  (e = +e),
                  (n >>>= 0),
                  o || R(t, 0, n, 8),
                  i.write(t, e, n, r, 52, 8),
                  n + 8
                );
              }
              (l.prototype.slice = function (t, e) {
                var n = this.length;
                (t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n),
                  (e = void 0 === e ? n : ~~e) < 0
                    ? (e += n) < 0 && (e = 0)
                    : e > n && (e = n),
                  e < t && (e = t);
                var r = this.subarray(t, e);
                return Object.setPrototypeOf(r, l.prototype), r;
              }),
                (l.prototype.readUIntLE = function (t, e, n) {
                  (t >>>= 0), (e >>>= 0), n || D(t, e, this.length);
                  for (var r = this[t], i = 1, o = 0; ++o < e && (i *= 256); )
                    r += this[t + o] * i;
                  return r;
                }),
                (l.prototype.readUIntBE = function (t, e, n) {
                  (t >>>= 0), (e >>>= 0), n || D(t, e, this.length);
                  for (var r = this[t + --e], i = 1; e > 0 && (i *= 256); )
                    r += this[t + --e] * i;
                  return r;
                }),
                (l.prototype.readUInt8 = function (t, e) {
                  return (t >>>= 0), e || D(t, 1, this.length), this[t];
                }),
                (l.prototype.readUInt16LE = function (t, e) {
                  return (
                    (t >>>= 0),
                    e || D(t, 2, this.length),
                    this[t] | (this[t + 1] << 8)
                  );
                }),
                (l.prototype.readUInt16BE = function (t, e) {
                  return (
                    (t >>>= 0),
                    e || D(t, 2, this.length),
                    (this[t] << 8) | this[t + 1]
                  );
                }),
                (l.prototype.readUInt32LE = function (t, e) {
                  return (
                    (t >>>= 0),
                    e || D(t, 4, this.length),
                    (this[t] | (this[t + 1] << 8) | (this[t + 2] << 16)) +
                      16777216 * this[t + 3]
                  );
                }),
                (l.prototype.readUInt32BE = function (t, e) {
                  return (
                    (t >>>= 0),
                    e || D(t, 4, this.length),
                    16777216 * this[t] +
                      ((this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3])
                  );
                }),
                (l.prototype.readIntLE = function (t, e, n) {
                  (t >>>= 0), (e >>>= 0), n || D(t, e, this.length);
                  for (var r = this[t], i = 1, o = 0; ++o < e && (i *= 256); )
                    r += this[t + o] * i;
                  return r >= (i *= 128) && (r -= Math.pow(2, 8 * e)), r;
                }),
                (l.prototype.readIntBE = function (t, e, n) {
                  (t >>>= 0), (e >>>= 0), n || D(t, e, this.length);
                  for (
                    var r = e, i = 1, o = this[t + --r];
                    r > 0 && (i *= 256);

                  )
                    o += this[t + --r] * i;
                  return o >= (i *= 128) && (o -= Math.pow(2, 8 * e)), o;
                }),
                (l.prototype.readInt8 = function (t, e) {
                  return (
                    (t >>>= 0),
                    e || D(t, 1, this.length),
                    128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
                  );
                }),
                (l.prototype.readInt16LE = function (t, e) {
                  (t >>>= 0), e || D(t, 2, this.length);
                  var n = this[t] | (this[t + 1] << 8);
                  return 32768 & n ? 4294901760 | n : n;
                }),
                (l.prototype.readInt16BE = function (t, e) {
                  (t >>>= 0), e || D(t, 2, this.length);
                  var n = this[t + 1] | (this[t] << 8);
                  return 32768 & n ? 4294901760 | n : n;
                }),
                (l.prototype.readInt32LE = function (t, e) {
                  return (
                    (t >>>= 0),
                    e || D(t, 4, this.length),
                    this[t] |
                      (this[t + 1] << 8) |
                      (this[t + 2] << 16) |
                      (this[t + 3] << 24)
                  );
                }),
                (l.prototype.readInt32BE = function (t, e) {
                  return (
                    (t >>>= 0),
                    e || D(t, 4, this.length),
                    (this[t] << 24) |
                      (this[t + 1] << 16) |
                      (this[t + 2] << 8) |
                      this[t + 3]
                  );
                }),
                (l.prototype.readFloatLE = function (t, e) {
                  return (
                    (t >>>= 0),
                    e || D(t, 4, this.length),
                    i.read(this, t, !0, 23, 4)
                  );
                }),
                (l.prototype.readFloatBE = function (t, e) {
                  return (
                    (t >>>= 0),
                    e || D(t, 4, this.length),
                    i.read(this, t, !1, 23, 4)
                  );
                }),
                (l.prototype.readDoubleLE = function (t, e) {
                  return (
                    (t >>>= 0),
                    e || D(t, 8, this.length),
                    i.read(this, t, !0, 52, 8)
                  );
                }),
                (l.prototype.readDoubleBE = function (t, e) {
                  return (
                    (t >>>= 0),
                    e || D(t, 8, this.length),
                    i.read(this, t, !1, 52, 8)
                  );
                }),
                (l.prototype.writeUIntLE = function (t, e, n, r) {
                  ((t = +t), (e >>>= 0), (n >>>= 0), r) ||
                    z(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
                  var i = 1,
                    o = 0;
                  for (this[e] = 255 & t; ++o < n && (i *= 256); )
                    this[e + o] = (t / i) & 255;
                  return e + n;
                }),
                (l.prototype.writeUIntBE = function (t, e, n, r) {
                  ((t = +t), (e >>>= 0), (n >>>= 0), r) ||
                    z(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
                  var i = n - 1,
                    o = 1;
                  for (this[e + i] = 255 & t; --i >= 0 && (o *= 256); )
                    this[e + i] = (t / o) & 255;
                  return e + n;
                }),
                (l.prototype.writeUInt8 = function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || z(this, t, e, 1, 255, 0),
                    (this[e] = 255 & t),
                    e + 1
                  );
                }),
                (l.prototype.writeUInt16LE = function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || z(this, t, e, 2, 65535, 0),
                    (this[e] = 255 & t),
                    (this[e + 1] = t >>> 8),
                    e + 2
                  );
                }),
                (l.prototype.writeUInt16BE = function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || z(this, t, e, 2, 65535, 0),
                    (this[e] = t >>> 8),
                    (this[e + 1] = 255 & t),
                    e + 2
                  );
                }),
                (l.prototype.writeUInt32LE = function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || z(this, t, e, 4, 4294967295, 0),
                    (this[e + 3] = t >>> 24),
                    (this[e + 2] = t >>> 16),
                    (this[e + 1] = t >>> 8),
                    (this[e] = 255 & t),
                    e + 4
                  );
                }),
                (l.prototype.writeUInt32BE = function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || z(this, t, e, 4, 4294967295, 0),
                    (this[e] = t >>> 24),
                    (this[e + 1] = t >>> 16),
                    (this[e + 2] = t >>> 8),
                    (this[e + 3] = 255 & t),
                    e + 4
                  );
                }),
                (l.prototype.writeIntLE = function (t, e, n, r) {
                  if (((t = +t), (e >>>= 0), !r)) {
                    var i = Math.pow(2, 8 * n - 1);
                    z(this, t, e, n, i - 1, -i);
                  }
                  var o = 0,
                    s = 1,
                    a = 0;
                  for (this[e] = 255 & t; ++o < n && (s *= 256); )
                    t < 0 && 0 === a && 0 !== this[e + o - 1] && (a = 1),
                      (this[e + o] = (((t / s) >> 0) - a) & 255);
                  return e + n;
                }),
                (l.prototype.writeIntBE = function (t, e, n, r) {
                  if (((t = +t), (e >>>= 0), !r)) {
                    var i = Math.pow(2, 8 * n - 1);
                    z(this, t, e, n, i - 1, -i);
                  }
                  var o = n - 1,
                    s = 1,
                    a = 0;
                  for (this[e + o] = 255 & t; --o >= 0 && (s *= 256); )
                    t < 0 && 0 === a && 0 !== this[e + o + 1] && (a = 1),
                      (this[e + o] = (((t / s) >> 0) - a) & 255);
                  return e + n;
                }),
                (l.prototype.writeInt8 = function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || z(this, t, e, 1, 127, -128),
                    t < 0 && (t = 255 + t + 1),
                    (this[e] = 255 & t),
                    e + 1
                  );
                }),
                (l.prototype.writeInt16LE = function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || z(this, t, e, 2, 32767, -32768),
                    (this[e] = 255 & t),
                    (this[e + 1] = t >>> 8),
                    e + 2
                  );
                }),
                (l.prototype.writeInt16BE = function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || z(this, t, e, 2, 32767, -32768),
                    (this[e] = t >>> 8),
                    (this[e + 1] = 255 & t),
                    e + 2
                  );
                }),
                (l.prototype.writeInt32LE = function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || z(this, t, e, 4, 2147483647, -2147483648),
                    (this[e] = 255 & t),
                    (this[e + 1] = t >>> 8),
                    (this[e + 2] = t >>> 16),
                    (this[e + 3] = t >>> 24),
                    e + 4
                  );
                }),
                (l.prototype.writeInt32BE = function (t, e, n) {
                  return (
                    (t = +t),
                    (e >>>= 0),
                    n || z(this, t, e, 4, 2147483647, -2147483648),
                    t < 0 && (t = 4294967295 + t + 1),
                    (this[e] = t >>> 24),
                    (this[e + 1] = t >>> 16),
                    (this[e + 2] = t >>> 8),
                    (this[e + 3] = 255 & t),
                    e + 4
                  );
                }),
                (l.prototype.writeFloatLE = function (t, e, n) {
                  return L(this, t, e, !0, n);
                }),
                (l.prototype.writeFloatBE = function (t, e, n) {
                  return L(this, t, e, !1, n);
                }),
                (l.prototype.writeDoubleLE = function (t, e, n) {
                  return F(this, t, e, !0, n);
                }),
                (l.prototype.writeDoubleBE = function (t, e, n) {
                  return F(this, t, e, !1, n);
                }),
                (l.prototype.copy = function (t, e, n, r) {
                  if (!l.isBuffer(t))
                    throw new TypeError("argument should be a Buffer");
                  if (
                    (n || (n = 0),
                    r || 0 === r || (r = this.length),
                    e >= t.length && (e = t.length),
                    e || (e = 0),
                    r > 0 && r < n && (r = n),
                    r === n)
                  )
                    return 0;
                  if (0 === t.length || 0 === this.length) return 0;
                  if (e < 0) throw new RangeError("targetStart out of bounds");
                  if (n < 0 || n >= this.length)
                    throw new RangeError("Index out of range");
                  if (r < 0) throw new RangeError("sourceEnd out of bounds");
                  r > this.length && (r = this.length),
                    t.length - e < r - n && (r = t.length - e + n);
                  var i = r - n;
                  if (
                    this === t &&
                    "function" === typeof Uint8Array.prototype.copyWithin
                  )
                    this.copyWithin(e, n, r);
                  else if (this === t && n < e && e < r)
                    for (var o = i - 1; o >= 0; --o) t[o + e] = this[o + n];
                  else Uint8Array.prototype.set.call(t, this.subarray(n, r), e);
                  return i;
                }),
                (l.prototype.fill = function (t, e, n, r) {
                  if ("string" === typeof t) {
                    if (
                      ("string" === typeof e
                        ? ((r = e), (e = 0), (n = this.length))
                        : "string" === typeof n && ((r = n), (n = this.length)),
                      void 0 !== r && "string" !== typeof r)
                    )
                      throw new TypeError("encoding must be a string");
                    if ("string" === typeof r && !l.isEncoding(r))
                      throw new TypeError("Unknown encoding: " + r);
                    if (1 === t.length) {
                      var i = t.charCodeAt(0);
                      (("utf8" === r && i < 128) || "latin1" === r) && (t = i);
                    }
                  } else
                    "number" === typeof t
                      ? (t &= 255)
                      : "boolean" === typeof t && (t = Number(t));
                  if (e < 0 || this.length < e || this.length < n)
                    throw new RangeError("Out of range index");
                  if (n <= e) return this;
                  var o;
                  if (
                    ((e >>>= 0),
                    (n = void 0 === n ? this.length : n >>> 0),
                    t || (t = 0),
                    "number" === typeof t)
                  )
                    for (o = e; o < n; ++o) this[o] = t;
                  else {
                    var s = l.isBuffer(t) ? t : l.from(t, r),
                      a = s.length;
                    if (0 === a)
                      throw new TypeError(
                        'The value "' + t + '" is invalid for argument "value"'
                      );
                    for (o = 0; o < n - e; ++o) this[o + e] = s[o % a];
                  }
                  return this;
                });
              var B = /[^+/0-9A-Za-z-_]/g;
              function N(t, e) {
                var n;
                e = e || 1 / 0;
                for (var r = t.length, i = null, o = [], s = 0; s < r; ++s) {
                  if ((n = t.charCodeAt(s)) > 55295 && n < 57344) {
                    if (!i) {
                      if (n > 56319) {
                        (e -= 3) > -1 && o.push(239, 191, 189);
                        continue;
                      }
                      if (s + 1 === r) {
                        (e -= 3) > -1 && o.push(239, 191, 189);
                        continue;
                      }
                      i = n;
                      continue;
                    }
                    if (n < 56320) {
                      (e -= 3) > -1 && o.push(239, 191, 189), (i = n);
                      continue;
                    }
                    n = 65536 + (((i - 55296) << 10) | (n - 56320));
                  } else i && (e -= 3) > -1 && o.push(239, 191, 189);
                  if (((i = null), n < 128)) {
                    if ((e -= 1) < 0) break;
                    o.push(n);
                  } else if (n < 2048) {
                    if ((e -= 2) < 0) break;
                    o.push((n >> 6) | 192, (63 & n) | 128);
                  } else if (n < 65536) {
                    if ((e -= 3) < 0) break;
                    o.push(
                      (n >> 12) | 224,
                      ((n >> 6) & 63) | 128,
                      (63 & n) | 128
                    );
                  } else {
                    if (!(n < 1114112)) throw new Error("Invalid code point");
                    if ((e -= 4) < 0) break;
                    o.push(
                      (n >> 18) | 240,
                      ((n >> 12) & 63) | 128,
                      ((n >> 6) & 63) | 128,
                      (63 & n) | 128
                    );
                  }
                }
                return o;
              }
              function j(t) {
                return r.toByteArray(
                  (function (t) {
                    if (
                      (t = (t = t.split("=")[0]).trim().replace(B, "")).length <
                      2
                    )
                      return "";
                    for (; t.length % 4 !== 0; ) t += "=";
                    return t;
                  })(t)
                );
              }
              function U(t, e, n, r) {
                for (
                  var i = 0;
                  i < r && !(i + n >= e.length || i >= t.length);
                  ++i
                )
                  e[i + n] = t[i];
                return i;
              }
              function Z(t, e) {
                return (
                  t instanceof e ||
                  (null != t &&
                    null != t.constructor &&
                    null != t.constructor.name &&
                    t.constructor.name === e.name)
                );
              }
              function V(t) {
                return t !== t;
              }
              var q = (function () {
                for (
                  var t = "0123456789abcdef", e = new Array(256), n = 0;
                  n < 16;
                  ++n
                )
                  for (var r = 16 * n, i = 0; i < 16; ++i)
                    e[r + i] = t[n] + t[i];
                return e;
              })();
            },
            783: function (t, e) {
              (e.read = function (t, e, n, r, i) {
                var o,
                  s,
                  a = 8 * i - r - 1,
                  l = (1 << a) - 1,
                  c = l >> 1,
                  u = -7,
                  h = n ? i - 1 : 0,
                  p = n ? -1 : 1,
                  d = t[e + h];
                for (
                  h += p, o = d & ((1 << -u) - 1), d >>= -u, u += a;
                  u > 0;
                  o = 256 * o + t[e + h], h += p, u -= 8
                );
                for (
                  s = o & ((1 << -u) - 1), o >>= -u, u += r;
                  u > 0;
                  s = 256 * s + t[e + h], h += p, u -= 8
                );
                if (0 === o) o = 1 - c;
                else {
                  if (o === l) return s ? NaN : (1 / 0) * (d ? -1 : 1);
                  (s += Math.pow(2, r)), (o -= c);
                }
                return (d ? -1 : 1) * s * Math.pow(2, o - r);
              }),
                (e.write = function (t, e, n, r, i, o) {
                  var s,
                    a,
                    l,
                    c = 8 * o - i - 1,
                    u = (1 << c) - 1,
                    h = u >> 1,
                    p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                    d = r ? 0 : o - 1,
                    f = r ? 1 : -1,
                    m = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0;
                  for (
                    e = Math.abs(e),
                      isNaN(e) || e === 1 / 0
                        ? ((a = isNaN(e) ? 1 : 0), (s = u))
                        : ((s = Math.floor(Math.log(e) / Math.LN2)),
                          e * (l = Math.pow(2, -s)) < 1 && (s--, (l *= 2)),
                          (e += s + h >= 1 ? p / l : p * Math.pow(2, 1 - h)) *
                            l >=
                            2 && (s++, (l /= 2)),
                          s + h >= u
                            ? ((a = 0), (s = u))
                            : s + h >= 1
                            ? ((a = (e * l - 1) * Math.pow(2, i)), (s += h))
                            : ((a = e * Math.pow(2, h - 1) * Math.pow(2, i)),
                              (s = 0)));
                    i >= 8;
                    t[n + d] = 255 & a, d += f, a /= 256, i -= 8
                  );
                  for (
                    s = (s << i) | a, c += i;
                    c > 0;
                    t[n + d] = 255 & s, d += f, s /= 256, c -= 8
                  );
                  t[n + d - f] |= 128 * m;
                });
            },
          },
          n = {};
        function r(t) {
          var i = n[t];
          if (void 0 !== i) return i.exports;
          var o = (n[t] = { exports: {} }),
            s = !0;
          try {
            e[t](o, o.exports, r), (s = !1);
          } finally {
            s && delete n[t];
          }
          return o.exports;
        }
        r.ab = "//";
        var i = r(72);
        t.exports = i;
      })();
    },
    7727: function () {},
    9008: function (t, e, n) {
      t.exports = n(5443);
    },
    11163: function (t, e, n) {
      t.exports = n(90387);
    },
    70631: function (t, e, n) {
      var r = "function" === typeof Map && Map.prototype,
        i =
          Object.getOwnPropertyDescriptor && r
            ? Object.getOwnPropertyDescriptor(Map.prototype, "size")
            : null,
        o = r && i && "function" === typeof i.get ? i.get : null,
        s = r && Map.prototype.forEach,
        a = "function" === typeof Set && Set.prototype,
        l =
          Object.getOwnPropertyDescriptor && a
            ? Object.getOwnPropertyDescriptor(Set.prototype, "size")
            : null,
        c = a && l && "function" === typeof l.get ? l.get : null,
        u = a && Set.prototype.forEach,
        h =
          "function" === typeof WeakMap && WeakMap.prototype
            ? WeakMap.prototype.has
            : null,
        p =
          "function" === typeof WeakSet && WeakSet.prototype
            ? WeakSet.prototype.has
            : null,
        d =
          "function" === typeof WeakRef && WeakRef.prototype
            ? WeakRef.prototype.deref
            : null,
        f = Boolean.prototype.valueOf,
        m = Object.prototype.toString,
        g = Function.prototype.toString,
        y = String.prototype.match,
        _ = "function" === typeof BigInt ? BigInt.prototype.valueOf : null,
        v = Object.getOwnPropertySymbols,
        b =
          "function" === typeof Symbol && "symbol" === typeof Symbol.iterator
            ? Symbol.prototype.toString
            : null,
        x = "function" === typeof Symbol && "object" === typeof Symbol.iterator,
        w = Object.prototype.propertyIsEnumerable,
        S =
          ("function" === typeof Reflect
            ? Reflect.getPrototypeOf
            : Object.getPrototypeOf) ||
          ([].__proto__ === Array.prototype
            ? function (t) {
                return t.__proto__;
              }
            : null),
        E = n(24654).custom,
        T = E && O(E) ? E : null,
        A =
          "function" === typeof Symbol &&
          "undefined" !== typeof Symbol.toStringTag
            ? Symbol.toStringTag
            : null;
      function C(t, e, n) {
        var r = "double" === (n.quoteStyle || e) ? '"' : "'";
        return r + t + r;
      }
      function P(t) {
        return String(t).replace(/"/g, "&quot;");
      }
      function M(t) {
        return (
          "[object Array]" === D(t) &&
          (!A || !("object" === typeof t && A in t))
        );
      }
      function O(t) {
        if (x) return t && "object" === typeof t && t instanceof Symbol;
        if ("symbol" === typeof t) return !0;
        if (!t || "object" !== typeof t || !b) return !1;
        try {
          return b.call(t), !0;
        } catch (e) {}
        return !1;
      }
      t.exports = function t(e, n, r, i) {
        var a = n || {};
        if (
          I(a, "quoteStyle") &&
          "single" !== a.quoteStyle &&
          "double" !== a.quoteStyle
        )
          throw new TypeError(
            'option "quoteStyle" must be "single" or "double"'
          );
        if (
          I(a, "maxStringLength") &&
          ("number" === typeof a.maxStringLength
            ? a.maxStringLength < 0 && a.maxStringLength !== 1 / 0
            : null !== a.maxStringLength)
        )
          throw new TypeError(
            'option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`'
          );
        var l = !I(a, "customInspect") || a.customInspect;
        if ("boolean" !== typeof l && "symbol" !== l)
          throw new TypeError(
            "option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`"
          );
        if (
          I(a, "indent") &&
          null !== a.indent &&
          "\t" !== a.indent &&
          !(parseInt(a.indent, 10) === a.indent && a.indent > 0)
        )
          throw new TypeError(
            'options "indent" must be "\\t", an integer > 0, or `null`'
          );
        if ("undefined" === typeof e) return "undefined";
        if (null === e) return "null";
        if ("boolean" === typeof e) return e ? "true" : "false";
        if ("string" === typeof e) return R(e, a);
        if ("number" === typeof e)
          return 0 === e ? (1 / 0 / e > 0 ? "0" : "-0") : String(e);
        if ("bigint" === typeof e) return String(e) + "n";
        var m = "undefined" === typeof a.depth ? 5 : a.depth;
        if (
          ("undefined" === typeof r && (r = 0),
          r >= m && m > 0 && "object" === typeof e)
        )
          return M(e) ? "[Array]" : "[Object]";
        var v = (function (t, e) {
          var n;
          if ("\t" === t.indent) n = "\t";
          else {
            if (!("number" === typeof t.indent && t.indent > 0)) return null;
            n = Array(t.indent + 1).join(" ");
          }
          return { base: n, prev: Array(e + 1).join(n) };
        })(a, r);
        if ("undefined" === typeof i) i = [];
        else if (z(i, e) >= 0) return "[Circular]";
        function w(e, n, o) {
          if ((n && (i = i.slice()).push(n), o)) {
            var s = { depth: a.depth };
            return (
              I(a, "quoteStyle") && (s.quoteStyle = a.quoteStyle),
              t(e, s, r + 1, i)
            );
          }
          return t(e, a, r + 1, i);
        }
        if ("function" === typeof e) {
          var E = (function (t) {
              if (t.name) return t.name;
              var e = y.call(g.call(t), /^function\s*([\w$]+)/);
              if (e) return e[1];
              return null;
            })(e),
            k = U(e, w);
          return (
            "[Function" +
            (E ? ": " + E : " (anonymous)") +
            "]" +
            (k.length > 0 ? " { " + k.join(", ") + " }" : "")
          );
        }
        if (O(e)) {
          var L = x
            ? String(e).replace(/^(Symbol\(.*\))_[^)]*$/, "$1")
            : b.call(e);
          return "object" !== typeof e || x ? L : F(L);
        }
        if (
          (function (t) {
            if (!t || "object" !== typeof t) return !1;
            if ("undefined" !== typeof HTMLElement && t instanceof HTMLElement)
              return !0;
            return (
              "string" === typeof t.nodeName &&
              "function" === typeof t.getAttribute
            );
          })(e)
        ) {
          for (
            var Z = "<" + String(e.nodeName).toLowerCase(),
              V = e.attributes || [],
              q = 0;
            q < V.length;
            q++
          )
            Z += " " + V[q].name + "=" + C(P(V[q].value), "double", a);
          return (
            (Z += ">"),
            e.childNodes && e.childNodes.length && (Z += "..."),
            (Z += "</" + String(e.nodeName).toLowerCase() + ">")
          );
        }
        if (M(e)) {
          if (0 === e.length) return "[]";
          var $ = U(e, w);
          return v &&
            !(function (t) {
              for (var e = 0; e < t.length; e++)
                if (z(t[e], "\n") >= 0) return !1;
              return !0;
            })($)
            ? "[" + j($, v) + "]"
            : "[ " + $.join(", ") + " ]";
        }
        if (
          (function (t) {
            return (
              "[object Error]" === D(t) &&
              (!A || !("object" === typeof t && A in t))
            );
          })(e)
        ) {
          var G = U(e, w);
          return 0 === G.length
            ? "[" + String(e) + "]"
            : "{ [" + String(e) + "] " + G.join(", ") + " }";
        }
        if ("object" === typeof e && l) {
          if (T && "function" === typeof e[T]) return e[T]();
          if ("symbol" !== l && "function" === typeof e.inspect)
            return e.inspect();
        }
        if (
          (function (t) {
            if (!o || !t || "object" !== typeof t) return !1;
            try {
              o.call(t);
              try {
                c.call(t);
              } catch (Z) {
                return !0;
              }
              return t instanceof Map;
            } catch (e) {}
            return !1;
          })(e)
        ) {
          var W = [];
          return (
            s.call(e, function (t, n) {
              W.push(w(n, e, !0) + " => " + w(t, e));
            }),
            N("Map", o.call(e), W, v)
          );
        }
        if (
          (function (t) {
            if (!c || !t || "object" !== typeof t) return !1;
            try {
              c.call(t);
              try {
                o.call(t);
              } catch (e) {
                return !0;
              }
              return t instanceof Set;
            } catch (n) {}
            return !1;
          })(e)
        ) {
          var H = [];
          return (
            u.call(e, function (t) {
              H.push(w(t, e));
            }),
            N("Set", c.call(e), H, v)
          );
        }
        if (
          (function (t) {
            if (!h || !t || "object" !== typeof t) return !1;
            try {
              h.call(t, h);
              try {
                p.call(t, p);
              } catch (Z) {
                return !0;
              }
              return t instanceof WeakMap;
            } catch (e) {}
            return !1;
          })(e)
        )
          return B("WeakMap");
        if (
          (function (t) {
            if (!p || !t || "object" !== typeof t) return !1;
            try {
              p.call(t, p);
              try {
                h.call(t, h);
              } catch (Z) {
                return !0;
              }
              return t instanceof WeakSet;
            } catch (e) {}
            return !1;
          })(e)
        )
          return B("WeakSet");
        if (
          (function (t) {
            if (!d || !t || "object" !== typeof t) return !1;
            try {
              return d.call(t), !0;
            } catch (e) {}
            return !1;
          })(e)
        )
          return B("WeakRef");
        if (
          (function (t) {
            return (
              "[object Number]" === D(t) &&
              (!A || !("object" === typeof t && A in t))
            );
          })(e)
        )
          return F(w(Number(e)));
        if (
          (function (t) {
            if (!t || "object" !== typeof t || !_) return !1;
            try {
              return _.call(t), !0;
            } catch (e) {}
            return !1;
          })(e)
        )
          return F(w(_.call(e)));
        if (
          (function (t) {
            return (
              "[object Boolean]" === D(t) &&
              (!A || !("object" === typeof t && A in t))
            );
          })(e)
        )
          return F(f.call(e));
        if (
          (function (t) {
            return (
              "[object String]" === D(t) &&
              (!A || !("object" === typeof t && A in t))
            );
          })(e)
        )
          return F(w(String(e)));
        if (
          !(function (t) {
            return (
              "[object Date]" === D(t) &&
              (!A || !("object" === typeof t && A in t))
            );
          })(e) &&
          !(function (t) {
            return (
              "[object RegExp]" === D(t) &&
              (!A || !("object" === typeof t && A in t))
            );
          })(e)
        ) {
          var X = U(e, w),
            K = S
              ? S(e) === Object.prototype
              : e instanceof Object || e.constructor === Object,
            Y = e instanceof Object ? "" : "null prototype",
            Q =
              !K && A && Object(e) === e && A in e
                ? D(e).slice(8, -1)
                : Y
                ? "Object"
                : "",
            J =
              (K || "function" !== typeof e.constructor
                ? ""
                : e.constructor.name
                ? e.constructor.name + " "
                : "") +
              (Q || Y
                ? "[" + [].concat(Q || [], Y || []).join(": ") + "] "
                : "");
          return 0 === X.length
            ? J + "{}"
            : v
            ? J + "{" + j(X, v) + "}"
            : J + "{ " + X.join(", ") + " }";
        }
        return String(e);
      };
      var k =
        Object.prototype.hasOwnProperty ||
        function (t) {
          return t in this;
        };
      function I(t, e) {
        return k.call(t, e);
      }
      function D(t) {
        return m.call(t);
      }
      function z(t, e) {
        if (t.indexOf) return t.indexOf(e);
        for (var n = 0, r = t.length; n < r; n++) if (t[n] === e) return n;
        return -1;
      }
      function R(t, e) {
        if (t.length > e.maxStringLength) {
          var n = t.length - e.maxStringLength,
            r = "... " + n + " more character" + (n > 1 ? "s" : "");
          return R(t.slice(0, e.maxStringLength), e) + r;
        }
        return C(
          t.replace(/(['\\])/g, "\\$1").replace(/[\x00-\x1f]/g, L),
          "single",
          e
        );
      }
      function L(t) {
        var e = t.charCodeAt(0),
          n = { 8: "b", 9: "t", 10: "n", 12: "f", 13: "r" }[e];
        return n
          ? "\\" + n
          : "\\x" + (e < 16 ? "0" : "") + e.toString(16).toUpperCase();
      }
      function F(t) {
        return "Object(" + t + ")";
      }
      function B(t) {
        return t + " { ? }";
      }
      function N(t, e, n, r) {
        return t + " (" + e + ") {" + (r ? j(n, r) : n.join(", ")) + "}";
      }
      function j(t, e) {
        if (0 === t.length) return "";
        var n = "\n" + e.prev + e.base;
        return n + t.join("," + n) + "\n" + e.prev;
      }
      function U(t, e) {
        var n = M(t),
          r = [];
        if (n) {
          r.length = t.length;
          for (var i = 0; i < t.length; i++) r[i] = I(t, i) ? e(t[i], t) : "";
        }
        var o,
          s = "function" === typeof v ? v(t) : [];
        if (x) {
          o = {};
          for (var a = 0; a < s.length; a++) o["$" + s[a]] = s[a];
        }
        for (var l in t)
          I(t, l) &&
            ((n && String(Number(l)) === l && l < t.length) ||
              (x && o["$" + l] instanceof Symbol) ||
              (/[^\w$]/.test(l)
                ? r.push(e(l, t) + ": " + e(t[l], t))
                : r.push(l + ": " + e(t[l], t))));
        if ("function" === typeof v)
          for (var c = 0; c < s.length; c++)
            w.call(t, s[c]) && r.push("[" + e(s[c]) + "]: " + e(t[s[c]], t));
        return r;
      }
    },
    34155: function (t) {
      var e,
        n,
        r = (t.exports = {});
      function i() {
        throw new Error("setTimeout has not been defined");
      }
      function o() {
        throw new Error("clearTimeout has not been defined");
      }
      function s(t) {
        if (e === setTimeout) return setTimeout(t, 0);
        if ((e === i || !e) && setTimeout)
          return (e = setTimeout), setTimeout(t, 0);
        try {
          return e(t, 0);
        } catch (n) {
          try {
            return e.call(null, t, 0);
          } catch (n) {
            return e.call(this, t, 0);
          }
        }
      }
      !(function () {
        try {
          e = "function" === typeof setTimeout ? setTimeout : i;
        } catch (t) {
          e = i;
        }
        try {
          n = "function" === typeof clearTimeout ? clearTimeout : o;
        } catch (t) {
          n = o;
        }
      })();
      var a,
        l = [],
        c = !1,
        u = -1;
      function h() {
        c &&
          a &&
          ((c = !1), a.length ? (l = a.concat(l)) : (u = -1), l.length && p());
      }
      function p() {
        if (!c) {
          var t = s(h);
          c = !0;
          for (var e = l.length; e; ) {
            for (a = l, l = []; ++u < e; ) a && a[u].run();
            (u = -1), (e = l.length);
          }
          (a = null),
            (c = !1),
            (function (t) {
              if (n === clearTimeout) return clearTimeout(t);
              if ((n === o || !n) && clearTimeout)
                return (n = clearTimeout), clearTimeout(t);
              try {
                n(t);
              } catch (e) {
                try {
                  return n.call(null, t);
                } catch (e) {
                  return n.call(this, t);
                }
              }
            })(t);
        }
      }
      function d(t, e) {
        (this.fun = t), (this.array = e);
      }
      function f() {}
      (r.nextTick = function (t) {
        var e = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
        l.push(new d(t, e)), 1 !== l.length || c || s(p);
      }),
        (d.prototype.run = function () {
          this.fun.apply(null, this.array);
        }),
        (r.title = "browser"),
        (r.browser = !0),
        (r.env = {}),
        (r.argv = []),
        (r.version = ""),
        (r.versions = {}),
        (r.on = f),
        (r.addListener = f),
        (r.once = f),
        (r.off = f),
        (r.removeListener = f),
        (r.removeAllListeners = f),
        (r.emit = f),
        (r.prependListener = f),
        (r.prependOnceListener = f),
        (r.listeners = function (t) {
          return [];
        }),
        (r.binding = function (t) {
          throw new Error("process.binding is not supported");
        }),
        (r.cwd = function () {
          return "/";
        }),
        (r.chdir = function (t) {
          throw new Error("process.chdir is not supported");
        }),
        (r.umask = function () {
          return 0;
        });
    },
    92703: function (t, e, n) {
      "use strict";
      var r = n(50414);
      function i() {}
      function o() {}
      (o.resetWarningCache = i),
        (t.exports = function () {
          function t(t, e, n, i, o, s) {
            if (s !== r) {
              var a = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
              );
              throw ((a.name = "Invariant Violation"), a);
            }
          }
          function e() {
            return t;
          }
          t.isRequired = t;
          var n = {
            array: t,
            bool: t,
            func: t,
            number: t,
            object: t,
            string: t,
            symbol: t,
            any: t,
            arrayOf: e,
            element: t,
            elementType: t,
            instanceOf: e,
            node: t,
            objectOf: e,
            oneOf: e,
            oneOfType: e,
            shape: e,
            exact: e,
            checkPropTypes: o,
            resetWarningCache: i,
          };
          return (n.PropTypes = n), n;
        });
    },
    45697: function (t, e, n) {
      t.exports = n(92703)();
    },
    50414: function (t) {
      "use strict";
      t.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    },
    55798: function (t) {
      "use strict";
      var e = String.prototype.replace,
        n = /%20/g,
        r = "RFC1738",
        i = "RFC3986";
      t.exports = {
        default: i,
        formatters: {
          RFC1738: function (t) {
            return e.call(t, n, "+");
          },
          RFC3986: function (t) {
            return String(t);
          },
        },
        RFC1738: r,
        RFC3986: i,
      };
    },
    80129: function (t, e, n) {
      "use strict";
      var r = n(58261),
        i = n(55235),
        o = n(55798);
      t.exports = { formats: o, parse: i, stringify: r };
    },
    55235: function (t, e, n) {
      "use strict";
      var r = n(12769),
        i = Object.prototype.hasOwnProperty,
        o = Array.isArray,
        s = {
          allowDots: !1,
          allowPrototypes: !1,
          allowSparse: !1,
          arrayLimit: 20,
          charset: "utf-8",
          charsetSentinel: !1,
          comma: !1,
          decoder: r.decode,
          delimiter: "&",
          depth: 5,
          ignoreQueryPrefix: !1,
          interpretNumericEntities: !1,
          parameterLimit: 1e3,
          parseArrays: !0,
          plainObjects: !1,
          strictNullHandling: !1,
        },
        a = function (t) {
          return t.replace(/&#(\d+);/g, function (t, e) {
            return String.fromCharCode(parseInt(e, 10));
          });
        },
        l = function (t, e) {
          return t && "string" === typeof t && e.comma && t.indexOf(",") > -1
            ? t.split(",")
            : t;
        },
        c = function (t, e, n, r) {
          if (t) {
            var o = n.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t,
              s = /(\[[^[\]]*])/g,
              a = n.depth > 0 && /(\[[^[\]]*])/.exec(o),
              c = a ? o.slice(0, a.index) : o,
              u = [];
            if (c) {
              if (
                !n.plainObjects &&
                i.call(Object.prototype, c) &&
                !n.allowPrototypes
              )
                return;
              u.push(c);
            }
            for (
              var h = 0;
              n.depth > 0 && null !== (a = s.exec(o)) && h < n.depth;

            ) {
              if (
                ((h += 1),
                !n.plainObjects &&
                  i.call(Object.prototype, a[1].slice(1, -1)) &&
                  !n.allowPrototypes)
              )
                return;
              u.push(a[1]);
            }
            return (
              a && u.push("[" + o.slice(a.index) + "]"),
              (function (t, e, n, r) {
                for (var i = r ? e : l(e, n), o = t.length - 1; o >= 0; --o) {
                  var s,
                    a = t[o];
                  if ("[]" === a && n.parseArrays) s = [].concat(i);
                  else {
                    s = n.plainObjects ? Object.create(null) : {};
                    var c =
                        "[" === a.charAt(0) && "]" === a.charAt(a.length - 1)
                          ? a.slice(1, -1)
                          : a,
                      u = parseInt(c, 10);
                    n.parseArrays || "" !== c
                      ? !isNaN(u) &&
                        a !== c &&
                        String(u) === c &&
                        u >= 0 &&
                        n.parseArrays &&
                        u <= n.arrayLimit
                        ? ((s = [])[u] = i)
                        : "__proto__" !== c && (s[c] = i)
                      : (s = { 0: i });
                  }
                  i = s;
                }
                return i;
              })(u, e, n, r)
            );
          }
        };
      t.exports = function (t, e) {
        var n = (function (t) {
          if (!t) return s;
          if (
            null !== t.decoder &&
            void 0 !== t.decoder &&
            "function" !== typeof t.decoder
          )
            throw new TypeError("Decoder has to be a function.");
          if (
            "undefined" !== typeof t.charset &&
            "utf-8" !== t.charset &&
            "iso-8859-1" !== t.charset
          )
            throw new TypeError(
              "The charset option must be either utf-8, iso-8859-1, or undefined"
            );
          var e = "undefined" === typeof t.charset ? s.charset : t.charset;
          return {
            allowDots:
              "undefined" === typeof t.allowDots ? s.allowDots : !!t.allowDots,
            allowPrototypes:
              "boolean" === typeof t.allowPrototypes
                ? t.allowPrototypes
                : s.allowPrototypes,
            allowSparse:
              "boolean" === typeof t.allowSparse
                ? t.allowSparse
                : s.allowSparse,
            arrayLimit:
              "number" === typeof t.arrayLimit ? t.arrayLimit : s.arrayLimit,
            charset: e,
            charsetSentinel:
              "boolean" === typeof t.charsetSentinel
                ? t.charsetSentinel
                : s.charsetSentinel,
            comma: "boolean" === typeof t.comma ? t.comma : s.comma,
            decoder: "function" === typeof t.decoder ? t.decoder : s.decoder,
            delimiter:
              "string" === typeof t.delimiter || r.isRegExp(t.delimiter)
                ? t.delimiter
                : s.delimiter,
            depth:
              "number" === typeof t.depth || !1 === t.depth
                ? +t.depth
                : s.depth,
            ignoreQueryPrefix: !0 === t.ignoreQueryPrefix,
            interpretNumericEntities:
              "boolean" === typeof t.interpretNumericEntities
                ? t.interpretNumericEntities
                : s.interpretNumericEntities,
            parameterLimit:
              "number" === typeof t.parameterLimit
                ? t.parameterLimit
                : s.parameterLimit,
            parseArrays: !1 !== t.parseArrays,
            plainObjects:
              "boolean" === typeof t.plainObjects
                ? t.plainObjects
                : s.plainObjects,
            strictNullHandling:
              "boolean" === typeof t.strictNullHandling
                ? t.strictNullHandling
                : s.strictNullHandling,
          };
        })(e);
        if ("" === t || null === t || "undefined" === typeof t)
          return n.plainObjects ? Object.create(null) : {};
        for (
          var u =
              "string" === typeof t
                ? (function (t, e) {
                    var n,
                      c = {},
                      u = e.ignoreQueryPrefix ? t.replace(/^\?/, "") : t,
                      h =
                        e.parameterLimit === 1 / 0 ? void 0 : e.parameterLimit,
                      p = u.split(e.delimiter, h),
                      d = -1,
                      f = e.charset;
                    if (e.charsetSentinel)
                      for (n = 0; n < p.length; ++n)
                        0 === p[n].indexOf("utf8=") &&
                          ("utf8=%E2%9C%93" === p[n]
                            ? (f = "utf-8")
                            : "utf8=%26%2310003%3B" === p[n] &&
                              (f = "iso-8859-1"),
                          (d = n),
                          (n = p.length));
                    for (n = 0; n < p.length; ++n)
                      if (n !== d) {
                        var m,
                          g,
                          y = p[n],
                          _ = y.indexOf("]="),
                          v = -1 === _ ? y.indexOf("=") : _ + 1;
                        -1 === v
                          ? ((m = e.decoder(y, s.decoder, f, "key")),
                            (g = e.strictNullHandling ? null : ""))
                          : ((m = e.decoder(
                              y.slice(0, v),
                              s.decoder,
                              f,
                              "key"
                            )),
                            (g = r.maybeMap(l(y.slice(v + 1), e), function (t) {
                              return e.decoder(t, s.decoder, f, "value");
                            }))),
                          g &&
                            e.interpretNumericEntities &&
                            "iso-8859-1" === f &&
                            (g = a(g)),
                          y.indexOf("[]=") > -1 && (g = o(g) ? [g] : g),
                          i.call(c, m)
                            ? (c[m] = r.combine(c[m], g))
                            : (c[m] = g);
                      }
                    return c;
                  })(t, n)
                : t,
            h = n.plainObjects ? Object.create(null) : {},
            p = Object.keys(u),
            d = 0;
          d < p.length;
          ++d
        ) {
          var f = p[d],
            m = c(f, u[f], n, "string" === typeof t);
          h = r.merge(h, m, n);
        }
        return !0 === n.allowSparse ? h : r.compact(h);
      };
    },
    58261: function (t, e, n) {
      "use strict";
      var r = n(37478),
        i = n(12769),
        o = n(55798),
        s = Object.prototype.hasOwnProperty,
        a = {
          brackets: function (t) {
            return t + "[]";
          },
          comma: "comma",
          indices: function (t, e) {
            return t + "[" + e + "]";
          },
          repeat: function (t) {
            return t;
          },
        },
        l = Array.isArray,
        c = String.prototype.split,
        u = Array.prototype.push,
        h = function (t, e) {
          u.apply(t, l(e) ? e : [e]);
        },
        p = Date.prototype.toISOString,
        d = o.default,
        f = {
          addQueryPrefix: !1,
          allowDots: !1,
          charset: "utf-8",
          charsetSentinel: !1,
          delimiter: "&",
          encode: !0,
          encoder: i.encode,
          encodeValuesOnly: !1,
          format: d,
          formatter: o.formatters[d],
          indices: !1,
          serializeDate: function (t) {
            return p.call(t);
          },
          skipNulls: !1,
          strictNullHandling: !1,
        },
        m = {},
        g = function t(e, n, o, s, a, u, p, d, g, y, _, v, b, x, w, S) {
          for (
            var E, T = e, A = S, C = 0, P = !1;
            void 0 !== (A = A.get(m)) && !P;

          ) {
            var M = A.get(e);
            if (((C += 1), "undefined" !== typeof M)) {
              if (M === C) throw new RangeError("Cyclic object value");
              P = !0;
            }
            "undefined" === typeof A.get(m) && (C = 0);
          }
          if (
            ("function" === typeof d
              ? (T = d(n, T))
              : T instanceof Date
              ? (T = _(T))
              : "comma" === o &&
                l(T) &&
                (T = i.maybeMap(T, function (t) {
                  return t instanceof Date ? _(t) : t;
                })),
            null === T)
          ) {
            if (a) return p && !x ? p(n, f.encoder, w, "key", v) : n;
            T = "";
          }
          if (
            "string" === typeof (E = T) ||
            "number" === typeof E ||
            "boolean" === typeof E ||
            "symbol" === typeof E ||
            "bigint" === typeof E ||
            i.isBuffer(T)
          ) {
            if (p) {
              var O = x ? n : p(n, f.encoder, w, "key", v);
              if ("comma" === o && x) {
                for (
                  var k = c.call(String(T), ","), I = "", D = 0;
                  D < k.length;
                  ++D
                )
                  I +=
                    (0 === D ? "" : ",") + b(p(k[D], f.encoder, w, "value", v));
                return [
                  b(O) + (s && l(T) && 1 === k.length ? "[]" : "") + "=" + I,
                ];
              }
              return [b(O) + "=" + b(p(T, f.encoder, w, "value", v))];
            }
            return [b(n) + "=" + b(String(T))];
          }
          var z,
            R = [];
          if ("undefined" === typeof T) return R;
          if ("comma" === o && l(T))
            z = [{ value: T.length > 0 ? T.join(",") || null : void 0 }];
          else if (l(d)) z = d;
          else {
            var L = Object.keys(T);
            z = g ? L.sort(g) : L;
          }
          for (
            var F = s && l(T) && 1 === T.length ? n + "[]" : n, B = 0;
            B < z.length;
            ++B
          ) {
            var N = z[B],
              j =
                "object" === typeof N && "undefined" !== typeof N.value
                  ? N.value
                  : T[N];
            if (!u || null !== j) {
              var U = l(T)
                ? "function" === typeof o
                  ? o(F, N)
                  : F
                : F + (y ? "." + N : "[" + N + "]");
              S.set(e, C);
              var Z = r();
              Z.set(m, S),
                h(R, t(j, U, o, s, a, u, p, d, g, y, _, v, b, x, w, Z));
            }
          }
          return R;
        };
      t.exports = function (t, e) {
        var n,
          i = t,
          c = (function (t) {
            if (!t) return f;
            if (
              null !== t.encoder &&
              "undefined" !== typeof t.encoder &&
              "function" !== typeof t.encoder
            )
              throw new TypeError("Encoder has to be a function.");
            var e = t.charset || f.charset;
            if (
              "undefined" !== typeof t.charset &&
              "utf-8" !== t.charset &&
              "iso-8859-1" !== t.charset
            )
              throw new TypeError(
                "The charset option must be either utf-8, iso-8859-1, or undefined"
              );
            var n = o.default;
            if ("undefined" !== typeof t.format) {
              if (!s.call(o.formatters, t.format))
                throw new TypeError("Unknown format option provided.");
              n = t.format;
            }
            var r = o.formatters[n],
              i = f.filter;
            return (
              ("function" === typeof t.filter || l(t.filter)) && (i = t.filter),
              {
                addQueryPrefix:
                  "boolean" === typeof t.addQueryPrefix
                    ? t.addQueryPrefix
                    : f.addQueryPrefix,
                allowDots:
                  "undefined" === typeof t.allowDots
                    ? f.allowDots
                    : !!t.allowDots,
                charset: e,
                charsetSentinel:
                  "boolean" === typeof t.charsetSentinel
                    ? t.charsetSentinel
                    : f.charsetSentinel,
                delimiter:
                  "undefined" === typeof t.delimiter
                    ? f.delimiter
                    : t.delimiter,
                encode: "boolean" === typeof t.encode ? t.encode : f.encode,
                encoder:
                  "function" === typeof t.encoder ? t.encoder : f.encoder,
                encodeValuesOnly:
                  "boolean" === typeof t.encodeValuesOnly
                    ? t.encodeValuesOnly
                    : f.encodeValuesOnly,
                filter: i,
                format: n,
                formatter: r,
                serializeDate:
                  "function" === typeof t.serializeDate
                    ? t.serializeDate
                    : f.serializeDate,
                skipNulls:
                  "boolean" === typeof t.skipNulls ? t.skipNulls : f.skipNulls,
                sort: "function" === typeof t.sort ? t.sort : null,
                strictNullHandling:
                  "boolean" === typeof t.strictNullHandling
                    ? t.strictNullHandling
                    : f.strictNullHandling,
              }
            );
          })(e);
        "function" === typeof c.filter
          ? (i = (0, c.filter)("", i))
          : l(c.filter) && (n = c.filter);
        var u,
          p = [];
        if ("object" !== typeof i || null === i) return "";
        u =
          e && e.arrayFormat in a
            ? e.arrayFormat
            : e && "indices" in e
            ? e.indices
              ? "indices"
              : "repeat"
            : "indices";
        var d = a[u];
        if (e && "commaRoundTrip" in e && "boolean" !== typeof e.commaRoundTrip)
          throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
        var m = "comma" === d && e && e.commaRoundTrip;
        n || (n = Object.keys(i)), c.sort && n.sort(c.sort);
        for (var y = r(), _ = 0; _ < n.length; ++_) {
          var v = n[_];
          (c.skipNulls && null === i[v]) ||
            h(
              p,
              g(
                i[v],
                v,
                d,
                m,
                c.strictNullHandling,
                c.skipNulls,
                c.encode ? c.encoder : null,
                c.filter,
                c.sort,
                c.allowDots,
                c.serializeDate,
                c.format,
                c.formatter,
                c.encodeValuesOnly,
                c.charset,
                y
              )
            );
        }
        var b = p.join(c.delimiter),
          x = !0 === c.addQueryPrefix ? "?" : "";
        return (
          c.charsetSentinel &&
            ("iso-8859-1" === c.charset
              ? (x += "utf8=%26%2310003%3B&")
              : (x += "utf8=%E2%9C%93&")),
          b.length > 0 ? x + b : ""
        );
      };
    },
    12769: function (t, e, n) {
      "use strict";
      var r = n(55798),
        i = Object.prototype.hasOwnProperty,
        o = Array.isArray,
        s = (function () {
          for (var t = [], e = 0; e < 256; ++e)
            t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
          return t;
        })(),
        a = function (t, e) {
          for (
            var n = e && e.plainObjects ? Object.create(null) : {}, r = 0;
            r < t.length;
            ++r
          )
            "undefined" !== typeof t[r] && (n[r] = t[r]);
          return n;
        };
      t.exports = {
        arrayToObject: a,
        assign: function (t, e) {
          return Object.keys(e).reduce(function (t, n) {
            return (t[n] = e[n]), t;
          }, t);
        },
        combine: function (t, e) {
          return [].concat(t, e);
        },
        compact: function (t) {
          for (
            var e = [{ obj: { o: t }, prop: "o" }], n = [], r = 0;
            r < e.length;
            ++r
          )
            for (
              var i = e[r], s = i.obj[i.prop], a = Object.keys(s), l = 0;
              l < a.length;
              ++l
            ) {
              var c = a[l],
                u = s[c];
              "object" === typeof u &&
                null !== u &&
                -1 === n.indexOf(u) &&
                (e.push({ obj: s, prop: c }), n.push(u));
            }
          return (
            (function (t) {
              for (; t.length > 1; ) {
                var e = t.pop(),
                  n = e.obj[e.prop];
                if (o(n)) {
                  for (var r = [], i = 0; i < n.length; ++i)
                    "undefined" !== typeof n[i] && r.push(n[i]);
                  e.obj[e.prop] = r;
                }
              }
            })(e),
            t
          );
        },
        decode: function (t, e, n) {
          var r = t.replace(/\+/g, " ");
          if ("iso-8859-1" === n) return r.replace(/%[0-9a-f]{2}/gi, unescape);
          try {
            return decodeURIComponent(r);
          } catch (i) {
            return r;
          }
        },
        encode: function (t, e, n, i, o) {
          if (0 === t.length) return t;
          var a = t;
          if (
            ("symbol" === typeof t
              ? (a = Symbol.prototype.toString.call(t))
              : "string" !== typeof t && (a = String(t)),
            "iso-8859-1" === n)
          )
            return escape(a).replace(/%u[0-9a-f]{4}/gi, function (t) {
              return "%26%23" + parseInt(t.slice(2), 16) + "%3B";
            });
          for (var l = "", c = 0; c < a.length; ++c) {
            var u = a.charCodeAt(c);
            45 === u ||
            46 === u ||
            95 === u ||
            126 === u ||
            (u >= 48 && u <= 57) ||
            (u >= 65 && u <= 90) ||
            (u >= 97 && u <= 122) ||
            (o === r.RFC1738 && (40 === u || 41 === u))
              ? (l += a.charAt(c))
              : u < 128
              ? (l += s[u])
              : u < 2048
              ? (l += s[192 | (u >> 6)] + s[128 | (63 & u)])
              : u < 55296 || u >= 57344
              ? (l +=
                  s[224 | (u >> 12)] +
                  s[128 | ((u >> 6) & 63)] +
                  s[128 | (63 & u)])
              : ((c += 1),
                (u = 65536 + (((1023 & u) << 10) | (1023 & a.charCodeAt(c)))),
                (l +=
                  s[240 | (u >> 18)] +
                  s[128 | ((u >> 12) & 63)] +
                  s[128 | ((u >> 6) & 63)] +
                  s[128 | (63 & u)]));
          }
          return l;
        },
        isBuffer: function (t) {
          return (
            !(!t || "object" !== typeof t) &&
            !!(
              t.constructor &&
              t.constructor.isBuffer &&
              t.constructor.isBuffer(t)
            )
          );
        },
        isRegExp: function (t) {
          return "[object RegExp]" === Object.prototype.toString.call(t);
        },
        maybeMap: function (t, e) {
          if (o(t)) {
            for (var n = [], r = 0; r < t.length; r += 1) n.push(e(t[r]));
            return n;
          }
          return e(t);
        },
        merge: function t(e, n, r) {
          if (!n) return e;
          if ("object" !== typeof n) {
            if (o(e)) e.push(n);
            else {
              if (!e || "object" !== typeof e) return [e, n];
              ((r && (r.plainObjects || r.allowPrototypes)) ||
                !i.call(Object.prototype, n)) &&
                (e[n] = !0);
            }
            return e;
          }
          if (!e || "object" !== typeof e) return [e].concat(n);
          var s = e;
          return (
            o(e) && !o(n) && (s = a(e, r)),
            o(e) && o(n)
              ? (n.forEach(function (n, o) {
                  if (i.call(e, o)) {
                    var s = e[o];
                    s && "object" === typeof s && n && "object" === typeof n
                      ? (e[o] = t(s, n, r))
                      : e.push(n);
                  } else e[o] = n;
                }),
                e)
              : Object.keys(n).reduce(function (e, o) {
                  var s = n[o];
                  return i.call(e, o) ? (e[o] = t(e[o], s, r)) : (e[o] = s), e;
                }, s)
          );
        },
      };
    },
    56421: function (t, e, n) {
      "use strict";
      var r,
        i = n(96425),
        o = (r = i) && r.__esModule ? r : { default: r };
      var s = {
        tags: function (t) {
          var e = t.id,
            n = t.events,
            r = t.dataLayer,
            i = t.dataLayerName,
            s = t.preview,
            a = "&gtm_auth=" + t.auth,
            l = "&gtm_preview=" + s;
          return (
            e || (0, o.default)("GTM Id is required"),
            {
              iframe:
                '\n      <iframe src="https://www.googletagmanager.com/ns.html?id=' +
                e +
                a +
                l +
                '&gtm_cookies_win=x"\n        height="0" width="0" style="display:none;visibility:hidden" id="tag-manager"></iframe>',
              script:
                "\n      (function(w,d,s,l,i){w[l]=w[l]||[];\n        w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js', " +
                JSON.stringify(n).slice(1, -1) +
                "});\n        var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';\n        j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl+'" +
                a +
                l +
                "&gtm_cookies_win=x';\n        f.parentNode.insertBefore(j,f);\n      })(window,document,'script','" +
                i +
                "','" +
                e +
                "');",
              dataLayerVar: this.dataLayer(r, i),
            }
          );
        },
        dataLayer: function (t, e) {
          return (
            "\n      window." +
            e +
            " = window." +
            e +
            " || [];\n      window." +
            e +
            ".push(" +
            JSON.stringify(t) +
            ")"
          );
        },
      };
      t.exports = s;
    },
    58676: function (t, e, n) {
      "use strict";
      var r,
        i = n(56421),
        o = (r = i) && r.__esModule ? r : { default: r };
      var s = {
        dataScript: function (t) {
          var e = document.createElement("script");
          return (e.innerHTML = t), e;
        },
        gtm: function (t) {
          var e = o.default.tags(t);
          return {
            noScript: function () {
              var t = document.createElement("noscript");
              return (t.innerHTML = e.iframe), t;
            },
            script: function () {
              var t = document.createElement("script");
              return (t.innerHTML = e.script), t;
            },
            dataScript: this.dataScript(e.dataLayerVar),
          };
        },
        initialize: function (t) {
          var e = t.gtmId,
            n = t.events,
            r = void 0 === n ? {} : n,
            i = t.dataLayer,
            o = t.dataLayerName,
            s = void 0 === o ? "dataLayer" : o,
            a = t.auth,
            l = void 0 === a ? "" : a,
            c = t.preview,
            u = void 0 === c ? "" : c,
            h = this.gtm({
              id: e,
              events: r,
              dataLayer: i || void 0,
              dataLayerName: s,
              auth: l,
              preview: u,
            });
          i && document.head.appendChild(h.dataScript),
            document.head.insertBefore(h.script(), document.head.childNodes[0]),
            document.body.insertBefore(
              h.noScript(),
              document.body.childNodes[0]
            );
        },
        dataLayer: function (t) {
          var e = t.dataLayer,
            n = t.dataLayerName,
            r = void 0 === n ? "dataLayer" : n;
          if (window[r]) return window[r].push(e);
          var i = o.default.dataLayer(e, r),
            s = this.dataScript(i);
          document.head.insertBefore(s, document.head.childNodes[0]);
        },
      };
      t.exports = s;
    },
    1785: function (t, e, n) {
      "use strict";
      var r,
        i = n(58676),
        o = (r = i) && r.__esModule ? r : { default: r };
      t.exports = o.default;
    },
    96425: function (t, e) {
      "use strict";
      Object.defineProperty(e, "__esModule", { value: !0 });
      e.default = function (t) {
        console.warn("[react-gtm]", t);
      };
    },
    69921: function (t, e) {
      "use strict";
      var n = "function" === typeof Symbol && Symbol.for,
        r = n ? Symbol.for("react.element") : 60103,
        i = n ? Symbol.for("react.portal") : 60106,
        o = n ? Symbol.for("react.fragment") : 60107,
        s = n ? Symbol.for("react.strict_mode") : 60108,
        a = n ? Symbol.for("react.profiler") : 60114,
        l = n ? Symbol.for("react.provider") : 60109,
        c = n ? Symbol.for("react.context") : 60110,
        u = n ? Symbol.for("react.async_mode") : 60111,
        h = n ? Symbol.for("react.concurrent_mode") : 60111,
        p = n ? Symbol.for("react.forward_ref") : 60112,
        d = n ? Symbol.for("react.suspense") : 60113,
        f = n ? Symbol.for("react.suspense_list") : 60120,
        m = n ? Symbol.for("react.memo") : 60115,
        g = n ? Symbol.for("react.lazy") : 60116,
        y = n ? Symbol.for("react.block") : 60121,
        _ = n ? Symbol.for("react.fundamental") : 60117,
        v = n ? Symbol.for("react.responder") : 60118,
        b = n ? Symbol.for("react.scope") : 60119;
      function x(t) {
        if ("object" === typeof t && null !== t) {
          var e = t.$$typeof;
          switch (e) {
            case r:
              switch ((t = t.type)) {
                case u:
                case h:
                case o:
                case a:
                case s:
                case d:
                  return t;
                default:
                  switch ((t = t && t.$$typeof)) {
                    case c:
                    case p:
                    case g:
                    case m:
                    case l:
                      return t;
                    default:
                      return e;
                  }
              }
            case i:
              return e;
          }
        }
      }
      function w(t) {
        return x(t) === h;
      }
      (e.AsyncMode = u),
        (e.ConcurrentMode = h),
        (e.ContextConsumer = c),
        (e.ContextProvider = l),
        (e.Element = r),
        (e.ForwardRef = p),
        (e.Fragment = o),
        (e.Lazy = g),
        (e.Memo = m),
        (e.Portal = i),
        (e.Profiler = a),
        (e.StrictMode = s),
        (e.Suspense = d),
        (e.isAsyncMode = function (t) {
          return w(t) || x(t) === u;
        }),
        (e.isConcurrentMode = w),
        (e.isContextConsumer = function (t) {
          return x(t) === c;
        }),
        (e.isContextProvider = function (t) {
          return x(t) === l;
        }),
        (e.isElement = function (t) {
          return "object" === typeof t && null !== t && t.$$typeof === r;
        }),
        (e.isForwardRef = function (t) {
          return x(t) === p;
        }),
        (e.isFragment = function (t) {
          return x(t) === o;
        }),
        (e.isLazy = function (t) {
          return x(t) === g;
        }),
        (e.isMemo = function (t) {
          return x(t) === m;
        }),
        (e.isPortal = function (t) {
          return x(t) === i;
        }),
        (e.isProfiler = function (t) {
          return x(t) === a;
        }),
        (e.isStrictMode = function (t) {
          return x(t) === s;
        }),
        (e.isSuspense = function (t) {
          return x(t) === d;
        }),
        (e.isValidElementType = function (t) {
          return (
            "string" === typeof t ||
            "function" === typeof t ||
            t === o ||
            t === h ||
            t === a ||
            t === s ||
            t === d ||
            t === f ||
            ("object" === typeof t &&
              null !== t &&
              (t.$$typeof === g ||
                t.$$typeof === m ||
                t.$$typeof === l ||
                t.$$typeof === c ||
                t.$$typeof === p ||
                t.$$typeof === _ ||
                t.$$typeof === v ||
                t.$$typeof === b ||
                t.$$typeof === y))
          );
        }),
        (e.typeOf = x);
    },
    59864: function (t, e, n) {
      "use strict";
      t.exports = n(69921);
    },
    99338: function (t, e, n) {
      "use strict";
      n.d(e, {
        Jx: function () {
          return dr;
        },
        Pv: function () {
          return Wr;
        },
        GI: function () {
          return Sr;
        },
        ZP: function () {
          return In;
        },
      });
      var r = n(87462),
        i = n(41451),
        o = n(4942),
        s = n(67294),
        a = n(45697);
      var l = n(40181);
      function c(t, e) {
        return (
          (function (t) {
            if (Array.isArray(t)) return t;
          })(t) ||
          (function (t, e) {
            var n =
              null == t
                ? null
                : ("undefined" !== typeof Symbol && t[Symbol.iterator]) ||
                  t["@@iterator"];
            if (null != n) {
              var r,
                i,
                o = [],
                s = !0,
                a = !1;
              try {
                for (
                  n = n.call(t);
                  !(s = (r = n.next()).done) &&
                  (o.push(r.value), !e || o.length !== e);
                  s = !0
                );
              } catch (l) {
                (a = !0), (i = l);
              } finally {
                try {
                  s || null == n.return || n.return();
                } finally {
                  if (a) throw i;
                }
              }
              return o;
            }
          })(t, e) ||
          (0, l.Z)(t, e) ||
          (function () {
            throw new TypeError(
              "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
            );
          })()
        );
      }
      var u = 1e-6,
        h = "undefined" !== typeof Float32Array ? Float32Array : Array;
      Math.random;
      Math.PI;
      Math.hypot ||
        (Math.hypot = function () {
          for (var t = 0, e = arguments.length; e--; )
            t += arguments[e] * arguments[e];
          return Math.sqrt(t);
        });
      !(function () {
        var t = (function () {
          var t = new h(4);
          return (
            h != Float32Array &&
              ((t[0] = 0), (t[1] = 0), (t[2] = 0), (t[3] = 0)),
            t
          );
        })();
      })();
      function p(t, e) {
        const n = (function (t, e, n) {
          var r = e[0],
            i = e[1],
            o = e[2],
            s = e[3];
          return (
            (t[0] = n[0] * r + n[4] * i + n[8] * o + n[12] * s),
            (t[1] = n[1] * r + n[5] * i + n[9] * o + n[13] * s),
            (t[2] = n[2] * r + n[6] * i + n[10] * o + n[14] * s),
            (t[3] = n[3] * r + n[7] * i + n[11] * o + n[15] * s),
            t
          );
        })([], e, t);
        var r, i, o;
        return (
          (r = n),
          (i = n),
          (o = 1 / n[3]),
          (r[0] = i[0] * o),
          (r[1] = i[1] * o),
          (r[2] = i[2] * o),
          (r[3] = i[3] * o),
          n
        );
      }
      function d(t, e) {
        const n = t % e;
        return n < 0 ? e + n : n;
      }
      function f(t, e, n) {
        return t < e ? e : t > n ? n : t;
      }
      const m =
        Math.log2 ||
        function (t) {
          return Math.log(t) * Math.LOG2E;
        };
      function g(t, e, n) {
        var r = e[0],
          i = e[1],
          o = e[2],
          s = e[3],
          a = e[4],
          l = e[5],
          c = e[6],
          u = e[7],
          h = e[8],
          p = e[9],
          d = e[10],
          f = e[11],
          m = e[12],
          g = e[13],
          y = e[14],
          _ = e[15],
          v = n[0],
          b = n[1],
          x = n[2],
          w = n[3];
        return (
          (t[0] = v * r + b * a + x * h + w * m),
          (t[1] = v * i + b * l + x * p + w * g),
          (t[2] = v * o + b * c + x * d + w * y),
          (t[3] = v * s + b * u + x * f + w * _),
          (v = n[4]),
          (b = n[5]),
          (x = n[6]),
          (w = n[7]),
          (t[4] = v * r + b * a + x * h + w * m),
          (t[5] = v * i + b * l + x * p + w * g),
          (t[6] = v * o + b * c + x * d + w * y),
          (t[7] = v * s + b * u + x * f + w * _),
          (v = n[8]),
          (b = n[9]),
          (x = n[10]),
          (w = n[11]),
          (t[8] = v * r + b * a + x * h + w * m),
          (t[9] = v * i + b * l + x * p + w * g),
          (t[10] = v * o + b * c + x * d + w * y),
          (t[11] = v * s + b * u + x * f + w * _),
          (v = n[12]),
          (b = n[13]),
          (x = n[14]),
          (w = n[15]),
          (t[12] = v * r + b * a + x * h + w * m),
          (t[13] = v * i + b * l + x * p + w * g),
          (t[14] = v * o + b * c + x * d + w * y),
          (t[15] = v * s + b * u + x * f + w * _),
          t
        );
      }
      function y(t, e, n) {
        var r,
          i,
          o,
          s,
          a,
          l,
          c,
          u,
          h,
          p,
          d,
          f,
          m = n[0],
          g = n[1],
          y = n[2];
        return (
          e === t
            ? ((t[12] = e[0] * m + e[4] * g + e[8] * y + e[12]),
              (t[13] = e[1] * m + e[5] * g + e[9] * y + e[13]),
              (t[14] = e[2] * m + e[6] * g + e[10] * y + e[14]),
              (t[15] = e[3] * m + e[7] * g + e[11] * y + e[15]))
            : ((r = e[0]),
              (i = e[1]),
              (o = e[2]),
              (s = e[3]),
              (a = e[4]),
              (l = e[5]),
              (c = e[6]),
              (u = e[7]),
              (h = e[8]),
              (p = e[9]),
              (d = e[10]),
              (f = e[11]),
              (t[0] = r),
              (t[1] = i),
              (t[2] = o),
              (t[3] = s),
              (t[4] = a),
              (t[5] = l),
              (t[6] = c),
              (t[7] = u),
              (t[8] = h),
              (t[9] = p),
              (t[10] = d),
              (t[11] = f),
              (t[12] = r * m + a * g + h * y + e[12]),
              (t[13] = i * m + l * g + p * y + e[13]),
              (t[14] = o * m + c * g + d * y + e[14]),
              (t[15] = s * m + u * g + f * y + e[15])),
          t
        );
      }
      function _(t, e, n) {
        var r = n[0],
          i = n[1],
          o = n[2];
        return (
          (t[0] = e[0] * r),
          (t[1] = e[1] * r),
          (t[2] = e[2] * r),
          (t[3] = e[3] * r),
          (t[4] = e[4] * i),
          (t[5] = e[5] * i),
          (t[6] = e[6] * i),
          (t[7] = e[7] * i),
          (t[8] = e[8] * o),
          (t[9] = e[9] * o),
          (t[10] = e[10] * o),
          (t[11] = e[11] * o),
          (t[12] = e[12]),
          (t[13] = e[13]),
          (t[14] = e[14]),
          (t[15] = e[15]),
          t
        );
      }
      var v = function (t, e, n, r, i) {
        var o,
          s = 1 / Math.tan(e / 2);
        return (
          (t[0] = s / n),
          (t[1] = 0),
          (t[2] = 0),
          (t[3] = 0),
          (t[4] = 0),
          (t[5] = s),
          (t[6] = 0),
          (t[7] = 0),
          (t[8] = 0),
          (t[9] = 0),
          (t[11] = -1),
          (t[12] = 0),
          (t[13] = 0),
          (t[15] = 0),
          null != i && i !== 1 / 0
            ? ((o = 1 / (r - i)),
              (t[10] = (i + r) * o),
              (t[14] = 2 * i * r * o))
            : ((t[10] = -1), (t[14] = -2 * r)),
          t
        );
      };
      function b(t, e) {
        var n = t[0],
          r = t[1],
          i = t[2],
          o = t[3],
          s = t[4],
          a = t[5],
          l = t[6],
          c = t[7],
          h = t[8],
          p = t[9],
          d = t[10],
          f = t[11],
          m = t[12],
          g = t[13],
          y = t[14],
          _ = t[15],
          v = e[0],
          b = e[1],
          x = e[2],
          w = e[3],
          S = e[4],
          E = e[5],
          T = e[6],
          A = e[7],
          C = e[8],
          P = e[9],
          M = e[10],
          O = e[11],
          k = e[12],
          I = e[13],
          D = e[14],
          z = e[15];
        return (
          Math.abs(n - v) <= u * Math.max(1, Math.abs(n), Math.abs(v)) &&
          Math.abs(r - b) <= u * Math.max(1, Math.abs(r), Math.abs(b)) &&
          Math.abs(i - x) <= u * Math.max(1, Math.abs(i), Math.abs(x)) &&
          Math.abs(o - w) <= u * Math.max(1, Math.abs(o), Math.abs(w)) &&
          Math.abs(s - S) <= u * Math.max(1, Math.abs(s), Math.abs(S)) &&
          Math.abs(a - E) <= u * Math.max(1, Math.abs(a), Math.abs(E)) &&
          Math.abs(l - T) <= u * Math.max(1, Math.abs(l), Math.abs(T)) &&
          Math.abs(c - A) <= u * Math.max(1, Math.abs(c), Math.abs(A)) &&
          Math.abs(h - C) <= u * Math.max(1, Math.abs(h), Math.abs(C)) &&
          Math.abs(p - P) <= u * Math.max(1, Math.abs(p), Math.abs(P)) &&
          Math.abs(d - M) <= u * Math.max(1, Math.abs(d), Math.abs(M)) &&
          Math.abs(f - O) <= u * Math.max(1, Math.abs(f), Math.abs(O)) &&
          Math.abs(m - k) <= u * Math.max(1, Math.abs(m), Math.abs(k)) &&
          Math.abs(g - I) <= u * Math.max(1, Math.abs(g), Math.abs(I)) &&
          Math.abs(y - D) <= u * Math.max(1, Math.abs(y), Math.abs(D)) &&
          Math.abs(_ - z) <= u * Math.max(1, Math.abs(_), Math.abs(z))
        );
      }
      function x(t, e, n) {
        return (t[0] = e[0] + n[0]), (t[1] = e[1] + n[1]), t;
      }
      function w(t) {
        var e = t[0],
          n = t[1];
        return Math.hypot(e, n);
      }
      function S(t, e, n, r) {
        var i = e[0],
          o = e[1];
        return (t[0] = i + r * (n[0] - i)), (t[1] = o + r * (n[1] - o)), t;
      }
      var E = function (t, e, n) {
        return (t[0] = e[0] - n[0]), (t[1] = e[1] - n[1]), t;
      };
      !(function () {
        var t = (function () {
          var t = new h(2);
          return h != Float32Array && ((t[0] = 0), (t[1] = 0)), t;
        })();
      })();
      var T = function (t, e, n) {
        return (
          (t[0] = e[0] * n[0]), (t[1] = e[1] * n[1]), (t[2] = e[2] * n[2]), t
        );
      };
      !(function () {
        var t = (function () {
          var t = new h(3);
          return h != Float32Array && ((t[0] = 0), (t[1] = 0), (t[2] = 0)), t;
        })();
      })();
      function A(t, e) {
        if (!t)
          throw new Error(e || "@math.gl/web-mercator: assertion failed.");
      }
      const C = Math.PI,
        P = C / 4,
        M = C / 180,
        O = 180 / C,
        k = 512,
        I = 85.051129,
        D = 1.5;
      function z(t) {
        return Math.pow(2, t);
      }
      function R(t) {
        return m(t);
      }
      function L(t) {
        const [e, n] = t;
        A(Number.isFinite(e)),
          A(Number.isFinite(n) && n >= -90 && n <= 90, "invalid latitude");
        const r = n * M;
        return [
          (k * (e * M + C)) / (2 * C),
          (k * (C + Math.log(Math.tan(P + 0.5 * r)))) / (2 * C),
        ];
      }
      function F(t) {
        const [e, n] = t,
          r = (e / k) * (2 * C) - C,
          i = 2 * (Math.atan(Math.exp((n / k) * (2 * C) - C)) - P);
        return [r * O, i * O];
      }
      function B(t) {
        const { latitude: e, longitude: n, highPrecision: r = !1 } = t;
        A(Number.isFinite(e) && Number.isFinite(n));
        const i = Math.cos(e * M),
          o = 512 / 360,
          s = o / i,
          a = 12790407194604047e-21 / i,
          l = {
            unitsPerMeter: [a, a, a],
            metersPerUnit: [1 / a, 1 / a, 1 / a],
            unitsPerDegree: [o, s, a],
            degreesPerUnit: [0.703125, 1 / s, 1 / a],
          };
        if (r) {
          const t = (M * Math.tan(e * M)) / i,
            n = (o * t) / 2,
            r = 12790407194604047e-21 * t,
            c = (r / s) * a;
          (l.unitsPerDegree2 = [0, n, r]), (l.unitsPerMeter2 = [c, 0, c]);
        }
        return l;
      }
      function N(t) {
        const {
            height: e,
            pitch: n,
            bearing: r,
            altitude: i,
            scale: o,
            center: s,
          } = t,
          a = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        y(a, a, [0, 0, -i]),
          (function (t, e, n) {
            var r = Math.sin(n),
              i = Math.cos(n),
              o = e[4],
              s = e[5],
              a = e[6],
              l = e[7],
              c = e[8],
              u = e[9],
              h = e[10],
              p = e[11];
            e !== t &&
              ((t[0] = e[0]),
              (t[1] = e[1]),
              (t[2] = e[2]),
              (t[3] = e[3]),
              (t[12] = e[12]),
              (t[13] = e[13]),
              (t[14] = e[14]),
              (t[15] = e[15])),
              (t[4] = o * i + c * r),
              (t[5] = s * i + u * r),
              (t[6] = a * i + h * r),
              (t[7] = l * i + p * r),
              (t[8] = c * i - o * r),
              (t[9] = u * i - s * r),
              (t[10] = h * i - a * r),
              (t[11] = p * i - l * r);
          })(a, a, -n * M),
          (function (t, e, n) {
            var r = Math.sin(n),
              i = Math.cos(n),
              o = e[0],
              s = e[1],
              a = e[2],
              l = e[3],
              c = e[4],
              u = e[5],
              h = e[6],
              p = e[7];
            e !== t &&
              ((t[8] = e[8]),
              (t[9] = e[9]),
              (t[10] = e[10]),
              (t[11] = e[11]),
              (t[12] = e[12]),
              (t[13] = e[13]),
              (t[14] = e[14]),
              (t[15] = e[15])),
              (t[0] = o * i + c * r),
              (t[1] = s * i + u * r),
              (t[2] = a * i + h * r),
              (t[3] = l * i + p * r),
              (t[4] = c * i - o * r),
              (t[5] = u * i - s * r),
              (t[6] = h * i - a * r),
              (t[7] = p * i - l * r);
          })(a, a, r * M);
        const l = o / e;
        var c, u;
        return (
          _(a, a, [l, l, l]),
          s &&
            y(
              a,
              a,
              (((c = [])[0] = -(u = s)[0]), (c[1] = -u[1]), (c[2] = -u[2]), c)
            ),
          a
        );
      }
      function j(t) {
        const {
          fov: e,
          aspect: n,
          near: r,
          far: i,
        } = (function (t) {
          const {
            width: e,
            height: n,
            altitude: r,
            pitch: i = 0,
            offset: o,
            center: s,
            scale: a,
            nearZMultiplier: l = 1,
            farZMultiplier: c = 1,
          } = t;
          let { fovy: u = U(D) } = t;
          void 0 !== r && (u = U(r));
          const h = u * M,
            p = i * M,
            d = Z(u);
          let m = d;
          s && (m += (s[2] * a) / Math.cos(p) / n);
          const g = h * (0.5 + (o ? o[1] : 0) / n),
            y =
              (Math.sin(g) * m) /
              Math.sin(f(Math.PI / 2 - p - g, 0.01, Math.PI - 0.01)),
            _ = Math.sin(p) * y + m,
            v = 10 * m;
          return {
            fov: h,
            aspect: e / n,
            focalDistance: d,
            near: l,
            far: Math.min(_ * c, v),
          };
        })(t);
        return v([], e, n, r, i);
      }
      function U(t) {
        return 2 * Math.atan(0.5 / t) * O;
      }
      function Z(t) {
        return 0.5 / Math.tan(0.5 * t * M);
      }
      function V(t, e, n = 0) {
        const [r, i, o] = t;
        if (
          (A(
            Number.isFinite(r) && Number.isFinite(i),
            "invalid pixel coordinate"
          ),
          Number.isFinite(o))
        ) {
          return p(e, [r, i, o, 1]);
        }
        const s = p(e, [r, i, 0, 1]),
          a = p(e, [r, i, 1, 1]),
          l = s[2],
          c = a[2];
        return S([], s, a, l === c ? 0 : ((n || 0) - l) / (c - l));
      }
      function q(t) {
        const {
            width: e,
            height: n,
            bounds: r,
            minExtent: i = 0,
            maxZoom: o = 24,
            offset: s = [0, 0],
          } = t,
          [[a, l], [c, u]] = r,
          h = (function (t = 0) {
            if ("number" === typeof t)
              return { top: t, bottom: t, left: t, right: t };
            return (
              A(
                Number.isFinite(t.top) &&
                  Number.isFinite(t.bottom) &&
                  Number.isFinite(t.left) &&
                  Number.isFinite(t.right)
              ),
              t
            );
          })(t.padding),
          p = L([a, f(u, -85.051129, I)]),
          d = L([c, f(l, -85.051129, I)]),
          g = [
            Math.max(Math.abs(d[0] - p[0]), i),
            Math.max(Math.abs(d[1] - p[1]), i),
          ],
          y = [
            e - h.left - h.right - 2 * Math.abs(s[0]),
            n - h.top - h.bottom - 2 * Math.abs(s[1]),
          ];
        A(y[0] > 0 && y[1] > 0);
        const _ = y[0] / g[0],
          v = y[1] / g[1],
          b = (h.right - h.left) / 2 / _,
          x = (h.top - h.bottom) / 2 / v,
          w = F([(d[0] + p[0]) / 2 + b, (d[1] + p[1]) / 2 + x]),
          S = Math.min(o, m(Math.abs(Math.min(_, v))));
        return (
          A(Number.isFinite(S)), { longitude: w[0], latitude: w[1], zoom: S }
        );
      }
      const $ = Math.PI / 180;
      function G(t, e, n) {
        const { pixelUnprojectionMatrix: r } = t,
          i = p(r, [e, 0, 1, 1]),
          o = p(r, [e, t.height, 1, 1]),
          s = F(
            S(
              [],
              i,
              o,
              (n * t.distanceScales.unitsPerMeter[2] - i[2]) / (o[2] - i[2])
            )
          );
        return s.push(n), s;
      }
      class W {
        constructor(t = { width: 1, height: 1 }) {
          (0, o.Z)(this, "latitude", void 0),
            (0, o.Z)(this, "longitude", void 0),
            (0, o.Z)(this, "zoom", void 0),
            (0, o.Z)(this, "pitch", void 0),
            (0, o.Z)(this, "bearing", void 0),
            (0, o.Z)(this, "altitude", void 0),
            (0, o.Z)(this, "fovy", void 0),
            (0, o.Z)(this, "meterOffset", void 0),
            (0, o.Z)(this, "center", void 0),
            (0, o.Z)(this, "width", void 0),
            (0, o.Z)(this, "height", void 0),
            (0, o.Z)(this, "scale", void 0),
            (0, o.Z)(this, "distanceScales", void 0),
            (0, o.Z)(this, "viewMatrix", void 0),
            (0, o.Z)(this, "projectionMatrix", void 0),
            (0, o.Z)(this, "viewProjectionMatrix", void 0),
            (0, o.Z)(this, "pixelProjectionMatrix", void 0),
            (0, o.Z)(this, "pixelUnprojectionMatrix", void 0),
            (0, o.Z)(
              this,
              "equals",
              (t) =>
                t instanceof W &&
                t.width === this.width &&
                t.height === this.height &&
                b(t.projectionMatrix, this.projectionMatrix) &&
                b(t.viewMatrix, this.viewMatrix)
            ),
            (0, o.Z)(this, "project", (t, e = {}) => {
              const { topLeft: n = !0 } = e,
                r = (function (t, e) {
                  const [n, r, i = 0] = t;
                  return (
                    A(
                      Number.isFinite(n) &&
                        Number.isFinite(r) &&
                        Number.isFinite(i)
                    ),
                    p(e, [n, r, i, 1])
                  );
                })(this.projectPosition(t), this.pixelProjectionMatrix),
                [i, o] = r,
                s = n ? o : this.height - o;
              return 2 === t.length ? [i, s] : [i, s, r[2]];
            }),
            (0, o.Z)(this, "unproject", (t, e = {}) => {
              const { topLeft: n = !0, targetZ: r } = e,
                [i, o, s] = t,
                a = n ? o : this.height - o,
                l = r && r * this.distanceScales.unitsPerMeter[2],
                c = V([i, a, s], this.pixelUnprojectionMatrix, l),
                [u, h, p] = this.unprojectPosition(c);
              return Number.isFinite(s)
                ? [u, h, p]
                : Number.isFinite(r)
                ? [u, h, r]
                : [u, h];
            }),
            (0, o.Z)(this, "projectPosition", (t) => {
              const [e, n] = L(t);
              return [e, n, (t[2] || 0) * this.distanceScales.unitsPerMeter[2]];
            }),
            (0, o.Z)(this, "unprojectPosition", (t) => {
              const [e, n] = F(t);
              return [e, n, (t[2] || 0) * this.distanceScales.metersPerUnit[2]];
            });
          let { width: e, height: n, altitude: r = null, fovy: i = null } = t;
          const {
            latitude: s = 0,
            longitude: a = 0,
            zoom: l = 0,
            pitch: c = 0,
            bearing: u = 0,
            position: h = null,
            nearZMultiplier: d = 0.02,
            farZMultiplier: f = 1.01,
          } = t;
          (e = e || 1),
            (n = n || 1),
            null === i && null === r
              ? ((r = D), (i = U(r)))
              : null === i
              ? (i = U(r))
              : null === r && (r = Z(i));
          const m = z(l);
          r = Math.max(0.75, r);
          const g = B({ longitude: a, latitude: s }),
            y = L([a, s]);
          var _, v, x;
          y.push(0),
            h &&
              ((_ = y),
              (v = y),
              (x = T([], h, g.unitsPerMeter)),
              (_[0] = v[0] + x[0]),
              (_[1] = v[1] + x[1]),
              (_[2] = v[2] + x[2])),
            (this.projectionMatrix = j({
              width: e,
              height: n,
              scale: m,
              center: y,
              pitch: c,
              fovy: i,
              nearZMultiplier: d,
              farZMultiplier: f,
            })),
            (this.viewMatrix = N({
              height: n,
              scale: m,
              center: y,
              pitch: c,
              bearing: u,
              altitude: r,
            })),
            (this.width = e),
            (this.height = n),
            (this.scale = m),
            (this.latitude = s),
            (this.longitude = a),
            (this.zoom = l),
            (this.pitch = c),
            (this.bearing = u),
            (this.altitude = r),
            (this.fovy = i),
            (this.center = y),
            (this.meterOffset = h || [0, 0, 0]),
            (this.distanceScales = g),
            this._initMatrices(),
            Object.freeze(this);
        }
        _initMatrices() {
          const {
              width: t,
              height: e,
              projectionMatrix: n,
              viewMatrix: r,
            } = this,
            i = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
          g(i, i, n), g(i, i, r), (this.viewProjectionMatrix = i);
          const o = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
          _(o, o, [t / 2, -e / 2, 1]), y(o, o, [1, -1, 0]), g(o, o, i);
          const s = (function (t, e) {
            var n = e[0],
              r = e[1],
              i = e[2],
              o = e[3],
              s = e[4],
              a = e[5],
              l = e[6],
              c = e[7],
              u = e[8],
              h = e[9],
              p = e[10],
              d = e[11],
              f = e[12],
              m = e[13],
              g = e[14],
              y = e[15],
              _ = n * a - r * s,
              v = n * l - i * s,
              b = n * c - o * s,
              x = r * l - i * a,
              w = r * c - o * a,
              S = i * c - o * l,
              E = u * m - h * f,
              T = u * g - p * f,
              A = u * y - d * f,
              C = h * g - p * m,
              P = h * y - d * m,
              M = p * y - d * g,
              O = _ * M - v * P + b * C + x * A - w * T + S * E;
            return O
              ? ((O = 1 / O),
                (t[0] = (a * M - l * P + c * C) * O),
                (t[1] = (i * P - r * M - o * C) * O),
                (t[2] = (m * S - g * w + y * x) * O),
                (t[3] = (p * w - h * S - d * x) * O),
                (t[4] = (l * A - s * M - c * T) * O),
                (t[5] = (n * M - i * A + o * T) * O),
                (t[6] = (g * b - f * S - y * v) * O),
                (t[7] = (u * S - p * b + d * v) * O),
                (t[8] = (s * P - a * A + c * E) * O),
                (t[9] = (r * A - n * P - o * E) * O),
                (t[10] = (f * w - m * b + y * _) * O),
                (t[11] = (h * b - u * w - d * _) * O),
                (t[12] = (a * T - s * C - l * E) * O),
                (t[13] = (n * C - r * T + i * E) * O),
                (t[14] = (m * v - f * x - g * _) * O),
                (t[15] = (u * x - h * v + p * _) * O),
                t)
              : null;
          })([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], o);
          if (!s) throw new Error("Pixel project matrix not invertible");
          (this.pixelProjectionMatrix = o), (this.pixelUnprojectionMatrix = s);
        }
        projectFlat(t) {
          return L(t);
        }
        unprojectFlat(t) {
          return F(t);
        }
        getMapCenterByLngLatPosition({ lngLat: t, pos: e }) {
          const n = V(e, this.pixelUnprojectionMatrix),
            r = x([], L(t), (((i = [])[0] = -(o = n)[0]), (i[1] = -o[1]), i));
          var i, o;
          return F(x([], this.center, r));
        }
        fitBounds(t, e = {}) {
          const { width: n, height: r } = this,
            {
              longitude: i,
              latitude: o,
              zoom: s,
            } = q(Object.assign({ width: n, height: r, bounds: t }, e));
          return new W({
            width: n,
            height: r,
            longitude: i,
            latitude: o,
            zoom: s,
          });
        }
        getBounds(t) {
          const e = this.getBoundingRegion(t),
            n = Math.min(...e.map((t) => t[0])),
            r = Math.max(...e.map((t) => t[0]));
          return [
            [n, Math.min(...e.map((t) => t[1]))],
            [r, Math.max(...e.map((t) => t[1]))],
          ];
        }
        getBoundingRegion(t = {}) {
          return (function (t, e = 0) {
            const { width: n, height: r, unproject: i } = t,
              o = { targetZ: e },
              s = i([0, r], o),
              a = i([n, r], o);
            let l, c;
            return (
              (t.fovy ? 0.5 * t.fovy * $ : Math.atan(0.5 / t.altitude)) >
              (90 - t.pitch) * $ - 0.01
                ? ((l = G(t, 0, e)), (c = G(t, n, e)))
                : ((l = i([0, 0], o)), (c = i([n, 0], o))),
              [s, a, c, l]
            );
          })(this, t.z || 0);
        }
        getLocationAtPoint({ lngLat: t, pos: e }) {
          return this.getMapCenterByLngLatPosition({ lngLat: t, pos: e });
        }
      }
      const H = ["longitude", "latitude", "zoom"],
        X = { curve: 1.414, speed: 1.2 };
      function K(t, e, n) {
        const r = (n = Object.assign({}, X, n)).curve,
          i = t.zoom,
          o = [t.longitude, t.latitude],
          s = z(i),
          a = e.zoom,
          l = [e.longitude, e.latitude],
          c = z(a - i),
          u = L(o),
          h = L(l),
          p = E([], h, u),
          d = Math.max(t.width, t.height),
          f = d / c,
          m = w(p) * s,
          g = Math.max(m, 0.01),
          y = r * r,
          _ = (f * f - d * d + y * y * g * g) / (2 * d * y * g),
          v = (f * f - d * d - y * y * g * g) / (2 * f * y * g),
          b = Math.log(Math.sqrt(_ * _ + 1) - _),
          x = Math.log(Math.sqrt(v * v + 1) - v);
        return {
          startZoom: i,
          startCenterXY: u,
          uDelta: p,
          w0: d,
          u1: m,
          S: (x - b) / r,
          rho: r,
          rho2: y,
          r0: b,
          r1: x,
        };
      }
      var Y = n(91033),
        Q = n(15671),
        J = n(43144),
        tt =
          ("undefined" !== typeof window ? window : n.g,
          "undefined" !== typeof n.g ? n.g : window,
          "undefined" !== typeof document ? document : {});
      function et(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function nt(t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? et(Object(n), !0).forEach(function (e) {
                (0, o.Z)(t, e, n[e]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
            : et(Object(n)).forEach(function (e) {
                Object.defineProperty(
                  t,
                  e,
                  Object.getOwnPropertyDescriptor(n, e)
                );
              });
        }
        return t;
      }
      function rt(t, e) {
        var n;
        if ("undefined" === typeof Symbol || null == t[Symbol.iterator]) {
          if (
            Array.isArray(t) ||
            (n = (function (t, e) {
              if (!t) return;
              if ("string" === typeof t) return it(t, e);
              var n = Object.prototype.toString.call(t).slice(8, -1);
              "Object" === n && t.constructor && (n = t.constructor.name);
              if ("Map" === n || "Set" === n) return Array.from(t);
              if (
                "Arguments" === n ||
                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
              )
                return it(t, e);
            })(t)) ||
            (e && t && "number" === typeof t.length)
          ) {
            n && (t = n);
            var r = 0,
              i = function () {};
            return {
              s: i,
              n: function () {
                return r >= t.length
                  ? { done: !0 }
                  : { done: !1, value: t[r++] };
              },
              e: function (t) {
                throw t;
              },
              f: i,
            };
          }
          throw new TypeError(
            "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
          );
        }
        var o,
          s = !0,
          a = !1;
        return {
          s: function () {
            n = t[Symbol.iterator]();
          },
          n: function () {
            var t = n.next();
            return (s = t.done), t;
          },
          e: function (t) {
            (a = !0), (o = t);
          },
          f: function () {
            try {
              s || null == n.return || n.return();
            } finally {
              if (a) throw o;
            }
          },
        };
      }
      function it(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
        return r;
      }
      var ot = [
        "type",
        "source",
        "source-layer",
        "minzoom",
        "maxzoom",
        "filter",
        "layout",
      ];
      function st(t) {
        if (!t) return null;
        if ("string" === typeof t) return t;
        t.toJS && (t = t.toJS());
        var e,
          n = {},
          r = rt(t.layers);
        try {
          for (r.s(); !(e = r.n()).done; ) {
            var i = e.value;
            n[i.id] = i;
          }
        } catch (s) {
          r.e(s);
        } finally {
          r.f();
        }
        var o = t.layers.map(function (t) {
          var e = n[t.ref],
            r = null;
          if (("interactive" in t && delete (r = nt({}, t)).interactive, e)) {
            delete (r = r || nt({}, t)).ref;
            var i,
              o = rt(ot);
            try {
              for (o.s(); !(i = o.n()).done; ) {
                var a = i.value;
                a in e && (r[a] = e[a]);
              }
            } catch (s) {
              o.e(s);
            } finally {
              o.f();
            }
          }
          return r || t;
        });
        return nt(nt({}, t), {}, { layers: o });
      }
      var at = n(34155);
      var lt = {
          container: a.object,
          gl: a.object,
          mapboxApiAccessToken: a.string,
          mapboxApiUrl: a.string,
          attributionControl: a.bool,
          preserveDrawingBuffer: a.bool,
          reuseMaps: a.bool,
          transformRequest: a.func,
          mapOptions: a.object,
          mapStyle: a.oneOfType([a.string, a.object]),
          preventStyleDiffing: a.bool,
          visible: a.bool,
          asyncRender: a.bool,
          onLoad: a.func,
          onError: a.func,
          width: a.number,
          height: a.number,
          viewState: a.object,
          longitude: a.number,
          latitude: a.number,
          zoom: a.number,
          bearing: a.number,
          pitch: a.number,
          altitude: a.number,
        },
        ct = {
          container: tt.body,
          mapboxApiAccessToken: (function () {
            var t = null;
            if ("undefined" !== typeof window && window.location) {
              var e = window.location.search.match(/access_token=([^&\/]*)/);
              t = e && e[1];
            }
            t ||
              "undefined" === typeof at ||
              (t =
                t ||
                at.env.MapboxAccessToken ||
                at.env.REACT_APP_MAPBOX_ACCESS_TOKEN);
            return t || "no-token";
          })(),
          mapboxApiUrl: "https://api.mapbox.com",
          preserveDrawingBuffer: !1,
          attributionControl: !0,
          reuseMaps: !1,
          mapOptions: {},
          mapStyle: "mapbox://styles/mapbox/light-v8",
          preventStyleDiffing: !1,
          visible: !0,
          asyncRender: !1,
          onLoad: function () {},
          onError: function (t) {
            t && console.error(t.error);
          },
          width: 0,
          height: 0,
          longitude: 0,
          latitude: 0,
          zoom: 0,
          bearing: 0,
          pitch: 0,
          altitude: 1.5,
        };
      function ut(t) {
        var e =
          arguments.length > 1 && void 0 !== arguments[1]
            ? arguments[1]
            : "component";
        t.debug && a.checkPropTypes(lt, t, "prop", e);
      }
      var ht = (function () {
        function t(e) {
          var n = this;
          if (
            ((0, Q.Z)(this, t),
            (0, o.Z)(this, "props", ct),
            (0, o.Z)(this, "width", 0),
            (0, o.Z)(this, "height", 0),
            (0, o.Z)(this, "_fireLoadEvent", function () {
              n.props.onLoad({ type: "load", target: n._map });
            }),
            !e.mapboxgl)
          )
            throw new Error("Mapbox not available");
          (this.mapboxgl = e.mapboxgl),
            t.initialized ||
              ((t.initialized = !0),
              this._checkStyleSheet(this.mapboxgl.version)),
            this._initialize(e);
        }
        return (
          (0, J.Z)(t, [
            {
              key: "finalize",
              value: function () {
                return this._destroy(), this;
              },
            },
            {
              key: "setProps",
              value: function (t) {
                return this._update(this.props, t), this;
              },
            },
            {
              key: "redraw",
              value: function () {
                var t = this._map;
                t.style &&
                  (t._frame && (t._frame.cancel(), (t._frame = null)),
                  t._render());
              },
            },
            {
              key: "getMap",
              value: function () {
                return this._map;
              },
            },
            {
              key: "_reuse",
              value: function (e) {
                this._map = t.savedMap;
                var n = this._map.getContainer(),
                  r = e.container;
                for (r.classList.add("mapboxgl-map"); n.childNodes.length > 0; )
                  r.appendChild(n.childNodes[0]);
                (this._map._container = r),
                  (t.savedMap = null),
                  e.mapStyle &&
                    this._map.setStyle(st(e.mapStyle), { diff: !1 }),
                  this._map.isStyleLoaded()
                    ? this._fireLoadEvent()
                    : this._map.once("styledata", this._fireLoadEvent);
              },
            },
            {
              key: "_create",
              value: function (e) {
                if (e.reuseMaps && t.savedMap) this._reuse(e);
                else {
                  if (e.gl) {
                    var n = HTMLCanvasElement.prototype.getContext;
                    HTMLCanvasElement.prototype.getContext = function () {
                      return (HTMLCanvasElement.prototype.getContext = n), e.gl;
                    };
                  }
                  var r = {
                    container: e.container,
                    center: [0, 0],
                    zoom: 8,
                    pitch: 0,
                    bearing: 0,
                    maxZoom: 24,
                    style: st(e.mapStyle),
                    interactive: !1,
                    trackResize: !1,
                    attributionControl: e.attributionControl,
                    preserveDrawingBuffer: e.preserveDrawingBuffer,
                  };
                  e.transformRequest &&
                    (r.transformRequest = e.transformRequest),
                    (this._map = new this.mapboxgl.Map(
                      Object.assign({}, r, e.mapOptions)
                    )),
                    this._map.once("load", e.onLoad),
                    this._map.on("error", e.onError);
                }
                return this;
              },
            },
            {
              key: "_destroy",
              value: function () {
                this._map &&
                  (t.savedMap
                    ? this._map.remove()
                    : ((t.savedMap = this._map),
                      this._map.off("load", this.props.onLoad),
                      this._map.off("error", this.props.onError),
                      this._map.off("styledata", this._fireLoadEvent)),
                  (this._map = null));
              },
            },
            {
              key: "_initialize",
              value: function (t) {
                var e = this;
                ut((t = Object.assign({}, ct, t)), "Mapbox"),
                  (this.mapboxgl.accessToken =
                    t.mapboxApiAccessToken || ct.mapboxApiAccessToken),
                  (this.mapboxgl.baseApiUrl = t.mapboxApiUrl),
                  this._create(t);
                var n = t.container;
                Object.defineProperty(n, "offsetWidth", {
                  get: function () {
                    return e.width;
                  },
                }),
                  Object.defineProperty(n, "clientWidth", {
                    get: function () {
                      return e.width;
                    },
                  }),
                  Object.defineProperty(n, "offsetHeight", {
                    get: function () {
                      return e.height;
                    },
                  }),
                  Object.defineProperty(n, "clientHeight", {
                    get: function () {
                      return e.height;
                    },
                  });
                var r = this._map.getCanvas();
                r && (r.style.outline = "none"),
                  this._updateMapViewport({}, t),
                  this._updateMapSize({}, t),
                  (this.props = t);
              },
            },
            {
              key: "_update",
              value: function (t, e) {
                if (this._map) {
                  ut((e = Object.assign({}, this.props, e)), "Mapbox");
                  var n = this._updateMapViewport(t, e),
                    r = this._updateMapSize(t, e);
                  this._updateMapStyle(t, e),
                    e.asyncRender || (!n && !r) || this.redraw(),
                    (this.props = e);
                }
              },
            },
            {
              key: "_updateMapStyle",
              value: function (t, e) {
                t.mapStyle !== e.mapStyle &&
                  this._map.setStyle(st(e.mapStyle), {
                    diff: !e.preventStyleDiffing,
                  });
              },
            },
            {
              key: "_updateMapSize",
              value: function (t, e) {
                var n = t.width !== e.width || t.height !== e.height;
                return (
                  n &&
                    ((this.width = e.width),
                    (this.height = e.height),
                    this._map.resize()),
                  n
                );
              },
            },
            {
              key: "_updateMapViewport",
              value: function (t, e) {
                var n = this._getViewState(t),
                  r = this._getViewState(e),
                  i =
                    r.latitude !== n.latitude ||
                    r.longitude !== n.longitude ||
                    r.zoom !== n.zoom ||
                    r.pitch !== n.pitch ||
                    r.bearing !== n.bearing ||
                    r.altitude !== n.altitude;
                return (
                  i &&
                    (this._map.jumpTo(this._viewStateToMapboxProps(r)),
                    r.altitude !== n.altitude &&
                      (this._map.transform.altitude = r.altitude)),
                  i
                );
              },
            },
            {
              key: "_getViewState",
              value: function (t) {
                var e = t.viewState || t,
                  n = e.longitude,
                  r = e.latitude,
                  i = e.zoom,
                  o = e.pitch,
                  s = void 0 === o ? 0 : o,
                  a = e.bearing,
                  l = void 0 === a ? 0 : a,
                  c = e.altitude;
                return {
                  longitude: n,
                  latitude: r,
                  zoom: i,
                  pitch: s,
                  bearing: l,
                  altitude: void 0 === c ? 1.5 : c,
                };
              },
            },
            {
              key: "_checkStyleSheet",
              value: function () {
                var t =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : "0.47.0";
                if ("undefined" !== typeof tt)
                  try {
                    var e = tt.createElement("div");
                    (e.className = "mapboxgl-map"),
                      (e.style.display = "none"),
                      tt.body.appendChild(e);
                    var n = "static" !== window.getComputedStyle(e).position;
                    if (!n) {
                      var r = tt.createElement("link");
                      r.setAttribute("rel", "stylesheet"),
                        r.setAttribute("type", "text/css"),
                        r.setAttribute(
                          "href",
                          "https://api.tiles.mapbox.com/mapbox-gl-js/v".concat(
                            t,
                            "/mapbox-gl.css"
                          )
                        ),
                        tt.head.appendChild(r);
                    }
                  } catch (i) {}
              },
            },
            {
              key: "_viewStateToMapboxProps",
              value: function (t) {
                return {
                  center: [t.longitude, t.latitude],
                  zoom: t.zoom,
                  bearing: t.bearing,
                  pitch: t.pitch,
                };
              },
            },
          ]),
          t
        );
      })();
      (0, o.Z)(ht, "initialized", !1),
        (0, o.Z)(ht, "propTypes", lt),
        (0, o.Z)(ht, "defaultProps", ct),
        (0, o.Z)(ht, "savedMap", null);
      var pt = n(6158),
        dt = n.n(pt);
      function ft(t) {
        return Array.isArray(t) || ArrayBuffer.isView(t);
      }
      function mt(t, e) {
        if (t === e) return !0;
        if (ft(t) && ft(e)) {
          if (t.length !== e.length) return !1;
          for (var n = 0; n < t.length; ++n) if (!mt(t[n], e[n])) return !1;
          return !0;
        }
        return Math.abs(t - e) <= 1e-7;
      }
      function gt(t, e, n) {
        return Math.max(e, Math.min(n, t));
      }
      function yt(t, e, n) {
        return ft(t)
          ? t.map(function (t, r) {
              return yt(t, e[r], n);
            })
          : n * e + (1 - n) * t;
      }
      function _t(t, e) {
        if (!t) throw new Error(e || "react-map-gl: assertion failed.");
      }
      function vt(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function bt(t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? vt(Object(n), !0).forEach(function (e) {
                (0, o.Z)(t, e, n[e]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
            : vt(Object(n)).forEach(function (e) {
                Object.defineProperty(
                  t,
                  e,
                  Object.getOwnPropertyDescriptor(n, e)
                );
              });
        }
        return t;
      }
      var xt = { minZoom: 0, maxZoom: 24, minPitch: 0, maxPitch: 85 },
        wt = 0,
        St = 0,
        Et = 1.5,
        Tt = (function () {
          function t(e) {
            var n = e.width,
              r = e.height,
              i = e.latitude,
              o = e.longitude,
              s = e.zoom,
              a = e.bearing,
              l = void 0 === a ? St : a,
              c = e.pitch,
              u = void 0 === c ? wt : c,
              h = e.altitude,
              p = void 0 === h ? Et : h,
              d = e.maxZoom,
              f = void 0 === d ? xt.maxZoom : d,
              m = e.minZoom,
              g = void 0 === m ? xt.minZoom : m,
              y = e.maxPitch,
              _ = void 0 === y ? xt.maxPitch : y,
              v = e.minPitch,
              b = void 0 === v ? xt.minPitch : v,
              x = e.transitionDuration,
              w = e.transitionEasing,
              S = e.transitionInterpolator,
              E = e.transitionInterruption,
              T = e.startPanLngLat,
              A = e.startZoomLngLat,
              C = e.startRotatePos,
              P = e.startBearing,
              M = e.startPitch,
              O = e.startZoom;
            (0, Q.Z)(this, t),
              _t(Number.isFinite(n), "`width` must be supplied"),
              _t(Number.isFinite(r), "`height` must be supplied"),
              _t(Number.isFinite(o), "`longitude` must be supplied"),
              _t(Number.isFinite(i), "`latitude` must be supplied"),
              _t(Number.isFinite(s), "`zoom` must be supplied"),
              (this._viewportProps = this._applyConstraints({
                width: n,
                height: r,
                latitude: i,
                longitude: o,
                zoom: s,
                bearing: l,
                pitch: u,
                altitude: p,
                maxZoom: f,
                minZoom: g,
                maxPitch: _,
                minPitch: b,
                transitionDuration: x,
                transitionEasing: w,
                transitionInterpolator: S,
                transitionInterruption: E,
              })),
              (this._state = {
                startPanLngLat: T,
                startZoomLngLat: A,
                startRotatePos: C,
                startBearing: P,
                startPitch: M,
                startZoom: O,
              });
          }
          return (
            (0, J.Z)(t, [
              {
                key: "getViewportProps",
                value: function () {
                  return this._viewportProps;
                },
              },
              {
                key: "getState",
                value: function () {
                  return this._state;
                },
              },
              {
                key: "panStart",
                value: function (t) {
                  var e = t.pos;
                  return this._getUpdatedMapState({
                    startPanLngLat: this._unproject(e),
                  });
                },
              },
              {
                key: "pan",
                value: function (t) {
                  var e = t.pos,
                    n = t.startPos,
                    r = this._state.startPanLngLat || this._unproject(n);
                  if (!r) return this;
                  var i = c(
                      this._calculateNewLngLat({ startPanLngLat: r, pos: e }),
                      2
                    ),
                    o = i[0],
                    s = i[1];
                  return this._getUpdatedMapState({
                    longitude: o,
                    latitude: s,
                  });
                },
              },
              {
                key: "panEnd",
                value: function () {
                  return this._getUpdatedMapState({ startPanLngLat: null });
                },
              },
              {
                key: "rotateStart",
                value: function (t) {
                  var e = t.pos;
                  return this._getUpdatedMapState({
                    startRotatePos: e,
                    startBearing: this._viewportProps.bearing,
                    startPitch: this._viewportProps.pitch,
                  });
                },
              },
              {
                key: "rotate",
                value: function (t) {
                  var e,
                    n = t.pos,
                    r = t.deltaAngleX,
                    i = void 0 === r ? 0 : r,
                    o = t.deltaAngleY,
                    s = void 0 === o ? 0 : o,
                    a = this._state,
                    l = a.startRotatePos,
                    c = a.startBearing,
                    u = a.startPitch;
                  return Number.isFinite(c) && Number.isFinite(u)
                    ? ((e = n
                        ? this._calculateNewPitchAndBearing(
                            bt(
                              bt({}, this._getRotationParams(n, l)),
                              {},
                              { startBearing: c, startPitch: u }
                            )
                          )
                        : { bearing: c + i, pitch: u + s }),
                      this._getUpdatedMapState(e))
                    : this;
                },
              },
              {
                key: "rotateEnd",
                value: function () {
                  return this._getUpdatedMapState({
                    startBearing: null,
                    startPitch: null,
                  });
                },
              },
              {
                key: "zoomStart",
                value: function (t) {
                  var e = t.pos;
                  return this._getUpdatedMapState({
                    startZoomLngLat: this._unproject(e),
                    startZoom: this._viewportProps.zoom,
                  });
                },
              },
              {
                key: "zoom",
                value: function (t) {
                  var e = t.pos,
                    n = t.startPos,
                    r = t.scale;
                  _t(r > 0, "`scale` must be a positive number");
                  var i = this._state,
                    o = i.startZoom,
                    s = i.startZoomLngLat;
                  Number.isFinite(o) ||
                    ((o = this._viewportProps.zoom),
                    (s = this._unproject(n) || this._unproject(e))),
                    _t(
                      s,
                      "`startZoomLngLat` prop is required for zoom behavior to calculate where to position the map."
                    );
                  var a = this._calculateNewZoom({
                      scale: r,
                      startZoom: o || 0,
                    }),
                    l = c(
                      new W(
                        Object.assign({}, this._viewportProps, { zoom: a })
                      ).getMapCenterByLngLatPosition({ lngLat: s, pos: e }),
                      2
                    ),
                    u = l[0],
                    h = l[1];
                  return this._getUpdatedMapState({
                    zoom: a,
                    longitude: u,
                    latitude: h,
                  });
                },
              },
              {
                key: "zoomEnd",
                value: function () {
                  return this._getUpdatedMapState({
                    startZoomLngLat: null,
                    startZoom: null,
                  });
                },
              },
              {
                key: "_getUpdatedMapState",
                value: function (e) {
                  return new t(
                    Object.assign({}, this._viewportProps, this._state, e)
                  );
                },
              },
              {
                key: "_applyConstraints",
                value: function (t) {
                  var e = t.maxZoom,
                    n = t.minZoom,
                    r = t.zoom;
                  t.zoom = gt(r, n, e);
                  var i = t.maxPitch,
                    o = t.minPitch,
                    s = t.pitch;
                  return (
                    (t.pitch = gt(s, o, i)),
                    Object.assign(
                      t,
                      (function (t) {
                        const { width: e, height: n, pitch: r = 0 } = t;
                        let {
                          longitude: i,
                          latitude: o,
                          zoom: s,
                          bearing: a = 0,
                        } = t;
                        (i < -180 || i > 180) && (i = d(i + 180, 360) - 180),
                          (a < -180 || a > 180) && (a = d(a + 180, 360) - 180);
                        const l = m(n / 512);
                        if (s <= l) (s = l), (o = 0);
                        else {
                          const t = n / 2 / Math.pow(2, s),
                            e = F([0, t])[1];
                          if (o < e) o = e;
                          else {
                            const e = F([0, 512 - t])[1];
                            o > e && (o = e);
                          }
                        }
                        return {
                          width: e,
                          height: n,
                          longitude: i,
                          latitude: o,
                          zoom: s,
                          pitch: r,
                          bearing: a,
                        };
                      })(t)
                    ),
                    t
                  );
                },
              },
              {
                key: "_unproject",
                value: function (t) {
                  var e = new W(this._viewportProps);
                  return t && e.unproject(t);
                },
              },
              {
                key: "_calculateNewLngLat",
                value: function (t) {
                  var e = t.startPanLngLat,
                    n = t.pos;
                  return new W(
                    this._viewportProps
                  ).getMapCenterByLngLatPosition({ lngLat: e, pos: n });
                },
              },
              {
                key: "_calculateNewZoom",
                value: function (t) {
                  var e = t.scale,
                    n = t.startZoom,
                    r = this._viewportProps,
                    i = r.maxZoom,
                    o = r.minZoom;
                  return gt(n + Math.log2(e), o, i);
                },
              },
              {
                key: "_calculateNewPitchAndBearing",
                value: function (t) {
                  var e = t.deltaScaleX,
                    n = t.deltaScaleY,
                    r = t.startBearing,
                    i = t.startPitch;
                  n = gt(n, -1, 1);
                  var o = this._viewportProps,
                    s = o.minPitch,
                    a = o.maxPitch,
                    l = i;
                  return (
                    n > 0
                      ? (l = i + n * (a - i))
                      : n < 0 && (l = i - n * (s - i)),
                    { pitch: l, bearing: r + 180 * e }
                  );
                },
              },
              {
                key: "_getRotationParams",
                value: function (t, e) {
                  var n = t[0] - e[0],
                    r = t[1] - e[1],
                    i = t[1],
                    o = e[1],
                    s = this._viewportProps,
                    a = s.width,
                    l = s.height,
                    c = n / a,
                    u = 0;
                  return (
                    r > 0
                      ? Math.abs(l - o) > 5 && (u = (r / (o - l)) * 1.2)
                      : r < 0 && o > 5 && (u = 1 - i / o),
                    {
                      deltaScaleX: c,
                      deltaScaleY: (u = Math.min(1, Math.max(-1, u))),
                    }
                  );
                },
              },
            ]),
            t
          );
        })();
      function At(t) {
        return t[0].toLowerCase() + t.slice(1);
      }
      function Ct(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function Pt(t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? Ct(Object(n), !0).forEach(function (e) {
                (0, o.Z)(t, e, n[e]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
            : Ct(Object(n)).forEach(function (e) {
                Object.defineProperty(
                  t,
                  e,
                  Object.getOwnPropertyDescriptor(n, e)
                );
              });
        }
        return t;
      }
      var Mt = (0, s.createContext)({
          viewport: null,
          map: null,
          container: null,
          onViewportChange: null,
          onViewStateChange: null,
          eventManager: null,
        }),
        Ot = Mt.Provider;
      Mt.Provider = function (t) {
        var e = t.value,
          n = t.children,
          r = c((0, s.useState)(null), 2),
          i = r[0],
          o = r[1],
          a = (0, s.useContext)(Mt);
        return (
          (e = Pt(Pt({ setMap: o }, a), {}, { map: (a && a.map) || i }, e)),
          s.createElement(Ot, { value: e }, n)
        );
      };
      var kt = Mt,
        It = "undefined" !== typeof window ? s.useLayoutEffect : s.useEffect;
      function Dt(t, e) {
        var n = e.longitude,
          r = e.latitude;
        return (
          (t && t.queryTerrainElevation && t.queryTerrainElevation([n, r])) || 0
        );
      }
      function zt(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function Rt(t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? zt(Object(n), !0).forEach(function (e) {
                (0, o.Z)(t, e, n[e]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
            : zt(Object(n)).forEach(function (e) {
                Object.defineProperty(
                  t,
                  e,
                  Object.getOwnPropertyDescriptor(n, e)
                );
              });
        }
        return t;
      }
      var Lt = "A valid API access token is required to use Mapbox data";
      function Ft(t) {
        var e = t.map,
          n = t.props,
          r = t.width,
          i = t.height,
          o = Rt(Rt(Rt({}, n), n.viewState), {}, { width: r, height: i });
        return (o.position = [0, 0, Dt(e, o)]), new W(o);
      }
      var Bt = {
          position: "absolute",
          width: "100%",
          height: "100%",
          overflow: "hidden",
        },
        Nt = Object.assign({}, ht.propTypes, {
          width: a.oneOfType([a.number, a.string]),
          height: a.oneOfType([a.number, a.string]),
          onResize: a.func,
          disableTokenWarning: a.bool,
          visible: a.bool,
          className: a.string,
          style: a.object,
          visibilityConstraints: a.object,
        }),
        jt = Object.assign({}, ht.defaultProps, {
          disableTokenWarning: !1,
          visible: !0,
          onResize: function () {},
          className: "",
          style: null,
          visibilityConstraints: xt,
        });
      function Ut() {
        return s.createElement(
          "div",
          {
            key: "warning",
            id: "no-token-warning",
            style: { position: "absolute", left: 0, top: 0 },
          },
          s.createElement("h3", { key: "header" }, Lt),
          s.createElement(
            "div",
            { key: "text" },
            "For information on setting up your basemap, read"
          ),
          s.createElement(
            "a",
            {
              key: "link",
              href: "https://visgl.github.io/react-map-gl/docs/get-started/mapbox-tokens",
            },
            "Note on Map Tokens"
          )
        );
      }
      var Zt = (0, s.forwardRef)(function (t, e) {
        var n = c((0, s.useState)(!0), 2),
          r = n[0],
          i = n[1],
          o = c((0, s.useState)({ width: 0, height: 0 }), 2),
          a = o[0],
          l = o[1],
          u = (0, s.useRef)(null),
          h = (0, s.useRef)(null),
          p = (0, s.useRef)(null),
          d = (0, s.useRef)(null),
          f = (0, s.useContext)(kt);
        It(function () {
          if (Zt.supported()) {
            var e = new ht(
              Rt(
                Rt(Rt({}, t), a),
                {},
                {
                  mapboxgl: dt(),
                  container: h.current,
                  onError: function (e) {
                    401 === ((e.error && e.error.status) || e.status) &&
                      r &&
                      (console.error(Lt), i(!1)),
                      t.onError(e);
                  },
                }
              )
            );
            (u.current = e), f && f.setMap && f.setMap(e.getMap());
            var n = new Y.default(function (e) {
              if (e[0].contentRect) {
                var n = e[0].contentRect,
                  r = n.width,
                  i = n.height;
                l({ width: r, height: i }), t.onResize({ width: r, height: i });
              }
            });
            return (
              n.observe(p.current),
              function () {
                e.finalize(), (u.current = null), n.disconnect();
              }
            );
          }
        }, []),
          It(function () {
            u.current && u.current.setProps(Rt(Rt({}, t), a));
          });
        var m = u.current && u.current.getMap();
        (0, s.useImperativeHandle)(
          e,
          function () {
            return (function (t) {
              return {
                getMap: function () {
                  return t.current && t.current.getMap();
                },
                queryRenderedFeatures: function (e) {
                  var n =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : {},
                    r = t.current && t.current.getMap();
                  return r && r.queryRenderedFeatures(e, n);
                },
              };
            })(u);
          },
          []
        );
        var g = (0, s.useCallback)(function (t) {
            var e = t.target;
            e === d.current && e.scrollTo(0, 0);
          }, []),
          y =
            m &&
            s.createElement(
              Ot,
              {
                value: Rt(
                  Rt({}, f),
                  {},
                  {
                    viewport: f.viewport || Ft(Rt({ map: m, props: t }, a)),
                    map: m,
                    container: f.container || p.current,
                  }
                ),
              },
              s.createElement(
                "div",
                {
                  key: "map-overlays",
                  className: "overlays",
                  ref: d,
                  style: Bt,
                  onScroll: g,
                },
                t.children
              )
            ),
          _ = t.className,
          v = t.width,
          b = t.height,
          x = t.style,
          w = t.visibilityConstraints,
          S = Object.assign({ position: "relative" }, x, {
            width: v,
            height: b,
          }),
          E =
            t.visible &&
            (function (t) {
              var e =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : xt;
              for (var n in e) {
                var r = n.slice(0, 3),
                  i = At(n.slice(3));
                if ("min" === r && t[i] < e[n]) return !1;
                if ("max" === r && t[i] > e[n]) return !1;
              }
              return !0;
            })(t.viewState || t, w),
          T = Object.assign({}, Bt, { visibility: E ? "inherit" : "hidden" });
        return s.createElement(
          "div",
          { key: "map-container", ref: p, style: S },
          s.createElement("div", {
            key: "map-mapbox",
            ref: h,
            style: T,
            className: _,
          }),
          y,
          !r && !t.disableTokenWarning && s.createElement(Ut, null)
        );
      });
      (Zt.supported = function () {
        return dt() && dt().supported();
      }),
        (Zt.propTypes = Nt),
        (Zt.defaultProps = jt);
      var Vt = Zt;
      function qt(t, e) {
        var n;
        if ("undefined" === typeof Symbol || null == t[Symbol.iterator]) {
          if (
            Array.isArray(t) ||
            (n = (function (t, e) {
              if (!t) return;
              if ("string" === typeof t) return $t(t, e);
              var n = Object.prototype.toString.call(t).slice(8, -1);
              "Object" === n && t.constructor && (n = t.constructor.name);
              if ("Map" === n || "Set" === n) return Array.from(t);
              if (
                "Arguments" === n ||
                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
              )
                return $t(t, e);
            })(t)) ||
            (e && t && "number" === typeof t.length)
          ) {
            n && (t = n);
            var r = 0,
              i = function () {};
            return {
              s: i,
              n: function () {
                return r >= t.length
                  ? { done: !0 }
                  : { done: !1, value: t[r++] };
              },
              e: function (t) {
                throw t;
              },
              f: i,
            };
          }
          throw new TypeError(
            "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
          );
        }
        var o,
          s = !0,
          a = !1;
        return {
          s: function () {
            n = t[Symbol.iterator]();
          },
          n: function () {
            var t = n.next();
            return (s = t.done), t;
          },
          e: function (t) {
            (a = !0), (o = t);
          },
          f: function () {
            try {
              s || null == n.return || n.return();
            } finally {
              if (a) throw o;
            }
          },
        };
      }
      function $t(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
        return r;
      }
      var Gt = (function () {
        function t() {
          (0, Q.Z)(this, t), (0, o.Z)(this, "propNames", []);
        }
        return (
          (0, J.Z)(t, [
            {
              key: "arePropsEqual",
              value: function (t, e) {
                var n,
                  r = qt(this.propNames || []);
                try {
                  for (r.s(); !(n = r.n()).done; ) {
                    var i = n.value;
                    if (!mt(t[i], e[i])) return !1;
                  }
                } catch (o) {
                  r.e(o);
                } finally {
                  r.f();
                }
                return !0;
              },
            },
            {
              key: "initializeProps",
              value: function (t, e) {
                return { start: t, end: e };
              },
            },
            {
              key: "interpolateProps",
              value: function (t, e, n) {
                _t(!1, "interpolateProps is not implemented");
              },
            },
            {
              key: "getDuration",
              value: function (t, e) {
                return e.transitionDuration;
              },
            },
          ]),
          t
        );
      })();
      function Wt(t) {
        if (void 0 === t)
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        return t;
      }
      var Ht = n(60136),
        Xt = n(71002);
      function Kt(t, e) {
        if (e && ("object" === (0, Xt.Z)(e) || "function" === typeof e))
          return e;
        if (void 0 !== e)
          throw new TypeError(
            "Derived constructors may only return object or undefined"
          );
        return Wt(t);
      }
      function Yt(t) {
        return (
          (Yt = Object.setPrototypeOf
            ? Object.getPrototypeOf
            : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t);
              }),
          Yt(t)
        );
      }
      var Qt = { longitude: 1, bearing: 1 };
      function Jt(t) {
        return Number.isFinite(t) || Array.isArray(t);
      }
      function te(t, e, n) {
        return (
          (function (t) {
            return t in Qt;
          })(t) &&
            Math.abs(n - e) > 180 &&
            (n = n < 0 ? n + 360 : n - 360),
          n
        );
      }
      function ee(t, e) {
        var n;
        if ("undefined" === typeof Symbol || null == t[Symbol.iterator]) {
          if (
            Array.isArray(t) ||
            (n = (function (t, e) {
              if (!t) return;
              if ("string" === typeof t) return ne(t, e);
              var n = Object.prototype.toString.call(t).slice(8, -1);
              "Object" === n && t.constructor && (n = t.constructor.name);
              if ("Map" === n || "Set" === n) return Array.from(t);
              if (
                "Arguments" === n ||
                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
              )
                return ne(t, e);
            })(t)) ||
            (e && t && "number" === typeof t.length)
          ) {
            n && (t = n);
            var r = 0,
              i = function () {};
            return {
              s: i,
              n: function () {
                return r >= t.length
                  ? { done: !0 }
                  : { done: !1, value: t[r++] };
              },
              e: function (t) {
                throw t;
              },
              f: i,
            };
          }
          throw new TypeError(
            "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
          );
        }
        var o,
          s = !0,
          a = !1;
        return {
          s: function () {
            n = t[Symbol.iterator]();
          },
          n: function () {
            var t = n.next();
            return (s = t.done), t;
          },
          e: function (t) {
            (a = !0), (o = t);
          },
          f: function () {
            try {
              s || null == n.return || n.return();
            } finally {
              if (a) throw o;
            }
          },
        };
      }
      function ne(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
        return r;
      }
      function re(t) {
        var e = (function () {
          if ("undefined" === typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" === typeof Proxy) return !0;
          try {
            return (
              Date.prototype.toString.call(
                Reflect.construct(Date, [], function () {})
              ),
              !0
            );
          } catch (t) {
            return !1;
          }
        })();
        return function () {
          var n,
            r = Yt(t);
          if (e) {
            var i = Yt(this).constructor;
            n = Reflect.construct(r, arguments, i);
          } else n = r.apply(this, arguments);
          return Kt(this, n);
        };
      }
      var ie = ["longitude", "latitude", "zoom", "bearing", "pitch"],
        oe = ["latitude", "longitude", "zoom", "width", "height"],
        se = ["bearing", "pitch"],
        ae = { speed: 1.2, curve: 1.414 };
      !(function (t) {
        (0, Ht.Z)(n, t);
        var e = re(n);
        function n() {
          var t,
            r =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {};
          return (
            (0, Q.Z)(this, n),
            (t = e.call(this)),
            (0, o.Z)(Wt(t), "propNames", ie),
            (t.props = Object.assign({}, ae, r)),
            t
          );
        }
        (0, J.Z)(n, [
          {
            key: "initializeProps",
            value: function (t, e) {
              var n,
                r = {},
                i = {},
                o = ee(oe);
              try {
                for (o.s(); !(n = o.n()).done; ) {
                  var s = n.value,
                    a = t[s],
                    l = e[s];
                  _t(
                    Jt(a) && Jt(l),
                    "".concat(s, " must be supplied for transition")
                  ),
                    (r[s] = a),
                    (i[s] = te(s, a, l));
                }
              } catch (f) {
                o.e(f);
              } finally {
                o.f();
              }
              var c,
                u = ee(se);
              try {
                for (u.s(); !(c = u.n()).done; ) {
                  var h = c.value,
                    p = t[h] || 0,
                    d = e[h] || 0;
                  (r[h] = p), (i[h] = te(h, p, d));
                }
              } catch (f) {
                u.e(f);
              } finally {
                u.f();
              }
              return { start: r, end: i };
            },
          },
          {
            key: "interpolateProps",
            value: function (t, e, n) {
              var r,
                i = (function (t, e, n, r) {
                  const {
                    startZoom: i,
                    startCenterXY: o,
                    uDelta: s,
                    w0: a,
                    u1: l,
                    S: c,
                    rho: u,
                    rho2: h,
                    r0: p,
                  } = K(t, e, r);
                  if (l < 0.01) {
                    const r = {};
                    for (const i of H) {
                      const o = t[i],
                        s = e[i];
                      r[i] = (d = n) * s + (1 - d) * o;
                    }
                    return r;
                  }
                  var d;
                  const f = n * c,
                    m = Math.cosh(p) / Math.cosh(p + u * f),
                    g =
                      (a *
                        ((Math.cosh(p) * Math.tanh(p + u * f) - Math.sinh(p)) /
                          h)) /
                      l,
                    y = i + R(1 / m),
                    _ =
                      ((w = g),
                      ((v = [])[0] = (b = s)[0] * w),
                      (v[1] = b[1] * w),
                      v);
                  var v, b, w;
                  x(_, _, o);
                  const S = F(_);
                  return { longitude: S[0], latitude: S[1], zoom: y };
                })(t, e, n, this.props),
                o = ee(se);
              try {
                for (o.s(); !(r = o.n()).done; ) {
                  var s = r.value;
                  i[s] = yt(t[s], e[s], n);
                }
              } catch (a) {
                o.e(a);
              } finally {
                o.f();
              }
              return i;
            },
          },
          {
            key: "getDuration",
            value: function (t, e) {
              var n = e.transitionDuration;
              return (
                "auto" === n &&
                  (n = (function (t, e, n) {
                    const r = { ...X, ...n },
                      { screenSpeed: i, speed: o, maxDuration: s } = r,
                      { S: a, rho: l } = K(t, e, r),
                      c = 1e3 * a;
                    let u;
                    return (
                      (u = Number.isFinite(i) ? c / (i / l) : c / o),
                      Number.isFinite(s) && u > s ? 0 : u
                    );
                  })(t, e, this.props)),
                n
              );
            },
          },
        ]);
      })(Gt);
      function le(t, e) {
        var n;
        if ("undefined" === typeof Symbol || null == t[Symbol.iterator]) {
          if (
            Array.isArray(t) ||
            (n = (function (t, e) {
              if (!t) return;
              if ("string" === typeof t) return ce(t, e);
              var n = Object.prototype.toString.call(t).slice(8, -1);
              "Object" === n && t.constructor && (n = t.constructor.name);
              if ("Map" === n || "Set" === n) return Array.from(t);
              if (
                "Arguments" === n ||
                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
              )
                return ce(t, e);
            })(t)) ||
            (e && t && "number" === typeof t.length)
          ) {
            n && (t = n);
            var r = 0,
              i = function () {};
            return {
              s: i,
              n: function () {
                return r >= t.length
                  ? { done: !0 }
                  : { done: !1, value: t[r++] };
              },
              e: function (t) {
                throw t;
              },
              f: i,
            };
          }
          throw new TypeError(
            "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
          );
        }
        var o,
          s = !0,
          a = !1;
        return {
          s: function () {
            n = t[Symbol.iterator]();
          },
          n: function () {
            var t = n.next();
            return (s = t.done), t;
          },
          e: function (t) {
            (a = !0), (o = t);
          },
          f: function () {
            try {
              s || null == n.return || n.return();
            } finally {
              if (a) throw o;
            }
          },
        };
      }
      function ce(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
        return r;
      }
      function ue(t) {
        var e = (function () {
          if ("undefined" === typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" === typeof Proxy) return !0;
          try {
            return (
              Date.prototype.toString.call(
                Reflect.construct(Date, [], function () {})
              ),
              !0
            );
          } catch (t) {
            return !1;
          }
        })();
        return function () {
          var n,
            r = Yt(t);
          if (e) {
            var i = Yt(this).constructor;
            n = Reflect.construct(r, arguments, i);
          } else n = r.apply(this, arguments);
          return Kt(this, n);
        };
      }
      var he = ["longitude", "latitude", "zoom", "bearing", "pitch"],
        pe = (function (t) {
          (0, Ht.Z)(n, t);
          var e = ue(n);
          function n() {
            var t,
              r =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : {};
            return (
              (0, Q.Z)(this, n),
              (t = e.call(this)),
              Array.isArray(r) && (r = { transitionProps: r }),
              (t.propNames = r.transitionProps || he),
              r.around && (t.around = r.around),
              t
            );
          }
          return (
            (0, J.Z)(n, [
              {
                key: "initializeProps",
                value: function (t, e) {
                  var n = {},
                    r = {};
                  if (this.around) {
                    n.around = this.around;
                    var i = new W(t).unproject(this.around);
                    Object.assign(r, e, {
                      around: new W(e).project(i),
                      aroundLngLat: i,
                    });
                  }
                  var o,
                    s = le(this.propNames);
                  try {
                    for (s.s(); !(o = s.n()).done; ) {
                      var a = o.value,
                        l = t[a],
                        c = e[a];
                      _t(
                        Jt(l) && Jt(c),
                        "".concat(a, " must be supplied for transition")
                      ),
                        (n[a] = l),
                        (r[a] = te(a, l, c));
                    }
                  } catch (u) {
                    s.e(u);
                  } finally {
                    s.f();
                  }
                  return { start: n, end: r };
                },
              },
              {
                key: "interpolateProps",
                value: function (t, e, n) {
                  var r,
                    i = {},
                    o = le(this.propNames);
                  try {
                    for (o.s(); !(r = o.n()).done; ) {
                      var s = r.value;
                      i[s] = yt(t[s], e[s], n);
                    }
                  } catch (h) {
                    o.e(h);
                  } finally {
                    o.f();
                  }
                  if (e.around) {
                    var a = c(
                        new W(
                          Object.assign({}, e, i)
                        ).getMapCenterByLngLatPosition({
                          lngLat: e.aroundLngLat,
                          pos: yt(t.around, e.around, n),
                        }),
                        2
                      ),
                      l = a[0],
                      u = a[1];
                    (i.longitude = l), (i.latitude = u);
                  }
                  return i;
                },
              },
            ]),
            n
          );
        })(Gt),
        de = function () {};
      var fe = 1,
        me = 2,
        ge = 3,
        ye = 4,
        _e = {
          transitionDuration: 0,
          transitionEasing: function (t) {
            return t;
          },
          transitionInterpolator: new pe(),
          transitionInterruption: fe,
          onTransitionStart: de,
          onTransitionInterrupt: de,
          onTransitionEnd: de,
        },
        ve = (function () {
          function t() {
            var e = this,
              n =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : {};
            (0, Q.Z)(this, t),
              (0, o.Z)(this, "_animationFrame", null),
              (0, o.Z)(this, "_onTransitionFrame", function () {
                (e._animationFrame = requestAnimationFrame(
                  e._onTransitionFrame
                )),
                  e._updateViewport();
              }),
              (this.props = null),
              (this.onViewportChange = n.onViewportChange || de),
              (this.onStateChange = n.onStateChange || de),
              (this.time = n.getTime || Date.now);
          }
          return (
            (0, J.Z)(t, [
              {
                key: "getViewportInTransition",
                value: function () {
                  return this._animationFrame
                    ? this.state.propsInTransition
                    : null;
                },
              },
              {
                key: "processViewportChange",
                value: function (t) {
                  var e = this.props;
                  if (
                    ((this.props = t),
                    !e || this._shouldIgnoreViewportChange(e, t))
                  )
                    return !1;
                  if (this._isTransitionEnabled(t)) {
                    var n = Object.assign({}, e),
                      r = Object.assign({}, t);
                    if (
                      this._isTransitionInProgress() &&
                      (e.onTransitionInterrupt(),
                      this.state.interruption === me
                        ? Object.assign(n, this.state.endProps)
                        : Object.assign(n, this.state.propsInTransition),
                      this.state.interruption === ye)
                    ) {
                      var i = this.time(),
                        o = (i - this.state.startTime) / this.state.duration;
                      (r.transitionDuration =
                        this.state.duration - (i - this.state.startTime)),
                        (r.transitionEasing = (function (t, e) {
                          var n = t(e);
                          return function (r) {
                            return (1 / (1 - n)) * (t(r * (1 - e) + e) - n);
                          };
                        })(this.state.easing, o)),
                        (r.transitionInterpolator = n.transitionInterpolator);
                    }
                    return (
                      r.onTransitionStart(), this._triggerTransition(n, r), !0
                    );
                  }
                  return (
                    this._isTransitionInProgress() &&
                      (e.onTransitionInterrupt(), this._endTransition()),
                    !1
                  );
                },
              },
              {
                key: "_isTransitionInProgress",
                value: function () {
                  return Boolean(this._animationFrame);
                },
              },
              {
                key: "_isTransitionEnabled",
                value: function (t) {
                  var e = t.transitionDuration,
                    n = t.transitionInterpolator;
                  return (e > 0 || "auto" === e) && Boolean(n);
                },
              },
              {
                key: "_isUpdateDueToCurrentTransition",
                value: function (t) {
                  return (
                    !!this.state.propsInTransition &&
                    this.state.interpolator.arePropsEqual(
                      t,
                      this.state.propsInTransition
                    )
                  );
                },
              },
              {
                key: "_shouldIgnoreViewportChange",
                value: function (t, e) {
                  return (
                    !t ||
                    (this._isTransitionInProgress()
                      ? this.state.interruption === ge ||
                        this._isUpdateDueToCurrentTransition(e)
                      : !this._isTransitionEnabled(e) ||
                        e.transitionInterpolator.arePropsEqual(t, e))
                  );
                },
              },
              {
                key: "_triggerTransition",
                value: function (t, e) {
                  _t(this._isTransitionEnabled(e)),
                    this._animationFrame &&
                      cancelAnimationFrame(this._animationFrame);
                  var n = e.transitionInterpolator,
                    r = n.getDuration
                      ? n.getDuration(t, e)
                      : e.transitionDuration;
                  if (0 !== r) {
                    var i = e.transitionInterpolator.initializeProps(t, e),
                      o = {
                        inTransition: !0,
                        isZooming: t.zoom !== e.zoom,
                        isPanning:
                          t.longitude !== e.longitude ||
                          t.latitude !== e.latitude,
                        isRotating:
                          t.bearing !== e.bearing || t.pitch !== e.pitch,
                      };
                    (this.state = {
                      duration: r,
                      easing: e.transitionEasing,
                      interpolator: e.transitionInterpolator,
                      interruption: e.transitionInterruption,
                      startTime: this.time(),
                      startProps: i.start,
                      endProps: i.end,
                      animation: null,
                      propsInTransition: {},
                    }),
                      this._onTransitionFrame(),
                      this.onStateChange(o);
                  }
                },
              },
              {
                key: "_endTransition",
                value: function () {
                  this._animationFrame &&
                    (cancelAnimationFrame(this._animationFrame),
                    (this._animationFrame = null)),
                    this.onStateChange({
                      inTransition: !1,
                      isZooming: !1,
                      isPanning: !1,
                      isRotating: !1,
                    });
                },
              },
              {
                key: "_updateViewport",
                value: function () {
                  var t = this.time(),
                    e = this.state,
                    n = e.startTime,
                    r = e.duration,
                    i = e.easing,
                    o = e.interpolator,
                    s = e.startProps,
                    a = e.endProps,
                    l = !1,
                    c = (t - n) / r;
                  c >= 1 && ((c = 1), (l = !0)), (c = i(c));
                  var u = o.interpolateProps(s, a, c),
                    h = new Tt(Object.assign({}, this.props, u));
                  (this.state.propsInTransition = h.getViewportProps()),
                    this.onViewportChange(
                      this.state.propsInTransition,
                      this.props
                    ),
                    l && (this._endTransition(), this.props.onTransitionEnd());
                },
              },
            ]),
            t
          );
        })();
      (0, o.Z)(ve, "defaultProps", _e);
      var be = n(50840);
      const xe = { mousedown: 1, mousemove: 2, mouseup: 4 };
      !(function (t) {
        const e = t.prototype.handler;
        t.prototype.handler = function (t) {
          const n = this.store;
          t.button > 0 &&
            "pointerdown" === t.type &&
            ((function (t, e) {
              for (let n = 0; n < t.length; n++) if (e(t[n])) return !0;
              return !1;
            })(n, (e) => e.pointerId === t.pointerId) ||
              n.push(t)),
            e.call(this, t);
        };
      })(be.PointerEventInput),
        (be.MouseInput.prototype.handler = function (t) {
          let e = xe[t.type];
          1 & e && t.button >= 0 && (this.pressed = !0),
            2 & e && 0 === t.which && (e = 4),
            this.pressed &&
              (4 & e && (this.pressed = !1),
              this.callback(this.manager, e, {
                pointers: [t],
                changedPointers: [t],
                pointerType: "mouse",
                srcEvent: t,
              }));
        });
      const we = be.Manager;
      var Se = be;
      class Ee {
        constructor(t, e, n) {
          (this.element = t),
            (this.callback = e),
            (this.options = { enable: !0, ...n });
        }
      }
      const Te = Se
          ? [
              [
                Se.Pan,
                { event: "tripan", pointers: 3, threshold: 0, enable: !1 },
              ],
              [Se.Rotate, { enable: !1 }],
              [Se.Pinch, { enable: !1 }],
              [Se.Swipe, { enable: !1 }],
              [Se.Pan, { threshold: 0, enable: !1 }],
              [Se.Press, { enable: !1 }],
              [Se.Tap, { event: "doubletap", taps: 2, enable: !1 }],
              [Se.Tap, { event: "anytap", enable: !1 }],
              [Se.Tap, { enable: !1 }],
            ]
          : null,
        Ae = {
          tripan: ["rotate", "pinch", "pan"],
          rotate: ["pinch"],
          pinch: ["pan"],
          pan: ["press", "doubletap", "anytap", "tap"],
          doubletap: ["anytap"],
          anytap: ["tap"],
        },
        Ce = { doubletap: ["tap"] },
        Pe = {
          pointerdown: "pointerdown",
          pointermove: "pointermove",
          pointerup: "pointerup",
          touchstart: "pointerdown",
          touchmove: "pointermove",
          touchend: "pointerup",
          mousedown: "pointerdown",
          mousemove: "pointermove",
          mouseup: "pointerup",
        },
        Me = {
          KEY_EVENTS: ["keydown", "keyup"],
          MOUSE_EVENTS: [
            "mousedown",
            "mousemove",
            "mouseup",
            "mouseover",
            "mouseout",
            "mouseleave",
          ],
          WHEEL_EVENTS: ["wheel", "mousewheel"],
        },
        Oe = {
          tap: "tap",
          anytap: "anytap",
          doubletap: "doubletap",
          press: "press",
          pinch: "pinch",
          pinchin: "pinch",
          pinchout: "pinch",
          pinchstart: "pinch",
          pinchmove: "pinch",
          pinchend: "pinch",
          pinchcancel: "pinch",
          rotate: "rotate",
          rotatestart: "rotate",
          rotatemove: "rotate",
          rotateend: "rotate",
          rotatecancel: "rotate",
          tripan: "tripan",
          tripanstart: "tripan",
          tripanmove: "tripan",
          tripanup: "tripan",
          tripandown: "tripan",
          tripanleft: "tripan",
          tripanright: "tripan",
          tripanend: "tripan",
          tripancancel: "tripan",
          pan: "pan",
          panstart: "pan",
          panmove: "pan",
          panup: "pan",
          pandown: "pan",
          panleft: "pan",
          panright: "pan",
          panend: "pan",
          pancancel: "pan",
          swipe: "swipe",
          swipeleft: "swipe",
          swiperight: "swipe",
          swipeup: "swipe",
          swipedown: "swipe",
        },
        ke = {
          click: "tap",
          anyclick: "anytap",
          dblclick: "doubletap",
          mousedown: "pointerdown",
          mousemove: "pointermove",
          mouseup: "pointerup",
          mouseover: "pointerover",
          mouseout: "pointerout",
          mouseleave: "pointerleave",
        },
        Ie =
          "undefined" !== typeof navigator && navigator.userAgent
            ? navigator.userAgent.toLowerCase()
            : "",
        De = "undefined" !== typeof window ? window : n.g;
      "undefined" !== typeof n.g ? n.g : window,
        "undefined" !== typeof document && document;
      let ze = !1;
      try {
        const t = {
          get passive() {
            return (ze = !0), !0;
          },
        };
        De.addEventListener("test", null, t),
          De.removeEventListener("test", null);
      } catch (ai) {
        ze = !1;
      }
      const Re = -1 !== Ie.indexOf("firefox"),
        { WHEEL_EVENTS: Le } = Me,
        Fe = "wheel",
        Be = 4.000244140625;
      class Ne extends Ee {
        constructor(t, e, n) {
          super(t, e, n),
            (this.handleEvent = (t) => {
              if (!this.options.enable) return;
              let e = t.deltaY;
              De.WheelEvent &&
                (Re &&
                  t.deltaMode === De.WheelEvent.DOM_DELTA_PIXEL &&
                  (e /= De.devicePixelRatio),
                t.deltaMode === De.WheelEvent.DOM_DELTA_LINE && (e *= 40)),
                0 !== e && e % Be === 0 && (e = Math.floor(e / Be)),
                t.shiftKey && e && (e *= 0.25),
                this.callback({
                  type: Fe,
                  center: { x: t.clientX, y: t.clientY },
                  delta: -e,
                  srcEvent: t,
                  pointerType: "mouse",
                  target: t.target,
                });
            }),
            (this.events = (this.options.events || []).concat(Le)),
            this.events.forEach((e) =>
              t.addEventListener(e, this.handleEvent, !!ze && { passive: !1 })
            );
        }
        destroy() {
          this.events.forEach((t) =>
            this.element.removeEventListener(t, this.handleEvent)
          );
        }
        enableEventType(t, e) {
          t === Fe && (this.options.enable = e);
        }
      }
      const { MOUSE_EVENTS: je } = Me,
        Ue = "pointermove",
        Ze = "pointerover",
        Ve = "pointerout",
        qe = "pointerenter",
        $e = "pointerleave";
      class Ge extends Ee {
        constructor(t, e, n) {
          super(t, e, n),
            (this.handleEvent = (t) => {
              this.handleOverEvent(t),
                this.handleOutEvent(t),
                this.handleEnterEvent(t),
                this.handleLeaveEvent(t),
                this.handleMoveEvent(t);
            }),
            (this.pressed = !1);
          const { enable: r } = this.options;
          (this.enableMoveEvent = r),
            (this.enableLeaveEvent = r),
            (this.enableEnterEvent = r),
            (this.enableOutEvent = r),
            (this.enableOverEvent = r),
            (this.events = (this.options.events || []).concat(je)),
            this.events.forEach((e) => t.addEventListener(e, this.handleEvent));
        }
        destroy() {
          this.events.forEach((t) =>
            this.element.removeEventListener(t, this.handleEvent)
          );
        }
        enableEventType(t, e) {
          t === Ue && (this.enableMoveEvent = e),
            t === Ze && (this.enableOverEvent = e),
            t === Ve && (this.enableOutEvent = e),
            t === qe && (this.enableEnterEvent = e),
            t === $e && (this.enableLeaveEvent = e);
        }
        handleOverEvent(t) {
          this.enableOverEvent && "mouseover" === t.type && this._emit(Ze, t);
        }
        handleOutEvent(t) {
          this.enableOutEvent && "mouseout" === t.type && this._emit(Ve, t);
        }
        handleEnterEvent(t) {
          this.enableEnterEvent && "mouseenter" === t.type && this._emit(qe, t);
        }
        handleLeaveEvent(t) {
          this.enableLeaveEvent && "mouseleave" === t.type && this._emit($e, t);
        }
        handleMoveEvent(t) {
          if (this.enableMoveEvent)
            switch (t.type) {
              case "mousedown":
                t.button >= 0 && (this.pressed = !0);
                break;
              case "mousemove":
                0 === t.which && (this.pressed = !1),
                  this.pressed || this._emit(Ue, t);
                break;
              case "mouseup":
                this.pressed = !1;
            }
        }
        _emit(t, e) {
          this.callback({
            type: t,
            center: { x: e.clientX, y: e.clientY },
            srcEvent: e,
            pointerType: "mouse",
            target: e.target,
          });
        }
      }
      const { KEY_EVENTS: We } = Me,
        He = "keydown",
        Xe = "keyup";
      class Ke extends Ee {
        constructor(t, e, n) {
          super(t, e, n),
            (this.handleEvent = (t) => {
              const e = t.target || t.srcElement;
              ("INPUT" === e.tagName && "text" === e.type) ||
                "TEXTAREA" === e.tagName ||
                (this.enableDownEvent &&
                  "keydown" === t.type &&
                  this.callback({
                    type: He,
                    srcEvent: t,
                    key: t.key,
                    target: t.target,
                  }),
                this.enableUpEvent &&
                  "keyup" === t.type &&
                  this.callback({
                    type: Xe,
                    srcEvent: t,
                    key: t.key,
                    target: t.target,
                  }));
            }),
            (this.enableDownEvent = this.options.enable),
            (this.enableUpEvent = this.options.enable),
            (this.events = (this.options.events || []).concat(We)),
            (t.tabIndex = this.options.tabIndex || 0),
            (t.style.outline = "none"),
            this.events.forEach((e) => t.addEventListener(e, this.handleEvent));
        }
        destroy() {
          this.events.forEach((t) =>
            this.element.removeEventListener(t, this.handleEvent)
          );
        }
        enableEventType(t, e) {
          t === He && (this.enableDownEvent = e),
            t === Xe && (this.enableUpEvent = e);
        }
      }
      const Ye = "contextmenu";
      class Qe extends Ee {
        constructor(t, e, n) {
          super(t, e, n),
            (this.handleEvent = (t) => {
              this.options.enable &&
                this.callback({
                  type: Ye,
                  center: { x: t.clientX, y: t.clientY },
                  srcEvent: t,
                  pointerType: "mouse",
                  target: t.target,
                });
            }),
            t.addEventListener("contextmenu", this.handleEvent);
        }
        destroy() {
          this.element.removeEventListener("contextmenu", this.handleEvent);
        }
        enableEventType(t, e) {
          t === Ye && (this.options.enable = e);
        }
      }
      const Je = {
        pointerdown: 1,
        pointermove: 2,
        pointerup: 4,
        mousedown: 1,
        mousemove: 2,
        mouseup: 4,
      };
      function tn(t) {
        const e = Je[t.srcEvent.type];
        if (!e) return null;
        const { buttons: n, button: r, which: i } = t.srcEvent;
        let o = !1,
          s = !1,
          a = !1;
        return (
          4 === e || (2 === e && !Number.isFinite(n))
            ? ((o = 1 === i), (s = 2 === i), (a = 3 === i))
            : 2 === e
            ? ((o = Boolean(1 & n)), (s = Boolean(4 & n)), (a = Boolean(2 & n)))
            : 1 === e && ((o = 0 === r), (s = 1 === r), (a = 2 === r)),
          { leftButton: o, middleButton: s, rightButton: a }
        );
      }
      function en(t, e) {
        const n = t.center;
        if (!n) return null;
        const r = e.getBoundingClientRect(),
          i = r.width / e.offsetWidth || 1,
          o = r.height / e.offsetHeight || 1;
        return {
          center: n,
          offsetCenter: {
            x: (n.x - r.left - e.clientLeft) / i,
            y: (n.y - r.top - e.clientTop) / o,
          },
        };
      }
      const nn = { srcElement: "root", priority: 0 };
      class rn {
        constructor(t) {
          (this.handleEvent = (t) => {
            if (this.isEmpty()) return;
            const e = this._normalizeEvent(t);
            let n = t.srcEvent.target;
            for (; n && n !== e.rootElement; ) {
              if ((this._emit(e, n), e.handled)) return;
              n = n.parentNode;
            }
            this._emit(e, "root");
          }),
            (this.eventManager = t),
            (this.handlers = []),
            (this.handlersByElement = new Map()),
            (this._active = !1);
        }
        isEmpty() {
          return !this._active;
        }
        add(t, e, n, r = !1, i = !1) {
          const { handlers: o, handlersByElement: s } = this;
          let a = nn;
          "string" === typeof n || (n && n.addEventListener)
            ? (a = { ...nn, srcElement: n })
            : n && (a = { ...nn, ...n });
          let l = s.get(a.srcElement);
          l || ((l = []), s.set(a.srcElement, l));
          const c = {
            type: t,
            handler: e,
            srcElement: a.srcElement,
            priority: a.priority,
          };
          r && (c.once = !0),
            i && (c.passive = !0),
            o.push(c),
            (this._active = this._active || !c.passive);
          let u = l.length - 1;
          for (; u >= 0 && !(l[u].priority >= c.priority); ) u--;
          l.splice(u + 1, 0, c);
        }
        remove(t, e) {
          const { handlers: n, handlersByElement: r } = this;
          for (let i = n.length - 1; i >= 0; i--) {
            const o = n[i];
            if (o.type === t && o.handler === e) {
              n.splice(i, 1);
              const t = r.get(o.srcElement);
              t.splice(t.indexOf(o), 1),
                0 === t.length && r.delete(o.srcElement);
            }
          }
          this._active = n.some((t) => !t.passive);
        }
        _emit(t, e) {
          const n = this.handlersByElement.get(e);
          if (n) {
            let e = !1;
            const r = () => {
                t.handled = !0;
              },
              i = () => {
                (t.handled = !0), (e = !0);
              },
              o = [];
            for (let s = 0; s < n.length; s++) {
              const { type: a, handler: l, once: c } = n[s];
              if (
                (l({
                  ...t,
                  type: a,
                  stopPropagation: r,
                  stopImmediatePropagation: i,
                }),
                c && o.push(n[s]),
                e)
              )
                break;
            }
            for (let t = 0; t < o.length; t++) {
              const { type: e, handler: n } = o[t];
              this.remove(e, n);
            }
          }
        }
        _normalizeEvent(t) {
          const e = this.eventManager.getElement();
          return {
            ...t,
            ...tn(t),
            ...en(t, e),
            preventDefault: () => {
              t.srcEvent.preventDefault();
            },
            stopImmediatePropagation: null,
            stopPropagation: null,
            handled: !1,
            rootElement: e,
          };
        }
      }
      const on = {
        events: null,
        recognizers: null,
        recognizerOptions: {},
        Manager: we,
        touchAction: "none",
        tabIndex: 0,
      };
      class sn {
        constructor(t = null, e) {
          (this._onBasicInput = (t) => {
            const { srcEvent: e } = t,
              n = Pe[e.type];
            n && this.manager.emit(n, t);
          }),
            (this._onOtherEvent = (t) => {
              this.manager.emit(t.type, t);
            }),
            (this.options = { ...on, ...e }),
            (this.events = new Map()),
            this.setElement(t);
          const { events: n } = this.options;
          n && this.on(n);
        }
        getElement() {
          return this.element;
        }
        setElement(t) {
          if ((this.element && this.destroy(), (this.element = t), !t)) return;
          const { options: e } = this,
            n = e.Manager;
          (this.manager = new n(t, {
            touchAction: e.touchAction,
            recognizers: e.recognizers || Te,
          }).on("hammer.input", this._onBasicInput)),
            e.recognizers ||
              Object.keys(Ae).forEach((t) => {
                const e = this.manager.get(t);
                e &&
                  Ae[t].forEach((t) => {
                    e.recognizeWith(t);
                  });
              });
          for (const r in e.recognizerOptions) {
            const t = this.manager.get(r);
            if (t) {
              const n = e.recognizerOptions[r];
              delete n.enable, t.set(n);
            }
          }
          (this.wheelInput = new Ne(t, this._onOtherEvent, { enable: !1 })),
            (this.moveInput = new Ge(t, this._onOtherEvent, { enable: !1 })),
            (this.keyInput = new Ke(t, this._onOtherEvent, {
              enable: !1,
              tabIndex: e.tabIndex,
            })),
            (this.contextmenuInput = new Qe(t, this._onOtherEvent, {
              enable: !1,
            }));
          for (const [r, i] of this.events)
            i.isEmpty() ||
              (this._toggleRecognizer(i.recognizerName, !0),
              this.manager.on(r, i.handleEvent));
        }
        destroy() {
          this.element &&
            (this.wheelInput.destroy(),
            this.moveInput.destroy(),
            this.keyInput.destroy(),
            this.contextmenuInput.destroy(),
            this.manager.destroy(),
            (this.wheelInput = null),
            (this.moveInput = null),
            (this.keyInput = null),
            (this.contextmenuInput = null),
            (this.manager = null),
            (this.element = null));
        }
        on(t, e, n) {
          this._addEventHandler(t, e, n, !1);
        }
        once(t, e, n) {
          this._addEventHandler(t, e, n, !0);
        }
        watch(t, e, n) {
          this._addEventHandler(t, e, n, !1, !0);
        }
        off(t, e) {
          this._removeEventHandler(t, e);
        }
        _toggleRecognizer(t, e) {
          const { manager: n } = this;
          if (!n) return;
          const r = n.get(t);
          if (r && r.options.enable !== e) {
            r.set({ enable: e });
            const i = Ce[t];
            i &&
              !this.options.recognizers &&
              i.forEach((i) => {
                const o = n.get(i);
                e
                  ? (o.requireFailure(t), r.dropRequireFailure(i))
                  : o.dropRequireFailure(t);
              });
          }
          this.wheelInput.enableEventType(t, e),
            this.moveInput.enableEventType(t, e),
            this.keyInput.enableEventType(t, e),
            this.contextmenuInput.enableEventType(t, e);
        }
        _addEventHandler(t, e, n, r, i) {
          if ("string" !== typeof t) {
            n = e;
            for (const e in t) this._addEventHandler(e, t[e], n, r, i);
            return;
          }
          const { manager: o, events: s } = this,
            a = ke[t] || t;
          let l = s.get(a);
          l ||
            ((l = new rn(this)),
            s.set(a, l),
            (l.recognizerName = Oe[a] || a),
            o && o.on(a, l.handleEvent)),
            l.add(t, e, n, r, i),
            l.isEmpty() || this._toggleRecognizer(l.recognizerName, !0);
        }
        _removeEventHandler(t, e) {
          if ("string" !== typeof t) {
            for (const e in t) this._removeEventHandler(e, t[e]);
            return;
          }
          const { events: n } = this,
            r = ke[t] || t,
            i = n.get(r);
          if (i && (i.remove(t, e), i.isEmpty())) {
            const { recognizerName: t } = i;
            let e = !1;
            for (const r of n.values())
              if (r.recognizerName === t && !r.isEmpty()) {
                e = !0;
                break;
              }
            e || this._toggleRecognizer(t, !1);
          }
        }
      }
      function an(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function ln(t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? an(Object(n), !0).forEach(function (e) {
                (0, o.Z)(t, e, n[e]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
            : an(Object(n)).forEach(function (e) {
                Object.defineProperty(
                  t,
                  e,
                  Object.getOwnPropertyDescriptor(n, e)
                );
              });
        }
        return t;
      }
      var cn = { transitionDuration: 0 },
        un = {
          transitionDuration: 300,
          transitionEasing: function (t) {
            return t;
          },
          transitionInterpolator: new pe(),
          transitionInterruption: fe,
        },
        hn = 300,
        pn = function (t) {
          return 1 - (1 - t) * (1 - t);
        },
        dn = ["wheel"],
        fn = ["panstart", "panmove", "panend"],
        mn = ["pinchstart", "pinchmove", "pinchend"],
        gn = ["tripanstart", "tripanmove", "tripanend"],
        yn = ["doubletap"],
        _n = ["keydown"],
        vn = (function () {
          function t() {
            var e = this;
            (0, Q.Z)(this, t),
              (0, o.Z)(this, "events", []),
              (0, o.Z)(this, "scrollZoom", !0),
              (0, o.Z)(this, "dragPan", !0),
              (0, o.Z)(this, "dragRotate", !0),
              (0, o.Z)(this, "doubleClickZoom", !0),
              (0, o.Z)(this, "touchZoom", !0),
              (0, o.Z)(this, "touchRotate", !1),
              (0, o.Z)(this, "keyboard", !0),
              (0, o.Z)(this, "_interactionState", { isDragging: !1 }),
              (0, o.Z)(this, "_events", {}),
              (0, o.Z)(this, "_setInteractionState", function (t) {
                Object.assign(e._interactionState, t),
                  e.onStateChange && e.onStateChange(e._interactionState);
              }),
              (0, o.Z)(this, "_onTransition", function (t, n) {
                e.onViewportChange(t, e._interactionState, n);
              }),
              (this.handleEvent = this.handleEvent.bind(this)),
              (this._transitionManager = new ve({
                onViewportChange: this._onTransition,
                onStateChange: this._setInteractionState,
              }));
          }
          return (
            (0, J.Z)(t, [
              {
                key: "handleEvent",
                value: function (t) {
                  this.mapState = this.getMapState();
                  var e = this._eventStartBlocked;
                  switch (t.type) {
                    case "panstart":
                      return !e && this._onPanStart(t);
                    case "panmove":
                      return this._onPan(t);
                    case "panend":
                      return this._onPanEnd(t);
                    case "pinchstart":
                      return !e && this._onPinchStart(t);
                    case "pinchmove":
                      return this._onPinch(t);
                    case "pinchend":
                      return this._onPinchEnd(t);
                    case "tripanstart":
                      return !e && this._onTriplePanStart(t);
                    case "tripanmove":
                      return this._onTriplePan(t);
                    case "tripanend":
                      return this._onTriplePanEnd(t);
                    case "doubletap":
                      return this._onDoubleTap(t);
                    case "wheel":
                      return this._onWheel(t);
                    case "keydown":
                      return this._onKeyDown(t);
                    default:
                      return !1;
                  }
                },
              },
              {
                key: "getCenter",
                value: function (t) {
                  var e = t.offsetCenter;
                  return [e.x, e.y];
                },
              },
              {
                key: "isFunctionKeyPressed",
                value: function (t) {
                  var e = t.srcEvent;
                  return Boolean(
                    e.metaKey || e.altKey || e.ctrlKey || e.shiftKey
                  );
                },
              },
              {
                key: "blockEvents",
                value: function (t) {
                  var e = this,
                    n = setTimeout(function () {
                      e._eventStartBlocked === n &&
                        (e._eventStartBlocked = null);
                    }, t);
                  this._eventStartBlocked = n;
                },
              },
              {
                key: "updateViewport",
                value: function (t, e, n) {
                  var r =
                      this.mapState instanceof Tt
                        ? this.mapState.getViewportProps()
                        : this.mapState,
                    i = ln(ln({}, t.getViewportProps()), e),
                    o = Object.keys(i).some(function (t) {
                      return r[t] !== i[t];
                    });
                  (this._state = t.getState()),
                    this._setInteractionState(n),
                    o && this.onViewportChange(i, this._interactionState, r);
                },
              },
              {
                key: "getMapState",
                value: function (t) {
                  return new Tt(
                    ln(ln(ln({}, this.mapStateProps), this._state), t)
                  );
                },
              },
              {
                key: "isDragging",
                value: function () {
                  return this._interactionState.isDragging;
                },
              },
              {
                key: "setOptions",
                value: function (t) {
                  var e = t.onViewportChange,
                    n = t.onStateChange,
                    r = t.eventManager,
                    i = void 0 === r ? this.eventManager : r,
                    o = t.isInteractive,
                    s = void 0 === o || o,
                    a = t.scrollZoom,
                    l = void 0 === a ? this.scrollZoom : a,
                    c = t.dragPan,
                    u = void 0 === c ? this.dragPan : c,
                    h = t.dragRotate,
                    p = void 0 === h ? this.dragRotate : h,
                    d = t.doubleClickZoom,
                    f = void 0 === d ? this.doubleClickZoom : d,
                    m = t.touchZoom,
                    g = void 0 === m ? this.touchZoom : m,
                    y = t.touchRotate,
                    _ = void 0 === y ? this.touchRotate : y,
                    v = t.keyboard,
                    b = void 0 === v ? this.keyboard : v;
                  (this.onViewportChange = e), (this.onStateChange = n);
                  var x = this.mapStateProps || {},
                    w = x.height !== t.height || x.width !== t.width;
                  (this.mapStateProps = t),
                    w && ((this.mapState = x), this.updateViewport(new Tt(t))),
                    this._transitionManager.processViewportChange(t),
                    this.eventManager !== i &&
                      ((this.eventManager = i),
                      (this._events = {}),
                      this.toggleEvents(this.events, !0)),
                    this.toggleEvents(dn, s && Boolean(l)),
                    this.toggleEvents(fn, s && Boolean(u || p)),
                    this.toggleEvents(mn, s && Boolean(g || _)),
                    this.toggleEvents(gn, s && Boolean(_)),
                    this.toggleEvents(yn, s && Boolean(f)),
                    this.toggleEvents(_n, s && Boolean(b)),
                    (this.scrollZoom = l),
                    (this.dragPan = u),
                    (this.dragRotate = p),
                    (this.doubleClickZoom = f),
                    (this.touchZoom = g),
                    (this.touchRotate = _),
                    (this.keyboard = b);
                },
              },
              {
                key: "toggleEvents",
                value: function (t, e) {
                  var n = this;
                  this.eventManager &&
                    t.forEach(function (t) {
                      n._events[t] !== e &&
                        ((n._events[t] = e),
                        e
                          ? n.eventManager.on(t, n.handleEvent)
                          : n.eventManager.off(t, n.handleEvent));
                    });
                },
              },
              {
                key: "_onPanStart",
                value: function (t) {
                  var e = this.getCenter(t);
                  this._panRotate =
                    this.isFunctionKeyPressed(t) || t.rightButton;
                  var n = this._panRotate
                    ? this.mapState.rotateStart({ pos: e })
                    : this.mapState.panStart({ pos: e });
                  return this.updateViewport(n, cn, { isDragging: !0 }), !0;
                },
              },
              {
                key: "_onPan",
                value: function (t) {
                  return (
                    !!this.isDragging() &&
                    (this._panRotate
                      ? this._onPanRotate(t)
                      : this._onPanMove(t))
                  );
                },
              },
              {
                key: "_onPanEnd",
                value: function (t) {
                  return (
                    !!this.isDragging() &&
                    (this._panRotate
                      ? this._onPanRotateEnd(t)
                      : this._onPanMoveEnd(t))
                  );
                },
              },
              {
                key: "_onPanMove",
                value: function (t) {
                  if (!this.dragPan) return !1;
                  var e = this.getCenter(t),
                    n = this.mapState.pan({ pos: e });
                  return this.updateViewport(n, cn, { isPanning: !0 }), !0;
                },
              },
              {
                key: "_onPanMoveEnd",
                value: function (t) {
                  if (this.dragPan) {
                    var e = this.dragPan.inertia,
                      n = void 0 === e ? hn : e;
                    if (n && t.velocity) {
                      var r = this.getCenter(t),
                        i = [
                          r[0] + (t.velocityX * n) / 2,
                          r[1] + (t.velocityY * n) / 2,
                        ],
                        o = this.mapState.pan({ pos: i }).panEnd();
                      return (
                        this.updateViewport(
                          o,
                          ln(
                            ln({}, un),
                            {},
                            { transitionDuration: n, transitionEasing: pn }
                          ),
                          { isDragging: !1, isPanning: !0 }
                        ),
                        !0
                      );
                    }
                  }
                  var s = this.mapState.panEnd();
                  return (
                    this.updateViewport(s, null, {
                      isDragging: !1,
                      isPanning: !1,
                    }),
                    !0
                  );
                },
              },
              {
                key: "_onPanRotate",
                value: function (t) {
                  if (!this.dragRotate) return !1;
                  var e = this.getCenter(t),
                    n = this.mapState.rotate({ pos: e });
                  return this.updateViewport(n, cn, { isRotating: !0 }), !0;
                },
              },
              {
                key: "_onPanRotateEnd",
                value: function (t) {
                  if (this.dragRotate) {
                    var e = this.dragRotate.inertia,
                      n = void 0 === e ? hn : e;
                    if (n && t.velocity) {
                      var r = this.getCenter(t),
                        i = [
                          r[0] + (t.velocityX * n) / 2,
                          r[1] + (t.velocityY * n) / 2,
                        ],
                        o = this.mapState.rotate({ pos: i }).rotateEnd();
                      return (
                        this.updateViewport(
                          o,
                          ln(
                            ln({}, un),
                            {},
                            { transitionDuration: n, transitionEasing: pn }
                          ),
                          { isDragging: !1, isRotating: !0 }
                        ),
                        !0
                      );
                    }
                  }
                  var s = this.mapState.panEnd();
                  return (
                    this.updateViewport(s, null, {
                      isDragging: !1,
                      isRotating: !1,
                    }),
                    !0
                  );
                },
              },
              {
                key: "_onWheel",
                value: function (t) {
                  if (!this.scrollZoom) return !1;
                  var e = this.scrollZoom,
                    n = e.speed,
                    r = void 0 === n ? 0.01 : n,
                    i = e.smooth,
                    o = void 0 !== i && i;
                  t.preventDefault();
                  var s = this.getCenter(t),
                    a = t.delta,
                    l = 2 / (1 + Math.exp(-Math.abs(a * r)));
                  a < 0 && 0 !== l && (l = 1 / l);
                  var c = this.mapState.zoom({ pos: s, scale: l });
                  return (
                    this.updateViewport(
                      c,
                      ln(
                        ln({}, un),
                        {},
                        {
                          transitionInterpolator: new pe({ around: s }),
                          transitionDuration: o ? 250 : 1,
                        }
                      ),
                      { isPanning: !0, isZooming: !0 }
                    ),
                    !0
                  );
                },
              },
              {
                key: "_onPinchStart",
                value: function (t) {
                  var e = this.getCenter(t),
                    n = this.mapState
                      .zoomStart({ pos: e })
                      .rotateStart({ pos: e });
                  return (
                    (this._startPinchRotation = t.rotation),
                    (this._lastPinchEvent = t),
                    this.updateViewport(n, cn, { isDragging: !0 }),
                    !0
                  );
                },
              },
              {
                key: "_onPinch",
                value: function (t) {
                  if (!this.isDragging()) return !1;
                  if (!this.touchZoom && !this.touchRotate) return !1;
                  var e = this.mapState;
                  if (this.touchZoom) {
                    var n = t.scale,
                      r = this.getCenter(t);
                    e = e.zoom({ pos: r, scale: n });
                  }
                  if (this.touchRotate) {
                    var i = t.rotation;
                    e = e.rotate({ deltaAngleX: this._startPinchRotation - i });
                  }
                  return (
                    this.updateViewport(e, cn, {
                      isDragging: !0,
                      isPanning: Boolean(this.touchZoom),
                      isZooming: Boolean(this.touchZoom),
                      isRotating: Boolean(this.touchRotate),
                    }),
                    (this._lastPinchEvent = t),
                    !0
                  );
                },
              },
              {
                key: "_onPinchEnd",
                value: function (t) {
                  if (!this.isDragging()) return !1;
                  if (this.touchZoom) {
                    var e = this.touchZoom.inertia,
                      n = void 0 === e ? hn : e,
                      r = this._lastPinchEvent;
                    if (n && r && t.scale !== r.scale) {
                      var i = this.getCenter(t),
                        o = this.mapState.rotateEnd(),
                        s = Math.log2(t.scale),
                        a =
                          (s - Math.log2(r.scale)) /
                          (t.deltaTime - r.deltaTime),
                        l = Math.pow(2, s + (a * n) / 2);
                      return (
                        (o = o.zoom({ pos: i, scale: l }).zoomEnd()),
                        this.updateViewport(
                          o,
                          ln(
                            ln({}, un),
                            {},
                            {
                              transitionInterpolator: new pe({ around: i }),
                              transitionDuration: n,
                              transitionEasing: pn,
                            }
                          ),
                          {
                            isDragging: !1,
                            isPanning: Boolean(this.touchZoom),
                            isZooming: Boolean(this.touchZoom),
                            isRotating: !1,
                          }
                        ),
                        this.blockEvents(n),
                        !0
                      );
                    }
                  }
                  var c = this.mapState.zoomEnd().rotateEnd();
                  return (
                    (this._state.startPinchRotation = 0),
                    this.updateViewport(c, null, {
                      isDragging: !1,
                      isPanning: !1,
                      isZooming: !1,
                      isRotating: !1,
                    }),
                    (this._startPinchRotation = null),
                    (this._lastPinchEvent = null),
                    !0
                  );
                },
              },
              {
                key: "_onTriplePanStart",
                value: function (t) {
                  var e = this.getCenter(t),
                    n = this.mapState.rotateStart({ pos: e });
                  return this.updateViewport(n, cn, { isDragging: !0 }), !0;
                },
              },
              {
                key: "_onTriplePan",
                value: function (t) {
                  if (!this.isDragging()) return !1;
                  if (!this.touchRotate) return !1;
                  var e = this.getCenter(t);
                  e[0] -= t.deltaX;
                  var n = this.mapState.rotate({ pos: e });
                  return this.updateViewport(n, cn, { isRotating: !0 }), !0;
                },
              },
              {
                key: "_onTriplePanEnd",
                value: function (t) {
                  if (!this.isDragging()) return !1;
                  if (this.touchRotate) {
                    var e = this.touchRotate.inertia,
                      n = void 0 === e ? hn : e;
                    if (n && t.velocityY) {
                      var r = this.getCenter(t),
                        i = [r[0], (r[1] += (t.velocityY * n) / 2)],
                        o = this.mapState.rotate({ pos: i });
                      return (
                        this.updateViewport(
                          o,
                          ln(
                            ln({}, un),
                            {},
                            { transitionDuration: n, transitionEasing: pn }
                          ),
                          { isDragging: !1, isRotating: !0 }
                        ),
                        this.blockEvents(n),
                        !1
                      );
                    }
                  }
                  var s = this.mapState.rotateEnd();
                  return (
                    this.updateViewport(s, null, {
                      isDragging: !1,
                      isRotating: !1,
                    }),
                    !0
                  );
                },
              },
              {
                key: "_onDoubleTap",
                value: function (t) {
                  if (!this.doubleClickZoom) return !1;
                  var e = this.getCenter(t),
                    n = this.isFunctionKeyPressed(t),
                    r = this.mapState.zoom({ pos: e, scale: n ? 0.5 : 2 });
                  return (
                    this.updateViewport(
                      r,
                      Object.assign({}, un, {
                        transitionInterpolator: new pe({ around: e }),
                      }),
                      { isZooming: !0 }
                    ),
                    !0
                  );
                },
              },
              {
                key: "_onKeyDown",
                value: function (t) {
                  if (!this.keyboard) return !1;
                  var e,
                    n = this.isFunctionKeyPressed(t),
                    r = this.keyboard,
                    i = r.zoomSpeed,
                    o = void 0 === i ? 2 : i,
                    s = r.moveSpeed,
                    a = void 0 === s ? 100 : s,
                    l = r.rotateSpeedX,
                    c = void 0 === l ? 15 : l,
                    u = r.rotateSpeedY,
                    h = void 0 === u ? 10 : u,
                    p = this.mapStateProps;
                  switch (t.srcEvent.keyCode) {
                    case 189:
                      e = n
                        ? this.getMapState({ zoom: p.zoom - Math.log2(o) - 1 })
                        : this.getMapState({ zoom: p.zoom - Math.log2(o) });
                      break;
                    case 187:
                      e = n
                        ? this.getMapState({ zoom: p.zoom + Math.log2(o) + 1 })
                        : this.getMapState({ zoom: p.zoom + Math.log2(o) });
                      break;
                    case 37:
                      e = n
                        ? this.getMapState({ bearing: p.bearing - c })
                        : this.mapState.pan({ pos: [a, 0], startPos: [0, 0] });
                      break;
                    case 39:
                      e = n
                        ? this.getMapState({ bearing: p.bearing + c })
                        : this.mapState.pan({ pos: [-a, 0], startPos: [0, 0] });
                      break;
                    case 38:
                      e = n
                        ? this.getMapState({ pitch: p.pitch + h })
                        : this.mapState.pan({ pos: [0, a], startPos: [0, 0] });
                      break;
                    case 40:
                      e = n
                        ? this.getMapState({ pitch: p.pitch - h })
                        : this.mapState.pan({ pos: [0, -a], startPos: [0, 0] });
                      break;
                    default:
                      return !1;
                  }
                  return this.updateViewport(e, un);
                },
              },
            ]),
            t
          );
        })();
      function bn(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function xn(t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? bn(Object(n), !0).forEach(function (e) {
                (0, o.Z)(t, e, n[e]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
            : bn(Object(n)).forEach(function (e) {
                Object.defineProperty(
                  t,
                  e,
                  Object.getOwnPropertyDescriptor(n, e)
                );
              });
        }
        return t;
      }
      var wn = Object.assign({}, Vt.propTypes, {
          maxZoom: a.number,
          minZoom: a.number,
          maxPitch: a.number,
          minPitch: a.number,
          onViewStateChange: a.func,
          onViewportChange: a.func,
          onInteractionStateChange: a.func,
          transitionDuration: a.oneOfType([a.number, a.string]),
          transitionInterpolator: a.object,
          transitionInterruption: a.number,
          transitionEasing: a.func,
          onTransitionStart: a.func,
          onTransitionInterrupt: a.func,
          onTransitionEnd: a.func,
          scrollZoom: a.oneOfType([a.bool, a.object]),
          dragPan: a.oneOfType([a.bool, a.object]),
          dragRotate: a.oneOfType([a.bool, a.object]),
          doubleClickZoom: a.bool,
          touchZoom: a.oneOfType([a.bool, a.object]),
          touchRotate: a.oneOfType([a.bool, a.object]),
          keyboard: a.oneOfType([a.bool, a.object]),
          onHover: a.func,
          onClick: a.func,
          onDblClick: a.func,
          onContextMenu: a.func,
          onMouseDown: a.func,
          onMouseMove: a.func,
          onMouseUp: a.func,
          onTouchStart: a.func,
          onTouchMove: a.func,
          onTouchEnd: a.func,
          onMouseEnter: a.func,
          onMouseLeave: a.func,
          onMouseOut: a.func,
          onWheel: a.func,
          touchAction: a.string,
          eventRecognizerOptions: a.object,
          clickRadius: a.number,
          interactiveLayerIds: a.array,
          getCursor: a.func,
          controller: a.instanceOf(vn),
        }),
        Sn = Object.assign({}, Vt.defaultProps, xt, ve.defaultProps, {
          onViewStateChange: null,
          onViewportChange: null,
          onClick: null,
          onNativeClick: null,
          onHover: null,
          onContextMenu: function (t) {
            return t.preventDefault();
          },
          scrollZoom: !0,
          dragPan: !0,
          dragRotate: !0,
          doubleClickZoom: !0,
          touchZoom: !0,
          touchRotate: !1,
          keyboard: !0,
          touchAction: "none",
          eventRecognizerOptions: {},
          clickRadius: 0,
          getCursor: function (t) {
            var e = t.isDragging,
              n = t.isHovering;
            return e ? "grabbing" : n ? "pointer" : "grab";
          },
        });
      function En(t) {
        if (t.lngLat || !t.offsetCenter) return t;
        var e = t.offsetCenter,
          n = e.x,
          r = e.y;
        if (!Number.isFinite(n) || !Number.isFinite(r)) return t;
        var i = [n, r];
        t.point = i;
        var o = this.viewport,
          s = o.unproject(i, { targetZ: o.meterOffset[2] });
        return (t.lngLat = [s[0], s[1]]), t;
      }
      function Tn(t) {
        var e = this.map;
        if (!e || !t) return null;
        var n = {},
          r = this.props.clickRadius;
        this.props.interactiveLayerIds &&
          (n.layers = this.props.interactiveLayerIds);
        try {
          return e.queryRenderedFeatures(
            r
              ? [
                  [t[0] - r, t[1] + r],
                  [t[0] + r, t[1] - r],
                ]
              : t,
            n
          );
        } catch (i) {
          return null;
        }
      }
      function An(t, e) {
        var n = this.props[t];
        n && n(En.call(this, e));
      }
      function Cn(t) {
        An.call(
          this,
          "touch" === t.pointerType ? "onTouchStart" : "onMouseDown",
          t
        );
      }
      function Pn(t) {
        An.call(
          this,
          "touch" === t.pointerType ? "onTouchEnd" : "onMouseUp",
          t
        );
      }
      function Mn(t) {
        if (
          (An.call(
            this,
            "touch" === t.pointerType ? "onTouchMove" : "onMouseMove",
            t
          ),
          !this.state.isDragging)
        ) {
          var e,
            n = this.props,
            r = n.onHover,
            i = n.interactiveLayerIds;
          (t = En.call(this, t)), (i || r) && (e = Tn.call(this, t.point));
          var o = Boolean(i && e && e.length > 0),
            s = o && !this.state.isHovering,
            a = !o && this.state.isHovering;
          (r || s) && ((t.features = e), r && r(t)),
            s && An.call(this, "onMouseEnter", t),
            a && An.call(this, "onMouseLeave", t),
            (s || a) && this.setState({ isHovering: o });
        }
      }
      function On(t) {
        var e = this.props,
          n = e.onClick,
          r = e.onNativeClick,
          i = e.onDblClick,
          o = e.doubleClickZoom,
          s = [],
          a = i || o;
        switch (t.type) {
          case "anyclick":
            s.push(r), a || s.push(n);
            break;
          case "click":
            a && s.push(n);
        }
        (s = s.filter(Boolean)).length &&
          (((t = En.call(this, t)).features = Tn.call(this, t.point)),
          s.forEach(function (e) {
            return e(t);
          }));
      }
      var kn = (0, s.forwardRef)(function (t, e) {
        var n = (0, s.useContext)(kt),
          o = (0, s.useMemo)(function () {
            return t.controller || new vn();
          }, []),
          a = (0, s.useMemo)(function () {
            return new sn(null, {
              touchAction: t.touchAction,
              recognizerOptions: t.eventRecognizerOptions,
            });
          }, []),
          l = (0, s.useRef)(null),
          c = (0, s.useRef)(null),
          u = (0, s.useRef)({
            width: 0,
            height: 0,
            state: { isHovering: !1, isDragging: !1 },
          }).current;
        (u.props = t),
          (u.map = c.current && c.current.getMap()),
          (u.setState = function (e) {
            (u.state = xn(xn({}, u.state), e)),
              (l.current.style.cursor = t.getCursor(u.state));
          });
        var h,
          p,
          d = !0,
          f = function (t, e, n) {
            if (d) h = [t, e, n];
            else {
              var r = u.props,
                i = r.onViewStateChange,
                o = r.onViewportChange;
              Object.defineProperty(t, "position", {
                get: function () {
                  return [0, 0, Dt(u.map, t)];
                },
              }),
                i && i({ viewState: t, interactionState: e, oldViewState: n }),
                o && o(t, e, n);
            }
          };
        (0, s.useImperativeHandle)(
          e,
          function () {
            return (function (t) {
              return {
                getMap: t.current && t.current.getMap,
                queryRenderedFeatures:
                  t.current && t.current.queryRenderedFeatures,
              };
            })(c);
          },
          []
        );
        var m = (0, s.useMemo)(
          function () {
            return xn(
              xn({}, n),
              {},
              { eventManager: a, container: n.container || l.current }
            );
          },
          [n, l.current]
        );
        (m.onViewportChange = f),
          (m.viewport = n.viewport || Ft(u)),
          (u.viewport = m.viewport);
        var g = function (t) {
            var e = t.isDragging,
              n = void 0 !== e && e;
            if ((n !== u.state.isDragging && u.setState({ isDragging: n }), d))
              p = t;
            else {
              var r = u.props.onInteractionStateChange;
              r && r(t);
            }
          },
          y = function () {
            u.width &&
              u.height &&
              o.setOptions(
                xn(
                  xn(xn({}, u.props), u.props.viewState),
                  {},
                  {
                    isInteractive: Boolean(
                      u.props.onViewStateChange || u.props.onViewportChange
                    ),
                    onViewportChange: f,
                    onStateChange: g,
                    eventManager: a,
                    width: u.width,
                    height: u.height,
                  }
                )
              );
          };
        (0, s.useEffect)(function () {
          return (
            a.setElement(l.current),
            a.on({
              pointerdown: Cn.bind(u),
              pointermove: Mn.bind(u),
              pointerup: Pn.bind(u),
              pointerleave: An.bind(u, "onMouseOut"),
              click: On.bind(u),
              anyclick: On.bind(u),
              dblclick: An.bind(u, "onDblClick"),
              wheel: An.bind(u, "onWheel"),
              contextmenu: An.bind(u, "onContextMenu"),
            }),
            function () {
              a.destroy();
            }
          );
        }, []),
          It(function () {
            h && f.apply(void 0, (0, i.Z)(h)), p && g(p);
          }),
          y();
        var _ = t.width,
          v = t.height,
          b = t.style,
          x = t.getCursor,
          w = (0, s.useMemo)(
            function () {
              return xn(
                xn({ position: "relative" }, b),
                {},
                { width: _, height: v, cursor: x(u.state) }
              );
            },
            [b, _, v, x, u.state]
          );
        return (
          (h && u._child) ||
            (u._child = s.createElement(
              Ot,
              { value: m },
              s.createElement(
                "div",
                { key: "event-canvas", ref: l, style: w },
                s.createElement(
                  Vt,
                  (0, r.Z)({}, t, {
                    width: "100%",
                    height: "100%",
                    style: null,
                    onResize: function (t) {
                      var e = t.width,
                        n = t.height;
                      (u.width = e),
                        (u.height = n),
                        y(),
                        u.props.onResize({ width: e, height: n });
                    },
                    ref: c,
                  })
                )
              )
            )),
          (d = !1),
          u._child
        );
      });
      (kn.supported = Vt.supported),
        (kn.propTypes = wn),
        (kn.defaultProps = Sn);
      var In = kn;
      function Dn(t, e) {
        if (t === e) return !0;
        if (!t || !e) return !1;
        if (Array.isArray(t)) {
          if (!Array.isArray(e) || t.length !== e.length) return !1;
          for (var n = 0; n < t.length; n++) if (!Dn(t[n], e[n])) return !1;
          return !0;
        }
        if (Array.isArray(e)) return !1;
        if ("object" === (0, Xt.Z)(t) && "object" === (0, Xt.Z)(e)) {
          var r = Object.keys(t),
            i = Object.keys(e);
          if (r.length !== i.length) return !1;
          for (var o = 0, s = r; o < s.length; o++) {
            var a = s[o];
            if (!e.hasOwnProperty(a)) return !1;
            if (!Dn(t[a], e[a])) return !1;
          }
          return !0;
        }
        return !1;
      }
      function zn(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      var Rn = { type: a.string.isRequired, id: a.string },
        Ln = 0;
      function Fn(t, e, n) {
        if (t.style && t.style._loaded) {
          var r = (function (t) {
            for (var e = 1; e < arguments.length; e++) {
              var n = null != arguments[e] ? arguments[e] : {};
              e % 2
                ? zn(Object(n), !0).forEach(function (e) {
                    (0, o.Z)(t, e, n[e]);
                  })
                : Object.getOwnPropertyDescriptors
                ? Object.defineProperties(
                    t,
                    Object.getOwnPropertyDescriptors(n)
                  )
                : zn(Object(n)).forEach(function (e) {
                    Object.defineProperty(
                      t,
                      e,
                      Object.getOwnPropertyDescriptor(n, e)
                    );
                  });
            }
            return t;
          })({}, n);
          return (
            delete r.id, delete r.children, t.addSource(e, r), t.getSource(e)
          );
        }
        return null;
      }
      function Bn(t) {
        var e = (0, s.useContext)(kt),
          n = (0, s.useRef)({ id: t.id, type: t.type }),
          r = c((0, s.useState)(0), 2)[1],
          i = (0, s.useMemo)(function () {
            return t.id || "jsx-source-".concat(Ln++);
          }, []),
          o = e.map;
        (0, s.useEffect)(
          function () {
            if (o) {
              var t = function () {
                return r(function (t) {
                  return t + 1;
                });
              };
              return (
                o.on("styledata", t),
                function () {
                  o.off("styledata", t),
                    requestAnimationFrame(function () {
                      o.style &&
                        o.style._loaded &&
                        o.getSource(i) &&
                        o.removeSource(i);
                    });
                }
              );
            }
          },
          [o, i]
        );
        var a = o && o.style && o.getSource(i);
        return (
          a
            ? (function (t, e, n) {
                _t(e.id === n.id, "source id changed"),
                  _t(e.type === n.type, "source type changed");
                var r = "",
                  i = 0;
                for (var o in e)
                  "children" === o ||
                    "id" === o ||
                    Dn(n[o], e[o]) ||
                    ((r = o), i++);
                if (i) {
                  var s = e.type;
                  if ("geojson" === s) t.setData(e.data);
                  else if ("image" === s)
                    t.updateImage({ url: e.url, coordinates: e.coordinates });
                  else if (
                    ("canvas" !== s && "video" !== s) ||
                    1 !== i ||
                    "coordinates" !== r
                  )
                    if ("vector" === s && t.setUrl)
                      switch (r) {
                        case "url":
                          t.setUrl(e.url);
                          break;
                        case "tiles":
                          t.setTiles(e.tiles);
                      }
                    else
                      console.warn(
                        "Unable to update <Source> prop: ".concat(r)
                      );
                  else t.setCoordinates(e.coordinates);
                }
              })(a, t, n.current)
            : (a = Fn(o, i, t)),
          (n.current = t),
          (a &&
            s.Children.map(t.children, function (t) {
              return t && (0, s.cloneElement)(t, { source: i });
            })) ||
            null
        );
      }
      Bn.propTypes = Rn;
      var Nn = n(91);
      function jn(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function Un(t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? jn(Object(n), !0).forEach(function (e) {
                (0, o.Z)(t, e, n[e]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
            : jn(Object(n)).forEach(function (e) {
                Object.defineProperty(
                  t,
                  e,
                  Object.getOwnPropertyDescriptor(n, e)
                );
              });
        }
        return t;
      }
      var Zn = {
        type: a.oneOf([
          "fill",
          "line",
          "symbol",
          "circle",
          "fill-extrusion",
          "raster",
          "background",
          "heatmap",
          "hillshade",
          "sky",
        ]).isRequired,
        id: a.string,
        source: a.string,
        beforeId: a.string,
      };
      function Vn(t, e, n, r) {
        _t(n.id === r.id, "layer id changed"),
          _t(n.type === r.type, "layer type changed");
        try {
          !(function (t, e, n, r) {
            var i = n.layout,
              o = void 0 === i ? {} : i,
              s = n.paint,
              a = void 0 === s ? {} : s,
              l = n.filter,
              c = n.minzoom,
              u = n.maxzoom,
              h = n.beforeId,
              p = (0, Nn.Z)(n, [
                "layout",
                "paint",
                "filter",
                "minzoom",
                "maxzoom",
                "beforeId",
              ]);
            if ((h !== r.beforeId && t.moveLayer(e, h), o !== r.layout)) {
              var d = r.layout || {};
              for (var f in o)
                Dn(o[f], d[f]) || t.setLayoutProperty(e, f, o[f]);
              for (var m in d)
                o.hasOwnProperty(m) || t.setLayoutProperty(e, m, void 0);
            }
            if (a !== r.paint) {
              var g = r.paint || {};
              for (var y in a) Dn(a[y], g[y]) || t.setPaintProperty(e, y, a[y]);
              for (var _ in g)
                a.hasOwnProperty(_) || t.setPaintProperty(e, _, void 0);
            }
            for (var v in (Dn(l, r.filter) || t.setFilter(e, l),
            (c === r.minzoom && u === r.maxzoom) ||
              t.setLayerZoomRange(e, c, u),
            p))
              Dn(p[v], r[v]) || t.setLayerProperty(e, v, p[v]);
          })(t, e, n, r);
        } catch (i) {
          console.warn(i);
        }
      }
      var qn = 0;
      function $n(t) {
        var e = (0, s.useContext)(kt),
          n = (0, s.useRef)({ id: t.id, type: t.type }),
          r = c((0, s.useState)(0), 2)[1],
          i = (0, s.useMemo)(function () {
            return t.id || "jsx-layer-".concat(qn++);
          }, []),
          o = e.map;
        return (
          (0, s.useEffect)(
            function () {
              if (o) {
                var t = function () {
                  return r(function (t) {
                    return t + 1;
                  });
                };
                return (
                  o.on("styledata", t),
                  function () {
                    o.off("styledata", t),
                      o.style && o.style._loaded && o.removeLayer(i);
                  }
                );
              }
            },
            [o]
          ),
          o && o.style && o.getLayer(i)
            ? Vn(o, i, t, n.current)
            : (function (t, e, n) {
                if (t.style && t.style._loaded) {
                  var r = Un(Un({}, n), {}, { id: e });
                  delete r.beforeId, t.addLayer(r, n.beforeId);
                }
              })(o, i, t),
          (n.current = t),
          null
        );
      }
      $n.propTypes = Zn;
      var Gn = {
          captureScroll: !1,
          captureDrag: !0,
          captureClick: !0,
          captureDoubleClick: !0,
          capturePointerMove: !1,
        },
        Wn = {
          captureScroll: a.bool,
          captureDrag: a.bool,
          captureClick: a.bool,
          captureDoubleClick: a.bool,
          capturePointerMove: a.bool,
        };
      function Hn(t) {
        var e = t.containerRef.current,
          n = t.context.eventManager;
        if (e && n) {
          var r = {
            wheel: function (e) {
              var n = t.props;
              n.captureScroll && e.stopPropagation(),
                n.onScroll && n.onScroll(e, t);
            },
            panstart: function (e) {
              var n = t.props;
              n.captureDrag && e.stopPropagation(),
                n.onDragStart && n.onDragStart(e, t);
            },
            anyclick: function (e) {
              var n = t.props;
              n.captureClick && e.stopPropagation(),
                n.onClick && n.onClick(e, t);
            },
            click: function (e) {
              var n = t.props;
              n.captureClick && e.stopPropagation(),
                n.onClick && n.onClick(e, t);
            },
            dblclick: function (e) {
              var n = t.props;
              n.captureDoubleClick && e.stopPropagation(),
                n.onDoubleClick && n.onDoubleClick(e, t);
            },
            pointermove: function (e) {
              var n = t.props;
              n.capturePointerMove && e.stopPropagation(),
                n.onPointerMove && n.onPointerMove(e, t);
            },
          };
          return (
            n.watch(r, e),
            function () {
              n.off(r);
            }
          );
        }
      }
      function Xn() {
        var t =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          e = (0, s.useContext)(kt),
          n = (0, s.useRef)(null),
          r = (0, s.useRef)({
            props: t,
            state: {},
            context: e,
            containerRef: n,
          }),
          i = r.current;
        return (
          (i.props = t),
          (i.context = e),
          (0, s.useEffect)(
            function () {
              return Hn(i);
            },
            [e.eventManager]
          ),
          i
        );
      }
      function Kn(t) {
        var e = (function () {
          if ("undefined" === typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" === typeof Proxy) return !0;
          try {
            return (
              Date.prototype.toString.call(
                Reflect.construct(Date, [], function () {})
              ),
              !0
            );
          } catch (t) {
            return !1;
          }
        })();
        return function () {
          var n,
            r = Yt(t);
          if (e) {
            var i = Yt(this).constructor;
            n = Reflect.construct(r, arguments, i);
          } else n = r.apply(this, arguments);
          return Kt(this, n);
        };
      }
      function Yn(t) {
        var e = t.instance,
          n = Xn(t),
          r = n.context,
          i = n.containerRef;
        return (e._context = r), (e._containerRef = i), e._render();
      }
      var Qn = (function (t) {
        (0, Ht.Z)(n, t);
        var e = Kn(n);
        function n() {
          var t;
          (0, Q.Z)(this, n);
          for (var r = arguments.length, i = new Array(r), a = 0; a < r; a++)
            i[a] = arguments[a];
          return (
            (t = e.call.apply(e, [this].concat(i))),
            (0, o.Z)(Wt(t), "_context", {}),
            (0, o.Z)(Wt(t), "_containerRef", (0, s.createRef)()),
            (0, o.Z)(Wt(t), "_onScroll", function (t) {}),
            (0, o.Z)(Wt(t), "_onDragStart", function (t) {}),
            (0, o.Z)(Wt(t), "_onDblClick", function (t) {}),
            (0, o.Z)(Wt(t), "_onClick", function (t) {}),
            (0, o.Z)(Wt(t), "_onPointerMove", function (t) {}),
            t
          );
        }
        return (
          (0, J.Z)(n, [
            {
              key: "_render",
              value: function () {
                throw new Error("_render() not implemented");
              },
            },
            {
              key: "render",
              value: function () {
                return s.createElement(
                  Yn,
                  (0, r.Z)({ instance: this }, this.props, {
                    onScroll: this._onScroll,
                    onDragStart: this._onDragStart,
                    onDblClick: this._onDblClick,
                    onClick: this._onClick,
                    onPointerMove: this._onPointerMove,
                  })
                );
              },
            },
          ]),
          n
        );
      })(s.PureComponent);
      function Jn(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function tr(t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? Jn(Object(n), !0).forEach(function (e) {
                (0, o.Z)(t, e, n[e]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
            : Jn(Object(n)).forEach(function (e) {
                Object.defineProperty(
                  t,
                  e,
                  Object.getOwnPropertyDescriptor(n, e)
                );
              });
        }
        return t;
      }
      (0, o.Z)(Qn, "propTypes", Wn), (0, o.Z)(Qn, "defaultProps", Gn);
      var er = Object.assign({}, Wn, {
          draggable: a.bool,
          onDrag: a.func,
          onDragEnd: a.func,
          onDragStart: a.func,
          offsetLeft: a.number,
          offsetTop: a.number,
        }),
        nr = Object.assign({}, Gn, {
          draggable: !1,
          offsetLeft: 0,
          offsetTop: 0,
        });
      function rr(t) {
        var e = t.offsetCenter;
        return [e.x, e.y];
      }
      function ir(t, e, n, r) {
        var i = t[0] + e[0] - n.offsetLeft,
          o = t[1] + e[1] - n.offsetTop;
        return r.viewport.unproject([i, o]);
      }
      function or(t, e) {
        var n = e.props,
          r = e.callbacks,
          i = e.state,
          o = e.context,
          s = e.containerRef;
        if (n.draggable) {
          t.stopPropagation();
          var a = rr(t),
            l = (function (t, e) {
              var n = t.center,
                r = n.x,
                i = n.y;
              if (e) {
                var o = e.getBoundingClientRect();
                return [o.left - r, o.top - i];
              }
              return null;
            })(t, s.current);
          if ((i.setDragPos(a), i.setDragOffset(l), r.onDragStart && l)) {
            var c = Object.assign({}, t);
            (c.lngLat = ir(a, l, n, o)), r.onDragStart(c);
          }
        }
      }
      function sr(t) {
        var e = t.context.eventManager;
        if (e && t.state.dragPos) {
          var n = {
            panmove: function (e) {
              return (function (t, e) {
                var n = e.props,
                  r = e.callbacks,
                  i = e.state,
                  o = e.context;
                t.stopPropagation();
                var s = rr(t);
                i.setDragPos(s);
                var a = i.dragOffset;
                if (r.onDrag && a) {
                  var l = Object.assign({}, t);
                  (l.lngLat = ir(s, a, n, o)), r.onDrag(l);
                }
              })(e, t);
            },
            panend: function (e) {
              return (function (t, e) {
                var n = e.props,
                  r = e.callbacks,
                  i = e.state,
                  o = e.context;
                t.stopPropagation();
                var s = i.dragPos,
                  a = i.dragOffset;
                if (
                  (i.setDragPos(null),
                  i.setDragOffset(null),
                  r.onDragEnd && s && a)
                ) {
                  var l = Object.assign({}, t);
                  (l.lngLat = ir(s, a, n, o)), r.onDragEnd(l);
                }
              })(e, t);
            },
            pancancel: function (e) {
              return (function (t, e) {
                var n = e.state;
                t.stopPropagation(), n.setDragPos(null), n.setDragOffset(null);
              })(e, t);
            },
          };
          return (
            e.watch(n),
            function () {
              e.off(n);
            }
          );
        }
      }
      var ar = ("undefined" !== typeof window && window.devicePixelRatio) || 1,
        lr = function (t) {
          return Math.round(t * ar) / ar;
        },
        cr = function (t, e) {
          var n =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : "x";
          if (null === t) return e;
          var r = "x" === n ? t.offsetWidth : t.offsetHeight;
          return (lr((e / 100) * r) / r) * 100;
        },
        ur = Object.assign({}, er, {
          className: a.string,
          longitude: a.number.isRequired,
          latitude: a.number.isRequired,
        }),
        hr = Object.assign({}, nr, { className: "" });
      function pr(t) {
        var e = (function (t) {
            var e = c((0, s.useState)(null), 2),
              n = e[0],
              r = e[1],
              i = c((0, s.useState)(null), 2),
              o = i[0],
              a = i[1],
              l = Xn(tr(tr({}, t), {}, { onDragStart: or }));
            return (
              (l.callbacks = t),
              (l.state.dragPos = n),
              (l.state.setDragPos = r),
              (l.state.dragOffset = o),
              (l.state.setDragOffset = a),
              (0, s.useEffect)(
                function () {
                  return sr(l);
                },
                [l.context.eventManager, Boolean(n)]
              ),
              l
            );
          })(t),
          n = e.state,
          r = e.containerRef,
          i = t.children,
          o = t.className,
          a = t.draggable,
          l = n.dragPos,
          u = (function (t) {
            var e = t.props,
              n = t.state,
              r = t.context,
              i = e.longitude,
              o = e.latitude,
              s = e.offsetLeft,
              a = e.offsetTop,
              l = n.dragPos,
              u = n.dragOffset,
              h = r.viewport,
              p = r.map;
            if (l && u) return [l[0] + u[0], l[1] + u[1]];
            var d = Dt(p, { longitude: i, latitude: o }),
              f = c(h.project([i, o, d]), 2),
              m = f[0],
              g = f[1];
            return [(m += s), (g += a)];
          })(e),
          h = c(u, 2),
          p = h[0],
          d = h[1],
          f = "translate(".concat(lr(p), "px, ").concat(lr(d), "px)"),
          m = a ? (l ? "grabbing" : "grab") : "auto",
          g = (0, s.useMemo)(
            function () {
              var t = {
                position: "absolute",
                left: 0,
                top: 0,
                transform: f,
                cursor: m,
              };
              return s.createElement(
                "div",
                {
                  className: "mapboxgl-marker ".concat(o),
                  ref: e.containerRef,
                  style: t,
                },
                i
              );
            },
            [i, o]
          ),
          y = r.current;
        return y && ((y.style.transform = f), (y.style.cursor = m)), g;
      }
      (pr.defaultProps = hr), (pr.propTypes = ur);
      var dr = s.memo(pr),
        fr = {
          top: { x: 0.5, y: 0 },
          "top-left": { x: 0, y: 0 },
          "top-right": { x: 1, y: 0 },
          bottom: { x: 0.5, y: 1 },
          "bottom-left": { x: 0, y: 1 },
          "bottom-right": { x: 1, y: 1 },
          left: { x: 0, y: 0.5 },
          right: { x: 1, y: 0.5 },
        },
        mr = Object.keys(fr);
      function gr(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function yr(t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? gr(Object(n), !0).forEach(function (e) {
                (0, o.Z)(t, e, n[e]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
            : gr(Object(n)).forEach(function (e) {
                Object.defineProperty(
                  t,
                  e,
                  Object.getOwnPropertyDescriptor(n, e)
                );
              });
        }
        return t;
      }
      var _r = Object.assign({}, Wn, {
          className: a.string,
          longitude: a.number.isRequired,
          latitude: a.number.isRequired,
          altitude: a.number,
          offsetLeft: a.number,
          offsetTop: a.number,
          tipSize: a.number,
          closeButton: a.bool,
          closeOnClick: a.bool,
          anchor: a.oneOf(Object.keys(fr)),
          dynamicPosition: a.bool,
          sortByDepth: a.bool,
          onClose: a.func,
        }),
        vr = Object.assign({}, Gn, {
          className: "",
          offsetLeft: 0,
          offsetTop: 0,
          tipSize: 10,
          anchor: "bottom",
          dynamicPosition: !0,
          sortByDepth: !1,
          closeButton: !0,
          closeOnClick: !0,
          onClose: function () {},
        });
      function br(t, e, n, r) {
        var i = c(r, 2),
          o = i[0],
          s = i[1],
          a = t.anchor,
          l = t.dynamicPosition,
          u = t.tipSize;
        return n && l
          ? (function (t) {
              var e = t.x,
                n = t.y,
                r = t.width,
                i = t.height,
                o = t.selfWidth,
                s = t.selfHeight,
                a = t.anchor,
                l = t.padding,
                c = void 0 === l ? 0 : l,
                u = fr[a],
                h = u.x,
                p = u.y,
                d = n - p * s,
                f = d + s,
                m = Math.max(0, c - d) + Math.max(0, f - i + c);
              if (m > 0) {
                var g = p,
                  y = m;
                for (p = 0; p <= 1; p += 0.5)
                  (f = (d = n - p * s) + s),
                    (m = Math.max(0, c - d) + Math.max(0, f - i + c)) < y &&
                      ((y = m), (g = p));
                p = g;
              }
              var _ = 0.5;
              0.5 === p && ((h = Math.floor(h)), (_ = 1));
              var v = e - h * o,
                b = v + o,
                x = Math.max(0, c - v) + Math.max(0, b - r + c);
              if (x > 0) {
                var w = h,
                  S = x;
                for (h = 0; h <= 1; h += _)
                  (b = (v = e - h * o) + o),
                    (x = Math.max(0, c - v) + Math.max(0, b - r + c)) < S &&
                      ((S = x), (w = h));
                h = w;
              }
              return (
                mr.find(function (t) {
                  var e = fr[t];
                  return e.x === h && e.y === p;
                }) || a
              );
            })({
              x: o,
              y: s,
              anchor: a,
              padding: u,
              width: e.width,
              height: e.height,
              selfWidth: n.clientWidth,
              selfHeight: n.clientHeight,
            })
          : a;
      }
      function xr(t, e) {
        var n = e.props,
          r = e.context;
        (n.closeOnClick ||
          "mapboxgl-popup-close-button" === t.target.className) &&
          (n.onClose(),
          r.eventManager &&
            r.eventManager.once(
              "click",
              function (t) {
                return t.stopPropagation();
              },
              t.target
            ));
      }
      function wr(t) {
        var e = (0, s.useRef)(null),
          n = Xn(yr(yr({}, t), {}, { onClick: xr })),
          r = n.context,
          i = n.containerRef,
          o = c((0, s.useState)(!1), 2)[1];
        (0, s.useEffect)(
          function () {
            o(!0);
          },
          [e.current]
        );
        var a = r.viewport,
          l = r.map,
          u = t.className,
          h = t.longitude,
          p = t.latitude,
          d = t.tipSize,
          f = t.closeButton,
          m = t.children,
          g = t.altitude;
        void 0 === g && (g = Dt(l, { longitude: h, latitude: p }));
        var y = a.project([h, p, g]),
          _ = br(t, a, e.current, y),
          v = (function (t, e, n, r, i) {
            var o = c(r, 3),
              s = o[0],
              a = o[1],
              l = o[2],
              u = t.offsetLeft,
              h = t.offsetTop,
              p = t.sortByDepth,
              d = fr[i],
              f = s + u,
              m = a + h,
              g = cr(n, 100 * -d.x),
              y = cr(n, 100 * -d.y, "y"),
              _ = {
                position: "absolute",
                transform: "\n      translate("
                  .concat(g, "%, ")
                  .concat(y, "%)\n      translate(")
                  .concat(lr(f), "px, ")
                  .concat(lr(m), "px)\n    "),
                display: void 0,
                zIndex: void 0,
              };
            return p
              ? (l > 1 ||
                l < -1 ||
                s < 0 ||
                s > e.width ||
                a < 0 ||
                a > e.height
                  ? (_.display = "none")
                  : (_.zIndex = Math.floor(((1 - l) / 2) * 1e5)),
                _)
              : _;
          })(t, a, i.current, y, _),
          b = (0, s.useCallback)(
            function (t) {
              return !r.eventManager && xr(t, n);
            },
            [r.eventManager]
          );
        return s.createElement(
          "div",
          {
            className: "mapboxgl-popup mapboxgl-popup-anchor-"
              .concat(_, " ")
              .concat(u),
            style: v,
            ref: i,
          },
          s.createElement("div", {
            key: "tip",
            className: "mapboxgl-popup-tip",
            style: { borderWidth: d },
          }),
          s.createElement(
            "div",
            {
              key: "content",
              ref: e,
              className: "mapboxgl-popup-content",
              onClick: b,
            },
            f &&
              s.createElement(
                "button",
                {
                  key: "close-button",
                  className: "mapboxgl-popup-close-button",
                  type: "button",
                },
                "\xd7"
              ),
            m
          )
        );
      }
      (wr.propTypes = _r), (wr.defaultProps = vr);
      var Sr = s.memo(wr);
      function Er(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      var Tr = Object.assign({}, Wn, {
          toggleLabel: a.string,
          className: a.string,
          style: a.object,
          compact: a.bool,
          customAttribution: a.oneOfType([a.string, a.arrayOf(a.string)]),
        }),
        Ar = Object.assign({}, Gn, {
          className: "",
          toggleLabel: "Toggle Attribution",
        });
      function Cr(t) {
        var e = Xn(t),
          n = e.context,
          r = e.containerRef,
          i = (0, s.useRef)(null),
          a = c((0, s.useState)(!1), 2),
          l = a[0],
          u = a[1];
        (0, s.useEffect)(
          function () {
            var e;
            return (
              n.map &&
                (e = (function (t, e, n, r) {
                  var i = new (dt().AttributionControl)(t);
                  return (
                    (i._map = e),
                    (i._container = n),
                    (i._innerContainer = r),
                    i._updateAttributions(),
                    i._updateEditLink(),
                    e.on("styledata", i._updateData),
                    e.on("sourcedata", i._updateData),
                    i
                  );
                })(
                  { customAttribution: t.customAttribution },
                  n.map,
                  r.current,
                  i.current
                )),
              function () {
                return (
                  e &&
                  (function (t) {
                    t._map.off("styledata", t._updateData),
                      t._map.off("sourcedata", t._updateData);
                  })(e)
                );
              }
            );
          },
          [n.map]
        );
        var h = void 0 === t.compact ? n.viewport.width <= 640 : t.compact;
        (0, s.useEffect)(
          function () {
            !h && l && u(!1);
          },
          [h]
        );
        var p = (0, s.useCallback)(function () {
            return u(function (t) {
              return !t;
            });
          }, []),
          d = (0, s.useMemo)(
            function () {
              return (function (t) {
                for (var e = 1; e < arguments.length; e++) {
                  var n = null != arguments[e] ? arguments[e] : {};
                  e % 2
                    ? Er(Object(n), !0).forEach(function (e) {
                        (0, o.Z)(t, e, n[e]);
                      })
                    : Object.getOwnPropertyDescriptors
                    ? Object.defineProperties(
                        t,
                        Object.getOwnPropertyDescriptors(n)
                      )
                    : Er(Object(n)).forEach(function (e) {
                        Object.defineProperty(
                          t,
                          e,
                          Object.getOwnPropertyDescriptor(n, e)
                        );
                      });
                }
                return t;
              })({ position: "absolute" }, t.style);
            },
            [t.style]
          );
        return s.createElement(
          "div",
          { style: d, className: t.className },
          s.createElement(
            "div",
            {
              ref: r,
              "aria-pressed": l,
              className: "mapboxgl-ctrl mapboxgl-ctrl-attrib "
                .concat(h ? "mapboxgl-compact" : "", " ")
                .concat(l ? "mapboxgl-compact-show" : ""),
            },
            s.createElement("button", {
              type: "button",
              className: "mapboxgl-ctrl-attrib-button",
              title: t.toggleLabel,
              onClick: p,
            }),
            s.createElement("div", {
              ref: i,
              className: "mapboxgl-ctrl-attrib-inner",
              role: "list",
            })
          )
        );
      }
      (Cr.propTypes = Tr), (Cr.defaultProps = Ar);
      s.memo(Cr);
      function Pr(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      var Mr = Object.assign({}, Wn, {
          className: a.string,
          style: a.object,
          container: a.object,
          label: a.string,
        }),
        Or = Object.assign({}, Gn, {
          className: "",
          container: null,
          label: "Toggle fullscreen",
        });
      function kr(t) {
        var e = Xn(t),
          n = e.context,
          r = e.containerRef,
          i = c((0, s.useState)(!1), 2),
          a = i[0],
          l = i[1],
          u = c((0, s.useState)(!1), 2),
          h = u[0],
          p = u[1],
          d = c((0, s.useState)(null), 2),
          f = d[0],
          m = d[1];
        (0, s.useEffect)(function () {
          var t = new (dt().FullscreenControl)();
          m(t), p(t._checkFullscreenSupport());
          var e = function () {
            var e = !t._fullscreen;
            (t._fullscreen = e), l(e);
          };
          return (
            tt.addEventListener(t._fullscreenchange, e),
            function () {
              tt.removeEventListener(t._fullscreenchange, e);
            }
          );
        }, []);
        var g = (0, s.useMemo)(
          function () {
            return (function (t) {
              for (var e = 1; e < arguments.length; e++) {
                var n = null != arguments[e] ? arguments[e] : {};
                e % 2
                  ? Pr(Object(n), !0).forEach(function (e) {
                      (0, o.Z)(t, e, n[e]);
                    })
                  : Object.getOwnPropertyDescriptors
                  ? Object.defineProperties(
                      t,
                      Object.getOwnPropertyDescriptors(n)
                    )
                  : Pr(Object(n)).forEach(function (e) {
                      Object.defineProperty(
                        t,
                        e,
                        Object.getOwnPropertyDescriptor(n, e)
                      );
                    });
              }
              return t;
            })({ position: "absolute" }, t.style);
          },
          [t.style]
        );
        if (!h) return null;
        var y = t.className,
          _ = t.label,
          v = a ? "shrink" : "fullscreen";
        return s.createElement(
          "div",
          { style: g, className: y },
          s.createElement(
            "div",
            { className: "mapboxgl-ctrl mapboxgl-ctrl-group", ref: r },
            s.createElement(
              "button",
              {
                key: v,
                className: "mapboxgl-ctrl-icon mapboxgl-ctrl-".concat(v),
                type: "button",
                title: _,
                onClick: function () {
                  f &&
                    ((f._container = t.container || n.container),
                    f._onClickFullscreen());
                },
              },
              s.createElement("span", {
                className: "mapboxgl-ctrl-icon",
                "aria-hidden": "true",
              })
            )
          )
        );
      }
      (kr.propTypes = Mr), (kr.defaultProps = Or);
      var Ir;
      s.memo(kr);
      function Dr(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      var zr = function () {},
        Rr = Object.assign({}, Wn, {
          className: a.string,
          style: a.object,
          label: a.string,
          disabledLabel: a.string,
          auto: a.bool,
          positionOptions: a.object,
          fitBoundsOptions: a.object,
          trackUserLocation: a.bool,
          showUserLocation: a.bool,
          showAccuracyCircle: a.bool,
          onViewStateChange: a.func,
          onViewportChange: a.func,
          onGeolocate: a.func,
        }),
        Lr = Object.assign({}, Gn, {
          className: "",
          label: "Find My Location",
          disabledLabel: "Location Not Available",
          auto: !1,
          positionOptions: { enableHighAccuracy: !1, timeout: 6e3 },
          fitBoundsOptions: { maxZoom: 15 },
          trackUserLocation: !1,
          showUserLocation: !0,
          showAccuracyCircle: !0,
          onGeolocate: function () {},
        });
      function Fr(t, e) {
        var n = e.context,
          r = e.props,
          i = (function (t) {
            var e = new (dt().LngLat)(t.coords.longitude, t.coords.latitude),
              n = t.coords.accuracy,
              r = e.toBounds(n);
            return [
              [r._ne.lng, r._ne.lat],
              [r._sw.lng, r._sw.lat],
            ];
          })(t),
          o = n.viewport.fitBounds(i, r.fitBoundsOptions),
          s = o.longitude,
          a = o.latitude,
          l = o.zoom,
          c = Object.assign({}, n.viewport, {
            longitude: s,
            latitude: a,
            zoom: l,
          }),
          u = new Tt(c),
          h = Object.assign({}, u.getViewportProps(), un),
          p = r.onViewportChange || n.onViewportChange || zr;
        (r.onViewStateChange || n.onViewStateChange || zr)({ viewState: h }),
          p(h);
      }
      function Br(t) {
        var e = Xn(t),
          n = e.context,
          r = e.containerRef,
          i = (0, s.useRef)(null),
          a = c((0, s.useState)(null), 2),
          l = a[0],
          u = a[1],
          h = c((0, s.useState)(!1), 2),
          p = h[0],
          d = h[1];
        (0, s.useEffect)(
          function () {
            var r;
            return (
              n.map &&
                (void 0 !== Ir
                  ? Promise.resolve(Ir)
                  : void 0 !== window.navigator.permissions
                  ? window.navigator.permissions
                      .query({ name: "geolocation" })
                      .then(function (t) {
                        return (Ir = "denied" !== t.state);
                      })
                  : ((Ir = Boolean(window.navigator.geolocation)),
                    Promise.resolve(Ir))
                ).then(function (o) {
                  d(o),
                    i.current &&
                      ((r = (function (t, e, n) {
                        var r = new (dt().GeolocateControl)(e);
                        (r._container = tt.createElement("div")),
                          (r._map = {
                            on: function () {},
                            _getUIString: function () {
                              return "";
                            },
                          }),
                          r._setupUI(!0),
                          (r._map = t.map),
                          (r._geolocateButton = n);
                        var i = t.eventManager;
                        return (
                          r.options.trackUserLocation &&
                            i &&
                            i.on("panstart", function () {
                              "ACTIVE_LOCK" === r._watchState &&
                                ((r._watchState = "BACKGROUND"),
                                n.classList.add(
                                  "mapboxgl-ctrl-geolocate-background"
                                ),
                                n.classList.remove(
                                  "mapboxgl-ctrl-geolocate-active"
                                ));
                            }),
                          r.on("geolocate", e.onGeolocate),
                          r
                        );
                      })(n, t, i.current)),
                      (r._updateCamera = function (t) {
                        return Fr(t, e);
                      }),
                      u(r));
                }),
              function () {
                r && r._clearWatch();
              }
            );
          },
          [n.map]
        );
        var f = (0, s.useCallback)(
          function () {
            l && ((l.options = e.props), l.trigger());
          },
          [l]
        );
        (0, s.useEffect)(
          function () {
            t.auto && f();
          },
          [l, t.auto]
        ),
          (0, s.useEffect)(
            function () {
              l && l._onZoom();
            },
            [n.viewport.zoom]
          );
        var m = t.className,
          g = t.label,
          y = t.disabledLabel,
          _ = t.trackUserLocation,
          v = (0, s.useMemo)(
            function () {
              return (function (t) {
                for (var e = 1; e < arguments.length; e++) {
                  var n = null != arguments[e] ? arguments[e] : {};
                  e % 2
                    ? Dr(Object(n), !0).forEach(function (e) {
                        (0, o.Z)(t, e, n[e]);
                      })
                    : Object.getOwnPropertyDescriptors
                    ? Object.defineProperties(
                        t,
                        Object.getOwnPropertyDescriptors(n)
                      )
                    : Dr(Object(n)).forEach(function (e) {
                        Object.defineProperty(
                          t,
                          e,
                          Object.getOwnPropertyDescriptor(n, e)
                        );
                      });
                }
                return t;
              })({ position: "absolute" }, t.style);
            },
            [t.style]
          );
        return s.createElement(
          "div",
          { style: v, className: m },
          s.createElement(
            "div",
            {
              key: "geolocate-control",
              className: "mapboxgl-ctrl mapboxgl-ctrl-group",
              ref: r,
            },
            s.createElement(
              "button",
              {
                key: "geolocate",
                className: "mapboxgl-ctrl-icon mapboxgl-ctrl-geolocate",
                ref: i,
                disabled: !p,
                "aria-pressed": !_,
                type: "button",
                title: p ? g : y,
                "aria-label": p ? g : y,
                onClick: f,
              },
              s.createElement("span", {
                className: "mapboxgl-ctrl-icon",
                "aria-hidden": "true",
              })
            )
          )
        );
      }
      (Br.propTypes = Rr), (Br.defaultProps = Lr);
      s.memo(Br);
      function Nr(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      var jr = function () {},
        Ur = Object.assign({}, Wn, {
          className: a.string,
          style: a.object,
          onViewStateChange: a.func,
          onViewportChange: a.func,
          showCompass: a.bool,
          showZoom: a.bool,
          zoomInLabel: a.string,
          zoomOutLabel: a.string,
          compassLabel: a.string,
        }),
        Zr = Object.assign({}, Gn, {
          className: "",
          showCompass: !0,
          showZoom: !0,
          zoomInLabel: "Zoom In",
          zoomOutLabel: "Zoom Out",
          compassLabel: "Reset North",
        });
      function Vr(t) {
        return (function (t, e) {
          for (
            var n = (t || "").split(".").map(Number),
              r = (e || "").split(".").map(Number),
              i = 0;
            i < 3;
            i++
          ) {
            var o = n[i] || 0,
              s = r[i] || 0;
            if (o < s) return -1;
            if (o > s) return 1;
          }
          return 0;
        })(t, "1.6.0") >= 0
          ? 2
          : 1;
      }
      function qr(t, e, n) {
        var r = t.viewport,
          i = new Tt(Object.assign({}, r, n)),
          o = Object.assign({}, i.getViewportProps(), un),
          s = e.onViewportChange || t.onViewportChange || jr;
        (e.onViewStateChange || t.onViewStateChange || jr)({ viewState: o }),
          s(o);
      }
      function $r(t, e, n, r) {
        return s.createElement(
          "button",
          {
            key: t,
            className: "mapboxgl-ctrl-icon mapboxgl-ctrl-".concat(t),
            type: "button",
            title: e,
            onClick: n,
          },
          r ||
            s.createElement("span", {
              className: "mapboxgl-ctrl-icon",
              "aria-hidden": "true",
            })
        );
      }
      function Gr(t) {
        var e = Xn(t),
          n = e.context,
          r = e.containerRef,
          i = t.className,
          a = t.showCompass,
          l = t.showZoom,
          c = t.zoomInLabel,
          u = t.zoomOutLabel,
          h = t.compassLabel,
          p = (0, s.useMemo)(
            function () {
              return (function (t) {
                for (var e = 1; e < arguments.length; e++) {
                  var n = null != arguments[e] ? arguments[e] : {};
                  e % 2
                    ? Nr(Object(n), !0).forEach(function (e) {
                        (0, o.Z)(t, e, n[e]);
                      })
                    : Object.getOwnPropertyDescriptors
                    ? Object.defineProperties(
                        t,
                        Object.getOwnPropertyDescriptors(n)
                      )
                    : Nr(Object(n)).forEach(function (e) {
                        Object.defineProperty(
                          t,
                          e,
                          Object.getOwnPropertyDescriptor(n, e)
                        );
                      });
                }
                return t;
              })({ position: "absolute" }, t.style);
            },
            [t.style]
          );
        return s.createElement(
          "div",
          { style: p, className: i },
          s.createElement(
            "div",
            { className: "mapboxgl-ctrl mapboxgl-ctrl-group", ref: r },
            l &&
              $r("zoom-in", c, function () {
                qr(n, t, { zoom: n.viewport.zoom + 1 });
              }),
            l &&
              $r("zoom-out", u, function () {
                qr(n, t, { zoom: n.viewport.zoom - 1 });
              }),
            a &&
              $r(
                "compass",
                h,
                function () {
                  qr(n, t, { bearing: 0, pitch: 0 });
                },
                (function (t) {
                  var e = (0, s.useMemo)(
                      function () {
                        return t.map ? Vr(t.map.version) : 2;
                      },
                      [t.map]
                    ),
                    n = t.viewport.bearing,
                    r = { transform: "rotate(".concat(-n, "deg)") };
                  return 2 === e
                    ? s.createElement("span", {
                        className: "mapboxgl-ctrl-icon",
                        "aria-hidden": "true",
                        style: r,
                      })
                    : s.createElement("span", {
                        className: "mapboxgl-ctrl-compass-arrow",
                        style: r,
                      });
                })(n)
              )
          )
        );
      }
      (Gr.propTypes = Ur), (Gr.defaultProps = Zr);
      var Wr = s.memo(Gr);
      function Hr(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      var Xr = Object.assign({}, Wn, {
          className: a.string,
          style: a.object,
          maxWidth: a.number,
          unit: a.oneOf(["imperial", "metric", "nautical"]),
        }),
        Kr = Object.assign({}, Gn, {
          className: "",
          maxWidth: 100,
          unit: "metric",
        });
      function Yr(t) {
        var e = Xn(t),
          n = e.context,
          r = e.containerRef,
          i = c((0, s.useState)(null), 2),
          a = i[0],
          l = i[1];
        (0, s.useEffect)(
          function () {
            if (n.map) {
              var t = new (dt().ScaleControl)();
              (t._map = n.map), (t._container = r.current), l(t);
            }
          },
          [n.map]
        ),
          a && ((a.options = t), a._onMove());
        var u = (0, s.useMemo)(
          function () {
            return (function (t) {
              for (var e = 1; e < arguments.length; e++) {
                var n = null != arguments[e] ? arguments[e] : {};
                e % 2
                  ? Hr(Object(n), !0).forEach(function (e) {
                      (0, o.Z)(t, e, n[e]);
                    })
                  : Object.getOwnPropertyDescriptors
                  ? Object.defineProperties(
                      t,
                      Object.getOwnPropertyDescriptors(n)
                    )
                  : Hr(Object(n)).forEach(function (e) {
                      Object.defineProperty(
                        t,
                        e,
                        Object.getOwnPropertyDescriptor(n, e)
                      );
                    });
              }
              return t;
            })({ position: "absolute" }, t.style);
          },
          [t.style]
        );
        return s.createElement(
          "div",
          { style: u, className: t.className },
          s.createElement("div", {
            ref: r,
            className: "mapboxgl-ctrl mapboxgl-ctrl-scale",
          })
        );
      }
      (Yr.propTypes = Xr), (Yr.defaultProps = Kr);
      s.memo(Yr);
      var Qr = ("undefined" !== typeof window && window.devicePixelRatio) || 1,
        Jr = Object.assign({}, Wn, { redraw: a.func.isRequired });
      function ti(t) {
        var e = Xn(t),
          n = e.context,
          r = e.containerRef,
          i = c((0, s.useState)(null), 2),
          o = i[0],
          a = i[1];
        (0, s.useEffect)(function () {
          a(r.current.getContext("2d"));
        }, []);
        var l = n.viewport,
          u = n.isDragging;
        return (
          o &&
            (o.save(),
            o.scale(Qr, Qr),
            t.redraw({
              width: l.width,
              height: l.height,
              ctx: o,
              isDragging: u,
              project: l.project,
              unproject: l.unproject,
            }),
            o.restore()),
          s.createElement("canvas", {
            ref: r,
            width: l.width * Qr,
            height: l.height * Qr,
            style: {
              width: "".concat(l.width, "px"),
              height: "".concat(l.height, "px"),
              position: "absolute",
              left: 0,
              top: 0,
            },
          })
        );
      }
      (ti.propTypes = Jr),
        (ti.defaultProps = {
          captureScroll: !1,
          captureDrag: !1,
          captureClick: !1,
          captureDoubleClick: !1,
          capturePointerMove: !1,
        });
      function ei(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      var ni = Object.assign({}, Wn, {
        redraw: a.func.isRequired,
        style: a.object,
      });
      function ri(t) {
        var e = Xn(t),
          n = e.context,
          r = e.containerRef,
          i = n.viewport,
          a = n.isDragging,
          l = (function (t) {
            for (var e = 1; e < arguments.length; e++) {
              var n = null != arguments[e] ? arguments[e] : {};
              e % 2
                ? ei(Object(n), !0).forEach(function (e) {
                    (0, o.Z)(t, e, n[e]);
                  })
                : Object.getOwnPropertyDescriptors
                ? Object.defineProperties(
                    t,
                    Object.getOwnPropertyDescriptors(n)
                  )
                : ei(Object(n)).forEach(function (e) {
                    Object.defineProperty(
                      t,
                      e,
                      Object.getOwnPropertyDescriptor(n, e)
                    );
                  });
            }
            return t;
          })(
            {
              position: "absolute",
              left: 0,
              top: 0,
              width: i.width,
              height: i.height,
            },
            t.style
          );
        return s.createElement(
          "div",
          { ref: r, style: l },
          t.redraw({
            width: i.width,
            height: i.height,
            isDragging: a,
            project: i.project,
            unproject: i.unproject,
          })
        );
      }
      (ri.propTypes = ni),
        (ri.defaultProps = {
          captureScroll: !1,
          captureDrag: !1,
          captureClick: !1,
          captureDoubleClick: !1,
          capturePointerMove: !1,
        });
      function ii(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      var oi = Object.assign({}, Wn, {
        redraw: a.func.isRequired,
        style: a.object,
      });
      function si(t) {
        var e = Xn(t),
          n = e.context,
          r = e.containerRef,
          i = n.viewport,
          a = n.isDragging,
          l = (function (t) {
            for (var e = 1; e < arguments.length; e++) {
              var n = null != arguments[e] ? arguments[e] : {};
              e % 2
                ? ii(Object(n), !0).forEach(function (e) {
                    (0, o.Z)(t, e, n[e]);
                  })
                : Object.getOwnPropertyDescriptors
                ? Object.defineProperties(
                    t,
                    Object.getOwnPropertyDescriptors(n)
                  )
                : ii(Object(n)).forEach(function (e) {
                    Object.defineProperty(
                      t,
                      e,
                      Object.getOwnPropertyDescriptor(n, e)
                    );
                  });
            }
            return t;
          })({ position: "absolute", left: 0, top: 0 }, t.style);
        return s.createElement(
          "svg",
          { width: i.width, height: i.height, ref: r, style: l },
          t.redraw({
            width: i.width,
            height: i.height,
            isDragging: a,
            project: i.project,
            unproject: i.unproject,
          })
        );
      }
      (si.propTypes = oi),
        (si.defaultProps = {
          captureScroll: !1,
          captureDrag: !1,
          captureClick: !1,
          captureDoubleClick: !1,
          capturePointerMove: !1,
        });
      dt() && dt().setRTLTextPlugin;
    },
    59852: function (t, e, n) {
      "use strict";
      n.d(e, {
        j: function () {
          return a;
        },
      });
      var r = n(94578),
        i = n(52943),
        o = n(52288),
        s = (function (t) {
          function e() {
            return t.apply(this, arguments) || this;
          }
          (0, r.Z)(e, t);
          var n = e.prototype;
          return (
            (n.onSubscribe = function () {
              this.removeEventListener || this.setDefaultEventListener();
            }),
            (n.setEventListener = function (t) {
              var e = this;
              this.removeEventListener && this.removeEventListener(),
                (this.removeEventListener = t(function (t) {
                  "boolean" === typeof t ? e.setFocused(t) : e.onFocus();
                }));
            }),
            (n.setFocused = function (t) {
              (this.focused = t), t && this.onFocus();
            }),
            (n.onFocus = function () {
              this.listeners.forEach(function (t) {
                t();
              });
            }),
            (n.isFocused = function () {
              return "boolean" === typeof this.focused
                ? this.focused
                : "undefined" === typeof document ||
                    [void 0, "visible", "prerender"].includes(
                      document.visibilityState
                    );
            }),
            (n.setDefaultEventListener = function () {
              var t;
              !o.sk &&
                (null == (t = window) ? void 0 : t.addEventListener) &&
                this.setEventListener(function (t) {
                  var e = function () {
                    return t();
                  };
                  return (
                    window.addEventListener("visibilitychange", e, !1),
                    window.addEventListener("focus", e, !1),
                    function () {
                      window.removeEventListener("visibilitychange", e),
                        window.removeEventListener("focus", e);
                    }
                  );
                });
            }),
            e
          );
        })(i.l),
        a = new s();
    },
    46747: function (t, e, n) {
      "use strict";
      n.d(e, {
        QueryClient: function () {
          return r.S;
        },
      });
      var r = n(89043),
        i = n(86755);
      n.o(i, "Hydrate") &&
        n.d(e, {
          Hydrate: function () {
            return i.Hydrate;
          },
        }),
        n.o(i, "QueryClientProvider") &&
          n.d(e, {
            QueryClientProvider: function () {
              return i.QueryClientProvider;
            },
          }),
        n.o(i, "useMutation") &&
          n.d(e, {
            useMutation: function () {
              return i.useMutation;
            },
          }),
        n.o(i, "useQuery") &&
          n.d(e, {
            useQuery: function () {
              return i.useQuery;
            },
          }),
        n.o(i, "useQueryClient") &&
          n.d(e, {
            useQueryClient: function () {
              return i.useQueryClient;
            },
          });
    },
    41909: function (t, e, n) {
      "use strict";
      n.d(e, {
        E: function () {
          return s;
        },
        j: function () {
          return o;
        },
      });
      var r = n(52288),
        i = console || { error: r.ZT, warn: r.ZT, log: r.ZT };
      function o() {
        return i;
      }
      function s(t) {
        i = t;
      }
    },
    81262: function (t, e, n) {
      "use strict";
      n.d(e, {
        R: function () {
          return c;
        },
        m: function () {
          return l;
        },
      });
      var r = n(87462),
        i = n(41909),
        o = n(101),
        s = n(21216),
        a = n(52288),
        l = (function () {
          function t(t) {
            (this.options = (0, r.Z)({}, t.defaultOptions, t.options)),
              (this.mutationId = t.mutationId),
              (this.mutationCache = t.mutationCache),
              (this.observers = []),
              (this.state = t.state || c());
          }
          var e = t.prototype;
          return (
            (e.setState = function (t) {
              this.dispatch({ type: "setState", state: t });
            }),
            (e.addObserver = function (t) {
              -1 === this.observers.indexOf(t) && this.observers.push(t);
            }),
            (e.removeObserver = function (t) {
              this.observers = this.observers.filter(function (e) {
                return e !== t;
              });
            }),
            (e.cancel = function () {
              return this.retryer
                ? (this.retryer.cancel(),
                  this.retryer.promise.then(a.ZT).catch(a.ZT))
                : Promise.resolve();
            }),
            (e.continue = function () {
              return this.retryer
                ? (this.retryer.continue(), this.retryer.promise)
                : this.execute();
            }),
            (e.execute = function () {
              var t,
                e = this,
                n = "loading" === this.state.status,
                r = Promise.resolve();
              return (
                n ||
                  (this.dispatch({
                    type: "loading",
                    variables: this.options.variables,
                  }),
                  (r = r
                    .then(function () {
                      return null == e.options.onMutate
                        ? void 0
                        : e.options.onMutate(e.state.variables);
                    })
                    .then(function (t) {
                      t !== e.state.context &&
                        e.dispatch({
                          type: "loading",
                          context: t,
                          variables: e.state.variables,
                        });
                    }))),
                r
                  .then(function () {
                    return e.executeMutation();
                  })
                  .then(function (n) {
                    (t = n),
                      null == e.mutationCache.config.onSuccess ||
                        e.mutationCache.config.onSuccess(
                          t,
                          e.state.variables,
                          e.state.context,
                          e
                        );
                  })
                  .then(function () {
                    return null == e.options.onSuccess
                      ? void 0
                      : e.options.onSuccess(
                          t,
                          e.state.variables,
                          e.state.context
                        );
                  })
                  .then(function () {
                    return null == e.options.onSettled
                      ? void 0
                      : e.options.onSettled(
                          t,
                          null,
                          e.state.variables,
                          e.state.context
                        );
                  })
                  .then(function () {
                    return e.dispatch({ type: "success", data: t }), t;
                  })
                  .catch(function (t) {
                    return (
                      null == e.mutationCache.config.onError ||
                        e.mutationCache.config.onError(
                          t,
                          e.state.variables,
                          e.state.context,
                          e
                        ),
                      (0, i.j)().error(t),
                      Promise.resolve()
                        .then(function () {
                          return null == e.options.onError
                            ? void 0
                            : e.options.onError(
                                t,
                                e.state.variables,
                                e.state.context
                              );
                        })
                        .then(function () {
                          return null == e.options.onSettled
                            ? void 0
                            : e.options.onSettled(
                                void 0,
                                t,
                                e.state.variables,
                                e.state.context
                              );
                        })
                        .then(function () {
                          throw (e.dispatch({ type: "error", error: t }), t);
                        })
                    );
                  })
              );
            }),
            (e.executeMutation = function () {
              var t,
                e = this;
              return (
                (this.retryer = new s.m4({
                  fn: function () {
                    return e.options.mutationFn
                      ? e.options.mutationFn(e.state.variables)
                      : Promise.reject("No mutationFn found");
                  },
                  onFail: function () {
                    e.dispatch({ type: "failed" });
                  },
                  onPause: function () {
                    e.dispatch({ type: "pause" });
                  },
                  onContinue: function () {
                    e.dispatch({ type: "continue" });
                  },
                  retry: null != (t = this.options.retry) ? t : 0,
                  retryDelay: this.options.retryDelay,
                })),
                this.retryer.promise
              );
            }),
            (e.dispatch = function (t) {
              var e = this;
              (this.state = (function (t, e) {
                switch (e.type) {
                  case "failed":
                    return (0, r.Z)({}, t, {
                      failureCount: t.failureCount + 1,
                    });
                  case "pause":
                    return (0, r.Z)({}, t, { isPaused: !0 });
                  case "continue":
                    return (0, r.Z)({}, t, { isPaused: !1 });
                  case "loading":
                    return (0, r.Z)({}, t, {
                      context: e.context,
                      data: void 0,
                      error: null,
                      isPaused: !1,
                      status: "loading",
                      variables: e.variables,
                    });
                  case "success":
                    return (0, r.Z)({}, t, {
                      data: e.data,
                      error: null,
                      status: "success",
                      isPaused: !1,
                    });
                  case "error":
                    return (0, r.Z)({}, t, {
                      data: void 0,
                      error: e.error,
                      failureCount: t.failureCount + 1,
                      isPaused: !1,
                      status: "error",
                    });
                  case "setState":
                    return (0, r.Z)({}, t, e.state);
                  default:
                    return t;
                }
              })(this.state, t)),
                o.V.batch(function () {
                  e.observers.forEach(function (e) {
                    e.onMutationUpdate(t);
                  }),
                    e.mutationCache.notify(e);
                });
            }),
            t
          );
        })();
      function c() {
        return {
          context: void 0,
          data: void 0,
          error: null,
          failureCount: 0,
          isPaused: !1,
          status: "idle",
          variables: void 0,
        };
      }
    },
    101: function (t, e, n) {
      "use strict";
      n.d(e, {
        V: function () {
          return o;
        },
      });
      var r = n(52288),
        i = (function () {
          function t() {
            (this.queue = []),
              (this.transactions = 0),
              (this.notifyFn = function (t) {
                t();
              }),
              (this.batchNotifyFn = function (t) {
                t();
              });
          }
          var e = t.prototype;
          return (
            (e.batch = function (t) {
              this.transactions++;
              var e = t();
              return this.transactions--, this.transactions || this.flush(), e;
            }),
            (e.schedule = function (t) {
              var e = this;
              this.transactions
                ? this.queue.push(t)
                : (0, r.A4)(function () {
                    e.notifyFn(t);
                  });
            }),
            (e.batchCalls = function (t) {
              var e = this;
              return function () {
                for (
                  var n = arguments.length, r = new Array(n), i = 0;
                  i < n;
                  i++
                )
                  r[i] = arguments[i];
                e.schedule(function () {
                  t.apply(void 0, r);
                });
              };
            }),
            (e.flush = function () {
              var t = this,
                e = this.queue;
              (this.queue = []),
                e.length &&
                  (0, r.A4)(function () {
                    t.batchNotifyFn(function () {
                      e.forEach(function (e) {
                        t.notifyFn(e);
                      });
                    });
                  });
            }),
            (e.setNotifyFunction = function (t) {
              this.notifyFn = t;
            }),
            (e.setBatchNotifyFunction = function (t) {
              this.batchNotifyFn = t;
            }),
            t
          );
        })(),
        o = new i();
    },
    40068: function (t, e, n) {
      "use strict";
      n.d(e, {
        N: function () {
          return a;
        },
      });
      var r = n(94578),
        i = n(52943),
        o = n(52288),
        s = (function (t) {
          function e() {
            return t.apply(this, arguments) || this;
          }
          (0, r.Z)(e, t);
          var n = e.prototype;
          return (
            (n.onSubscribe = function () {
              this.removeEventListener || this.setDefaultEventListener();
            }),
            (n.setEventListener = function (t) {
              var e = this;
              this.removeEventListener && this.removeEventListener(),
                (this.removeEventListener = t(function (t) {
                  "boolean" === typeof t ? e.setOnline(t) : e.onOnline();
                }));
            }),
            (n.setOnline = function (t) {
              (this.online = t), t && this.onOnline();
            }),
            (n.onOnline = function () {
              this.listeners.forEach(function (t) {
                t();
              });
            }),
            (n.isOnline = function () {
              return "boolean" === typeof this.online
                ? this.online
                : "undefined" === typeof navigator ||
                    "undefined" === typeof navigator.onLine ||
                    navigator.onLine;
            }),
            (n.setDefaultEventListener = function () {
              var t;
              !o.sk &&
                (null == (t = window) ? void 0 : t.addEventListener) &&
                this.setEventListener(function (t) {
                  var e = function () {
                    return t();
                  };
                  return (
                    window.addEventListener("online", e, !1),
                    window.addEventListener("offline", e, !1),
                    function () {
                      window.removeEventListener("online", e),
                        window.removeEventListener("offline", e);
                    }
                  );
                });
            }),
            e
          );
        })(i.l),
        a = new s();
    },
    89043: function (t, e, n) {
      "use strict";
      n.d(e, {
        S: function () {
          return _;
        },
      });
      var r = n(87462),
        i = n(52288),
        o = n(94578),
        s = n(101),
        a = n(41909),
        l = n(21216),
        c = (function () {
          function t(t) {
            (this.defaultOptions = t.defaultOptions),
              this.setOptions(t.options),
              (this.observers = []),
              (this.cache = t.cache),
              (this.queryKey = t.queryKey),
              (this.queryHash = t.queryHash),
              (this.initialState =
                t.state || this.getDefaultState(this.options)),
              (this.state = this.initialState),
              this.scheduleGc();
          }
          var e = t.prototype;
          return (
            (e.setOptions = function (t) {
              var e;
              (this.options = (0, r.Z)({}, this.defaultOptions, t)),
                (this.cacheTime = Math.max(
                  this.cacheTime || 0,
                  null != (e = this.options.cacheTime) ? e : 3e5
                ));
            }),
            (e.setDefaultOptions = function (t) {
              this.defaultOptions = t;
            }),
            (e.scheduleGc = function () {
              var t = this;
              this.clearGcTimeout(),
                (0, i.PN)(this.cacheTime) &&
                  (this.gcTimeout = setTimeout(function () {
                    t.optionalRemove();
                  }, this.cacheTime));
            }),
            (e.clearGcTimeout = function () {
              clearTimeout(this.gcTimeout), (this.gcTimeout = void 0);
            }),
            (e.optionalRemove = function () {
              this.observers.length ||
                this.state.isFetching ||
                this.cache.remove(this);
            }),
            (e.setData = function (t, e) {
              var n,
                r,
                o = this.state.data,
                s = (0, i.SE)(t, o);
              return (
                (
                  null == (n = (r = this.options).isDataEqual)
                    ? void 0
                    : n.call(r, o, s)
                )
                  ? (s = o)
                  : !1 !== this.options.structuralSharing &&
                    (s = (0, i.Q$)(o, s)),
                this.dispatch({
                  data: s,
                  type: "success",
                  dataUpdatedAt: null == e ? void 0 : e.updatedAt,
                }),
                s
              );
            }),
            (e.setState = function (t, e) {
              this.dispatch({ type: "setState", state: t, setStateOptions: e });
            }),
            (e.cancel = function (t) {
              var e,
                n = this.promise;
              return (
                null == (e = this.retryer) || e.cancel(t),
                n ? n.then(i.ZT).catch(i.ZT) : Promise.resolve()
              );
            }),
            (e.destroy = function () {
              this.clearGcTimeout(), this.cancel({ silent: !0 });
            }),
            (e.reset = function () {
              this.destroy(), this.setState(this.initialState);
            }),
            (e.isActive = function () {
              return this.observers.some(function (t) {
                return !1 !== t.options.enabled;
              });
            }),
            (e.isFetching = function () {
              return this.state.isFetching;
            }),
            (e.isStale = function () {
              return (
                this.state.isInvalidated ||
                !this.state.dataUpdatedAt ||
                this.observers.some(function (t) {
                  return t.getCurrentResult().isStale;
                })
              );
            }),
            (e.isStaleByTime = function (t) {
              return (
                void 0 === t && (t = 0),
                this.state.isInvalidated ||
                  !this.state.dataUpdatedAt ||
                  !(0, i.Kp)(this.state.dataUpdatedAt, t)
              );
            }),
            (e.onFocus = function () {
              var t,
                e = this.observers.find(function (t) {
                  return t.shouldFetchOnWindowFocus();
                });
              e && e.refetch(), null == (t = this.retryer) || t.continue();
            }),
            (e.onOnline = function () {
              var t,
                e = this.observers.find(function (t) {
                  return t.shouldFetchOnReconnect();
                });
              e && e.refetch(), null == (t = this.retryer) || t.continue();
            }),
            (e.addObserver = function (t) {
              -1 === this.observers.indexOf(t) &&
                (this.observers.push(t),
                this.clearGcTimeout(),
                this.cache.notify({
                  type: "observerAdded",
                  query: this,
                  observer: t,
                }));
            }),
            (e.removeObserver = function (t) {
              -1 !== this.observers.indexOf(t) &&
                ((this.observers = this.observers.filter(function (e) {
                  return e !== t;
                })),
                this.observers.length ||
                  (this.retryer &&
                    (this.retryer.isTransportCancelable
                      ? this.retryer.cancel({ revert: !0 })
                      : this.retryer.cancelRetry()),
                  this.cacheTime ? this.scheduleGc() : this.cache.remove(this)),
                this.cache.notify({
                  type: "observerRemoved",
                  query: this,
                  observer: t,
                }));
            }),
            (e.getObserversCount = function () {
              return this.observers.length;
            }),
            (e.invalidate = function () {
              this.state.isInvalidated || this.dispatch({ type: "invalidate" });
            }),
            (e.fetch = function (t, e) {
              var n,
                r,
                o = this;
              if (this.state.isFetching)
                if (
                  this.state.dataUpdatedAt &&
                  (null == e ? void 0 : e.cancelRefetch)
                )
                  this.cancel({ silent: !0 });
                else if (this.promise) return this.promise;
              if ((t && this.setOptions(t), !this.options.queryFn)) {
                var s = this.observers.find(function (t) {
                  return t.options.queryFn;
                });
                s && this.setOptions(s.options);
              }
              var c,
                u,
                h = (0, i.mc)(this.queryKey),
                p = { queryKey: h, pageParam: void 0 },
                d = {
                  fetchOptions: e,
                  options: this.options,
                  queryKey: h,
                  state: this.state,
                  fetchFn: function () {
                    return o.options.queryFn
                      ? o.options.queryFn(p)
                      : Promise.reject("Missing queryFn");
                  },
                };
              (null == (n = this.options.behavior) ? void 0 : n.onFetch) &&
                (null == (c = this.options.behavior) || c.onFetch(d));
              ((this.revertState = this.state),
              this.state.isFetching &&
                this.state.fetchMeta ===
                  (null == (r = d.fetchOptions) ? void 0 : r.meta)) ||
                this.dispatch({
                  type: "fetch",
                  meta: null == (u = d.fetchOptions) ? void 0 : u.meta,
                });
              return (
                (this.retryer = new l.m4({
                  fn: d.fetchFn,
                  onSuccess: function (t) {
                    o.setData(t),
                      null == o.cache.config.onSuccess ||
                        o.cache.config.onSuccess(t, o),
                      0 === o.cacheTime && o.optionalRemove();
                  },
                  onError: function (t) {
                    ((0, l.DV)(t) && t.silent) ||
                      o.dispatch({ type: "error", error: t }),
                      (0, l.DV)(t) ||
                        (null == o.cache.config.onError ||
                          o.cache.config.onError(t, o),
                        (0, a.j)().error(t)),
                      0 === o.cacheTime && o.optionalRemove();
                  },
                  onFail: function () {
                    o.dispatch({ type: "failed" });
                  },
                  onPause: function () {
                    o.dispatch({ type: "pause" });
                  },
                  onContinue: function () {
                    o.dispatch({ type: "continue" });
                  },
                  retry: d.options.retry,
                  retryDelay: d.options.retryDelay,
                })),
                (this.promise = this.retryer.promise),
                this.promise
              );
            }),
            (e.dispatch = function (t) {
              var e = this;
              (this.state = this.reducer(this.state, t)),
                s.V.batch(function () {
                  e.observers.forEach(function (e) {
                    e.onQueryUpdate(t);
                  }),
                    e.cache.notify({
                      query: e,
                      type: "queryUpdated",
                      action: t,
                    });
                });
            }),
            (e.getDefaultState = function (t) {
              var e =
                  "function" === typeof t.initialData
                    ? t.initialData()
                    : t.initialData,
                n =
                  "undefined" !== typeof t.initialData
                    ? "function" === typeof t.initialDataUpdatedAt
                      ? t.initialDataUpdatedAt()
                      : t.initialDataUpdatedAt
                    : 0,
                r = "undefined" !== typeof e;
              return {
                data: e,
                dataUpdateCount: 0,
                dataUpdatedAt: r ? (null != n ? n : Date.now()) : 0,
                error: null,
                errorUpdateCount: 0,
                errorUpdatedAt: 0,
                fetchFailureCount: 0,
                fetchMeta: null,
                isFetching: !1,
                isInvalidated: !1,
                isPaused: !1,
                status: r ? "success" : "idle",
              };
            }),
            (e.reducer = function (t, e) {
              var n, i;
              switch (e.type) {
                case "failed":
                  return (0, r.Z)({}, t, {
                    fetchFailureCount: t.fetchFailureCount + 1,
                  });
                case "pause":
                  return (0, r.Z)({}, t, { isPaused: !0 });
                case "continue":
                  return (0, r.Z)({}, t, { isPaused: !1 });
                case "fetch":
                  return (0, r.Z)({}, t, {
                    fetchFailureCount: 0,
                    fetchMeta: null != (n = e.meta) ? n : null,
                    isFetching: !0,
                    isPaused: !1,
                    status: t.dataUpdatedAt ? t.status : "loading",
                  });
                case "success":
                  return (0, r.Z)({}, t, {
                    data: e.data,
                    dataUpdateCount: t.dataUpdateCount + 1,
                    dataUpdatedAt:
                      null != (i = e.dataUpdatedAt) ? i : Date.now(),
                    error: null,
                    fetchFailureCount: 0,
                    isFetching: !1,
                    isInvalidated: !1,
                    isPaused: !1,
                    status: "success",
                  });
                case "error":
                  var o = e.error;
                  return (0, l.DV)(o) && o.revert && this.revertState
                    ? (0, r.Z)({}, this.revertState)
                    : (0, r.Z)({}, t, {
                        error: o,
                        errorUpdateCount: t.errorUpdateCount + 1,
                        errorUpdatedAt: Date.now(),
                        fetchFailureCount: t.fetchFailureCount + 1,
                        isFetching: !1,
                        isPaused: !1,
                        status: "error",
                      });
                case "invalidate":
                  return (0, r.Z)({}, t, { isInvalidated: !0 });
                case "setState":
                  return (0, r.Z)({}, t, e.state);
                default:
                  return t;
              }
            }),
            t
          );
        })(),
        u = n(52943),
        h = (function (t) {
          function e(e) {
            var n;
            return (
              ((n = t.call(this) || this).config = e || {}),
              (n.queries = []),
              (n.queriesMap = {}),
              n
            );
          }
          (0, o.Z)(e, t);
          var n = e.prototype;
          return (
            (n.build = function (t, e, n) {
              var r,
                o = e.queryKey,
                s = null != (r = e.queryHash) ? r : (0, i.Rm)(o, e),
                a = this.get(s);
              return (
                a ||
                  ((a = new c({
                    cache: this,
                    queryKey: o,
                    queryHash: s,
                    options: t.defaultQueryOptions(e),
                    state: n,
                    defaultOptions: t.getQueryDefaults(o),
                  })),
                  this.add(a)),
                a
              );
            }),
            (n.add = function (t) {
              this.queriesMap[t.queryHash] ||
                ((this.queriesMap[t.queryHash] = t),
                this.queries.push(t),
                this.notify({ type: "queryAdded", query: t }));
            }),
            (n.remove = function (t) {
              var e = this.queriesMap[t.queryHash];
              e &&
                (t.destroy(),
                (this.queries = this.queries.filter(function (e) {
                  return e !== t;
                })),
                e === t && delete this.queriesMap[t.queryHash],
                this.notify({ type: "queryRemoved", query: t }));
            }),
            (n.clear = function () {
              var t = this;
              s.V.batch(function () {
                t.queries.forEach(function (e) {
                  t.remove(e);
                });
              });
            }),
            (n.get = function (t) {
              return this.queriesMap[t];
            }),
            (n.getAll = function () {
              return this.queries;
            }),
            (n.find = function (t, e) {
              var n = (0, i.I6)(t, e)[0];
              return (
                "undefined" === typeof n.exact && (n.exact = !0),
                this.queries.find(function (t) {
                  return (0, i._x)(n, t);
                })
              );
            }),
            (n.findAll = function (t, e) {
              var n = (0, i.I6)(t, e)[0];
              return n
                ? this.queries.filter(function (t) {
                    return (0, i._x)(n, t);
                  })
                : this.queries;
            }),
            (n.notify = function (t) {
              var e = this;
              s.V.batch(function () {
                e.listeners.forEach(function (e) {
                  e(t);
                });
              });
            }),
            (n.onFocus = function () {
              var t = this;
              s.V.batch(function () {
                t.queries.forEach(function (t) {
                  t.onFocus();
                });
              });
            }),
            (n.onOnline = function () {
              var t = this;
              s.V.batch(function () {
                t.queries.forEach(function (t) {
                  t.onOnline();
                });
              });
            }),
            e
          );
        })(u.l),
        p = n(81262),
        d = (function (t) {
          function e(e) {
            var n;
            return (
              ((n = t.call(this) || this).config = e || {}),
              (n.mutations = []),
              (n.mutationId = 0),
              n
            );
          }
          (0, o.Z)(e, t);
          var n = e.prototype;
          return (
            (n.build = function (t, e, n) {
              var r = new p.m({
                mutationCache: this,
                mutationId: ++this.mutationId,
                options: t.defaultMutationOptions(e),
                state: n,
                defaultOptions: e.mutationKey
                  ? t.getMutationDefaults(e.mutationKey)
                  : void 0,
              });
              return this.add(r), r;
            }),
            (n.add = function (t) {
              this.mutations.push(t), this.notify(t);
            }),
            (n.remove = function (t) {
              (this.mutations = this.mutations.filter(function (e) {
                return e !== t;
              })),
                t.cancel(),
                this.notify(t);
            }),
            (n.clear = function () {
              var t = this;
              s.V.batch(function () {
                t.mutations.forEach(function (e) {
                  t.remove(e);
                });
              });
            }),
            (n.getAll = function () {
              return this.mutations;
            }),
            (n.find = function (t) {
              return (
                "undefined" === typeof t.exact && (t.exact = !0),
                this.mutations.find(function (e) {
                  return (0, i.X7)(t, e);
                })
              );
            }),
            (n.findAll = function (t) {
              return this.mutations.filter(function (e) {
                return (0, i.X7)(t, e);
              });
            }),
            (n.notify = function (t) {
              var e = this;
              s.V.batch(function () {
                e.listeners.forEach(function (e) {
                  e(t);
                });
              });
            }),
            (n.onFocus = function () {
              this.resumePausedMutations();
            }),
            (n.onOnline = function () {
              this.resumePausedMutations();
            }),
            (n.resumePausedMutations = function () {
              var t = this.mutations.filter(function (t) {
                return t.state.isPaused;
              });
              return s.V.batch(function () {
                return t.reduce(function (t, e) {
                  return t.then(function () {
                    return e.continue().catch(i.ZT);
                  });
                }, Promise.resolve());
              });
            }),
            e
          );
        })(u.l),
        f = n(59852),
        m = n(40068);
      function g(t, e) {
        return null == t.getNextPageParam
          ? void 0
          : t.getNextPageParam(e[e.length - 1], e);
      }
      function y(t, e) {
        return null == t.getPreviousPageParam
          ? void 0
          : t.getPreviousPageParam(e[0], e);
      }
      var _ = (function () {
        function t(t) {
          void 0 === t && (t = {}),
            (this.queryCache = t.queryCache || new h()),
            (this.mutationCache = t.mutationCache || new d()),
            (this.defaultOptions = t.defaultOptions || {}),
            (this.queryDefaults = []),
            (this.mutationDefaults = []);
        }
        var e = t.prototype;
        return (
          (e.mount = function () {
            var t = this;
            (this.unsubscribeFocus = f.j.subscribe(function () {
              f.j.isFocused() &&
                m.N.isOnline() &&
                (t.mutationCache.onFocus(), t.queryCache.onFocus());
            })),
              (this.unsubscribeOnline = m.N.subscribe(function () {
                f.j.isFocused() &&
                  m.N.isOnline() &&
                  (t.mutationCache.onOnline(), t.queryCache.onOnline());
              }));
          }),
          (e.unmount = function () {
            var t, e;
            null == (t = this.unsubscribeFocus) || t.call(this),
              null == (e = this.unsubscribeOnline) || e.call(this);
          }),
          (e.isFetching = function (t, e) {
            var n = (0, i.I6)(t, e)[0];
            return (n.fetching = !0), this.queryCache.findAll(n).length;
          }),
          (e.isMutating = function (t) {
            return this.mutationCache.findAll((0, r.Z)({}, t, { fetching: !0 }))
              .length;
          }),
          (e.getQueryData = function (t, e) {
            var n;
            return null == (n = this.queryCache.find(t, e))
              ? void 0
              : n.state.data;
          }),
          (e.getQueriesData = function (t) {
            return this.getQueryCache()
              .findAll(t)
              .map(function (t) {
                return [t.queryKey, t.state.data];
              });
          }),
          (e.setQueryData = function (t, e, n) {
            var r = (0, i._v)(t),
              o = this.defaultQueryOptions(r);
            return this.queryCache.build(this, o).setData(e, n);
          }),
          (e.setQueriesData = function (t, e, n) {
            var r = this;
            return s.V.batch(function () {
              return r
                .getQueryCache()
                .findAll(t)
                .map(function (t) {
                  var i = t.queryKey;
                  return [i, r.setQueryData(i, e, n)];
                });
            });
          }),
          (e.getQueryState = function (t, e) {
            var n;
            return null == (n = this.queryCache.find(t, e)) ? void 0 : n.state;
          }),
          (e.removeQueries = function (t, e) {
            var n = (0, i.I6)(t, e)[0],
              r = this.queryCache;
            s.V.batch(function () {
              r.findAll(n).forEach(function (t) {
                r.remove(t);
              });
            });
          }),
          (e.resetQueries = function (t, e, n) {
            var o = this,
              a = (0, i.I6)(t, e, n),
              l = a[0],
              c = a[1],
              u = this.queryCache,
              h = (0, r.Z)({}, l, { active: !0 });
            return s.V.batch(function () {
              return (
                u.findAll(l).forEach(function (t) {
                  t.reset();
                }),
                o.refetchQueries(h, c)
              );
            });
          }),
          (e.cancelQueries = function (t, e, n) {
            var r = this,
              o = (0, i.I6)(t, e, n),
              a = o[0],
              l = o[1],
              c = void 0 === l ? {} : l;
            "undefined" === typeof c.revert && (c.revert = !0);
            var u = s.V.batch(function () {
              return r.queryCache.findAll(a).map(function (t) {
                return t.cancel(c);
              });
            });
            return Promise.all(u).then(i.ZT).catch(i.ZT);
          }),
          (e.invalidateQueries = function (t, e, n) {
            var o,
              a,
              l,
              c = this,
              u = (0, i.I6)(t, e, n),
              h = u[0],
              p = u[1],
              d = (0, r.Z)({}, h, {
                active:
                  null == (o = null != (a = h.refetchActive) ? a : h.active) ||
                  o,
                inactive: null != (l = h.refetchInactive) && l,
              });
            return s.V.batch(function () {
              return (
                c.queryCache.findAll(h).forEach(function (t) {
                  t.invalidate();
                }),
                c.refetchQueries(d, p)
              );
            });
          }),
          (e.refetchQueries = function (t, e, n) {
            var r = this,
              o = (0, i.I6)(t, e, n),
              a = o[0],
              l = o[1],
              c = s.V.batch(function () {
                return r.queryCache.findAll(a).map(function (t) {
                  return t.fetch(void 0, {
                    meta: { refetchPage: null == a ? void 0 : a.refetchPage },
                  });
                });
              }),
              u = Promise.all(c).then(i.ZT);
            return (
              (null == l ? void 0 : l.throwOnError) || (u = u.catch(i.ZT)), u
            );
          }),
          (e.fetchQuery = function (t, e, n) {
            var r = (0, i._v)(t, e, n),
              o = this.defaultQueryOptions(r);
            "undefined" === typeof o.retry && (o.retry = !1);
            var s = this.queryCache.build(this, o);
            return s.isStaleByTime(o.staleTime)
              ? s.fetch(o)
              : Promise.resolve(s.state.data);
          }),
          (e.prefetchQuery = function (t, e, n) {
            return this.fetchQuery(t, e, n).then(i.ZT).catch(i.ZT);
          }),
          (e.fetchInfiniteQuery = function (t, e, n) {
            var r = (0, i._v)(t, e, n);
            return (
              (r.behavior = {
                onFetch: function (t) {
                  t.fetchFn = function () {
                    var e,
                      n,
                      r,
                      i,
                      o,
                      s,
                      a,
                      c =
                        null == (e = t.fetchOptions) || null == (n = e.meta)
                          ? void 0
                          : n.refetchPage,
                      u =
                        null == (r = t.fetchOptions) || null == (i = r.meta)
                          ? void 0
                          : i.fetchMore,
                      h = null == u ? void 0 : u.pageParam,
                      p = "forward" === (null == u ? void 0 : u.direction),
                      d = "backward" === (null == u ? void 0 : u.direction),
                      f = (null == (o = t.state.data) ? void 0 : o.pages) || [],
                      m =
                        (null == (s = t.state.data) ? void 0 : s.pageParams) ||
                        [],
                      _ = m,
                      v = !1,
                      b =
                        t.options.queryFn ||
                        function () {
                          return Promise.reject("Missing queryFn");
                        },
                      x = function (t, e, n, r) {
                        return (
                          (_ = r ? [e].concat(_) : [].concat(_, [e])),
                          r ? [n].concat(t) : [].concat(t, [n])
                        );
                      },
                      w = function (e, n, r, i) {
                        if (v) return Promise.reject("Cancelled");
                        if ("undefined" === typeof r && !n && e.length)
                          return Promise.resolve(e);
                        var o = { queryKey: t.queryKey, pageParam: r },
                          s = b(o),
                          a = Promise.resolve(s).then(function (t) {
                            return x(e, r, t, i);
                          });
                        return (0, l.LE)(s) && (a.cancel = s.cancel), a;
                      };
                    if (f.length)
                      if (p) {
                        var S = "undefined" !== typeof h,
                          E = S ? h : g(t.options, f);
                        a = w(f, S, E);
                      } else if (d) {
                        var T = "undefined" !== typeof h,
                          A = T ? h : y(t.options, f);
                        a = w(f, T, A, !0);
                      } else
                        !(function () {
                          _ = [];
                          var e =
                              "undefined" === typeof t.options.getNextPageParam,
                            n = !c || !f[0] || c(f[0], 0, f);
                          a = n
                            ? w([], e, m[0])
                            : Promise.resolve(x([], m[0], f[0]));
                          for (
                            var r = function (n) {
                                a = a.then(function (r) {
                                  if (!c || !f[n] || c(f[n], n, f)) {
                                    var i = e ? m[n] : g(t.options, r);
                                    return w(r, e, i);
                                  }
                                  return Promise.resolve(x(r, m[n], f[n]));
                                });
                              },
                              i = 1;
                            i < f.length;
                            i++
                          )
                            r(i);
                        })();
                    else a = w([]);
                    var C = a.then(function (t) {
                      return { pages: t, pageParams: _ };
                    });
                    return (
                      (C.cancel = function () {
                        (v = !0), (0, l.LE)(a) && a.cancel();
                      }),
                      C
                    );
                  };
                },
              }),
              this.fetchQuery(r)
            );
          }),
          (e.prefetchInfiniteQuery = function (t, e, n) {
            return this.fetchInfiniteQuery(t, e, n).then(i.ZT).catch(i.ZT);
          }),
          (e.cancelMutations = function () {
            var t = this,
              e = s.V.batch(function () {
                return t.mutationCache.getAll().map(function (t) {
                  return t.cancel();
                });
              });
            return Promise.all(e).then(i.ZT).catch(i.ZT);
          }),
          (e.resumePausedMutations = function () {
            return this.getMutationCache().resumePausedMutations();
          }),
          (e.executeMutation = function (t) {
            return this.mutationCache.build(this, t).execute();
          }),
          (e.getQueryCache = function () {
            return this.queryCache;
          }),
          (e.getMutationCache = function () {
            return this.mutationCache;
          }),
          (e.getDefaultOptions = function () {
            return this.defaultOptions;
          }),
          (e.setDefaultOptions = function (t) {
            this.defaultOptions = t;
          }),
          (e.setQueryDefaults = function (t, e) {
            var n = this.queryDefaults.find(function (e) {
              return (0, i.yF)(t) === (0, i.yF)(e.queryKey);
            });
            n
              ? (n.defaultOptions = e)
              : this.queryDefaults.push({ queryKey: t, defaultOptions: e });
          }),
          (e.getQueryDefaults = function (t) {
            var e;
            return t
              ? null ==
                (e = this.queryDefaults.find(function (e) {
                  return (0, i.to)(t, e.queryKey);
                }))
                ? void 0
                : e.defaultOptions
              : void 0;
          }),
          (e.setMutationDefaults = function (t, e) {
            var n = this.mutationDefaults.find(function (e) {
              return (0, i.yF)(t) === (0, i.yF)(e.mutationKey);
            });
            n
              ? (n.defaultOptions = e)
              : this.mutationDefaults.push({
                  mutationKey: t,
                  defaultOptions: e,
                });
          }),
          (e.getMutationDefaults = function (t) {
            var e;
            return t
              ? null ==
                (e = this.mutationDefaults.find(function (e) {
                  return (0, i.to)(t, e.mutationKey);
                }))
                ? void 0
                : e.defaultOptions
              : void 0;
          }),
          (e.defaultQueryOptions = function (t) {
            if (null == t ? void 0 : t._defaulted) return t;
            var e = (0, r.Z)(
              {},
              this.defaultOptions.queries,
              this.getQueryDefaults(null == t ? void 0 : t.queryKey),
              t,
              { _defaulted: !0 }
            );
            return (
              !e.queryHash &&
                e.queryKey &&
                (e.queryHash = (0, i.Rm)(e.queryKey, e)),
              e
            );
          }),
          (e.defaultQueryObserverOptions = function (t) {
            return this.defaultQueryOptions(t);
          }),
          (e.defaultMutationOptions = function (t) {
            return (null == t ? void 0 : t._defaulted)
              ? t
              : (0, r.Z)(
                  {},
                  this.defaultOptions.mutations,
                  this.getMutationDefaults(null == t ? void 0 : t.mutationKey),
                  t,
                  { _defaulted: !0 }
                );
          }),
          (e.clear = function () {
            this.queryCache.clear(), this.mutationCache.clear();
          }),
          t
        );
      })();
    },
    21216: function (t, e, n) {
      "use strict";
      n.d(e, {
        DV: function () {
          return c;
        },
        LE: function () {
          return a;
        },
        m4: function () {
          return u;
        },
      });
      var r = n(59852),
        i = n(40068),
        o = n(52288);
      function s(t) {
        return Math.min(1e3 * Math.pow(2, t), 3e4);
      }
      function a(t) {
        return "function" === typeof (null == t ? void 0 : t.cancel);
      }
      var l = function (t) {
        (this.revert = null == t ? void 0 : t.revert),
          (this.silent = null == t ? void 0 : t.silent);
      };
      function c(t) {
        return t instanceof l;
      }
      var u = function (t) {
        var e,
          n,
          c,
          u,
          h = this,
          p = !1;
        (this.cancel = function (t) {
          return null == e ? void 0 : e(t);
        }),
          (this.cancelRetry = function () {
            p = !0;
          }),
          (this.continue = function () {
            return null == n ? void 0 : n();
          }),
          (this.failureCount = 0),
          (this.isPaused = !1),
          (this.isResolved = !1),
          (this.isTransportCancelable = !1),
          (this.promise = new Promise(function (t, e) {
            (c = t), (u = e);
          }));
        var d = function (e) {
            h.isResolved ||
              ((h.isResolved = !0),
              null == t.onSuccess || t.onSuccess(e),
              null == n || n(),
              c(e));
          },
          f = function (e) {
            h.isResolved ||
              ((h.isResolved = !0),
              null == t.onError || t.onError(e),
              null == n || n(),
              u(e));
          };
        !(function c() {
          if (!h.isResolved) {
            var u;
            try {
              u = t.fn();
            } catch (m) {
              u = Promise.reject(m);
            }
            (e = function (t) {
              if (!h.isResolved && (f(new l(t)), a(u)))
                try {
                  u.cancel();
                } catch (e) {}
            }),
              (h.isTransportCancelable = a(u)),
              Promise.resolve(u)
                .then(d)
                .catch(function (e) {
                  var a, l;
                  if (!h.isResolved) {
                    var u = null != (a = t.retry) ? a : 3,
                      d = null != (l = t.retryDelay) ? l : s,
                      m = "function" === typeof d ? d(h.failureCount, e) : d,
                      g =
                        !0 === u ||
                        ("number" === typeof u && h.failureCount < u) ||
                        ("function" === typeof u && u(h.failureCount, e));
                    !p && g
                      ? (h.failureCount++,
                        null == t.onFail || t.onFail(h.failureCount, e),
                        (0, o.Gh)(m)
                          .then(function () {
                            if (!r.j.isFocused() || !i.N.isOnline())
                              return new Promise(function (e) {
                                (n = e),
                                  (h.isPaused = !0),
                                  null == t.onPause || t.onPause();
                              }).then(function () {
                                (n = void 0),
                                  (h.isPaused = !1),
                                  null == t.onContinue || t.onContinue();
                              });
                          })
                          .then(function () {
                            p ? f(e) : c();
                          }))
                      : f(e);
                  }
                });
          }
        })();
      };
    },
    52943: function (t, e, n) {
      "use strict";
      n.d(e, {
        l: function () {
          return r;
        },
      });
      var r = (function () {
        function t() {
          this.listeners = [];
        }
        var e = t.prototype;
        return (
          (e.subscribe = function (t) {
            var e = this,
              n = t || function () {};
            return (
              this.listeners.push(n),
              this.onSubscribe(),
              function () {
                (e.listeners = e.listeners.filter(function (t) {
                  return t !== n;
                })),
                  e.onUnsubscribe();
              }
            );
          }),
          (e.hasListeners = function () {
            return this.listeners.length > 0;
          }),
          (e.onSubscribe = function () {}),
          (e.onUnsubscribe = function () {}),
          t
        );
      })();
    },
    86755: function () {},
    52288: function (t, e, n) {
      "use strict";
      n.d(e, {
        A4: function () {
          return T;
        },
        Gh: function () {
          return E;
        },
        I6: function () {
          return p;
        },
        Kp: function () {
          return c;
        },
        PN: function () {
          return a;
        },
        Q$: function () {
          return v;
        },
        Rm: function () {
          return m;
        },
        SE: function () {
          return s;
        },
        VS: function () {
          return b;
        },
        X7: function () {
          return f;
        },
        ZT: function () {
          return o;
        },
        _v: function () {
          return u;
        },
        _x: function () {
          return d;
        },
        lV: function () {
          return h;
        },
        mc: function () {
          return l;
        },
        sk: function () {
          return i;
        },
        to: function () {
          return y;
        },
        yF: function () {
          return g;
        },
      });
      var r = n(87462),
        i = "undefined" === typeof window;
      function o() {}
      function s(t, e) {
        return "function" === typeof t ? t(e) : t;
      }
      function a(t) {
        return "number" === typeof t && t >= 0 && t !== 1 / 0;
      }
      function l(t) {
        return Array.isArray(t) ? t : [t];
      }
      function c(t, e) {
        return Math.max(t + (e || 0) - Date.now(), 0);
      }
      function u(t, e, n) {
        return S(t)
          ? "function" === typeof e
            ? (0, r.Z)({}, n, { queryKey: t, queryFn: e })
            : (0, r.Z)({}, e, { queryKey: t })
          : t;
      }
      function h(t, e, n) {
        return S(t)
          ? "function" === typeof e
            ? (0, r.Z)({}, n, { mutationKey: t, mutationFn: e })
            : (0, r.Z)({}, e, { mutationKey: t })
          : "function" === typeof t
          ? (0, r.Z)({}, e, { mutationFn: t })
          : (0, r.Z)({}, t);
      }
      function p(t, e, n) {
        return S(t) ? [(0, r.Z)({}, e, { queryKey: t }), n] : [t || {}, e];
      }
      function d(t, e) {
        var n = t.active,
          r = t.exact,
          i = t.fetching,
          o = t.inactive,
          s = t.predicate,
          a = t.queryKey,
          l = t.stale;
        if (S(a))
          if (r) {
            if (e.queryHash !== m(a, e.options)) return !1;
          } else if (!y(e.queryKey, a)) return !1;
        var c = (function (t, e) {
          return (!0 === t && !0 === e) || (null == t && null == e)
            ? "all"
            : !1 === t && !1 === e
            ? "none"
            : (null != t ? t : !e)
            ? "active"
            : "inactive";
        })(n, o);
        if ("none" === c) return !1;
        if ("all" !== c) {
          var u = e.isActive();
          if ("active" === c && !u) return !1;
          if ("inactive" === c && u) return !1;
        }
        return (
          ("boolean" !== typeof l || e.isStale() === l) &&
          ("boolean" !== typeof i || e.isFetching() === i) &&
          !(s && !s(e))
        );
      }
      function f(t, e) {
        var n = t.exact,
          r = t.fetching,
          i = t.predicate,
          o = t.mutationKey;
        if (S(o)) {
          if (!e.options.mutationKey) return !1;
          if (n) {
            if (g(e.options.mutationKey) !== g(o)) return !1;
          } else if (!y(e.options.mutationKey, o)) return !1;
        }
        return (
          ("boolean" !== typeof r || ("loading" === e.state.status) === r) &&
          !(i && !i(e))
        );
      }
      function m(t, e) {
        return ((null == e ? void 0 : e.queryKeyHashFn) || g)(t);
      }
      function g(t) {
        var e,
          n = l(t);
        return (
          (e = n),
          JSON.stringify(e, function (t, e) {
            return x(e)
              ? Object.keys(e)
                  .sort()
                  .reduce(function (t, n) {
                    return (t[n] = e[n]), t;
                  }, {})
              : e;
          })
        );
      }
      function y(t, e) {
        return _(l(t), l(e));
      }
      function _(t, e) {
        return (
          t === e ||
          (typeof t === typeof e &&
            !(!t || !e || "object" !== typeof t || "object" !== typeof e) &&
            !Object.keys(e).some(function (n) {
              return !_(t[n], e[n]);
            }))
        );
      }
      function v(t, e) {
        if (t === e) return t;
        var n = Array.isArray(t) && Array.isArray(e);
        if (n || (x(t) && x(e))) {
          for (
            var r = n ? t.length : Object.keys(t).length,
              i = n ? e : Object.keys(e),
              o = i.length,
              s = n ? [] : {},
              a = 0,
              l = 0;
            l < o;
            l++
          ) {
            var c = n ? l : i[l];
            (s[c] = v(t[c], e[c])), s[c] === t[c] && a++;
          }
          return r === o && a === r ? t : s;
        }
        return e;
      }
      function b(t, e) {
        if ((t && !e) || (e && !t)) return !1;
        for (var n in t) if (t[n] !== e[n]) return !1;
        return !0;
      }
      function x(t) {
        if (!w(t)) return !1;
        var e = t.constructor;
        if ("undefined" === typeof e) return !0;
        var n = e.prototype;
        return !!w(n) && !!n.hasOwnProperty("isPrototypeOf");
      }
      function w(t) {
        return "[object Object]" === Object.prototype.toString.call(t);
      }
      function S(t) {
        return "string" === typeof t || Array.isArray(t);
      }
      function E(t) {
        return new Promise(function (e) {
          setTimeout(e, t);
        });
      }
      function T(t) {
        Promise.resolve()
          .then(t)
          .catch(function (t) {
            return setTimeout(function () {
              throw t;
            });
          });
      }
    },
    88767: function (t, e, n) {
      "use strict";
      n.d(e, {
        Hydrate: function () {
          return i.Hydrate;
        },
        QueryClient: function () {
          return r.QueryClient;
        },
        QueryClientProvider: function () {
          return i.QueryClientProvider;
        },
        useMutation: function () {
          return i.useMutation;
        },
        useQuery: function () {
          return i.useQuery;
        },
        useQueryClient: function () {
          return i.useQueryClient;
        },
      });
      var r = n(46747);
      n.o(r, "Hydrate") &&
        n.d(e, {
          Hydrate: function () {
            return r.Hydrate;
          },
        }),
        n.o(r, "QueryClientProvider") &&
          n.d(e, {
            QueryClientProvider: function () {
              return r.QueryClientProvider;
            },
          }),
        n.o(r, "useMutation") &&
          n.d(e, {
            useMutation: function () {
              return r.useMutation;
            },
          }),
        n.o(r, "useQuery") &&
          n.d(e, {
            useQuery: function () {
              return r.useQuery;
            },
          }),
        n.o(r, "useQueryClient") &&
          n.d(e, {
            useQueryClient: function () {
              return r.useQueryClient;
            },
          });
      var i = n(24830);
    },
    24830: function (t, e, n) {
      "use strict";
      n.d(e, {
        Hydrate: function () {
          return I;
        },
        QueryClientProvider: function () {
          return p;
        },
        useMutation: function () {
          return b;
        },
        useQuery: function () {
          return O;
        },
        useQueryClient: function () {
          return h;
        },
      });
      var r = n(101),
        i = n(73935).unstable_batchedUpdates;
      r.V.setBatchNotifyFunction(i);
      var o = n(41909),
        s = console;
      s && (0, o.E)(s);
      var a = n(67294),
        l = a.createContext(void 0),
        c = a.createContext(!1);
      function u(t) {
        return t && "undefined" !== typeof window
          ? (window.ReactQueryClientContext ||
              (window.ReactQueryClientContext = l),
            window.ReactQueryClientContext)
          : l;
      }
      var h = function () {
          var t = a.useContext(u(a.useContext(c)));
          if (!t)
            throw new Error(
              "No QueryClient set, use QueryClientProvider to set one"
            );
          return t;
        },
        p = function (t) {
          var e = t.client,
            n = t.contextSharing,
            r = void 0 !== n && n,
            i = t.children;
          a.useEffect(
            function () {
              return (
                e.mount(),
                function () {
                  e.unmount();
                }
              );
            },
            [e]
          );
          var o = u(r);
          return a.createElement(
            c.Provider,
            { value: r },
            a.createElement(o.Provider, { value: e }, i)
          );
        },
        d = n(87462),
        f = n(52288),
        m = n(94578),
        g = n(81262),
        y = n(52943),
        _ = (function (t) {
          function e(e, n) {
            var r;
            return (
              ((r = t.call(this) || this).client = e),
              r.setOptions(n),
              r.bindMethods(),
              r.updateResult(),
              r
            );
          }
          (0, m.Z)(e, t);
          var n = e.prototype;
          return (
            (n.bindMethods = function () {
              (this.mutate = this.mutate.bind(this)),
                (this.reset = this.reset.bind(this));
            }),
            (n.setOptions = function (t) {
              this.options = this.client.defaultMutationOptions(t);
            }),
            (n.onUnsubscribe = function () {
              var t;
              this.listeners.length ||
                null == (t = this.currentMutation) ||
                t.removeObserver(this);
            }),
            (n.onMutationUpdate = function (t) {
              this.updateResult();
              var e = { listeners: !0 };
              "success" === t.type
                ? (e.onSuccess = !0)
                : "error" === t.type && (e.onError = !0),
                this.notify(e);
            }),
            (n.getCurrentResult = function () {
              return this.currentResult;
            }),
            (n.reset = function () {
              (this.currentMutation = void 0),
                this.updateResult(),
                this.notify({ listeners: !0 });
            }),
            (n.mutate = function (t, e) {
              return (
                (this.mutateOptions = e),
                this.currentMutation &&
                  this.currentMutation.removeObserver(this),
                (this.currentMutation = this.client
                  .getMutationCache()
                  .build(
                    this.client,
                    (0, d.Z)({}, this.options, {
                      variables:
                        "undefined" !== typeof t ? t : this.options.variables,
                    })
                  )),
                this.currentMutation.addObserver(this),
                this.currentMutation.execute()
              );
            }),
            (n.updateResult = function () {
              var t = this.currentMutation
                  ? this.currentMutation.state
                  : (0, g.R)(),
                e = (0, d.Z)({}, t, {
                  isLoading: "loading" === t.status,
                  isSuccess: "success" === t.status,
                  isError: "error" === t.status,
                  isIdle: "idle" === t.status,
                  mutate: this.mutate,
                  reset: this.reset,
                });
              this.currentResult = e;
            }),
            (n.notify = function (t) {
              var e = this;
              r.V.batch(function () {
                e.mutateOptions &&
                  (t.onSuccess
                    ? (null == e.mutateOptions.onSuccess ||
                        e.mutateOptions.onSuccess(
                          e.currentResult.data,
                          e.currentResult.variables,
                          e.currentResult.context
                        ),
                      null == e.mutateOptions.onSettled ||
                        e.mutateOptions.onSettled(
                          e.currentResult.data,
                          null,
                          e.currentResult.variables,
                          e.currentResult.context
                        ))
                    : t.onError &&
                      (null == e.mutateOptions.onError ||
                        e.mutateOptions.onError(
                          e.currentResult.error,
                          e.currentResult.variables,
                          e.currentResult.context
                        ),
                      null == e.mutateOptions.onSettled ||
                        e.mutateOptions.onSettled(
                          void 0,
                          e.currentResult.error,
                          e.currentResult.variables,
                          e.currentResult.context
                        ))),
                  t.listeners &&
                    e.listeners.forEach(function (t) {
                      t(e.currentResult);
                    });
              });
            }),
            e
          );
        })(y.l);
      function v(t, e, n) {
        return "function" === typeof e
          ? e(n)
          : "boolean" === typeof e
          ? e
          : !!t;
      }
      function b(t, e, n) {
        var i = a.useRef(!1),
          o = a.useState(0)[1],
          s = (0, f.lV)(t, e, n),
          l = h(),
          c = a.useRef();
        c.current ? c.current.setOptions(s) : (c.current = new _(l, s));
        var u = c.current.getCurrentResult();
        a.useEffect(function () {
          i.current = !0;
          var t = c.current.subscribe(
            r.V.batchCalls(function () {
              i.current &&
                o(function (t) {
                  return t + 1;
                });
            })
          );
          return function () {
            (i.current = !1), t();
          };
        }, []);
        var p = a.useCallback(function (t, e) {
          c.current.mutate(t, e).catch(f.ZT);
        }, []);
        if (u.error && v(void 0, c.current.options.useErrorBoundary, u.error))
          throw u.error;
        return (0, d.Z)({}, u, { mutate: p, mutateAsync: u.mutate });
      }
      var x = n(59852),
        w = n(21216),
        S = (function (t) {
          function e(e, n) {
            var r;
            return (
              ((r = t.call(this) || this).client = e),
              (r.options = n),
              (r.trackedProps = []),
              (r.previousSelectError = null),
              r.bindMethods(),
              r.setOptions(n),
              r
            );
          }
          (0, m.Z)(e, t);
          var n = e.prototype;
          return (
            (n.bindMethods = function () {
              (this.remove = this.remove.bind(this)),
                (this.refetch = this.refetch.bind(this));
            }),
            (n.onSubscribe = function () {
              1 === this.listeners.length &&
                (this.currentQuery.addObserver(this),
                E(this.currentQuery, this.options) && this.executeFetch(),
                this.updateTimers());
            }),
            (n.onUnsubscribe = function () {
              this.listeners.length || this.destroy();
            }),
            (n.shouldFetchOnReconnect = function () {
              return (
                (t = this.currentQuery),
                !1 !== (e = this.options).enabled &&
                  ("always" === e.refetchOnReconnect ||
                    (!1 !== e.refetchOnReconnect && A(t, e)))
              );
              var t, e;
            }),
            (n.shouldFetchOnWindowFocus = function () {
              return (
                (t = this.currentQuery),
                !1 !== (e = this.options).enabled &&
                  ("always" === e.refetchOnWindowFocus ||
                    (!1 !== e.refetchOnWindowFocus && A(t, e)))
              );
              var t, e;
            }),
            (n.destroy = function () {
              (this.listeners = []),
                this.clearTimers(),
                this.currentQuery.removeObserver(this);
            }),
            (n.setOptions = function (t, e) {
              var n = this.options,
                r = this.currentQuery;
              if (
                ((this.options = this.client.defaultQueryObserverOptions(t)),
                "undefined" !== typeof this.options.enabled &&
                  "boolean" !== typeof this.options.enabled)
              )
                throw new Error("Expected enabled to be a boolean");
              this.options.queryKey || (this.options.queryKey = n.queryKey),
                this.updateQuery();
              var i = this.hasListeners();
              i &&
                T(this.currentQuery, r, this.options, n) &&
                this.executeFetch(),
                this.updateResult(e),
                !i ||
                  (this.currentQuery === r &&
                    this.options.enabled === n.enabled &&
                    this.options.staleTime === n.staleTime) ||
                  this.updateStaleTimeout(),
                !i ||
                  (this.currentQuery === r &&
                    this.options.enabled === n.enabled &&
                    this.options.refetchInterval === n.refetchInterval) ||
                  this.updateRefetchInterval();
            }),
            (n.getOptimisticResult = function (t) {
              var e = this.client.defaultQueryObserverOptions(t),
                n = this.client.getQueryCache().build(this.client, e);
              return this.createResult(n, e);
            }),
            (n.getCurrentResult = function () {
              return this.currentResult;
            }),
            (n.trackResult = function (t) {
              var e = this,
                n = {};
              return (
                Object.keys(t).forEach(function (r) {
                  Object.defineProperty(n, r, {
                    configurable: !1,
                    enumerable: !0,
                    get: function () {
                      var n = r;
                      return (
                        e.trackedProps.includes(n) || e.trackedProps.push(n),
                        t[n]
                      );
                    },
                  });
                }),
                n
              );
            }),
            (n.getNextResult = function (t) {
              var e = this;
              return new Promise(function (n, r) {
                var i = e.subscribe(function (e) {
                  e.isFetching ||
                    (i(),
                    e.isError && (null == t ? void 0 : t.throwOnError)
                      ? r(e.error)
                      : n(e));
                });
              });
            }),
            (n.getCurrentQuery = function () {
              return this.currentQuery;
            }),
            (n.remove = function () {
              this.client.getQueryCache().remove(this.currentQuery);
            }),
            (n.refetch = function (t) {
              return this.fetch(
                (0, d.Z)({}, t, {
                  meta: { refetchPage: null == t ? void 0 : t.refetchPage },
                })
              );
            }),
            (n.fetchOptimistic = function (t) {
              var e = this,
                n = this.client.defaultQueryObserverOptions(t),
                r = this.client.getQueryCache().build(this.client, n);
              return r.fetch().then(function () {
                return e.createResult(r, n);
              });
            }),
            (n.fetch = function (t) {
              var e = this;
              return this.executeFetch(t).then(function () {
                return e.updateResult(), e.currentResult;
              });
            }),
            (n.executeFetch = function (t) {
              this.updateQuery();
              var e = this.currentQuery.fetch(this.options, t);
              return (
                (null == t ? void 0 : t.throwOnError) || (e = e.catch(f.ZT)), e
              );
            }),
            (n.updateStaleTimeout = function () {
              var t = this;
              if (
                (this.clearStaleTimeout(),
                !f.sk &&
                  !this.currentResult.isStale &&
                  (0, f.PN)(this.options.staleTime))
              ) {
                var e =
                  (0, f.Kp)(
                    this.currentResult.dataUpdatedAt,
                    this.options.staleTime
                  ) + 1;
                this.staleTimeoutId = setTimeout(function () {
                  t.currentResult.isStale || t.updateResult();
                }, e);
              }
            }),
            (n.updateRefetchInterval = function () {
              var t = this;
              this.clearRefetchInterval(),
                !f.sk &&
                  !1 !== this.options.enabled &&
                  (0, f.PN)(this.options.refetchInterval) &&
                  (this.refetchIntervalId = setInterval(function () {
                    (t.options.refetchIntervalInBackground ||
                      x.j.isFocused()) &&
                      t.executeFetch();
                  }, this.options.refetchInterval));
            }),
            (n.updateTimers = function () {
              this.updateStaleTimeout(), this.updateRefetchInterval();
            }),
            (n.clearTimers = function () {
              this.clearStaleTimeout(), this.clearRefetchInterval();
            }),
            (n.clearStaleTimeout = function () {
              clearTimeout(this.staleTimeoutId), (this.staleTimeoutId = void 0);
            }),
            (n.clearRefetchInterval = function () {
              clearInterval(this.refetchIntervalId),
                (this.refetchIntervalId = void 0);
            }),
            (n.createResult = function (t, e) {
              var n,
                r = this.currentQuery,
                i = this.options,
                s = this.currentResult,
                a = this.currentResultState,
                l = this.currentResultOptions,
                c = t !== r,
                u = c ? t.state : this.currentQueryInitialState,
                h = c ? this.currentResult : this.previousQueryResult,
                p = t.state,
                d = p.dataUpdatedAt,
                m = p.error,
                g = p.errorUpdatedAt,
                y = p.isFetching,
                _ = p.status,
                v = !1,
                b = !1;
              if (e.optimisticResults) {
                var x = this.hasListeners(),
                  w = !x && E(t, e),
                  S = x && T(t, r, e, i);
                (w || S) && ((y = !0), d || (_ = "loading"));
              }
              if (
                e.keepPreviousData &&
                !p.dataUpdateCount &&
                (null == h ? void 0 : h.isSuccess) &&
                "error" !== _
              )
                (n = h.data), (d = h.dataUpdatedAt), (_ = h.status), (v = !0);
              else if (e.select && "undefined" !== typeof p.data)
                if (
                  s &&
                  p.data === (null == a ? void 0 : a.data) &&
                  e.select === (null == l ? void 0 : l.select) &&
                  !this.previousSelectError
                )
                  n = s.data;
                else
                  try {
                    (n = e.select(p.data)),
                      !1 !== e.structuralSharing &&
                        (n = (0, f.Q$)(null == s ? void 0 : s.data, n)),
                      (this.previousSelectError = null);
                  } catch (P) {
                    (0, o.j)().error(P),
                      (m = P),
                      (this.previousSelectError = P),
                      (g = Date.now()),
                      (_ = "error");
                  }
              else n = p.data;
              if (
                "undefined" !== typeof e.placeholderData &&
                "undefined" === typeof n &&
                ("loading" === _ || "idle" === _)
              ) {
                var C;
                if (
                  (null == s ? void 0 : s.isPlaceholderData) &&
                  e.placeholderData === (null == l ? void 0 : l.placeholderData)
                )
                  C = s.data;
                else if (
                  ((C =
                    "function" === typeof e.placeholderData
                      ? e.placeholderData()
                      : e.placeholderData),
                  e.select && "undefined" !== typeof C)
                )
                  try {
                    (C = e.select(C)),
                      !1 !== e.structuralSharing &&
                        (C = (0, f.Q$)(null == s ? void 0 : s.data, C)),
                      (this.previousSelectError = null);
                  } catch (P) {
                    (0, o.j)().error(P),
                      (m = P),
                      (this.previousSelectError = P),
                      (g = Date.now()),
                      (_ = "error");
                  }
                "undefined" !== typeof C &&
                  ((_ = "success"), (n = C), (b = !0));
              }
              return {
                status: _,
                isLoading: "loading" === _,
                isSuccess: "success" === _,
                isError: "error" === _,
                isIdle: "idle" === _,
                data: n,
                dataUpdatedAt: d,
                error: m,
                errorUpdatedAt: g,
                failureCount: p.fetchFailureCount,
                isFetched: p.dataUpdateCount > 0 || p.errorUpdateCount > 0,
                isFetchedAfterMount:
                  p.dataUpdateCount > u.dataUpdateCount ||
                  p.errorUpdateCount > u.errorUpdateCount,
                isFetching: y,
                isRefetching: y && "loading" !== _,
                isLoadingError: "error" === _ && 0 === p.dataUpdatedAt,
                isPlaceholderData: b,
                isPreviousData: v,
                isRefetchError: "error" === _ && 0 !== p.dataUpdatedAt,
                isStale: A(t, e),
                refetch: this.refetch,
                remove: this.remove,
              };
            }),
            (n.shouldNotifyListeners = function (t, e) {
              if (!e) return !0;
              if (t === e) return !1;
              var n = this.options,
                r = n.notifyOnChangeProps,
                i = n.notifyOnChangePropsExclusions;
              if (!r && !i) return !0;
              if ("tracked" === r && !this.trackedProps.length) return !0;
              var o = "tracked" === r ? this.trackedProps : r;
              return Object.keys(t).some(function (n) {
                var r = n,
                  s = t[r] !== e[r],
                  a =
                    null == o
                      ? void 0
                      : o.some(function (t) {
                          return t === n;
                        }),
                  l =
                    null == i
                      ? void 0
                      : i.some(function (t) {
                          return t === n;
                        });
                return s && !l && (!o || a);
              });
            }),
            (n.updateResult = function (t) {
              var e = this.currentResult;
              if (
                ((this.currentResult = this.createResult(
                  this.currentQuery,
                  this.options
                )),
                (this.currentResultState = this.currentQuery.state),
                (this.currentResultOptions = this.options),
                !(0, f.VS)(this.currentResult, e))
              ) {
                var n = { cache: !0 };
                !1 !== (null == t ? void 0 : t.listeners) &&
                  this.shouldNotifyListeners(this.currentResult, e) &&
                  (n.listeners = !0),
                  this.notify((0, d.Z)({}, n, t));
              }
            }),
            (n.updateQuery = function () {
              var t = this.client
                .getQueryCache()
                .build(this.client, this.options);
              if (t !== this.currentQuery) {
                var e = this.currentQuery;
                (this.currentQuery = t),
                  (this.currentQueryInitialState = t.state),
                  (this.previousQueryResult = this.currentResult),
                  this.hasListeners() &&
                    (null == e || e.removeObserver(this), t.addObserver(this));
              }
            }),
            (n.onQueryUpdate = function (t) {
              var e = {};
              "success" === t.type
                ? (e.onSuccess = !0)
                : "error" !== t.type || (0, w.DV)(t.error) || (e.onError = !0),
                this.updateResult(e),
                this.hasListeners() && this.updateTimers();
            }),
            (n.notify = function (t) {
              var e = this;
              r.V.batch(function () {
                t.onSuccess
                  ? (null == e.options.onSuccess ||
                      e.options.onSuccess(e.currentResult.data),
                    null == e.options.onSettled ||
                      e.options.onSettled(e.currentResult.data, null))
                  : t.onError &&
                    (null == e.options.onError ||
                      e.options.onError(e.currentResult.error),
                    null == e.options.onSettled ||
                      e.options.onSettled(void 0, e.currentResult.error)),
                  t.listeners &&
                    e.listeners.forEach(function (t) {
                      t(e.currentResult);
                    }),
                  t.cache &&
                    e.client
                      .getQueryCache()
                      .notify({
                        query: e.currentQuery,
                        type: "observerResultsUpdated",
                      });
              });
            }),
            e
          );
        })(y.l);
      function E(t, e) {
        return (
          (function (t, e) {
            return (
              !1 !== e.enabled &&
              !t.state.dataUpdatedAt &&
              !("error" === t.state.status && !1 === e.retryOnMount)
            );
          })(t, e) ||
          (function (t, e) {
            return (
              !1 !== e.enabled &&
              t.state.dataUpdatedAt > 0 &&
              ("always" === e.refetchOnMount ||
                (!1 !== e.refetchOnMount && A(t, e)))
            );
          })(t, e)
        );
      }
      function T(t, e, n, r) {
        return (
          !1 !== n.enabled &&
          (t !== e || !1 === r.enabled) &&
          (!n.suspense || "error" !== t.state.status || !1 === r.enabled) &&
          A(t, n)
        );
      }
      function A(t, e) {
        return t.isStaleByTime(e.staleTime);
      }
      function C() {
        var t = !1;
        return {
          clearReset: function () {
            t = !1;
          },
          reset: function () {
            t = !0;
          },
          isReset: function () {
            return t;
          },
        };
      }
      var P = a.createContext(C());
      function M(t, e) {
        var n = a.useRef(!1),
          i = a.useState(0)[1],
          o = h(),
          s = a.useContext(P),
          l = o.defaultQueryObserverOptions(t);
        (l.optimisticResults = !0),
          l.onError && (l.onError = r.V.batchCalls(l.onError)),
          l.onSuccess && (l.onSuccess = r.V.batchCalls(l.onSuccess)),
          l.onSettled && (l.onSettled = r.V.batchCalls(l.onSettled)),
          l.suspense && "number" !== typeof l.staleTime && (l.staleTime = 1e3),
          (l.suspense || l.useErrorBoundary) &&
            (s.isReset() || (l.retryOnMount = !1));
        var c = a.useState(function () {
            return new e(o, l);
          })[0],
          u = c.getOptimisticResult(l);
        if (
          (a.useEffect(
            function () {
              (n.current = !0), s.clearReset();
              var t = c.subscribe(
                r.V.batchCalls(function () {
                  n.current &&
                    i(function (t) {
                      return t + 1;
                    });
                })
              );
              return (
                c.updateResult(),
                function () {
                  (n.current = !1), t();
                }
              );
            },
            [s, c]
          ),
          a.useEffect(
            function () {
              c.setOptions(l, { listeners: !1 });
            },
            [l, c]
          ),
          l.suspense && u.isLoading)
        )
          throw c
            .fetchOptimistic(l)
            .then(function (t) {
              var e = t.data;
              null == l.onSuccess || l.onSuccess(e),
                null == l.onSettled || l.onSettled(e, null);
            })
            .catch(function (t) {
              s.clearReset(),
                null == l.onError || l.onError(t),
                null == l.onSettled || l.onSettled(void 0, t);
            });
        if (
          u.isError &&
          !u.isFetching &&
          v(l.suspense, l.useErrorBoundary, u.error)
        )
          throw u.error;
        return "tracked" === l.notifyOnChangeProps && (u = c.trackResult(u)), u;
      }
      function O(t, e, n) {
        return M((0, f._v)(t, e, n), S);
      }
      function k(t, e) {
        var n = h(),
          r = a.useRef(e);
        (r.current = e),
          a.useMemo(
            function () {
              t &&
                (function (t, e, n) {
                  if ("object" === typeof e && null !== e) {
                    var r = t.getMutationCache(),
                      i = t.getQueryCache(),
                      o = e.mutations || [],
                      s = e.queries || [];
                    o.forEach(function (e) {
                      var i;
                      r.build(
                        t,
                        (0, d.Z)(
                          {},
                          null == n || null == (i = n.defaultOptions)
                            ? void 0
                            : i.mutations,
                          { mutationKey: e.mutationKey }
                        ),
                        e.state
                      );
                    }),
                      s.forEach(function (e) {
                        var r,
                          o = i.get(e.queryHash);
                        o
                          ? o.state.dataUpdatedAt < e.state.dataUpdatedAt &&
                            o.setState(e.state)
                          : i.build(
                              t,
                              (0, d.Z)(
                                {},
                                null == n || null == (r = n.defaultOptions)
                                  ? void 0
                                  : r.queries,
                                { queryKey: e.queryKey, queryHash: e.queryHash }
                              ),
                              e.state
                            );
                      });
                  }
                })(n, t, r.current);
            },
            [n, t]
          );
      }
      var I = function (t) {
        var e = t.children,
          n = t.options;
        return k(t.state, n), e;
      };
    },
    25617: function (t, e, n) {
      "use strict";
      n.d(e, {
        zt: function () {
          return u;
        },
        I0: function () {
          return m;
        },
        v9: function () {
          return v;
        },
      });
      var r = n(67294),
        i = (n(45697), r.createContext(null));
      var o = function (t) {
          t();
        },
        s = function () {
          return o;
        };
      var a = {
        notify: function () {},
        get: function () {
          return [];
        },
      };
      function l(t, e) {
        var n,
          r = a;
        function i() {
          l.onStateChange && l.onStateChange();
        }
        function o() {
          n ||
            ((n = e ? e.addNestedSub(i) : t.subscribe(i)),
            (r = (function () {
              var t = s(),
                e = null,
                n = null;
              return {
                clear: function () {
                  (e = null), (n = null);
                },
                notify: function () {
                  t(function () {
                    for (var t = e; t; ) t.callback(), (t = t.next);
                  });
                },
                get: function () {
                  for (var t = [], n = e; n; ) t.push(n), (n = n.next);
                  return t;
                },
                subscribe: function (t) {
                  var r = !0,
                    i = (n = { callback: t, next: null, prev: n });
                  return (
                    i.prev ? (i.prev.next = i) : (e = i),
                    function () {
                      r &&
                        null !== e &&
                        ((r = !1),
                        i.next ? (i.next.prev = i.prev) : (n = i.prev),
                        i.prev ? (i.prev.next = i.next) : (e = i.next));
                    }
                  );
                },
              };
            })()));
        }
        var l = {
          addNestedSub: function (t) {
            return o(), r.subscribe(t);
          },
          notifyNestedSubs: function () {
            r.notify();
          },
          handleChangeWrapper: i,
          isSubscribed: function () {
            return Boolean(n);
          },
          trySubscribe: o,
          tryUnsubscribe: function () {
            n && (n(), (n = void 0), r.clear(), (r = a));
          },
          getListeners: function () {
            return r;
          },
        };
        return l;
      }
      var c =
        "undefined" !== typeof window &&
        "undefined" !== typeof window.document &&
        "undefined" !== typeof window.document.createElement
          ? r.useLayoutEffect
          : r.useEffect;
      var u = function (t) {
        var e = t.store,
          n = t.context,
          o = t.children,
          s = (0, r.useMemo)(
            function () {
              var t = l(e);
              return (
                (t.onStateChange = t.notifyNestedSubs),
                { store: e, subscription: t }
              );
            },
            [e]
          ),
          a = (0, r.useMemo)(
            function () {
              return e.getState();
            },
            [e]
          );
        c(
          function () {
            var t = s.subscription;
            return (
              t.trySubscribe(),
              a !== e.getState() && t.notifyNestedSubs(),
              function () {
                t.tryUnsubscribe(), (t.onStateChange = null);
              }
            );
          },
          [s, a]
        );
        var u = n || i;
        return r.createElement(u.Provider, { value: s }, o);
      };
      n(8679), n(59864);
      n(87462);
      function h() {
        return (0, r.useContext)(i);
      }
      function p(t) {
        void 0 === t && (t = i);
        var e =
          t === i
            ? h
            : function () {
                return (0, r.useContext)(t);
              };
        return function () {
          return e().store;
        };
      }
      var d = p();
      function f(t) {
        void 0 === t && (t = i);
        var e = t === i ? d : p(t);
        return function () {
          return e().dispatch;
        };
      }
      var m = f(),
        g = function (t, e) {
          return t === e;
        };
      function y(t) {
        void 0 === t && (t = i);
        var e =
          t === i
            ? h
            : function () {
                return (0, r.useContext)(t);
              };
        return function (t, n) {
          void 0 === n && (n = g);
          var i = e(),
            o = (function (t, e, n, i) {
              var o,
                s = (0, r.useReducer)(function (t) {
                  return t + 1;
                }, 0)[1],
                a = (0, r.useMemo)(
                  function () {
                    return l(n, i);
                  },
                  [n, i]
                ),
                u = (0, r.useRef)(),
                h = (0, r.useRef)(),
                p = (0, r.useRef)(),
                d = (0, r.useRef)(),
                f = n.getState();
              try {
                if (t !== h.current || f !== p.current || u.current) {
                  var m = t(f);
                  o = void 0 !== d.current && e(m, d.current) ? d.current : m;
                } else o = d.current;
              } catch (g) {
                throw (
                  (u.current &&
                    (g.message +=
                      "\nThe error may be correlated with this previous error:\n" +
                      u.current.stack +
                      "\n\n"),
                  g)
                );
              }
              return (
                c(function () {
                  (h.current = t),
                    (p.current = f),
                    (d.current = o),
                    (u.current = void 0);
                }),
                c(
                  function () {
                    function t() {
                      try {
                        var t = n.getState();
                        if (t === p.current) return;
                        var r = h.current(t);
                        if (e(r, d.current)) return;
                        (d.current = r), (p.current = t);
                      } catch (g) {
                        u.current = g;
                      }
                      s();
                    }
                    return (
                      (a.onStateChange = t),
                      a.trySubscribe(),
                      t(),
                      function () {
                        return a.tryUnsubscribe();
                      }
                    );
                  },
                  [n, a]
                ),
                o
              );
            })(t, n, i.store, i.subscription);
          return (0, r.useDebugValue)(o), o;
        };
      }
      var _,
        v = y(),
        b = n(73935);
      (_ = b.unstable_batchedUpdates), (o = _);
    },
    40782: function (t, e, n) {
      "use strict";
      n.d(e, {
        Ix: function () {
          return O;
        },
        Am: function () {
          return Z;
        },
      });
      var r = n(67294);
      function i(t) {
        var e,
          n,
          r = "";
        if ("string" === typeof t || "number" === typeof t) r += t;
        else if ("object" === typeof t)
          if (Array.isArray(t))
            for (e = 0; e < t.length; e++)
              t[e] && (n = i(t[e])) && (r && (r += " "), (r += n));
          else for (e in t) t[e] && (r && (r += " "), (r += e));
        return r;
      }
      function o() {
        for (var t, e, n = 0, r = ""; n < arguments.length; )
          (t = arguments[n++]) && (e = i(t)) && (r && (r += " "), (r += e));
        return r;
      }
      var s = n(73935);
      function a() {
        return (
          (a =
            Object.assign ||
            function (t) {
              for (var e = 1; e < arguments.length; e++) {
                var n = arguments[e];
                for (var r in n)
                  Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
              }
              return t;
            }),
          a.apply(this, arguments)
        );
      }
      function l(t) {
        return "number" === typeof t && !isNaN(t);
      }
      function c(t) {
        return "boolean" === typeof t;
      }
      function u(t) {
        return "string" === typeof t;
      }
      function h(t) {
        return "function" === typeof t;
      }
      function p(t) {
        return u(t) || h(t) ? t : null;
      }
      function d(t) {
        return 0 === t || t;
      }
      var f = !(
        "undefined" === typeof window ||
        !window.document ||
        !window.document.createElement
      );
      function m(t) {
        return (0, r.isValidElement)(t) || u(t) || h(t) || l(t);
      }
      var g = {
          TOP_LEFT: "top-left",
          TOP_RIGHT: "top-right",
          TOP_CENTER: "top-center",
          BOTTOM_LEFT: "bottom-left",
          BOTTOM_RIGHT: "bottom-right",
          BOTTOM_CENTER: "bottom-center",
        },
        y = {
          INFO: "info",
          SUCCESS: "success",
          WARNING: "warning",
          ERROR: "error",
          DEFAULT: "default",
          DARK: "dark",
        };
      function _(t) {
        var e = t.enter,
          n = t.exit,
          i = t.appendPosition,
          o = void 0 !== i && i,
          s = t.collapse,
          a = void 0 === s || s,
          l = t.collapseDuration,
          c = void 0 === l ? 300 : l;
        return function (t) {
          var i = t.children,
            s = t.position,
            l = t.preventExitTransition,
            u = t.done,
            h = t.nodeRef,
            p = t.isIn,
            d = o ? e + "--" + s : e,
            f = o ? n + "--" + s : n,
            m = (0, r.useRef)(),
            g = (0, r.useRef)(0);
          function y() {
            var t = h.current;
            t.removeEventListener("animationend", y),
              0 === g.current && (t.className = m.current);
          }
          function _() {
            var t = h.current;
            t.removeEventListener("animationend", _),
              a
                ? (function (t, e, n) {
                    void 0 === n && (n = 300);
                    var r = t.scrollHeight,
                      i = t.style;
                    requestAnimationFrame(function () {
                      (i.minHeight = "initial"),
                        (i.height = r + "px"),
                        (i.transition = "all " + n + "ms"),
                        requestAnimationFrame(function () {
                          (i.height = "0"),
                            (i.padding = "0"),
                            (i.margin = "0"),
                            setTimeout(e, n);
                        });
                    });
                  })(t, u, c)
                : u();
          }
          return (
            (0, r.useLayoutEffect)(function () {
              !(function () {
                var t = h.current;
                (m.current = t.className),
                  (t.className += " " + d),
                  t.addEventListener("animationend", y);
              })();
            }, []),
            (0, r.useEffect)(
              function () {
                p ||
                  (l
                    ? _()
                    : (function () {
                        g.current = 1;
                        var t = h.current;
                        (t.className += " " + f),
                          t.addEventListener("animationend", _);
                      })());
              },
              [p]
            ),
            r.createElement(r.Fragment, null, i)
          );
        };
      }
      var v = {
        list: new Map(),
        emitQueue: new Map(),
        on: function (t, e) {
          return (
            this.list.has(t) || this.list.set(t, []),
            this.list.get(t).push(e),
            this
          );
        },
        off: function (t, e) {
          if (e) {
            var n = this.list.get(t).filter(function (t) {
              return t !== e;
            });
            return this.list.set(t, n), this;
          }
          return this.list.delete(t), this;
        },
        cancelEmit: function (t) {
          var e = this.emitQueue.get(t);
          return e && (e.forEach(clearTimeout), this.emitQueue.delete(t)), this;
        },
        emit: function (t) {
          for (
            var e = this,
              n = arguments.length,
              r = new Array(n > 1 ? n - 1 : 0),
              i = 1;
            i < n;
            i++
          )
            r[i - 1] = arguments[i];
          this.list.has(t) &&
            this.list.get(t).forEach(function (n) {
              var i = setTimeout(function () {
                n.apply(void 0, r);
              }, 0);
              e.emitQueue.has(t) || e.emitQueue.set(t, []),
                e.emitQueue.get(t).push(i);
            });
        },
      };
      function b(t, e) {
        void 0 === e && (e = !1);
        var n = (0, r.useRef)(t);
        return (
          (0, r.useEffect)(function () {
            e && (n.current = t);
          }),
          n.current
        );
      }
      function x(t, e) {
        switch (e.type) {
          case 0:
            return [].concat(t, [e.toastId]).filter(function (t) {
              return t !== e.staleId;
            });
          case 1:
            return d(e.toastId)
              ? t.filter(function (t) {
                  return t !== e.toastId;
                })
              : [];
        }
      }
      function w(t) {
        var e = (0, r.useReducer)(function (t) {
            return t + 1;
          }, 0)[1],
          n = (0, r.useReducer)(x, []),
          i = n[0],
          o = n[1],
          s = (0, r.useRef)(null),
          a = b(0),
          f = b([]),
          g = b({}),
          y = b({
            toastKey: 1,
            displayedToast: 0,
            props: t,
            containerId: null,
            isToastActive: _,
            getToast: function (t) {
              return g[t] || null;
            },
          });
        function _(t) {
          return -1 !== i.indexOf(t);
        }
        function w(t) {
          var e = t.containerId;
          !y.props.limit ||
            (e && y.containerId !== e) ||
            ((a -= f.length), (f = []));
        }
        function S(t) {
          o({ type: 1, toastId: t });
        }
        function E() {
          var t = f.shift();
          A(t.toastContent, t.toastProps, t.staleId);
        }
        function T(t, n) {
          var i = n.delay,
            o = n.staleId,
            _ = (function (t, e) {
              if (null == t) return {};
              var n,
                r,
                i = {},
                o = Object.keys(t);
              for (r = 0; r < o.length; r++)
                (n = o[r]), e.indexOf(n) >= 0 || (i[n] = t[n]);
              return i;
            })(n, ["delay", "staleId"]);
          if (
            m(t) &&
            !(function (t) {
              var e = t.containerId,
                n = t.toastId,
                r = t.updateId;
              return !!(
                !s.current ||
                (y.props.enableMultiContainer && e !== y.props.containerId) ||
                (g[n] && null == r)
              );
            })(_)
          ) {
            var v = _.toastId,
              b = _.updateId,
              x = y.props,
              w = function () {
                return S(v);
              },
              T = null == _.updateId;
            T && a++;
            var C,
              P,
              M = {
                toastId: v,
                updateId: b,
                isIn: !1,
                key: _.key || y.toastKey++,
                type: _.type,
                closeToast: w,
                closeButton: _.closeButton,
                rtl: x.rtl,
                position: _.position || x.position,
                transition: _.transition || x.transition,
                className: p(_.className || x.toastClassName),
                bodyClassName: p(_.bodyClassName || x.bodyClassName),
                style: _.style || x.toastStyle,
                bodyStyle: _.bodyStyle || x.bodyStyle,
                onClick: _.onClick || x.onClick,
                pauseOnHover: c(_.pauseOnHover)
                  ? _.pauseOnHover
                  : x.pauseOnHover,
                pauseOnFocusLoss: c(_.pauseOnFocusLoss)
                  ? _.pauseOnFocusLoss
                  : x.pauseOnFocusLoss,
                draggable: c(_.draggable) ? _.draggable : x.draggable,
                draggablePercent: l(_.draggablePercent)
                  ? _.draggablePercent
                  : x.draggablePercent,
                draggableDirection:
                  _.draggableDirection || x.draggableDirection,
                closeOnClick: c(_.closeOnClick)
                  ? _.closeOnClick
                  : x.closeOnClick,
                progressClassName: p(
                  _.progressClassName || x.progressClassName
                ),
                progressStyle: _.progressStyle || x.progressStyle,
                autoClose:
                  ((C = _.autoClose),
                  (P = x.autoClose),
                  !1 === C || (l(C) && C > 0) ? C : P),
                hideProgressBar: c(_.hideProgressBar)
                  ? _.hideProgressBar
                  : x.hideProgressBar,
                progress: _.progress,
                role: u(_.role) ? _.role : x.role,
                deleteToast: function () {
                  !(function (t) {
                    delete g[t];
                    var n = f.length;
                    (a = d(t) ? a - 1 : a - y.displayedToast) < 0 && (a = 0);
                    if (n > 0) {
                      var r = d(t) ? 1 : y.props.limit;
                      if (1 === n || 1 === r) y.displayedToast++, E();
                      else {
                        var i = r > n ? n : r;
                        y.displayedToast = i;
                        for (var o = 0; o < i; o++) E();
                      }
                    } else e();
                  })(v);
                },
              };
            h(_.onOpen) && (M.onOpen = _.onOpen),
              h(_.onClose) && (M.onClose = _.onClose),
              "y" === M.draggableDirection &&
                80 === M.draggablePercent &&
                (M.draggablePercent *= 1.5);
            var O = x.closeButton;
            !1 === _.closeButton || m(_.closeButton)
              ? (O = _.closeButton)
              : !0 === _.closeButton &&
                (O = !m(x.closeButton) || x.closeButton),
              (M.closeButton = O);
            var k = t;
            (0, r.isValidElement)(t) && !u(t.type)
              ? (k = (0, r.cloneElement)(t, { closeToast: w, toastProps: M }))
              : h(t) && (k = t({ closeToast: w, toastProps: M })),
              x.limit && x.limit > 0 && a > x.limit && T
                ? f.push({ toastContent: k, toastProps: M, staleId: o })
                : l(i) && i > 0
                ? setTimeout(function () {
                    A(k, M, o);
                  }, i)
                : A(k, M, o);
          }
        }
        function A(t, e, n) {
          var r = e.toastId;
          n && delete g[n],
            (g[r] = { content: t, props: e }),
            o({ type: 0, toastId: r, staleId: n });
        }
        return (
          (0, r.useEffect)(function () {
            return (
              (y.containerId = t.containerId),
              v
                .cancelEmit(3)
                .on(0, T)
                .on(1, function (t) {
                  return s.current && S(t);
                })
                .on(5, w)
                .emit(2, y),
              function () {
                return v.emit(3, y);
              }
            );
          }, []),
          (0, r.useEffect)(
            function () {
              (y.isToastActive = _),
                (y.displayedToast = i.length),
                v.emit(4, i.length, t.containerId);
            },
            [i]
          ),
          (0, r.useEffect)(function () {
            y.props = t;
          }),
          {
            getToastToRender: function (e) {
              for (
                var n = {},
                  r = t.newestOnTop ? Object.keys(g).reverse() : Object.keys(g),
                  i = 0;
                i < r.length;
                i++
              ) {
                var o = g[r[i]],
                  s = o.props.position;
                n[s] || (n[s] = []), n[s].push(o);
              }
              return Object.keys(n).map(function (t) {
                return e(t, n[t]);
              });
            },
            collection: g,
            containerRef: s,
            isToastActive: _,
          }
        );
      }
      function S(t) {
        return t.targetTouches && t.targetTouches.length >= 1
          ? t.targetTouches[0].clientX
          : t.clientX;
      }
      function E(t) {
        return t.targetTouches && t.targetTouches.length >= 1
          ? t.targetTouches[0].clientY
          : t.clientY;
      }
      function T(t) {
        var e = (0, r.useState)(!0),
          n = e[0],
          i = e[1],
          o = (0, r.useState)(!1),
          s = o[0],
          a = o[1],
          l = (0, r.useRef)(null),
          c = b({
            start: 0,
            x: 0,
            y: 0,
            delta: 0,
            removalDistance: 0,
            canCloseOnClick: !0,
            canDrag: !1,
            boundingRect: null,
          }),
          u = b(t, !0),
          p = t.autoClose,
          d = t.pauseOnHover,
          f = t.closeToast,
          m = t.onClick,
          g = t.closeOnClick;
        function y(e) {
          if (t.draggable) {
            var n = l.current;
            (c.canCloseOnClick = !0),
              (c.canDrag = !0),
              (c.boundingRect = n.getBoundingClientRect()),
              (n.style.transition = ""),
              (c.x = S(e.nativeEvent)),
              (c.y = E(e.nativeEvent)),
              "x" === t.draggableDirection
                ? ((c.start = c.x),
                  (c.removalDistance =
                    n.offsetWidth * (t.draggablePercent / 100)))
                : ((c.start = c.y),
                  (c.removalDistance =
                    n.offsetHeight * (t.draggablePercent / 100)));
          }
        }
        function _() {
          if (c.boundingRect) {
            var e = c.boundingRect,
              n = e.top,
              r = e.bottom,
              i = e.left,
              o = e.right;
            t.pauseOnHover && c.x >= i && c.x <= o && c.y >= n && c.y <= r
              ? x()
              : v();
          }
        }
        function v() {
          i(!0);
        }
        function x() {
          i(!1);
        }
        function w(e) {
          if (c.canDrag) {
            e.preventDefault();
            var r = l.current;
            n && x(),
              (c.x = S(e)),
              (c.y = E(e)),
              "x" === t.draggableDirection
                ? (c.delta = c.x - c.start)
                : (c.delta = c.y - c.start),
              c.start !== c.x && (c.canCloseOnClick = !1),
              (r.style.transform =
                "translate" + t.draggableDirection + "(" + c.delta + "px)"),
              (r.style.opacity =
                "" + (1 - Math.abs(c.delta / c.removalDistance)));
          }
        }
        function T() {
          var e = l.current;
          if (c.canDrag) {
            if (((c.canDrag = !1), Math.abs(c.delta) > c.removalDistance))
              return a(!0), void t.closeToast();
            (e.style.transition = "transform 0.2s, opacity 0.2s"),
              (e.style.transform = "translate" + t.draggableDirection + "(0)"),
              (e.style.opacity = "1");
          }
        }
        (0, r.useEffect)(function () {
          return (
            h(t.onOpen) &&
              t.onOpen((0, r.isValidElement)(t.children) && t.children.props),
            function () {
              h(u.onClose) &&
                u.onClose(
                  (0, r.isValidElement)(u.children) && u.children.props
                );
            }
          );
        }, []),
          (0, r.useEffect)(
            function () {
              return (
                t.draggable &&
                  (document.addEventListener("mousemove", w),
                  document.addEventListener("mouseup", T),
                  document.addEventListener("touchmove", w),
                  document.addEventListener("touchend", T)),
                function () {
                  t.draggable &&
                    (document.removeEventListener("mousemove", w),
                    document.removeEventListener("mouseup", T),
                    document.removeEventListener("touchmove", w),
                    document.removeEventListener("touchend", T));
                }
              );
            },
            [t.draggable]
          ),
          (0, r.useEffect)(
            function () {
              return (
                t.pauseOnFocusLoss &&
                  (function () {
                    document.hasFocus() || x();
                    window.addEventListener("focus", v),
                      window.addEventListener("blur", x);
                  })(),
                function () {
                  t.pauseOnFocusLoss &&
                    (window.removeEventListener("focus", v),
                    window.removeEventListener("blur", x));
                }
              );
            },
            [t.pauseOnFocusLoss]
          );
        var A = {
          onMouseDown: y,
          onTouchStart: y,
          onMouseUp: _,
          onTouchEnd: _,
        };
        return (
          p && d && ((A.onMouseEnter = x), (A.onMouseLeave = v)),
          g &&
            (A.onClick = function (t) {
              m && m(t), c.canCloseOnClick && f();
            }),
          {
            playToast: v,
            pauseToast: x,
            isRunning: n,
            preventExitTransition: s,
            toastRef: l,
            eventHandlers: A,
          }
        );
      }
      function A(t) {
        var e = t.closeToast,
          n = t.type,
          i = t.ariaLabel,
          o = void 0 === i ? "close" : i;
        return (0, r.createElement)(
          "button",
          {
            className: "Toastify__close-button Toastify__close-button--" + n,
            type: "button",
            onClick: function (t) {
              t.stopPropagation(), e(t);
            },
            "aria-label": o,
          },
          (0, r.createElement)(
            "svg",
            { "aria-hidden": "true", viewBox: "0 0 14 16" },
            (0, r.createElement)("path", {
              fillRule: "evenodd",
              d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z",
            })
          )
        );
      }
      function C(t) {
        var e,
          n,
          i = t.delay,
          s = t.isRunning,
          l = t.closeToast,
          c = t.type,
          u = t.hide,
          p = t.className,
          d = t.style,
          f = t.controlledProgress,
          m = t.progress,
          g = t.rtl,
          y = t.isIn,
          _ = a({}, d, {
            animationDuration: i + "ms",
            animationPlayState: s ? "running" : "paused",
            opacity: u ? 0 : 1,
          });
        f && (_.transform = "scaleX(" + m + ")");
        var v = o(
            "Toastify__progress-bar",
            f
              ? "Toastify__progress-bar--controlled"
              : "Toastify__progress-bar--animated",
            "Toastify__progress-bar--" + c,
            (((e = {})["Toastify__progress-bar--rtl"] = g), e)
          ),
          b = h(p) ? p({ rtl: g, type: c, defaultClassName: v }) : o(v, p),
          x =
            (((n = {})[f && m >= 1 ? "onTransitionEnd" : "onAnimationEnd"] =
              f && m < 1
                ? null
                : function () {
                    y && l();
                  }),
            n);
        return (0, r.createElement)(
          "div",
          Object.assign(
            {
              role: "progressbar",
              "aria-hidden": u ? "true" : "false",
              "aria-label": "notification timer",
              className: b,
              style: _,
            },
            x
          )
        );
      }
      C.defaultProps = { type: y.DEFAULT, hide: !1 };
      var P = function (t) {
          var e,
            n = T(t),
            i = n.isRunning,
            s = n.preventExitTransition,
            a = n.toastRef,
            l = n.eventHandlers,
            c = t.closeButton,
            u = t.children,
            p = t.autoClose,
            d = t.onClick,
            f = t.type,
            m = t.hideProgressBar,
            g = t.closeToast,
            y = t.transition,
            _ = t.position,
            v = t.className,
            b = t.style,
            x = t.bodyClassName,
            w = t.bodyStyle,
            S = t.progressClassName,
            E = t.progressStyle,
            A = t.updateId,
            P = t.role,
            M = t.progress,
            O = t.rtl,
            k = t.toastId,
            I = t.deleteToast,
            D = t.isIn,
            z = o(
              "Toastify__toast",
              "Toastify__toast--" + f,
              (((e = {})["Toastify__toast--rtl"] = O), e)
            ),
            R = h(v)
              ? v({ rtl: O, position: _, type: f, defaultClassName: z })
              : o(z, v),
            L = !!M;
          return (0, r.createElement)(
            y,
            {
              isIn: D,
              done: I,
              position: _,
              preventExitTransition: s,
              nodeRef: a,
            },
            (0, r.createElement)(
              "div",
              Object.assign({ id: k, onClick: d, className: R }, l, {
                style: b,
                ref: a,
              }),
              (0, r.createElement)(
                "div",
                Object.assign({}, D && { role: P }, {
                  className: h(x)
                    ? x({ type: f })
                    : o("Toastify__toast-body", x),
                  style: w,
                }),
                u
              ),
              (function (t) {
                if (t) {
                  var e = { closeToast: g, type: f };
                  return h(t)
                    ? t(e)
                    : (0, r.isValidElement)(t)
                    ? (0, r.cloneElement)(t, e)
                    : void 0;
                }
              })(c),
              (p || L) &&
                (0, r.createElement)(
                  C,
                  Object.assign({}, A && !L ? { key: "pb-" + A } : {}, {
                    rtl: O,
                    delay: p,
                    isRunning: i,
                    isIn: D,
                    closeToast: g,
                    hide: m,
                    type: f,
                    style: E,
                    className: S,
                    controlledProgress: L,
                    progress: M,
                  })
                )
            )
          );
        },
        M = _({
          enter: "Toastify--animate Toastify__bounce-enter",
          exit: "Toastify--animate Toastify__bounce-exit",
          appendPosition: !0,
        }),
        O = function (t) {
          var e = w(t),
            n = e.getToastToRender,
            i = e.containerRef,
            s = e.isToastActive,
            l = t.className,
            c = t.style,
            u = t.rtl,
            d = t.containerId;
          function f(t) {
            var e,
              n = o(
                "Toastify__toast-container",
                "Toastify__toast-container--" + t,
                (((e = {})["Toastify__toast-container--rtl"] = u), e)
              );
            return h(l)
              ? l({ position: t, rtl: u, defaultClassName: n })
              : o(n, p(l));
          }
          return (0, r.createElement)(
            "div",
            { ref: i, className: "Toastify", id: d },
            n(function (t, e) {
              var n =
                0 === e.length ? a({}, c, { pointerEvents: "none" }) : a({}, c);
              return (0, r.createElement)(
                "div",
                { className: f(t), style: n, key: "container-" + t },
                e.map(function (t) {
                  var e = t.content,
                    n = t.props;
                  return (0,
                  r.createElement)(P, Object.assign({}, n, { isIn: s(n.toastId), key: "toast-" + n.key, closeButton: !0 === n.closeButton ? A : n.closeButton }), e);
                })
              );
            })
          );
        };
      O.defaultProps = {
        position: g.TOP_RIGHT,
        transition: M,
        rtl: !1,
        autoClose: 5e3,
        hideProgressBar: !1,
        closeButton: A,
        pauseOnHover: !0,
        pauseOnFocusLoss: !0,
        closeOnClick: !0,
        newestOnTop: !1,
        draggable: !0,
        draggablePercent: 80,
        draggableDirection: "x",
        role: "alert",
      };
      var k,
        I,
        D,
        z = new Map(),
        R = [],
        L = !1;
      function F() {
        return Math.random().toString(36).substr(2, 9);
      }
      function B(t) {
        return t && (u(t.toastId) || l(t.toastId)) ? t.toastId : F();
      }
      function N(t, e) {
        return (
          z.size > 0
            ? v.emit(0, t, e)
            : (R.push({ content: t, options: e }),
              L &&
                f &&
                ((L = !1),
                (I = document.createElement("div")),
                document.body.appendChild(I),
                (0, s.render)(
                  (0, r.createElement)(O, Object.assign({}, D)),
                  I
                ))),
          e.toastId
        );
      }
      function j(t, e) {
        return a({}, e, { type: (e && e.type) || t, toastId: B(e) });
      }
      var U = function (t) {
          return function (e, n) {
            return N(e, j(t, n));
          };
        },
        Z = function (t, e) {
          return N(t, j(y.DEFAULT, e));
        };
      (Z.success = U(y.SUCCESS)),
        (Z.info = U(y.INFO)),
        (Z.error = U(y.ERROR)),
        (Z.warning = U(y.WARNING)),
        (Z.dark = U(y.DARK)),
        (Z.warn = Z.warning),
        (Z.dismiss = function (t) {
          return v.emit(1, t);
        }),
        (Z.clearWaitingQueue = function (t) {
          return void 0 === t && (t = {}), v.emit(5, t);
        }),
        (Z.isActive = function (t) {
          var e = !1;
          return (
            z.forEach(function (n) {
              n.isToastActive && n.isToastActive(t) && (e = !0);
            }),
            e
          );
        }),
        (Z.update = function (t, e) {
          void 0 === e && (e = {}),
            setTimeout(function () {
              var n = (function (t, e) {
                var n = e.containerId,
                  r = z.get(n || k);
                return r ? r.getToast(t) : null;
              })(t, e);
              if (n) {
                var r = n.props,
                  i = n.content,
                  o = a({}, r, e, { toastId: e.toastId || t, updateId: F() });
                o.toastId !== t && (o.staleId = t);
                var s = o.render || i;
                delete o.render, N(s, o);
              }
            }, 0);
        }),
        (Z.done = function (t) {
          Z.update(t, { progress: 1 });
        }),
        (Z.onChange = function (t) {
          return (
            h(t) && v.on(4, t),
            function () {
              h(t) && v.off(4, t);
            }
          );
        }),
        (Z.configure = function (t) {
          void 0 === t && (t = {}), (L = !0), (D = t);
        }),
        (Z.POSITION = g),
        (Z.TYPE = y),
        v
          .on(2, function (t) {
            (k = t.containerId || t),
              z.set(k, t),
              R.forEach(function (t) {
                v.emit(0, t.content, t.options);
              }),
              (R = []);
          })
          .on(3, function (t) {
            z.delete(t.containerId || t),
              0 === z.size && v.off(0).off(1).off(5),
              f && I && document.body.removeChild(I);
          });
    },
    28500: function (t, e, n) {
      "use strict";
      var r = n(45217).compose;
      (e.Uo =
        "undefined" !== typeof window &&
        window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
          ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
          : function () {
              if (0 !== arguments.length)
                return "object" === typeof arguments[0]
                  ? r
                  : r.apply(null, arguments);
            }),
        "undefined" !== typeof window &&
          window.__REDUX_DEVTOOLS_EXTENSION__ &&
          window.__REDUX_DEVTOOLS_EXTENSION__;
    },
    23488: function (t, e, n) {
      "use strict";
      (e.__esModule = !0),
        (e.default = function (t) {
          var e = (0, i.default)(t);
          return {
            getItem: function (t) {
              return new Promise(function (n, r) {
                n(e.getItem(t));
              });
            },
            setItem: function (t, n) {
              return new Promise(function (r, i) {
                r(e.setItem(t, n));
              });
            },
            removeItem: function (t) {
              return new Promise(function (n, r) {
                n(e.removeItem(t));
              });
            },
          };
        });
      var r,
        i = (r = n(77290)) && r.__esModule ? r : { default: r };
    },
    77290: function (t, e) {
      "use strict";
      function n(t) {
        return (
          (n =
            "function" === typeof Symbol && "symbol" === typeof Symbol.iterator
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t &&
                    "function" === typeof Symbol &&
                    t.constructor === Symbol &&
                    t !== Symbol.prototype
                    ? "symbol"
                    : typeof t;
                }),
          n(t)
        );
      }
      function r() {}
      (e.__esModule = !0),
        (e.default = function (t) {
          var e = "".concat(t, "Storage");
          return (function (t) {
            if (
              "object" !==
                ("undefined" === typeof self ? "undefined" : n(self)) ||
              !(t in self)
            )
              return !1;
            try {
              var e = self[t],
                r = "redux-persist ".concat(t, " test");
              e.setItem(r, "test"), e.getItem(r), e.removeItem(r);
            } catch (i) {
              return !1;
            }
            return !0;
          })(e)
            ? self[e]
            : i;
        });
      var i = { getItem: r, setItem: r, removeItem: r };
    },
    76734: function (t, e, n) {
      "use strict";
      var r;
      e.Z = void 0;
      var i = (0,
      ((r = n(23488)) && r.__esModule ? r : { default: r }).default)("local");
      e.Z = i;
    },
    45217: function (t, e, n) {
      "use strict";
      n.r(e),
        n.d(e, {
          __DO_NOT_USE__ActionTypes: function () {
            return c;
          },
          applyMiddleware: function () {
            return g;
          },
          bindActionCreators: function () {
            return f;
          },
          combineReducers: function () {
            return p;
          },
          compose: function () {
            return m;
          },
          createStore: function () {
            return h;
          },
        });
      var r = n(4942);
      function i(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(t);
          e &&
            (r = r.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function o(t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? i(Object(n), !0).forEach(function (e) {
                (0, r.Z)(t, e, n[e]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
            : i(Object(n)).forEach(function (e) {
                Object.defineProperty(
                  t,
                  e,
                  Object.getOwnPropertyDescriptor(n, e)
                );
              });
        }
        return t;
      }
      function s(t) {
        return (
          "Minified Redux error #" +
          t +
          "; visit https://redux.js.org/Errors?code=" +
          t +
          " for the full message or use the non-minified dev environment for full errors. "
        );
      }
      var a =
          ("function" === typeof Symbol && Symbol.observable) || "@@observable",
        l = function () {
          return Math.random().toString(36).substring(7).split("").join(".");
        },
        c = {
          INIT: "@@redux/INIT" + l(),
          REPLACE: "@@redux/REPLACE" + l(),
          PROBE_UNKNOWN_ACTION: function () {
            return "@@redux/PROBE_UNKNOWN_ACTION" + l();
          },
        };
      function u(t) {
        if ("object" !== typeof t || null === t) return !1;
        for (var e = t; null !== Object.getPrototypeOf(e); )
          e = Object.getPrototypeOf(e);
        return Object.getPrototypeOf(t) === e;
      }
      function h(t, e, n) {
        var r;
        if (
          ("function" === typeof e && "function" === typeof n) ||
          ("function" === typeof n && "function" === typeof arguments[3])
        )
          throw new Error(s(0));
        if (
          ("function" === typeof e &&
            "undefined" === typeof n &&
            ((n = e), (e = void 0)),
          "undefined" !== typeof n)
        ) {
          if ("function" !== typeof n) throw new Error(s(1));
          return n(h)(t, e);
        }
        if ("function" !== typeof t) throw new Error(s(2));
        var i = t,
          o = e,
          l = [],
          p = l,
          d = !1;
        function f() {
          p === l && (p = l.slice());
        }
        function m() {
          if (d) throw new Error(s(3));
          return o;
        }
        function g(t) {
          if ("function" !== typeof t) throw new Error(s(4));
          if (d) throw new Error(s(5));
          var e = !0;
          return (
            f(),
            p.push(t),
            function () {
              if (e) {
                if (d) throw new Error(s(6));
                (e = !1), f();
                var n = p.indexOf(t);
                p.splice(n, 1), (l = null);
              }
            }
          );
        }
        function y(t) {
          if (!u(t)) throw new Error(s(7));
          if ("undefined" === typeof t.type) throw new Error(s(8));
          if (d) throw new Error(s(9));
          try {
            (d = !0), (o = i(o, t));
          } finally {
            d = !1;
          }
          for (var e = (l = p), n = 0; n < e.length; n++) {
            (0, e[n])();
          }
          return t;
        }
        function _(t) {
          if ("function" !== typeof t) throw new Error(s(10));
          (i = t), y({ type: c.REPLACE });
        }
        function v() {
          var t,
            e = g;
          return (
            ((t = {
              subscribe: function (t) {
                if ("object" !== typeof t || null === t) throw new Error(s(11));
                function n() {
                  t.next && t.next(m());
                }
                return n(), { unsubscribe: e(n) };
              },
            })[a] = function () {
              return this;
            }),
            t
          );
        }
        return (
          y({ type: c.INIT }),
          ((r = { dispatch: y, subscribe: g, getState: m, replaceReducer: _ })[
            a
          ] = v),
          r
        );
      }
      function p(t) {
        for (var e = Object.keys(t), n = {}, r = 0; r < e.length; r++) {
          var i = e[r];
          0, "function" === typeof t[i] && (n[i] = t[i]);
        }
        var o,
          a = Object.keys(n);
        try {
          !(function (t) {
            Object.keys(t).forEach(function (e) {
              var n = t[e];
              if ("undefined" === typeof n(void 0, { type: c.INIT }))
                throw new Error(s(12));
              if (
                "undefined" ===
                typeof n(void 0, { type: c.PROBE_UNKNOWN_ACTION() })
              )
                throw new Error(s(13));
            });
          })(n);
        } catch (l) {
          o = l;
        }
        return function (t, e) {
          if ((void 0 === t && (t = {}), o)) throw o;
          for (var r = !1, i = {}, l = 0; l < a.length; l++) {
            var c = a[l],
              u = n[c],
              h = t[c],
              p = u(h, e);
            if ("undefined" === typeof p) {
              e && e.type;
              throw new Error(s(14));
            }
            (i[c] = p), (r = r || p !== h);
          }
          return (r = r || a.length !== Object.keys(t).length) ? i : t;
        };
      }
      function d(t, e) {
        return function () {
          return e(t.apply(this, arguments));
        };
      }
      function f(t, e) {
        if ("function" === typeof t) return d(t, e);
        if ("object" !== typeof t || null === t) throw new Error(s(16));
        var n = {};
        for (var r in t) {
          var i = t[r];
          "function" === typeof i && (n[r] = d(i, e));
        }
        return n;
      }
      function m() {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
          e[n] = arguments[n];
        return 0 === e.length
          ? function (t) {
              return t;
            }
          : 1 === e.length
          ? e[0]
          : e.reduce(function (t, e) {
              return function () {
                return t(e.apply(void 0, arguments));
              };
            });
      }
      function g() {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
          e[n] = arguments[n];
        return function (t) {
          return function () {
            var n = t.apply(void 0, arguments),
              r = function () {
                throw new Error(s(15));
              },
              i = {
                getState: n.getState,
                dispatch: function () {
                  return r.apply(void 0, arguments);
                },
              },
              a = e.map(function (t) {
                return t(i);
              });
            return (
              (r = m.apply(void 0, a)(n.dispatch)),
              o(o({}, n), {}, { dispatch: r })
            );
          };
        };
      }
    },
    91033: function (t, e, n) {
      "use strict";
      n.r(e);
      var r = (function () {
          if ("undefined" !== typeof Map) return Map;
          function t(t, e) {
            var n = -1;
            return (
              t.some(function (t, r) {
                return t[0] === e && ((n = r), !0);
              }),
              n
            );
          }
          return (function () {
            function e() {
              this.__entries__ = [];
            }
            return (
              Object.defineProperty(e.prototype, "size", {
                get: function () {
                  return this.__entries__.length;
                },
                enumerable: !0,
                configurable: !0,
              }),
              (e.prototype.get = function (e) {
                var n = t(this.__entries__, e),
                  r = this.__entries__[n];
                return r && r[1];
              }),
              (e.prototype.set = function (e, n) {
                var r = t(this.__entries__, e);
                ~r
                  ? (this.__entries__[r][1] = n)
                  : this.__entries__.push([e, n]);
              }),
              (e.prototype.delete = function (e) {
                var n = this.__entries__,
                  r = t(n, e);
                ~r && n.splice(r, 1);
              }),
              (e.prototype.has = function (e) {
                return !!~t(this.__entries__, e);
              }),
              (e.prototype.clear = function () {
                this.__entries__.splice(0);
              }),
              (e.prototype.forEach = function (t, e) {
                void 0 === e && (e = null);
                for (var n = 0, r = this.__entries__; n < r.length; n++) {
                  var i = r[n];
                  t.call(e, i[1], i[0]);
                }
              }),
              e
            );
          })();
        })(),
        i =
          "undefined" !== typeof window &&
          "undefined" !== typeof document &&
          window.document === document,
        o =
          "undefined" !== typeof n.g && n.g.Math === Math
            ? n.g
            : "undefined" !== typeof self && self.Math === Math
            ? self
            : "undefined" !== typeof window && window.Math === Math
            ? window
            : Function("return this")(),
        s =
          "function" === typeof requestAnimationFrame
            ? requestAnimationFrame.bind(o)
            : function (t) {
                return setTimeout(function () {
                  return t(Date.now());
                }, 1e3 / 60);
              };
      var a = [
          "top",
          "right",
          "bottom",
          "left",
          "width",
          "height",
          "size",
          "weight",
        ],
        l = "undefined" !== typeof MutationObserver,
        c = (function () {
          function t() {
            (this.connected_ = !1),
              (this.mutationEventsAdded_ = !1),
              (this.mutationsObserver_ = null),
              (this.observers_ = []),
              (this.onTransitionEnd_ = this.onTransitionEnd_.bind(this)),
              (this.refresh = (function (t, e) {
                var n = !1,
                  r = !1,
                  i = 0;
                function o() {
                  n && ((n = !1), t()), r && l();
                }
                function a() {
                  s(o);
                }
                function l() {
                  var t = Date.now();
                  if (n) {
                    if (t - i < 2) return;
                    r = !0;
                  } else (n = !0), (r = !1), setTimeout(a, e);
                  i = t;
                }
                return l;
              })(this.refresh.bind(this), 20));
          }
          return (
            (t.prototype.addObserver = function (t) {
              ~this.observers_.indexOf(t) || this.observers_.push(t),
                this.connected_ || this.connect_();
            }),
            (t.prototype.removeObserver = function (t) {
              var e = this.observers_,
                n = e.indexOf(t);
              ~n && e.splice(n, 1),
                !e.length && this.connected_ && this.disconnect_();
            }),
            (t.prototype.refresh = function () {
              this.updateObservers_() && this.refresh();
            }),
            (t.prototype.updateObservers_ = function () {
              var t = this.observers_.filter(function (t) {
                return t.gatherActive(), t.hasActive();
              });
              return (
                t.forEach(function (t) {
                  return t.broadcastActive();
                }),
                t.length > 0
              );
            }),
            (t.prototype.connect_ = function () {
              i &&
                !this.connected_ &&
                (document.addEventListener(
                  "transitionend",
                  this.onTransitionEnd_
                ),
                window.addEventListener("resize", this.refresh),
                l
                  ? ((this.mutationsObserver_ = new MutationObserver(
                      this.refresh
                    )),
                    this.mutationsObserver_.observe(document, {
                      attributes: !0,
                      childList: !0,
                      characterData: !0,
                      subtree: !0,
                    }))
                  : (document.addEventListener(
                      "DOMSubtreeModified",
                      this.refresh
                    ),
                    (this.mutationEventsAdded_ = !0)),
                (this.connected_ = !0));
            }),
            (t.prototype.disconnect_ = function () {
              i &&
                this.connected_ &&
                (document.removeEventListener(
                  "transitionend",
                  this.onTransitionEnd_
                ),
                window.removeEventListener("resize", this.refresh),
                this.mutationsObserver_ && this.mutationsObserver_.disconnect(),
                this.mutationEventsAdded_ &&
                  document.removeEventListener(
                    "DOMSubtreeModified",
                    this.refresh
                  ),
                (this.mutationsObserver_ = null),
                (this.mutationEventsAdded_ = !1),
                (this.connected_ = !1));
            }),
            (t.prototype.onTransitionEnd_ = function (t) {
              var e = t.propertyName,
                n = void 0 === e ? "" : e;
              a.some(function (t) {
                return !!~n.indexOf(t);
              }) && this.refresh();
            }),
            (t.getInstance = function () {
              return (
                this.instance_ || (this.instance_ = new t()), this.instance_
              );
            }),
            (t.instance_ = null),
            t
          );
        })(),
        u = function (t, e) {
          for (var n = 0, r = Object.keys(e); n < r.length; n++) {
            var i = r[n];
            Object.defineProperty(t, i, {
              value: e[i],
              enumerable: !1,
              writable: !1,
              configurable: !0,
            });
          }
          return t;
        },
        h = function (t) {
          return (t && t.ownerDocument && t.ownerDocument.defaultView) || o;
        },
        p = _(0, 0, 0, 0);
      function d(t) {
        return parseFloat(t) || 0;
      }
      function f(t) {
        for (var e = [], n = 1; n < arguments.length; n++)
          e[n - 1] = arguments[n];
        return e.reduce(function (e, n) {
          return e + d(t["border-" + n + "-width"]);
        }, 0);
      }
      function m(t) {
        var e = t.clientWidth,
          n = t.clientHeight;
        if (!e && !n) return p;
        var r = h(t).getComputedStyle(t),
          i = (function (t) {
            for (
              var e = {}, n = 0, r = ["top", "right", "bottom", "left"];
              n < r.length;
              n++
            ) {
              var i = r[n],
                o = t["padding-" + i];
              e[i] = d(o);
            }
            return e;
          })(r),
          o = i.left + i.right,
          s = i.top + i.bottom,
          a = d(r.width),
          l = d(r.height);
        if (
          ("border-box" === r.boxSizing &&
            (Math.round(a + o) !== e && (a -= f(r, "left", "right") + o),
            Math.round(l + s) !== n && (l -= f(r, "top", "bottom") + s)),
          !(function (t) {
            return t === h(t).document.documentElement;
          })(t))
        ) {
          var c = Math.round(a + o) - e,
            u = Math.round(l + s) - n;
          1 !== Math.abs(c) && (a -= c), 1 !== Math.abs(u) && (l -= u);
        }
        return _(i.left, i.top, a, l);
      }
      var g =
        "undefined" !== typeof SVGGraphicsElement
          ? function (t) {
              return t instanceof h(t).SVGGraphicsElement;
            }
          : function (t) {
              return (
                t instanceof h(t).SVGElement && "function" === typeof t.getBBox
              );
            };
      function y(t) {
        return i
          ? g(t)
            ? (function (t) {
                var e = t.getBBox();
                return _(0, 0, e.width, e.height);
              })(t)
            : m(t)
          : p;
      }
      function _(t, e, n, r) {
        return { x: t, y: e, width: n, height: r };
      }
      var v = (function () {
          function t(t) {
            (this.broadcastWidth = 0),
              (this.broadcastHeight = 0),
              (this.contentRect_ = _(0, 0, 0, 0)),
              (this.target = t);
          }
          return (
            (t.prototype.isActive = function () {
              var t = y(this.target);
              return (
                (this.contentRect_ = t),
                t.width !== this.broadcastWidth ||
                  t.height !== this.broadcastHeight
              );
            }),
            (t.prototype.broadcastRect = function () {
              var t = this.contentRect_;
              return (
                (this.broadcastWidth = t.width),
                (this.broadcastHeight = t.height),
                t
              );
            }),
            t
          );
        })(),
        b = function (t, e) {
          var n = (function (t) {
            var e = t.x,
              n = t.y,
              r = t.width,
              i = t.height,
              o =
                "undefined" !== typeof DOMRectReadOnly
                  ? DOMRectReadOnly
                  : Object,
              s = Object.create(o.prototype);
            return (
              u(s, {
                x: e,
                y: n,
                width: r,
                height: i,
                top: n,
                right: e + r,
                bottom: i + n,
                left: e,
              }),
              s
            );
          })(e);
          u(this, { target: t, contentRect: n });
        },
        x = (function () {
          function t(t, e, n) {
            if (
              ((this.activeObservations_ = []),
              (this.observations_ = new r()),
              "function" !== typeof t)
            )
              throw new TypeError(
                "The callback provided as parameter 1 is not a function."
              );
            (this.callback_ = t),
              (this.controller_ = e),
              (this.callbackCtx_ = n);
          }
          return (
            (t.prototype.observe = function (t) {
              if (!arguments.length)
                throw new TypeError("1 argument required, but only 0 present.");
              if ("undefined" !== typeof Element && Element instanceof Object) {
                if (!(t instanceof h(t).Element))
                  throw new TypeError('parameter 1 is not of type "Element".');
                var e = this.observations_;
                e.has(t) ||
                  (e.set(t, new v(t)),
                  this.controller_.addObserver(this),
                  this.controller_.refresh());
              }
            }),
            (t.prototype.unobserve = function (t) {
              if (!arguments.length)
                throw new TypeError("1 argument required, but only 0 present.");
              if ("undefined" !== typeof Element && Element instanceof Object) {
                if (!(t instanceof h(t).Element))
                  throw new TypeError('parameter 1 is not of type "Element".');
                var e = this.observations_;
                e.has(t) &&
                  (e.delete(t),
                  e.size || this.controller_.removeObserver(this));
              }
            }),
            (t.prototype.disconnect = function () {
              this.clearActive(),
                this.observations_.clear(),
                this.controller_.removeObserver(this);
            }),
            (t.prototype.gatherActive = function () {
              var t = this;
              this.clearActive(),
                this.observations_.forEach(function (e) {
                  e.isActive() && t.activeObservations_.push(e);
                });
            }),
            (t.prototype.broadcastActive = function () {
              if (this.hasActive()) {
                var t = this.callbackCtx_,
                  e = this.activeObservations_.map(function (t) {
                    return new b(t.target, t.broadcastRect());
                  });
                this.callback_.call(t, e, t), this.clearActive();
              }
            }),
            (t.prototype.clearActive = function () {
              this.activeObservations_.splice(0);
            }),
            (t.prototype.hasActive = function () {
              return this.activeObservations_.length > 0;
            }),
            t
          );
        })(),
        w = "undefined" !== typeof WeakMap ? new WeakMap() : new r(),
        S = function t(e) {
          if (!(this instanceof t))
            throw new TypeError("Cannot call a class as a function.");
          if (!arguments.length)
            throw new TypeError("1 argument required, but only 0 present.");
          var n = c.getInstance(),
            r = new x(e, n, this);
          w.set(this, r);
        };
      ["observe", "unobserve", "disconnect"].forEach(function (t) {
        S.prototype[t] = function () {
          var e;
          return (e = w.get(this))[t].apply(e, arguments);
        };
      });
      var E = "undefined" !== typeof o.ResizeObserver ? o.ResizeObserver : S;
      e.default = E;
    },
    37478: function (t, e, n) {
      "use strict";
      var r = n(40210),
        i = n(21924),
        o = n(70631),
        s = r("%TypeError%"),
        a = r("%WeakMap%", !0),
        l = r("%Map%", !0),
        c = i("WeakMap.prototype.get", !0),
        u = i("WeakMap.prototype.set", !0),
        h = i("WeakMap.prototype.has", !0),
        p = i("Map.prototype.get", !0),
        d = i("Map.prototype.set", !0),
        f = i("Map.prototype.has", !0),
        m = function (t, e) {
          for (var n, r = t; null !== (n = r.next); r = n)
            if (n.key === e)
              return (r.next = n.next), (n.next = t.next), (t.next = n), n;
        };
      t.exports = function () {
        var t,
          e,
          n,
          r = {
            assert: function (t) {
              if (!r.has(t))
                throw new s("Side channel does not contain " + o(t));
            },
            get: function (r) {
              if (
                a &&
                r &&
                ("object" === typeof r || "function" === typeof r)
              ) {
                if (t) return c(t, r);
              } else if (l) {
                if (e) return p(e, r);
              } else if (n)
                return (function (t, e) {
                  var n = m(t, e);
                  return n && n.value;
                })(n, r);
            },
            has: function (r) {
              if (
                a &&
                r &&
                ("object" === typeof r || "function" === typeof r)
              ) {
                if (t) return h(t, r);
              } else if (l) {
                if (e) return f(e, r);
              } else if (n)
                return (function (t, e) {
                  return !!m(t, e);
                })(n, r);
              return !1;
            },
            set: function (r, i) {
              a && r && ("object" === typeof r || "function" === typeof r)
                ? (t || (t = new a()), u(t, r, i))
                : l
                ? (e || (e = new l()), d(e, r, i))
                : (n || (n = { key: {}, next: null }),
                  (function (t, e, n) {
                    var r = m(t, e);
                    r
                      ? (r.value = n)
                      : (t.next = { key: e, next: t.next, value: n });
                  })(n, r, i));
            },
          };
        return r;
      };
    },
    93120: function (t, e) {
      var n, r, i;
      !(function (o, s) {
        "use strict";
        (r = []),
          void 0 ===
            (i =
              "function" ===
              typeof (n = function () {
                function t(t) {
                  return !isNaN(parseFloat(t)) && isFinite(t);
                }
                function e(t) {
                  return t.charAt(0).toUpperCase() + t.substring(1);
                }
                function n(t) {
                  return function () {
                    return this[t];
                  };
                }
                var r = ["isConstructor", "isEval", "isNative", "isToplevel"],
                  i = ["columnNumber", "lineNumber"],
                  o = ["fileName", "functionName", "source"],
                  s = ["args"],
                  a = ["evalOrigin"],
                  l = r.concat(i, o, s, a);
                function c(t) {
                  if (t)
                    for (var n = 0; n < l.length; n++)
                      void 0 !== t[l[n]] && this["set" + e(l[n])](t[l[n]]);
                }
                (c.prototype = {
                  getArgs: function () {
                    return this.args;
                  },
                  setArgs: function (t) {
                    if ("[object Array]" !== Object.prototype.toString.call(t))
                      throw new TypeError("Args must be an Array");
                    this.args = t;
                  },
                  getEvalOrigin: function () {
                    return this.evalOrigin;
                  },
                  setEvalOrigin: function (t) {
                    if (t instanceof c) this.evalOrigin = t;
                    else {
                      if (!(t instanceof Object))
                        throw new TypeError(
                          "Eval Origin must be an Object or StackFrame"
                        );
                      this.evalOrigin = new c(t);
                    }
                  },
                  toString: function () {
                    var t = this.getFileName() || "",
                      e = this.getLineNumber() || "",
                      n = this.getColumnNumber() || "",
                      r = this.getFunctionName() || "";
                    return this.getIsEval()
                      ? t
                        ? "[eval] (" + t + ":" + e + ":" + n + ")"
                        : "[eval]:" + e + ":" + n
                      : r
                      ? r + " (" + t + ":" + e + ":" + n + ")"
                      : t + ":" + e + ":" + n;
                  },
                }),
                  (c.fromString = function (t) {
                    var e = t.indexOf("("),
                      n = t.lastIndexOf(")"),
                      r = t.substring(0, e),
                      i = t.substring(e + 1, n).split(","),
                      o = t.substring(n + 1);
                    if (0 === o.indexOf("@"))
                      var s = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(o, ""),
                        a = s[1],
                        l = s[2],
                        u = s[3];
                    return new c({
                      functionName: r,
                      args: i || void 0,
                      fileName: a,
                      lineNumber: l || void 0,
                      columnNumber: u || void 0,
                    });
                  });
                for (var u = 0; u < r.length; u++)
                  (c.prototype["get" + e(r[u])] = n(r[u])),
                    (c.prototype["set" + e(r[u])] = (function (t) {
                      return function (e) {
                        this[t] = Boolean(e);
                      };
                    })(r[u]));
                for (var h = 0; h < i.length; h++)
                  (c.prototype["get" + e(i[h])] = n(i[h])),
                    (c.prototype["set" + e(i[h])] = (function (e) {
                      return function (n) {
                        if (!t(n)) throw new TypeError(e + " must be a Number");
                        this[e] = Number(n);
                      };
                    })(i[h]));
                for (var p = 0; p < o.length; p++)
                  (c.prototype["get" + e(o[p])] = n(o[p])),
                    (c.prototype["set" + e(o[p])] = (function (t) {
                      return function (e) {
                        this[t] = String(e);
                      };
                    })(o[p]));
                return c;
              })
                ? n.apply(e, r)
                : n) || (t.exports = i);
      })();
    },
    34595: function (t, e, n) {
      var r, i, o;
      !(function (s, a) {
        "use strict";
        (i = [n(93120)]),
          (r = function (t) {
            return {
              backtrace: function (e) {
                var n = [],
                  r = 10;
                "object" === typeof e &&
                  "number" === typeof e.maxStackSize &&
                  (r = e.maxStackSize);
                for (var i = arguments.callee; i && n.length < r; ) {
                  for (
                    var o = new Array(i.arguments.length), s = 0;
                    s < o.length;
                    ++s
                  )
                    o[s] = i.arguments[s];
                  /function(?:\s+([\w$]+))+\s*\(/.test(i.toString())
                    ? n.push(
                        new t({ functionName: RegExp.$1 || void 0, args: o })
                      )
                    : n.push(new t({ args: o }));
                  try {
                    i = i.caller;
                  } catch (a) {
                    break;
                  }
                }
                return n;
              },
            };
          }),
          void 0 === (o = "function" === typeof r ? r.apply(e, i) : r) ||
            (t.exports = o);
      })();
    },
    59829: function (t, e) {
      var n, r, i;
      !(function (o, s) {
        "use strict";
        (r = []),
          void 0 ===
            (i =
              "function" ===
              typeof (n = function () {
                function t(t) {
                  return !isNaN(parseFloat(t)) && isFinite(t);
                }
                function e(t, e, n, r, i, o) {
                  void 0 !== t && this.setFunctionName(t),
                    void 0 !== e && this.setArgs(e),
                    void 0 !== n && this.setFileName(n),
                    void 0 !== r && this.setLineNumber(r),
                    void 0 !== i && this.setColumnNumber(i),
                    void 0 !== o && this.setSource(o);
                }
                return (
                  (e.prototype = {
                    getFunctionName: function () {
                      return this.functionName;
                    },
                    setFunctionName: function (t) {
                      this.functionName = String(t);
                    },
                    getArgs: function () {
                      return this.args;
                    },
                    setArgs: function (t) {
                      if (
                        "[object Array]" !== Object.prototype.toString.call(t)
                      )
                        throw new TypeError("Args must be an Array");
                      this.args = t;
                    },
                    getFileName: function () {
                      return this.fileName;
                    },
                    setFileName: function (t) {
                      this.fileName = String(t);
                    },
                    getLineNumber: function () {
                      return this.lineNumber;
                    },
                    setLineNumber: function (e) {
                      if (!t(e))
                        throw new TypeError("Line Number must be a Number");
                      this.lineNumber = Number(e);
                    },
                    getColumnNumber: function () {
                      return this.columnNumber;
                    },
                    setColumnNumber: function (e) {
                      if (!t(e))
                        throw new TypeError("Column Number must be a Number");
                      this.columnNumber = Number(e);
                    },
                    getSource: function () {
                      return this.source;
                    },
                    setSource: function (t) {
                      this.source = String(t);
                    },
                    toString: function () {
                      return (
                        (this.getFunctionName() || "{anonymous}") +
                        ("(" + (this.getArgs() || []).join(",") + ")") +
                        (this.getFileName() ? "@" + this.getFileName() : "") +
                        (t(this.getLineNumber())
                          ? ":" + this.getLineNumber()
                          : "") +
                        (t(this.getColumnNumber())
                          ? ":" + this.getColumnNumber()
                          : "")
                      );
                    },
                  }),
                  e
                );
              })
                ? n.apply(e, r)
                : n) || (t.exports = i);
      })();
    },
    9817: function (t, e, n) {
      var r = n(99479),
        i = Object.prototype.hasOwnProperty;
      function o() {
        (this._array = []), (this._set = Object.create(null));
      }
      (o.fromArray = function (t, e) {
        for (var n = new o(), r = 0, i = t.length; r < i; r++) n.add(t[r], e);
        return n;
      }),
        (o.prototype.size = function () {
          return Object.getOwnPropertyNames(this._set).length;
        }),
        (o.prototype.add = function (t, e) {
          var n = r.toSetString(t),
            o = i.call(this._set, n),
            s = this._array.length;
          (o && !e) || this._array.push(t), o || (this._set[n] = s);
        }),
        (o.prototype.has = function (t) {
          var e = r.toSetString(t);
          return i.call(this._set, e);
        }),
        (o.prototype.indexOf = function (t) {
          var e = r.toSetString(t);
          if (i.call(this._set, e)) return this._set[e];
          throw new Error('"' + t + '" is not in the set.');
        }),
        (o.prototype.at = function (t) {
          if (t >= 0 && t < this._array.length) return this._array[t];
          throw new Error("No element indexed by " + t);
        }),
        (o.prototype.toArray = function () {
          return this._array.slice();
        }),
        (e.I = o);
    },
    60647: function (t, e, n) {
      var r = n(18855);
      (e.encode = function (t) {
        var e,
          n = "",
          i = (function (t) {
            return t < 0 ? 1 + (-t << 1) : 0 + (t << 1);
          })(t);
        do {
          (e = 31 & i), (i >>>= 5) > 0 && (e |= 32), (n += r.encode(e));
        } while (i > 0);
        return n;
      }),
        (e.decode = function (t, e, n) {
          var i,
            o,
            s = t.length,
            a = 0,
            l = 0;
          do {
            if (e >= s)
              throw new Error("Expected more digits in base 64 VLQ value.");
            if (-1 === (o = r.decode(t.charCodeAt(e++))))
              throw new Error("Invalid base64 digit: " + t.charAt(e - 1));
            (i = !!(32 & o)), (a += (o &= 31) << l), (l += 5);
          } while (i);
          (n.value = (function (t) {
            var e = t >> 1;
            return 1 === (1 & t) ? -e : e;
          })(a)),
            (n.rest = e);
        });
    },
    18855: function (t, e) {
      var n =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(
          ""
        );
      (e.encode = function (t) {
        if (0 <= t && t < n.length) return n[t];
        throw new TypeError("Must be between 0 and 63: " + t);
      }),
        (e.decode = function (t) {
          return 65 <= t && t <= 90
            ? t - 65
            : 97 <= t && t <= 122
            ? t - 97 + 26
            : 48 <= t && t <= 57
            ? t - 48 + 52
            : 43 == t
            ? 62
            : 47 == t
            ? 63
            : -1;
        });
    },
    4274: function (t, e) {
      function n(t, r, i, o, s, a) {
        var l = Math.floor((r - t) / 2) + t,
          c = s(i, o[l], !0);
        return 0 === c
          ? l
          : c > 0
          ? r - l > 1
            ? n(l, r, i, o, s, a)
            : a == e.LEAST_UPPER_BOUND
            ? r < o.length
              ? r
              : -1
            : l
          : l - t > 1
          ? n(t, l, i, o, s, a)
          : a == e.LEAST_UPPER_BOUND
          ? l
          : t < 0
          ? -1
          : t;
      }
      (e.GREATEST_LOWER_BOUND = 1),
        (e.LEAST_UPPER_BOUND = 2),
        (e.search = function (t, r, i, o) {
          if (0 === r.length) return -1;
          var s = n(-1, r.length, t, r, i, o || e.GREATEST_LOWER_BOUND);
          if (s < 0) return -1;
          for (; s - 1 >= 0 && 0 === i(r[s], r[s - 1], !0); ) --s;
          return s;
        });
    },
    91027: function (t, e, n) {
      var r = n(99479);
      function i() {
        (this._array = []),
          (this._sorted = !0),
          (this._last = { generatedLine: -1, generatedColumn: 0 });
      }
      (i.prototype.unsortedForEach = function (t, e) {
        this._array.forEach(t, e);
      }),
        (i.prototype.add = function (t) {
          !(function (t, e) {
            var n = t.generatedLine,
              i = e.generatedLine,
              o = t.generatedColumn,
              s = e.generatedColumn;
            return (
              i > n ||
              (i == n && s >= o) ||
              r.compareByGeneratedPositionsInflated(t, e) <= 0
            );
          })(this._last, t)
            ? ((this._sorted = !1), this._array.push(t))
            : ((this._last = t), this._array.push(t));
        }),
        (i.prototype.toArray = function () {
          return (
            this._sorted ||
              (this._array.sort(r.compareByGeneratedPositionsInflated),
              (this._sorted = !0)),
            this._array
          );
        }),
        (e.H = i);
    },
    91956: function (t, e) {
      function n(t, e, n) {
        var r = t[e];
        (t[e] = t[n]), (t[n] = r);
      }
      function r(t, e, i, o) {
        if (i < o) {
          var s = i - 1;
          n(t, ((u = i), (h = o), Math.round(u + Math.random() * (h - u))), o);
          for (var a = t[o], l = i; l < o; l++)
            e(t[l], a) <= 0 && n(t, (s += 1), l);
          n(t, s + 1, l);
          var c = s + 1;
          r(t, e, i, c - 1), r(t, e, c + 1, o);
        }
        var u, h;
      }
      e.U = function (t, e) {
        r(t, e, 0, t.length - 1);
      };
    },
    35667: function (t, e, n) {
      var r = n(99479),
        i = n(4274),
        o = n(9817).I,
        s = n(60647),
        a = n(91956).U;
      function l(t) {
        var e = t;
        return (
          "string" === typeof t && (e = JSON.parse(t.replace(/^\)\]\}'/, ""))),
          null != e.sections ? new h(e) : new c(e)
        );
      }
      function c(t) {
        var e = t;
        "string" === typeof t && (e = JSON.parse(t.replace(/^\)\]\}'/, "")));
        var n = r.getArg(e, "version"),
          i = r.getArg(e, "sources"),
          s = r.getArg(e, "names", []),
          a = r.getArg(e, "sourceRoot", null),
          l = r.getArg(e, "sourcesContent", null),
          c = r.getArg(e, "mappings"),
          u = r.getArg(e, "file", null);
        if (n != this._version) throw new Error("Unsupported version: " + n);
        (i = i
          .map(String)
          .map(r.normalize)
          .map(function (t) {
            return a && r.isAbsolute(a) && r.isAbsolute(t)
              ? r.relative(a, t)
              : t;
          })),
          (this._names = o.fromArray(s.map(String), !0)),
          (this._sources = o.fromArray(i, !0)),
          (this.sourceRoot = a),
          (this.sourcesContent = l),
          (this._mappings = c),
          (this.file = u);
      }
      function u() {
        (this.generatedLine = 0),
          (this.generatedColumn = 0),
          (this.source = null),
          (this.originalLine = null),
          (this.originalColumn = null),
          (this.name = null);
      }
      function h(t) {
        var e = t;
        "string" === typeof t && (e = JSON.parse(t.replace(/^\)\]\}'/, "")));
        var n = r.getArg(e, "version"),
          i = r.getArg(e, "sections");
        if (n != this._version) throw new Error("Unsupported version: " + n);
        (this._sources = new o()), (this._names = new o());
        var s = { line: -1, column: 0 };
        this._sections = i.map(function (t) {
          if (t.url)
            throw new Error(
              "Support for url field in sections not implemented."
            );
          var e = r.getArg(t, "offset"),
            n = r.getArg(e, "line"),
            i = r.getArg(e, "column");
          if (n < s.line || (n === s.line && i < s.column))
            throw new Error(
              "Section offsets must be ordered and non-overlapping."
            );
          return (
            (s = e),
            {
              generatedOffset: { generatedLine: n + 1, generatedColumn: i + 1 },
              consumer: new l(r.getArg(t, "map")),
            }
          );
        });
      }
      (l.fromSourceMap = function (t) {
        return c.fromSourceMap(t);
      }),
        (l.prototype._version = 3),
        (l.prototype.__generatedMappings = null),
        Object.defineProperty(l.prototype, "_generatedMappings", {
          get: function () {
            return (
              this.__generatedMappings ||
                this._parseMappings(this._mappings, this.sourceRoot),
              this.__generatedMappings
            );
          },
        }),
        (l.prototype.__originalMappings = null),
        Object.defineProperty(l.prototype, "_originalMappings", {
          get: function () {
            return (
              this.__originalMappings ||
                this._parseMappings(this._mappings, this.sourceRoot),
              this.__originalMappings
            );
          },
        }),
        (l.prototype._charIsMappingSeparator = function (t, e) {
          var n = t.charAt(e);
          return ";" === n || "," === n;
        }),
        (l.prototype._parseMappings = function (t, e) {
          throw new Error("Subclasses must implement _parseMappings");
        }),
        (l.GENERATED_ORDER = 1),
        (l.ORIGINAL_ORDER = 2),
        (l.GREATEST_LOWER_BOUND = 1),
        (l.LEAST_UPPER_BOUND = 2),
        (l.prototype.eachMapping = function (t, e, n) {
          var i,
            o = e || null;
          switch (n || l.GENERATED_ORDER) {
            case l.GENERATED_ORDER:
              i = this._generatedMappings;
              break;
            case l.ORIGINAL_ORDER:
              i = this._originalMappings;
              break;
            default:
              throw new Error("Unknown order of iteration.");
          }
          var s = this.sourceRoot;
          i.map(function (t) {
            var e = null === t.source ? null : this._sources.at(t.source);
            return (
              null != e && null != s && (e = r.join(s, e)),
              {
                source: e,
                generatedLine: t.generatedLine,
                generatedColumn: t.generatedColumn,
                originalLine: t.originalLine,
                originalColumn: t.originalColumn,
                name: null === t.name ? null : this._names.at(t.name),
              }
            );
          }, this).forEach(t, o);
        }),
        (l.prototype.allGeneratedPositionsFor = function (t) {
          var e = r.getArg(t, "line"),
            n = {
              source: r.getArg(t, "source"),
              originalLine: e,
              originalColumn: r.getArg(t, "column", 0),
            };
          if (
            (null != this.sourceRoot &&
              (n.source = r.relative(this.sourceRoot, n.source)),
            !this._sources.has(n.source))
          )
            return [];
          n.source = this._sources.indexOf(n.source);
          var o = [],
            s = this._findMapping(
              n,
              this._originalMappings,
              "originalLine",
              "originalColumn",
              r.compareByOriginalPositions,
              i.LEAST_UPPER_BOUND
            );
          if (s >= 0) {
            var a = this._originalMappings[s];
            if (void 0 === t.column)
              for (var l = a.originalLine; a && a.originalLine === l; )
                o.push({
                  line: r.getArg(a, "generatedLine", null),
                  column: r.getArg(a, "generatedColumn", null),
                  lastColumn: r.getArg(a, "lastGeneratedColumn", null),
                }),
                  (a = this._originalMappings[++s]);
            else
              for (
                var c = a.originalColumn;
                a && a.originalLine === e && a.originalColumn == c;

              )
                o.push({
                  line: r.getArg(a, "generatedLine", null),
                  column: r.getArg(a, "generatedColumn", null),
                  lastColumn: r.getArg(a, "lastGeneratedColumn", null),
                }),
                  (a = this._originalMappings[++s]);
          }
          return o;
        }),
        (e.SourceMapConsumer = l),
        (c.prototype = Object.create(l.prototype)),
        (c.prototype.consumer = l),
        (c.fromSourceMap = function (t) {
          var e = Object.create(c.prototype),
            n = (e._names = o.fromArray(t._names.toArray(), !0)),
            i = (e._sources = o.fromArray(t._sources.toArray(), !0));
          (e.sourceRoot = t._sourceRoot),
            (e.sourcesContent = t._generateSourcesContent(
              e._sources.toArray(),
              e.sourceRoot
            )),
            (e.file = t._file);
          for (
            var s = t._mappings.toArray().slice(),
              l = (e.__generatedMappings = []),
              h = (e.__originalMappings = []),
              p = 0,
              d = s.length;
            p < d;
            p++
          ) {
            var f = s[p],
              m = new u();
            (m.generatedLine = f.generatedLine),
              (m.generatedColumn = f.generatedColumn),
              f.source &&
                ((m.source = i.indexOf(f.source)),
                (m.originalLine = f.originalLine),
                (m.originalColumn = f.originalColumn),
                f.name && (m.name = n.indexOf(f.name)),
                h.push(m)),
              l.push(m);
          }
          return a(e.__originalMappings, r.compareByOriginalPositions), e;
        }),
        (c.prototype._version = 3),
        Object.defineProperty(c.prototype, "sources", {
          get: function () {
            return this._sources.toArray().map(function (t) {
              return null != this.sourceRoot ? r.join(this.sourceRoot, t) : t;
            }, this);
          },
        }),
        (c.prototype._parseMappings = function (t, e) {
          for (
            var n,
              i,
              o,
              l,
              c,
              h = 1,
              p = 0,
              d = 0,
              f = 0,
              m = 0,
              g = 0,
              y = t.length,
              _ = 0,
              v = {},
              b = {},
              x = [],
              w = [];
            _ < y;

          )
            if (";" === t.charAt(_)) h++, _++, (p = 0);
            else if ("," === t.charAt(_)) _++;
            else {
              for (
                (n = new u()).generatedLine = h, l = _;
                l < y && !this._charIsMappingSeparator(t, l);
                l++
              );
              if ((o = v[(i = t.slice(_, l))])) _ += i.length;
              else {
                for (o = []; _ < l; )
                  s.decode(t, _, b), (c = b.value), (_ = b.rest), o.push(c);
                if (2 === o.length)
                  throw new Error("Found a source, but no line and column");
                if (3 === o.length)
                  throw new Error("Found a source and line, but no column");
                v[i] = o;
              }
              (n.generatedColumn = p + o[0]),
                (p = n.generatedColumn),
                o.length > 1 &&
                  ((n.source = m + o[1]),
                  (m += o[1]),
                  (n.originalLine = d + o[2]),
                  (d = n.originalLine),
                  (n.originalLine += 1),
                  (n.originalColumn = f + o[3]),
                  (f = n.originalColumn),
                  o.length > 4 && ((n.name = g + o[4]), (g += o[4]))),
                w.push(n),
                "number" === typeof n.originalLine && x.push(n);
            }
          a(w, r.compareByGeneratedPositionsDeflated),
            (this.__generatedMappings = w),
            a(x, r.compareByOriginalPositions),
            (this.__originalMappings = x);
        }),
        (c.prototype._findMapping = function (t, e, n, r, o, s) {
          if (t[n] <= 0)
            throw new TypeError(
              "Line must be greater than or equal to 1, got " + t[n]
            );
          if (t[r] < 0)
            throw new TypeError(
              "Column must be greater than or equal to 0, got " + t[r]
            );
          return i.search(t, e, o, s);
        }),
        (c.prototype.computeColumnSpans = function () {
          for (var t = 0; t < this._generatedMappings.length; ++t) {
            var e = this._generatedMappings[t];
            if (t + 1 < this._generatedMappings.length) {
              var n = this._generatedMappings[t + 1];
              if (e.generatedLine === n.generatedLine) {
                e.lastGeneratedColumn = n.generatedColumn - 1;
                continue;
              }
            }
            e.lastGeneratedColumn = 1 / 0;
          }
        }),
        (c.prototype.originalPositionFor = function (t) {
          var e = {
              generatedLine: r.getArg(t, "line"),
              generatedColumn: r.getArg(t, "column"),
            },
            n = this._findMapping(
              e,
              this._generatedMappings,
              "generatedLine",
              "generatedColumn",
              r.compareByGeneratedPositionsDeflated,
              r.getArg(t, "bias", l.GREATEST_LOWER_BOUND)
            );
          if (n >= 0) {
            var i = this._generatedMappings[n];
            if (i.generatedLine === e.generatedLine) {
              var o = r.getArg(i, "source", null);
              null !== o &&
                ((o = this._sources.at(o)),
                null != this.sourceRoot && (o = r.join(this.sourceRoot, o)));
              var s = r.getArg(i, "name", null);
              return (
                null !== s && (s = this._names.at(s)),
                {
                  source: o,
                  line: r.getArg(i, "originalLine", null),
                  column: r.getArg(i, "originalColumn", null),
                  name: s,
                }
              );
            }
          }
          return { source: null, line: null, column: null, name: null };
        }),
        (c.prototype.hasContentsOfAllSources = function () {
          return (
            !!this.sourcesContent &&
            this.sourcesContent.length >= this._sources.size() &&
            !this.sourcesContent.some(function (t) {
              return null == t;
            })
          );
        }),
        (c.prototype.sourceContentFor = function (t, e) {
          if (!this.sourcesContent) return null;
          if (
            (null != this.sourceRoot && (t = r.relative(this.sourceRoot, t)),
            this._sources.has(t))
          )
            return this.sourcesContent[this._sources.indexOf(t)];
          var n;
          if (null != this.sourceRoot && (n = r.urlParse(this.sourceRoot))) {
            var i = t.replace(/^file:\/\//, "");
            if ("file" == n.scheme && this._sources.has(i))
              return this.sourcesContent[this._sources.indexOf(i)];
            if ((!n.path || "/" == n.path) && this._sources.has("/" + t))
              return this.sourcesContent[this._sources.indexOf("/" + t)];
          }
          if (e) return null;
          throw new Error('"' + t + '" is not in the SourceMap.');
        }),
        (c.prototype.generatedPositionFor = function (t) {
          var e = r.getArg(t, "source");
          if (
            (null != this.sourceRoot && (e = r.relative(this.sourceRoot, e)),
            !this._sources.has(e))
          )
            return { line: null, column: null, lastColumn: null };
          var n = {
              source: (e = this._sources.indexOf(e)),
              originalLine: r.getArg(t, "line"),
              originalColumn: r.getArg(t, "column"),
            },
            i = this._findMapping(
              n,
              this._originalMappings,
              "originalLine",
              "originalColumn",
              r.compareByOriginalPositions,
              r.getArg(t, "bias", l.GREATEST_LOWER_BOUND)
            );
          if (i >= 0) {
            var o = this._originalMappings[i];
            if (o.source === n.source)
              return {
                line: r.getArg(o, "generatedLine", null),
                column: r.getArg(o, "generatedColumn", null),
                lastColumn: r.getArg(o, "lastGeneratedColumn", null),
              };
          }
          return { line: null, column: null, lastColumn: null };
        }),
        (h.prototype = Object.create(l.prototype)),
        (h.prototype.constructor = l),
        (h.prototype._version = 3),
        Object.defineProperty(h.prototype, "sources", {
          get: function () {
            for (var t = [], e = 0; e < this._sections.length; e++)
              for (
                var n = 0;
                n < this._sections[e].consumer.sources.length;
                n++
              )
                t.push(this._sections[e].consumer.sources[n]);
            return t;
          },
        }),
        (h.prototype.originalPositionFor = function (t) {
          var e = {
              generatedLine: r.getArg(t, "line"),
              generatedColumn: r.getArg(t, "column"),
            },
            n = i.search(e, this._sections, function (t, e) {
              var n = t.generatedLine - e.generatedOffset.generatedLine;
              return n || t.generatedColumn - e.generatedOffset.generatedColumn;
            }),
            o = this._sections[n];
          return o
            ? o.consumer.originalPositionFor({
                line: e.generatedLine - (o.generatedOffset.generatedLine - 1),
                column:
                  e.generatedColumn -
                  (o.generatedOffset.generatedLine === e.generatedLine
                    ? o.generatedOffset.generatedColumn - 1
                    : 0),
                bias: t.bias,
              })
            : { source: null, line: null, column: null, name: null };
        }),
        (h.prototype.hasContentsOfAllSources = function () {
          return this._sections.every(function (t) {
            return t.consumer.hasContentsOfAllSources();
          });
        }),
        (h.prototype.sourceContentFor = function (t, e) {
          for (var n = 0; n < this._sections.length; n++) {
            var r = this._sections[n].consumer.sourceContentFor(t, !0);
            if (r) return r;
          }
          if (e) return null;
          throw new Error('"' + t + '" is not in the SourceMap.');
        }),
        (h.prototype.generatedPositionFor = function (t) {
          for (var e = 0; e < this._sections.length; e++) {
            var n = this._sections[e];
            if (-1 !== n.consumer.sources.indexOf(r.getArg(t, "source"))) {
              var i = n.consumer.generatedPositionFor(t);
              if (i)
                return {
                  line: i.line + (n.generatedOffset.generatedLine - 1),
                  column:
                    i.column +
                    (n.generatedOffset.generatedLine === i.line
                      ? n.generatedOffset.generatedColumn - 1
                      : 0),
                };
            }
          }
          return { line: null, column: null };
        }),
        (h.prototype._parseMappings = function (t, e) {
          (this.__generatedMappings = []), (this.__originalMappings = []);
          for (var n = 0; n < this._sections.length; n++)
            for (
              var i = this._sections[n],
                o = i.consumer._generatedMappings,
                s = 0;
              s < o.length;
              s++
            ) {
              var l = o[s],
                c = i.consumer._sources.at(l.source);
              null !== i.consumer.sourceRoot &&
                (c = r.join(i.consumer.sourceRoot, c)),
                this._sources.add(c),
                (c = this._sources.indexOf(c));
              var u = i.consumer._names.at(l.name);
              this._names.add(u), (u = this._names.indexOf(u));
              var h = {
                source: c,
                generatedLine:
                  l.generatedLine + (i.generatedOffset.generatedLine - 1),
                generatedColumn:
                  l.generatedColumn +
                  (i.generatedOffset.generatedLine === l.generatedLine
                    ? i.generatedOffset.generatedColumn - 1
                    : 0),
                originalLine: l.originalLine,
                originalColumn: l.originalColumn,
                name: u,
              };
              this.__generatedMappings.push(h),
                "number" === typeof h.originalLine &&
                  this.__originalMappings.push(h);
            }
          a(this.__generatedMappings, r.compareByGeneratedPositionsDeflated),
            a(this.__originalMappings, r.compareByOriginalPositions);
        });
    },
    78902: function (t, e, n) {
      var r = n(60647),
        i = n(99479),
        o = n(9817).I,
        s = n(91027).H;
      function a(t) {
        t || (t = {}),
          (this._file = i.getArg(t, "file", null)),
          (this._sourceRoot = i.getArg(t, "sourceRoot", null)),
          (this._skipValidation = i.getArg(t, "skipValidation", !1)),
          (this._sources = new o()),
          (this._names = new o()),
          (this._mappings = new s()),
          (this._sourcesContents = null);
      }
      (a.prototype._version = 3),
        (a.fromSourceMap = function (t) {
          var e = t.sourceRoot,
            n = new a({ file: t.file, sourceRoot: e });
          return (
            t.eachMapping(function (t) {
              var r = {
                generated: { line: t.generatedLine, column: t.generatedColumn },
              };
              null != t.source &&
                ((r.source = t.source),
                null != e && (r.source = i.relative(e, r.source)),
                (r.original = {
                  line: t.originalLine,
                  column: t.originalColumn,
                }),
                null != t.name && (r.name = t.name)),
                n.addMapping(r);
            }),
            t.sources.forEach(function (e) {
              var r = t.sourceContentFor(e);
              null != r && n.setSourceContent(e, r);
            }),
            n
          );
        }),
        (a.prototype.addMapping = function (t) {
          var e = i.getArg(t, "generated"),
            n = i.getArg(t, "original", null),
            r = i.getArg(t, "source", null),
            o = i.getArg(t, "name", null);
          this._skipValidation || this._validateMapping(e, n, r, o),
            null != r &&
              ((r = String(r)), this._sources.has(r) || this._sources.add(r)),
            null != o &&
              ((o = String(o)), this._names.has(o) || this._names.add(o)),
            this._mappings.add({
              generatedLine: e.line,
              generatedColumn: e.column,
              originalLine: null != n && n.line,
              originalColumn: null != n && n.column,
              source: r,
              name: o,
            });
        }),
        (a.prototype.setSourceContent = function (t, e) {
          var n = t;
          null != this._sourceRoot && (n = i.relative(this._sourceRoot, n)),
            null != e
              ? (this._sourcesContents ||
                  (this._sourcesContents = Object.create(null)),
                (this._sourcesContents[i.toSetString(n)] = e))
              : this._sourcesContents &&
                (delete this._sourcesContents[i.toSetString(n)],
                0 === Object.keys(this._sourcesContents).length &&
                  (this._sourcesContents = null));
        }),
        (a.prototype.applySourceMap = function (t, e, n) {
          var r = e;
          if (null == e) {
            if (null == t.file)
              throw new Error(
                'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.'
              );
            r = t.file;
          }
          var s = this._sourceRoot;
          null != s && (r = i.relative(s, r));
          var a = new o(),
            l = new o();
          this._mappings.unsortedForEach(function (e) {
            if (e.source === r && null != e.originalLine) {
              var o = t.originalPositionFor({
                line: e.originalLine,
                column: e.originalColumn,
              });
              null != o.source &&
                ((e.source = o.source),
                null != n && (e.source = i.join(n, e.source)),
                null != s && (e.source = i.relative(s, e.source)),
                (e.originalLine = o.line),
                (e.originalColumn = o.column),
                null != o.name && (e.name = o.name));
            }
            var c = e.source;
            null == c || a.has(c) || a.add(c);
            var u = e.name;
            null == u || l.has(u) || l.add(u);
          }, this),
            (this._sources = a),
            (this._names = l),
            t.sources.forEach(function (e) {
              var r = t.sourceContentFor(e);
              null != r &&
                (null != n && (e = i.join(n, e)),
                null != s && (e = i.relative(s, e)),
                this.setSourceContent(e, r));
            }, this);
        }),
        (a.prototype._validateMapping = function (t, e, n, r) {
          if (
            (!(
              t &&
              "line" in t &&
              "column" in t &&
              t.line > 0 &&
              t.column >= 0
            ) ||
              e ||
              n ||
              r) &&
            !(
              t &&
              "line" in t &&
              "column" in t &&
              e &&
              "line" in e &&
              "column" in e &&
              t.line > 0 &&
              t.column >= 0 &&
              e.line > 0 &&
              e.column >= 0 &&
              n
            )
          )
            throw new Error(
              "Invalid mapping: " +
                JSON.stringify({
                  generated: t,
                  source: n,
                  original: e,
                  name: r,
                })
            );
        }),
        (a.prototype._serializeMappings = function () {
          for (
            var t,
              e,
              n,
              o,
              s = 0,
              a = 1,
              l = 0,
              c = 0,
              u = 0,
              h = 0,
              p = "",
              d = this._mappings.toArray(),
              f = 0,
              m = d.length;
            f < m;
            f++
          ) {
            if (((t = ""), (e = d[f]).generatedLine !== a))
              for (s = 0; e.generatedLine !== a; ) (t += ";"), a++;
            else if (f > 0) {
              if (!i.compareByGeneratedPositionsInflated(e, d[f - 1])) continue;
              t += ",";
            }
            (t += r.encode(e.generatedColumn - s)),
              (s = e.generatedColumn),
              null != e.source &&
                ((o = this._sources.indexOf(e.source)),
                (t += r.encode(o - h)),
                (h = o),
                (t += r.encode(e.originalLine - 1 - c)),
                (c = e.originalLine - 1),
                (t += r.encode(e.originalColumn - l)),
                (l = e.originalColumn),
                null != e.name &&
                  ((n = this._names.indexOf(e.name)),
                  (t += r.encode(n - u)),
                  (u = n))),
              (p += t);
          }
          return p;
        }),
        (a.prototype._generateSourcesContent = function (t, e) {
          return t.map(function (t) {
            if (!this._sourcesContents) return null;
            null != e && (t = i.relative(e, t));
            var n = i.toSetString(t);
            return Object.prototype.hasOwnProperty.call(
              this._sourcesContents,
              n
            )
              ? this._sourcesContents[n]
              : null;
          }, this);
        }),
        (a.prototype.toJSON = function () {
          var t = {
            version: this._version,
            sources: this._sources.toArray(),
            names: this._names.toArray(),
            mappings: this._serializeMappings(),
          };
          return (
            null != this._file && (t.file = this._file),
            null != this._sourceRoot && (t.sourceRoot = this._sourceRoot),
            this._sourcesContents &&
              (t.sourcesContent = this._generateSourcesContent(
                t.sources,
                t.sourceRoot
              )),
            t
          );
        }),
        (a.prototype.toString = function () {
          return JSON.stringify(this.toJSON());
        }),
        (e.SourceMapGenerator = a);
    },
    25786: function (t, e, n) {
      var r = n(78902).SourceMapGenerator,
        i = n(99479),
        o = /(\r?\n)/,
        s = "$$$isSourceNode$$$";
      function a(t, e, n, r, i) {
        (this.children = []),
          (this.sourceContents = {}),
          (this.line = null == t ? null : t),
          (this.column = null == e ? null : e),
          (this.source = null == n ? null : n),
          (this.name = null == i ? null : i),
          (this[s] = !0),
          null != r && this.add(r);
      }
      (a.fromStringWithSourceMap = function (t, e, n) {
        var r = new a(),
          s = t.split(o),
          l = function () {
            return s.shift() + (s.shift() || "");
          },
          c = 1,
          u = 0,
          h = null;
        return (
          e.eachMapping(function (t) {
            if (null !== h) {
              if (!(c < t.generatedLine)) {
                var e = (n = s[0]).substr(0, t.generatedColumn - u);
                return (
                  (s[0] = n.substr(t.generatedColumn - u)),
                  (u = t.generatedColumn),
                  p(h, e),
                  void (h = t)
                );
              }
              p(h, l()), c++, (u = 0);
            }
            for (; c < t.generatedLine; ) r.add(l()), c++;
            if (u < t.generatedColumn) {
              var n = s[0];
              r.add(n.substr(0, t.generatedColumn)),
                (s[0] = n.substr(t.generatedColumn)),
                (u = t.generatedColumn);
            }
            h = t;
          }, this),
          s.length > 0 && (h && p(h, l()), r.add(s.join(""))),
          e.sources.forEach(function (t) {
            var o = e.sourceContentFor(t);
            null != o &&
              (null != n && (t = i.join(n, t)), r.setSourceContent(t, o));
          }),
          r
        );
        function p(t, e) {
          if (null === t || void 0 === t.source) r.add(e);
          else {
            var o = n ? i.join(n, t.source) : t.source;
            r.add(new a(t.originalLine, t.originalColumn, o, e, t.name));
          }
        }
      }),
        (a.prototype.add = function (t) {
          if (Array.isArray(t))
            t.forEach(function (t) {
              this.add(t);
            }, this);
          else {
            if (!t[s] && "string" !== typeof t)
              throw new TypeError(
                "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " +
                  t
              );
            t && this.children.push(t);
          }
          return this;
        }),
        (a.prototype.prepend = function (t) {
          if (Array.isArray(t))
            for (var e = t.length - 1; e >= 0; e--) this.prepend(t[e]);
          else {
            if (!t[s] && "string" !== typeof t)
              throw new TypeError(
                "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " +
                  t
              );
            this.children.unshift(t);
          }
          return this;
        }),
        (a.prototype.walk = function (t) {
          for (var e, n = 0, r = this.children.length; n < r; n++)
            (e = this.children[n])[s]
              ? e.walk(t)
              : "" !== e &&
                t(e, {
                  source: this.source,
                  line: this.line,
                  column: this.column,
                  name: this.name,
                });
        }),
        (a.prototype.join = function (t) {
          var e,
            n,
            r = this.children.length;
          if (r > 0) {
            for (e = [], n = 0; n < r - 1; n++)
              e.push(this.children[n]), e.push(t);
            e.push(this.children[n]), (this.children = e);
          }
          return this;
        }),
        (a.prototype.replaceRight = function (t, e) {
          var n = this.children[this.children.length - 1];
          return (
            n[s]
              ? n.replaceRight(t, e)
              : "string" === typeof n
              ? (this.children[this.children.length - 1] = n.replace(t, e))
              : this.children.push("".replace(t, e)),
            this
          );
        }),
        (a.prototype.setSourceContent = function (t, e) {
          this.sourceContents[i.toSetString(t)] = e;
        }),
        (a.prototype.walkSourceContents = function (t) {
          for (var e = 0, n = this.children.length; e < n; e++)
            this.children[e][s] && this.children[e].walkSourceContents(t);
          var r = Object.keys(this.sourceContents);
          for (e = 0, n = r.length; e < n; e++)
            t(i.fromSetString(r[e]), this.sourceContents[r[e]]);
        }),
        (a.prototype.toString = function () {
          var t = "";
          return (
            this.walk(function (e) {
              t += e;
            }),
            t
          );
        }),
        (a.prototype.toStringWithSourceMap = function (t) {
          var e = { code: "", line: 1, column: 0 },
            n = new r(t),
            i = !1,
            o = null,
            s = null,
            a = null,
            l = null;
          return (
            this.walk(function (t, r) {
              (e.code += t),
                null !== r.source && null !== r.line && null !== r.column
                  ? ((o === r.source &&
                      s === r.line &&
                      a === r.column &&
                      l === r.name) ||
                      n.addMapping({
                        source: r.source,
                        original: { line: r.line, column: r.column },
                        generated: { line: e.line, column: e.column },
                        name: r.name,
                      }),
                    (o = r.source),
                    (s = r.line),
                    (a = r.column),
                    (l = r.name),
                    (i = !0))
                  : i &&
                    (n.addMapping({
                      generated: { line: e.line, column: e.column },
                    }),
                    (o = null),
                    (i = !1));
              for (var c = 0, u = t.length; c < u; c++)
                10 === t.charCodeAt(c)
                  ? (e.line++,
                    (e.column = 0),
                    c + 1 === u
                      ? ((o = null), (i = !1))
                      : i &&
                        n.addMapping({
                          source: r.source,
                          original: { line: r.line, column: r.column },
                          generated: { line: e.line, column: e.column },
                          name: r.name,
                        }))
                  : e.column++;
            }),
            this.walkSourceContents(function (t, e) {
              n.setSourceContent(t, e);
            }),
            { code: e.code, map: n }
          );
        }),
        (e.SourceNode = a);
    },
    99479: function (t, e) {
      e.getArg = function (t, e, n) {
        if (e in t) return t[e];
        if (3 === arguments.length) return n;
        throw new Error('"' + e + '" is a required argument.');
      };
      var n = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/,
        r = /^data:.+\,.+$/;
      function i(t) {
        var e = t.match(n);
        return e
          ? { scheme: e[1], auth: e[2], host: e[3], port: e[4], path: e[5] }
          : null;
      }
      function o(t) {
        var e = "";
        return (
          t.scheme && (e += t.scheme + ":"),
          (e += "//"),
          t.auth && (e += t.auth + "@"),
          t.host && (e += t.host),
          t.port && (e += ":" + t.port),
          t.path && (e += t.path),
          e
        );
      }
      function s(t) {
        var n = t,
          r = i(t);
        if (r) {
          if (!r.path) return t;
          n = r.path;
        }
        for (
          var s,
            a = e.isAbsolute(n),
            l = n.split(/\/+/),
            c = 0,
            u = l.length - 1;
          u >= 0;
          u--
        )
          "." === (s = l[u])
            ? l.splice(u, 1)
            : ".." === s
            ? c++
            : c > 0 &&
              ("" === s
                ? (l.splice(u + 1, c), (c = 0))
                : (l.splice(u, 2), c--));
        return (
          "" === (n = l.join("/")) && (n = a ? "/" : "."),
          r ? ((r.path = n), o(r)) : n
        );
      }
      (e.urlParse = i),
        (e.urlGenerate = o),
        (e.normalize = s),
        (e.join = function (t, e) {
          "" === t && (t = "."), "" === e && (e = ".");
          var n = i(e),
            a = i(t);
          if ((a && (t = a.path || "/"), n && !n.scheme))
            return a && (n.scheme = a.scheme), o(n);
          if (n || e.match(r)) return e;
          if (a && !a.host && !a.path) return (a.host = e), o(a);
          var l = "/" === e.charAt(0) ? e : s(t.replace(/\/+$/, "") + "/" + e);
          return a ? ((a.path = l), o(a)) : l;
        }),
        (e.isAbsolute = function (t) {
          return "/" === t.charAt(0) || !!t.match(n);
        }),
        (e.relative = function (t, e) {
          "" === t && (t = "."), (t = t.replace(/\/$/, ""));
          for (var n = 0; 0 !== e.indexOf(t + "/"); ) {
            var r = t.lastIndexOf("/");
            if (r < 0) return e;
            if ((t = t.slice(0, r)).match(/^([^\/]+:\/)?\/*$/)) return e;
            ++n;
          }
          return Array(n + 1).join("../") + e.substr(t.length + 1);
        });
      var a = !("__proto__" in Object.create(null));
      function l(t) {
        return t;
      }
      function c(t) {
        if (!t) return !1;
        var e = t.length;
        if (e < 9) return !1;
        if (
          95 !== t.charCodeAt(e - 1) ||
          95 !== t.charCodeAt(e - 2) ||
          111 !== t.charCodeAt(e - 3) ||
          116 !== t.charCodeAt(e - 4) ||
          111 !== t.charCodeAt(e - 5) ||
          114 !== t.charCodeAt(e - 6) ||
          112 !== t.charCodeAt(e - 7) ||
          95 !== t.charCodeAt(e - 8) ||
          95 !== t.charCodeAt(e - 9)
        )
          return !1;
        for (var n = e - 10; n >= 0; n--) if (36 !== t.charCodeAt(n)) return !1;
        return !0;
      }
      function u(t, e) {
        return t === e ? 0 : t > e ? 1 : -1;
      }
      (e.toSetString = a
        ? l
        : function (t) {
            return c(t) ? "$" + t : t;
          }),
        (e.fromSetString = a
          ? l
          : function (t) {
              return c(t) ? t.slice(1) : t;
            }),
        (e.compareByOriginalPositions = function (t, e, n) {
          var r = t.source - e.source;
          return 0 !== r ||
            0 !== (r = t.originalLine - e.originalLine) ||
            0 !== (r = t.originalColumn - e.originalColumn) ||
            n ||
            0 !== (r = t.generatedColumn - e.generatedColumn) ||
            0 !== (r = t.generatedLine - e.generatedLine)
            ? r
            : t.name - e.name;
        }),
        (e.compareByGeneratedPositionsDeflated = function (t, e, n) {
          var r = t.generatedLine - e.generatedLine;
          return 0 !== r ||
            0 !== (r = t.generatedColumn - e.generatedColumn) ||
            n ||
            0 !== (r = t.source - e.source) ||
            0 !== (r = t.originalLine - e.originalLine) ||
            0 !== (r = t.originalColumn - e.originalColumn)
            ? r
            : t.name - e.name;
        }),
        (e.compareByGeneratedPositionsInflated = function (t, e) {
          var n = t.generatedLine - e.generatedLine;
          return 0 !== n ||
            0 !== (n = t.generatedColumn - e.generatedColumn) ||
            0 !== (n = u(t.source, e.source)) ||
            0 !== (n = t.originalLine - e.originalLine) ||
            0 !== (n = t.originalColumn - e.originalColumn)
            ? n
            : u(t.name, e.name);
        });
    },
    17252: function (t, e, n) {
      (e.SourceMapGenerator = n(78902).SourceMapGenerator),
        (e.SourceMapConsumer = n(35667).SourceMapConsumer),
        (e.SourceNode = n(25786).SourceNode);
    },
    64358: function (t, e, n) {
      var r, i, o;
      !(function (s, a) {
        "use strict";
        (i = [n(17252), n(59829)]),
          void 0 ===
            (o =
              "function" ===
              typeof (r = function (t, e) {
                function n(t) {
                  return new Promise(function (e, n) {
                    var r = new XMLHttpRequest();
                    r.open("get", t),
                      (r.onerror = n),
                      (r.onreadystatechange = function () {
                        4 === r.readyState &&
                          (r.status >= 200 && r.status < 300
                            ? e(r.responseText)
                            : n(
                                new Error(
                                  "HTTP status: " +
                                    r.status +
                                    " retrieving " +
                                    t
                                )
                              ));
                      }),
                      r.send();
                  });
                }
                function r(t) {
                  if ("undefined" !== typeof window && window.atob)
                    return window.atob(t);
                  throw new Error(
                    "You must supply a polyfill for window.atob in this environment"
                  );
                }
                function i(t) {
                  if ("undefined" !== typeof JSON && JSON.parse)
                    return JSON.parse(t);
                  throw new Error(
                    "You must supply a polyfill for JSON.parse in this environment"
                  );
                }
                function o(t, e) {
                  for (
                    var n,
                      r = /function\s+([^(]*?)\s*\(([^)]*)\)/,
                      i =
                        /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*function\b/,
                      o =
                        /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*(?:eval|new Function)\b/,
                      s = t.split("\n"),
                      a = "",
                      l = Math.min(e, 20),
                      c = 0;
                    c < l;
                    ++c
                  ) {
                    var u = s[e - c - 1],
                      h = u.indexOf("//");
                    if ((h >= 0 && (u = u.substr(0, h)), u)) {
                      if (((a = u + a), (n = i.exec(a)) && n[1])) return n[1];
                      if ((n = r.exec(a)) && n[1]) return n[1];
                      if ((n = o.exec(a)) && n[1]) return n[1];
                    }
                  }
                }
                function s() {
                  if (
                    "function" !== typeof Object.defineProperty ||
                    "function" !== typeof Object.create
                  )
                    throw new Error(
                      "Unable to consume source maps in older browsers"
                    );
                }
                function a(t) {
                  if ("object" !== typeof t)
                    throw new TypeError("Given StackFrame is not an object");
                  if ("string" !== typeof t.fileName)
                    throw new TypeError("Given file name is not a String");
                  if (
                    "number" !== typeof t.lineNumber ||
                    t.lineNumber % 1 !== 0 ||
                    t.lineNumber < 1
                  )
                    throw new TypeError(
                      "Given line number must be a positive integer"
                    );
                  if (
                    "number" !== typeof t.columnNumber ||
                    t.columnNumber % 1 !== 0 ||
                    t.columnNumber < 0
                  )
                    throw new TypeError(
                      "Given column number must be a non-negative integer"
                    );
                  return !0;
                }
                function l(t) {
                  var e = /\/\/[#@] ?sourceMappingURL=([^\s'"]+)\s*$/.exec(t);
                  if (e && e[1]) return e[1];
                  throw new Error("sourceMappingURL not found");
                }
                function c(n, r, i) {
                  return new Promise(function (o, s) {
                    var a = new t.SourceMapConsumer(r),
                      l = a.originalPositionFor({
                        line: n.lineNumber,
                        column: n.columnNumber,
                      });
                    if (l.source) {
                      var c = a.sourceContentFor(l.source);
                      c && (i[l.source] = c),
                        o(
                          new e(
                            l.name || n.functionName,
                            n.args,
                            l.source,
                            l.line,
                            l.column
                          )
                        );
                    } else s(new Error("Could not get original source for given stackframe and source map"));
                  });
                }
                return function t(u) {
                  if (!(this instanceof t)) return new t(u);
                  (u = u || {}),
                    (this.sourceCache = u.sourceCache || {}),
                    (this.ajax = u.ajax || n),
                    (this._atob = u.atob || r),
                    (this._get = function (t) {
                      return new Promise(
                        function (e, n) {
                          var r = "data:" === t.substr(0, 5);
                          if (this.sourceCache[t]) e(this.sourceCache[t]);
                          else if (u.offline && !r)
                            n(
                              new Error(
                                "Cannot make network requests in offline mode"
                              )
                            );
                          else if (r) {
                            var i =
                                /^data:application\/json;([\w=:"-]+;)*base64,/,
                              o = t.match(i);
                            if (o) {
                              var s = o[0].length,
                                a = t.substr(s),
                                l = this._atob(a);
                              (this.sourceCache[t] = l), e(l);
                            } else
                              n(
                                new Error(
                                  "The encoding of the inline sourcemap is not supported"
                                )
                              );
                          } else {
                            var c = this.ajax(t, { method: "get" });
                            (this.sourceCache[t] = c), c.then(e, n);
                          }
                        }.bind(this)
                      );
                    }),
                    (this.pinpoint = function (t) {
                      return new Promise(
                        function (e, n) {
                          this.getMappedLocation(t).then(
                            function (t) {
                              function n() {
                                e(t);
                              }
                              this.findFunctionName(t).then(e, n).catch(n);
                            }.bind(this),
                            n
                          );
                        }.bind(this)
                      );
                    }),
                    (this.findFunctionName = function (t) {
                      return new Promise(
                        function (n, r) {
                          a(t),
                            this._get(t.fileName)
                              .then(function (r) {
                                var i = t.lineNumber,
                                  s = t.columnNumber,
                                  a = o(r, i, s);
                                n(a ? new e(a, t.args, t.fileName, i, s) : t);
                              }, r)
                              .catch(r);
                        }.bind(this)
                      );
                    }),
                    (this.getMappedLocation = function (t) {
                      return new Promise(
                        function (e, n) {
                          s(), a(t);
                          var r = this.sourceCache,
                            o = t.fileName;
                          this._get(o)
                            .then(
                              function (s) {
                                var a = l(s),
                                  u = "data:" === a.substr(0, 5),
                                  h = o.substring(0, o.lastIndexOf("/") + 1);
                                "/" === a[0] ||
                                  u ||
                                  /^https?:\/\/|^\/\//i.test(a) ||
                                  (a = h + a),
                                  this._get(a)
                                    .then(function (n) {
                                      "string" === typeof n &&
                                        (n = i(n.replace(/^\)\]\}'/, ""))),
                                        "undefined" === typeof n.sourceRoot &&
                                          (n.sourceRoot = h),
                                        c(t, n, r)
                                          .then(e)
                                          .catch(function () {
                                            e(t);
                                          });
                                    }, n)
                                    .catch(n);
                              }.bind(this),
                              n
                            )
                            .catch(n);
                        }.bind(this)
                      );
                    });
                };
              })
                ? r.apply(e, i)
                : r) || (t.exports = o);
      })();
    },
    70401: function (t, e, n) {
      var r, i, o;
      !(function (s, a) {
        "use strict";
        (i = [n(79180), n(34595), n(64358)]),
          (r = function (t, e, n) {
            var r = {
                filter: function (t) {
                  return (
                    -1 === (t.functionName || "").indexOf("StackTrace$$") &&
                    -1 ===
                      (t.functionName || "").indexOf("ErrorStackParser$$") &&
                    -1 === (t.functionName || "").indexOf("StackTraceGPS$$") &&
                    -1 === (t.functionName || "").indexOf("StackGenerator$$")
                  );
                },
                sourceCache: {},
              },
              i = function () {
                try {
                  throw new Error();
                } catch (t) {
                  return t;
                }
              };
            function o(t, e) {
              var n = {};
              return (
                [t, e].forEach(function (t) {
                  for (var e in t) t.hasOwnProperty(e) && (n[e] = t[e]);
                  return n;
                }),
                n
              );
            }
            function s(t) {
              return t.stack || t["opera#sourceloc"];
            }
            function a(t, e) {
              return "function" === typeof e ? t.filter(e) : t;
            }
            return {
              get: function (t) {
                var e = i();
                return s(e)
                  ? this.fromError(e, t)
                  : this.generateArtificially(t);
              },
              getSync: function (n) {
                n = o(r, n);
                var l = i();
                return a(s(l) ? t.parse(l) : e.backtrace(n), n.filter);
              },
              fromError: function (e, i) {
                i = o(r, i);
                var s = new n(i);
                return new Promise(
                  function (n) {
                    var r = a(t.parse(e), i.filter);
                    n(
                      Promise.all(
                        r.map(function (t) {
                          return new Promise(function (e) {
                            function n() {
                              e(t);
                            }
                            s.pinpoint(t).then(e, n).catch(n);
                          });
                        })
                      )
                    );
                  }.bind(this)
                );
              },
              generateArtificially: function (t) {
                t = o(r, t);
                var n = e.backtrace(t);
                return (
                  "function" === typeof t.filter && (n = n.filter(t.filter)),
                  Promise.resolve(n)
                );
              },
              instrument: function (t, e, n, r) {
                if ("function" !== typeof t)
                  throw new Error("Cannot instrument non-function object");
                if ("function" === typeof t.__stacktraceOriginalFn) return t;
                var i = function () {
                  try {
                    return (
                      this.get().then(e, n).catch(n),
                      t.apply(r || this, arguments)
                    );
                  } catch (i) {
                    throw (s(i) && this.fromError(i).then(e, n).catch(n), i);
                  }
                }.bind(this);
                return (i.__stacktraceOriginalFn = t), i;
              },
              deinstrument: function (t) {
                if ("function" !== typeof t)
                  throw new Error("Cannot de-instrument non-function object");
                return "function" === typeof t.__stacktraceOriginalFn
                  ? t.__stacktraceOriginalFn
                  : t;
              },
              report: function (t, e, n) {
                return new Promise(function (r, i) {
                  var o = new XMLHttpRequest();
                  (o.onerror = i),
                    (o.onreadystatechange = function () {
                      4 === o.readyState &&
                        (o.status >= 200 && o.status < 400
                          ? r(o.responseText)
                          : i(
                              new Error(
                                "POST to " +
                                  e +
                                  " failed with status: " +
                                  o.status
                              )
                            ));
                    }),
                    o.open("post", e),
                    o.setRequestHeader("Content-Type", "application/json");
                  var s = { stack: t };
                  void 0 !== n && (s.message = n), o.send(JSON.stringify(s));
                });
              },
            };
          }),
          void 0 === (o = "function" === typeof r ? r.apply(e, i) : r) ||
            (t.exports = o);
      })();
    },
    86874: function (t, e, n) {
      "use strict";
      e.G = void 0;
      var r = n(3836);
      Object.defineProperty(e, "G", {
        enumerable: !0,
        get: function () {
          return r.StopWatch;
        },
      });
    },
    3836: function (t, e, n) {
      "use strict";
      Object.defineProperty(e, "__esModule", { value: !0 }),
        (e.StopWatch = void 0);
      const r = n(26173);
      class i {
        constructor(t = "") {
          (this.currentTaskName = null),
            (this.startTimeMillis = 0),
            (this.totalTimeMillis = 0),
            (this.taskList = []),
            (this.id = t);
        }
        start(t = "") {
          null !== this.currentTaskName &&
            this.throwError("Can't start StopWatch: it's already running"),
            (this.currentTaskName = t),
            (this.startTimeMillis = Date.now());
        }
        stop() {
          null === this.currentTaskName &&
            this.throwError("Can't stop StopWatch: it's not running");
          const t = Date.now() - this.startTimeMillis;
          this.totalTimeMillis += t;
          const e = new r.TaskInfo(this.currentTaskName, t);
          this.taskList.push(e), (this.currentTaskName = null);
        }
        prettyPrint() {
          const t = [this.shortSummary()];
          this.taskList.length
            ? (t.push("------------------------------------------"),
              t.push("ms \t\t % \t\t Task name"),
              t.push("------------------------------------------"),
              this.taskList.forEach((e) => {
                let n = "0";
                try {
                  n = e.calculatePercentage(this.totalTimeMillis);
                } catch (r) {}
                t.push(`${e.timeMills} \t\t ${n} \t\t ${e.taskName}`);
              }))
            : t.push(i.NoTaskMessage);
          const e = t.join("\n");
          return console.info(e), e;
        }
        getTask(t) {
          const e = this.taskList.find((e) => e.taskName === t);
          return (
            null === e ||
              void 0 === e ||
              e.calculatePercentage(this.totalTimeMillis),
            e
          );
        }
        getTotalTime() {
          return this.totalTimeMillis;
        }
        shortSummary() {
          return `StopWatch '${this.id}' running time (millis) = ${this.totalTimeMillis}`;
        }
        isRunning() {
          return null !== this.currentTaskName;
        }
        getTaskCount() {
          return this.taskList.length;
        }
        throwError(t) {
          throw new Error(t);
        }
      }
      (e.StopWatch = i), (i.NoTaskMessage = "No task info kept");
    },
    26173: function (t, e) {
      "use strict";
      Object.defineProperty(e, "__esModule", { value: !0 }),
        (e.TaskInfo = void 0);
      e.TaskInfo = class {
        constructor(t, e) {
          (this._taskName = t), (this._timeMillis = e);
        }
        get taskName() {
          return this._taskName;
        }
        get timeMills() {
          return this._timeMillis;
        }
        get percentage() {
          return this._percentage;
        }
        calculatePercentage(t) {
          return (
            (this._percentage = ((100 * this._timeMillis) / t).toFixed(2)),
            this._percentage
          );
        }
      };
    },
    41465: function (t, e, n) {
      function r(t) {
        if (!t.options.indentation && !t.options.lineSeparator) return;
        let e;
        for (t.content += t.options.lineSeparator, e = 0; e < t.level; e++)
          t.content += t.options.indentation;
      }
      function i(t, e) {
        t.content += e;
      }
      function o(t, e, n) {
        if ("string" === typeof t.content)
          !(function (t, e, n) {
            n || (t.content = t.content.trim());
            t.content.length > 0 &&
              (!n && e.content.length > 0 && r(e), i(e, t.content));
          })(t, e, n);
        else if ("Element" === t.type)
          !(function (t, e, n) {
            !n && e.content.length > 0 && r(e);
            if ((i(e, "<" + t.name), s(e, t.attributes), null === t.children)) {
              const t = e.options.whiteSpaceAtEndOfSelfclosingTag
                ? " />"
                : "/>";
              i(e, t);
            } else if (0 === t.children.length) i(e, "></" + t.name + ">");
            else {
              i(e, ">"), e.level++;
              let s = "preserve" === t.attributes["xml:space"];
              if (!s && e.options.collapseContent) {
                let e = !1,
                  n = !1,
                  r = !1;
                t.children.forEach(function (i, o) {
                  "Text" === i.type
                    ? (i.content.includes("\n")
                        ? ((n = !0), (i.content = i.content.trim()))
                        : (0 !== o && o !== t.children.length - 1) ||
                          (0 === i.content.trim().length && (i.content = "")),
                      i.content.length > 0 && (e = !0))
                    : "CDATA" === i.type
                    ? (e = !0)
                    : (r = !0);
                }),
                  !e || (r && n) || (s = !0);
              }
              t.children.forEach(function (t) {
                o(t, e, n || s, e.options);
              }),
                e.level--,
                n || s || r(e),
                i(e, "</" + t.name + ">");
            }
          })(t, e, n);
        else {
          if ("ProcessingInstruction" !== t.type)
            throw new Error("Unknown node type: " + t.type);
          a(t, e);
        }
      }
      function s(t, e) {
        Object.keys(e).forEach(function (n) {
          const r = e[n].replace(/"/g, "&quot;");
          i(t, " " + n + '="' + r + '"');
        });
      }
      function a(t, e) {
        e.content.length > 0 && r(e),
          i(e, "<?" + t.name),
          s(e, t.attributes),
          i(e, "?>");
      }
      t.exports = function (t, e = {}) {
        (e.indentation = "indentation" in e ? e.indentation : "    "),
          (e.collapseContent = !0 === e.collapseContent),
          (e.lineSeparator = "lineSeparator" in e ? e.lineSeparator : "\r\n"),
          (e.whiteSpaceAtEndOfSelfclosingTag =
            !!e.whiteSpaceAtEndOfSelfclosingTag);
        const r = n(37121)(t, { filter: e.filter }),
          i = { content: "", level: 0, options: e };
        return (
          r.declaration && a(r.declaration, i),
          r.children.forEach(function (t) {
            o(t, i, !1);
          }),
          i.content.replace(/\r\n/g, "\n").replace(/\n/g, e.lineSeparator)
        );
      };
    },
    37121: function (t) {
      t.exports = function (t, e = {}) {
        function n() {
          return (
            o() ||
            (function () {
              const t = l(/^([^<]+)/);
              if (t) {
                const n = { type: "Text", content: t[1] };
                return { excluded: !1 === e.filter(n), node: n };
              }
            })() ||
            s() ||
            (function () {
              if (t.startsWith("<![CDATA[")) {
                const n = t.indexOf("]]>");
                if (n > -1) {
                  const r = n + 3,
                    i = { type: "CDATA", content: t.substring(0, r) };
                  return (
                    (t = t.slice(r)), { excluded: !1 === e.filter(i), node: i }
                  );
                }
              }
            })()
          );
        }
        function r() {
          return (
            l(/\s*/),
            o(!0) ||
              s() ||
              (function () {
                const t = l(/^<!DOCTYPE\s+[^>]*>/);
                if (t) {
                  const n = { type: "DocumentType", content: t[0] };
                  return { excluded: !1 === e.filter(n), node: n };
                }
              })() ||
              i(!1)
          );
        }
        function i(t) {
          const n = l(t ? /^<\?(xml)\s*/ : /^<\?([\w-:.]+)\s*/);
          if (!n) return;
          const r = {
            name: n[1],
            type: "ProcessingInstruction",
            attributes: {},
          };
          for (; !c() && !u("?>"); ) {
            const t = a();
            if (!t) return r;
            r.attributes[t.name] = t.value;
          }
          return l(/\?>/), { excluded: !t && !1 === e.filter(r), node: r };
        }
        function o(t) {
          const r = l(/^<([\w-:.]+)\s*/);
          if (!r) return;
          const i = {
            type: "Element",
            name: r[1],
            attributes: {},
            children: [],
          };
          for (; !(c() || u(">") || u("?>") || u("/>")); ) {
            const t = a();
            if (!t) return i;
            i.attributes[t.name] = t.value;
          }
          const o = !t && !1 === e.filter(i);
          if (l(/^\s*\/>/))
            return (i.children = null), { excluded: o, node: i };
          if ((l(/\??>/), !o)) {
            let t = n();
            for (; t; ) t.excluded || i.children.push(t.node), (t = n());
          }
          return l(/^<\/[\w-:.]+>/), { excluded: o, node: i };
        }
        function s() {
          const t = l(/^<!--[\s\S]*?-->/);
          if (t) {
            const n = { type: "Comment", content: t[0] };
            return { excluded: !1 === e.filter(n), node: n };
          }
        }
        function a() {
          const t = l(/([\w-:.]+)\s*=\s*("[^"]*"|'[^']*'|\w+)\s*/);
          var e;
          if (t)
            return {
              name: t[1],
              value: ((e = t[2]), e.replace(/^['"]|['"]$/g, "")),
            };
        }
        function l(e) {
          const n = t.match(e);
          if (n) return (t = t.slice(n[0].length)), n;
        }
        function c() {
          return 0 === t.length;
        }
        function u(e) {
          return 0 === t.indexOf(e);
        }
        return (
          (e.filter = e.filter || (() => !0)),
          (t = t.trim()),
          (function () {
            const t = i(!0),
              e = [];
            let n,
              o = r();
            for (; o; ) {
              if ("Element" === o.node.type) {
                if (n) throw new Error("Found multiple root nodes");
                n = o.node;
              }
              o.excluded || e.push(o.node), (o = r());
            }
            if (!n) throw new Error("Failed to parse XML");
            return { declaration: t ? t.node : null, root: n, children: e };
          })()
        );
      };
    },
    24654: function () {},
    30907: function (t, e, n) {
      "use strict";
      function r(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
        return r;
      }
      n.d(e, {
        Z: function () {
          return r;
        },
      });
    },
    15671: function (t, e, n) {
      "use strict";
      function r(t, e) {
        if (!(t instanceof e))
          throw new TypeError("Cannot call a class as a function");
      }
      n.d(e, {
        Z: function () {
          return r;
        },
      });
    },
    43144: function (t, e, n) {
      "use strict";
      function r(t, e) {
        for (var n = 0; n < e.length; n++) {
          var r = e[n];
          (r.enumerable = r.enumerable || !1),
            (r.configurable = !0),
            "value" in r && (r.writable = !0),
            Object.defineProperty(t, r.key, r);
        }
      }
      function i(t, e, n) {
        return e && r(t.prototype, e), n && r(t, n), t;
      }
      n.d(e, {
        Z: function () {
          return i;
        },
      });
    },
    4942: function (t, e, n) {
      "use strict";
      function r(t, e, n) {
        return (
          e in t
            ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (t[e] = n),
          t
        );
      }
      n.d(e, {
        Z: function () {
          return r;
        },
      });
    },
    87462: function (t, e, n) {
      "use strict";
      function r() {
        return (
          (r =
            Object.assign ||
            function (t) {
              for (var e = 1; e < arguments.length; e++) {
                var n = arguments[e];
                for (var r in n)
                  Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
              }
              return t;
            }),
          r.apply(this, arguments)
        );
      }
      n.d(e, {
        Z: function () {
          return r;
        },
      });
    },
    60136: function (t, e, n) {
      "use strict";
      n.d(e, {
        Z: function () {
          return i;
        },
      });
      var r = n(89611);
      function i(t, e) {
        if ("function" !== typeof e && null !== e)
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        (t.prototype = Object.create(e && e.prototype, {
          constructor: { value: t, writable: !0, configurable: !0 },
        })),
          e && (0, r.Z)(t, e);
      }
    },
    94578: function (t, e, n) {
      "use strict";
      n.d(e, {
        Z: function () {
          return i;
        },
      });
      var r = n(89611);
      function i(t, e) {
        (t.prototype = Object.create(e.prototype)),
          (t.prototype.constructor = t),
          (0, r.Z)(t, e);
      }
    },
    91: function (t, e, n) {
      "use strict";
      function r(t, e) {
        if (null == t) return {};
        var n,
          r,
          i = (function (t, e) {
            if (null == t) return {};
            var n,
              r,
              i = {},
              o = Object.keys(t);
            for (r = 0; r < o.length; r++)
              (n = o[r]), e.indexOf(n) >= 0 || (i[n] = t[n]);
            return i;
          })(t, e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(t);
          for (r = 0; r < o.length; r++)
            (n = o[r]),
              e.indexOf(n) >= 0 ||
                (Object.prototype.propertyIsEnumerable.call(t, n) &&
                  (i[n] = t[n]));
        }
        return i;
      }
      n.d(e, {
        Z: function () {
          return r;
        },
      });
    },
    89611: function (t, e, n) {
      "use strict";
      function r(t, e) {
        return (
          (r =
            Object.setPrototypeOf ||
            function (t, e) {
              return (t.__proto__ = e), t;
            }),
          r(t, e)
        );
      }
      n.d(e, {
        Z: function () {
          return r;
        },
      });
    },
    41451: function (t, e, n) {
      "use strict";
      n.d(e, {
        Z: function () {
          return o;
        },
      });
      var r = n(30907);
      var i = n(40181);
      function o(t) {
        return (
          (function (t) {
            if (Array.isArray(t)) return (0, r.Z)(t);
          })(t) ||
          (function (t) {
            if (
              ("undefined" !== typeof Symbol && null != t[Symbol.iterator]) ||
              null != t["@@iterator"]
            )
              return Array.from(t);
          })(t) ||
          (0, i.Z)(t) ||
          (function () {
            throw new TypeError(
              "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
            );
          })()
        );
      }
    },
    71002: function (t, e, n) {
      "use strict";
      function r(t) {
        return (
          (r =
            "function" === typeof Symbol && "symbol" === typeof Symbol.iterator
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t &&
                    "function" === typeof Symbol &&
                    t.constructor === Symbol &&
                    t !== Symbol.prototype
                    ? "symbol"
                    : typeof t;
                }),
          r(t)
        );
      }
      n.d(e, {
        Z: function () {
          return r;
        },
      });
    },
    40181: function (t, e, n) {
      "use strict";
      n.d(e, {
        Z: function () {
          return i;
        },
      });
      var r = n(30907);
      function i(t, e) {
        if (t) {
          if ("string" === typeof t) return (0, r.Z)(t, e);
          var n = Object.prototype.toString.call(t).slice(8, -1);
          return (
            "Object" === n && t.constructor && (n = t.constructor.name),
            "Map" === n || "Set" === n
              ? Array.from(t)
              : "Arguments" === n ||
                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
              ? (0, r.Z)(t, e)
              : void 0
          );
        }
      }
    },
    20943: function (t, e, n) {
      "use strict";
      function r(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
        return r;
      }
      n.d(e, {
        Z: function () {
          return r;
        },
      });
    },
    47568: function (t, e, n) {
      "use strict";
      function r(t, e, n, r, i, o, s) {
        try {
          var a = t[o](s),
            l = a.value;
        } catch (c) {
          return void n(c);
        }
        a.done ? e(l) : Promise.resolve(l).then(r, i);
      }
      function i(t) {
        return function () {
          var e = this,
            n = arguments;
          return new Promise(function (i, o) {
            var s = t.apply(e, n);
            function a(t) {
              r(s, i, o, a, l, "next", t);
            }
            function l(t) {
              r(s, i, o, a, l, "throw", t);
            }
            a(void 0);
          });
        };
      }
      n.d(e, {
        Z: function () {
          return i;
        },
      });
    },
    51438: function (t, e, n) {
      "use strict";
      function r(t, e) {
        if (!(t instanceof e))
          throw new TypeError("Cannot call a class as a function");
      }
      n.d(e, {
        Z: function () {
          return r;
        },
      });
    },
    52951: function (t, e, n) {
      "use strict";
      function r(t, e) {
        for (var n = 0; n < e.length; n++) {
          var r = e[n];
          (r.enumerable = r.enumerable || !1),
            (r.configurable = !0),
            "value" in r && (r.writable = !0),
            Object.defineProperty(t, r.key, r);
        }
      }
      function i(t, e, n) {
        return e && r(t.prototype, e), n && r(t, n), t;
      }
      n.d(e, {
        Z: function () {
          return i;
        },
      });
    },
    14924: function (t, e, n) {
      "use strict";
      function r(t, e, n) {
        return (
          e in t
            ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (t[e] = n),
          t
        );
      }
      n.d(e, {
        Z: function () {
          return r;
        },
      });
    },
    13375: function (t, e, n) {
      "use strict";
      function r(t) {
        if (
          ("undefined" !== typeof Symbol && null != t[Symbol.iterator]) ||
          null != t["@@iterator"]
        )
          return Array.from(t);
      }
      n.d(e, {
        Z: function () {
          return r;
        },
      });
    },
    26042: function (t, e, n) {
      "use strict";
      n.d(e, {
        Z: function () {
          return i;
        },
      });
      var r = n(14924);
      function i(t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = null != arguments[e] ? arguments[e] : {},
            i = Object.keys(n);
          "function" === typeof Object.getOwnPropertySymbols &&
            (i = i.concat(
              Object.getOwnPropertySymbols(n).filter(function (t) {
                return Object.getOwnPropertyDescriptor(n, t).enumerable;
              })
            )),
            i.forEach(function (e) {
              (0, r.Z)(t, e, n[e]);
            });
        }
        return t;
      }
    },
    69396: function (t, e, n) {
      "use strict";
      function r(t, e) {
        return (
          (e = null != e ? e : {}),
          Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(e))
            : (function (t, e) {
                var n = Object.keys(t);
                if (Object.getOwnPropertySymbols) {
                  var r = Object.getOwnPropertySymbols(t);
                  e &&
                    (r = r.filter(function (e) {
                      return Object.getOwnPropertyDescriptor(t, e).enumerable;
                    })),
                    n.push.apply(n, r);
                }
                return n;
              })(Object(e)).forEach(function (n) {
                Object.defineProperty(
                  t,
                  n,
                  Object.getOwnPropertyDescriptor(e, n)
                );
              }),
          t
        );
      }
      n.d(e, {
        Z: function () {
          return r;
        },
      });
    },
    29815: function (t, e, n) {
      "use strict";
      n.d(e, {
        Z: function () {
          return s;
        },
      });
      var r = n(20943);
      var i = n(13375);
      var o = n(91566);
      function s(t) {
        return (
          (function (t) {
            if (Array.isArray(t)) return (0, r.Z)(t);
          })(t) ||
          (0, i.Z)(t) ||
          (0, o.Z)(t) ||
          (function () {
            throw new TypeError(
              "Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
            );
          })()
        );
      }
    },
    91566: function (t, e, n) {
      "use strict";
      n.d(e, {
        Z: function () {
          return i;
        },
      });
      var r = n(20943);
      function i(t, e) {
        if (t) {
          if ("string" === typeof t) return (0, r.Z)(t, e);
          var n = Object.prototype.toString.call(t).slice(8, -1);
          return (
            "Object" === n && t.constructor && (n = t.constructor.name),
            "Map" === n || "Set" === n
              ? Array.from(n)
              : "Arguments" === n ||
                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
              ? (0, r.Z)(t, e)
              : void 0
          );
        }
      }
    },
    32816: function (t, e, n) {
      "use strict";
      var r = n(2568),
        i = n(70401);
      function o(t, e) {
        return function () {
          return t.apply(e, arguments);
        };
      }
      const { toString: s } = Object.prototype,
        { getPrototypeOf: a } = Object,
        l =
          ((c = Object.create(null)),
          (t) => {
            const e = s.call(t);
            return c[e] || (c[e] = e.slice(8, -1).toLowerCase());
          });
      var c;
      const u = (t) => ((t = t.toLowerCase()), (e) => l(e) === t),
        h = (t) => (e) => typeof e === t,
        { isArray: p } = Array,
        d = h("undefined");
      const f = u("ArrayBuffer");
      const m = h("string"),
        g = h("function"),
        y = h("number"),
        _ = (t) => null !== t && "object" === typeof t,
        v = (t) => {
          if ("object" !== l(t)) return !1;
          const e = a(t);
          return (
            (null === e ||
              e === Object.prototype ||
              null === Object.getPrototypeOf(e)) &&
            !(Symbol.toStringTag in t) &&
            !(Symbol.iterator in t)
          );
        },
        b = u("Date"),
        x = u("File"),
        w = u("Blob"),
        S = u("FileList"),
        E = u("URLSearchParams");
      function T(t, e, { allOwnKeys: n = !1 } = {}) {
        if (null === t || "undefined" === typeof t) return;
        let r, i;
        if (("object" !== typeof t && (t = [t]), p(t)))
          for (r = 0, i = t.length; r < i; r++) e.call(null, t[r], r, t);
        else {
          const i = n ? Object.getOwnPropertyNames(t) : Object.keys(t),
            o = i.length;
          let s;
          for (r = 0; r < o; r++) (s = i[r]), e.call(null, t[s], s, t);
        }
      }
      function A(t, e) {
        e = e.toLowerCase();
        const n = Object.keys(t);
        let r,
          i = n.length;
        for (; i-- > 0; ) if (((r = n[i]), e === r.toLowerCase())) return r;
        return null;
      }
      const C =
          "undefined" !== typeof globalThis
            ? globalThis
            : "undefined" !== typeof self
            ? self
            : "undefined" !== typeof window
            ? window
            : global,
        P = (t) => !d(t) && t !== C;
      const M =
        ((O = "undefined" !== typeof Uint8Array && a(Uint8Array)),
        (t) => O && t instanceof O);
      var O;
      const k = u("HTMLFormElement"),
        I = (
          ({ hasOwnProperty: t }) =>
          (e, n) =>
            t.call(e, n)
        )(Object.prototype),
        D = u("RegExp"),
        z = (t, e) => {
          const n = Object.getOwnPropertyDescriptors(t),
            r = {};
          T(n, (n, i) => {
            !1 !== e(n, i, t) && (r[i] = n);
          }),
            Object.defineProperties(t, r);
        },
        R = "abcdefghijklmnopqrstuvwxyz",
        L = "0123456789",
        F = { DIGIT: L, ALPHA: R, ALPHA_DIGIT: R + R.toUpperCase() + L };
      var B = {
        isArray: p,
        isArrayBuffer: f,
        isBuffer: function (t) {
          return (
            null !== t &&
            !d(t) &&
            null !== t.constructor &&
            !d(t.constructor) &&
            g(t.constructor.isBuffer) &&
            t.constructor.isBuffer(t)
          );
        },
        isFormData: (t) => {
          const e = "[object FormData]";
          return (
            t &&
            (("function" === typeof FormData && t instanceof FormData) ||
              s.call(t) === e ||
              (g(t.toString) && t.toString() === e))
          );
        },
        isArrayBufferView: function (t) {
          let e;
          return (
            (e =
              "undefined" !== typeof ArrayBuffer && ArrayBuffer.isView
                ? ArrayBuffer.isView(t)
                : t && t.buffer && f(t.buffer)),
            e
          );
        },
        isString: m,
        isNumber: y,
        isBoolean: (t) => !0 === t || !1 === t,
        isObject: _,
        isPlainObject: v,
        isUndefined: d,
        isDate: b,
        isFile: x,
        isBlob: w,
        isRegExp: D,
        isFunction: g,
        isStream: (t) => _(t) && g(t.pipe),
        isURLSearchParams: E,
        isTypedArray: M,
        isFileList: S,
        forEach: T,
        merge: function t() {
          const { caseless: e } = (P(this) && this) || {},
            n = {},
            r = (r, i) => {
              const o = (e && A(n, i)) || i;
              v(n[o]) && v(r)
                ? (n[o] = t(n[o], r))
                : v(r)
                ? (n[o] = t({}, r))
                : p(r)
                ? (n[o] = r.slice())
                : (n[o] = r);
            };
          for (let i = 0, o = arguments.length; i < o; i++)
            arguments[i] && T(arguments[i], r);
          return n;
        },
        extend: (t, e, n, { allOwnKeys: r } = {}) => (
          T(
            e,
            (e, r) => {
              n && g(e) ? (t[r] = o(e, n)) : (t[r] = e);
            },
            { allOwnKeys: r }
          ),
          t
        ),
        trim: (t) =>
          t.trim
            ? t.trim()
            : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
        stripBOM: (t) => (65279 === t.charCodeAt(0) && (t = t.slice(1)), t),
        inherits: (t, e, n, r) => {
          (t.prototype = Object.create(e.prototype, r)),
            (t.prototype.constructor = t),
            Object.defineProperty(t, "super", { value: e.prototype }),
            n && Object.assign(t.prototype, n);
        },
        toFlatObject: (t, e, n, r) => {
          let i, o, s;
          const l = {};
          if (((e = e || {}), null == t)) return e;
          do {
            for (i = Object.getOwnPropertyNames(t), o = i.length; o-- > 0; )
              (s = i[o]),
                (r && !r(s, t, e)) || l[s] || ((e[s] = t[s]), (l[s] = !0));
            t = !1 !== n && a(t);
          } while (t && (!n || n(t, e)) && t !== Object.prototype);
          return e;
        },
        kindOf: l,
        kindOfTest: u,
        endsWith: (t, e, n) => {
          (t = String(t)),
            (void 0 === n || n > t.length) && (n = t.length),
            (n -= e.length);
          const r = t.indexOf(e, n);
          return -1 !== r && r === n;
        },
        toArray: (t) => {
          if (!t) return null;
          if (p(t)) return t;
          let e = t.length;
          if (!y(e)) return null;
          const n = new Array(e);
          for (; e-- > 0; ) n[e] = t[e];
          return n;
        },
        forEachEntry: (t, e) => {
          const n = (t && t[Symbol.iterator]).call(t);
          let r;
          for (; (r = n.next()) && !r.done; ) {
            const n = r.value;
            e.call(t, n[0], n[1]);
          }
        },
        matchAll: (t, e) => {
          let n;
          const r = [];
          for (; null !== (n = t.exec(e)); ) r.push(n);
          return r;
        },
        isHTMLForm: k,
        hasOwnProperty: I,
        hasOwnProp: I,
        reduceDescriptors: z,
        freezeMethods: (t) => {
          z(t, (e, n) => {
            if (g(t) && -1 !== ["arguments", "caller", "callee"].indexOf(n))
              return !1;
            const r = t[n];
            g(r) &&
              ((e.enumerable = !1),
              "writable" in e
                ? (e.writable = !1)
                : e.set ||
                  (e.set = () => {
                    throw Error("Can not rewrite read-only method '" + n + "'");
                  }));
          });
        },
        toObjectSet: (t, e) => {
          const n = {},
            r = (t) => {
              t.forEach((t) => {
                n[t] = !0;
              });
            };
          return p(t) ? r(t) : r(String(t).split(e)), n;
        },
        toCamelCase: (t) =>
          t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (t, e, n) {
            return e.toUpperCase() + n;
          }),
        noop: () => {},
        toFiniteNumber: (t, e) => ((t = +t), Number.isFinite(t) ? t : e),
        findKey: A,
        global: C,
        isContextDefined: P,
        ALPHABET: F,
        generateString: (t = 16, e = F.ALPHA_DIGIT) => {
          let n = "";
          const { length: r } = e;
          for (; t--; ) n += e[(Math.random() * r) | 0];
          return n;
        },
        isSpecCompliantForm: function (t) {
          return !!(
            t &&
            g(t.append) &&
            "FormData" === t[Symbol.toStringTag] &&
            t[Symbol.iterator]
          );
        },
        toJSONObject: (t) => {
          const e = new Array(10),
            n = (t, r) => {
              if (_(t)) {
                if (e.indexOf(t) >= 0) return;
                if (!("toJSON" in t)) {
                  e[r] = t;
                  const i = p(t) ? [] : {};
                  return (
                    T(t, (t, e) => {
                      const o = n(t, r + 1);
                      !d(o) && (i[e] = o);
                    }),
                    (e[r] = void 0),
                    i
                  );
                }
              }
              return t;
            };
          return n(t, 0);
        },
      };
      function N(t, e, n, r, i) {
        Error.call(this),
          Error.captureStackTrace
            ? Error.captureStackTrace(this, this.constructor)
            : (this.stack = new Error().stack),
          (this.message = t),
          (this.name = "AxiosError"),
          e && (this.code = e),
          n && (this.config = n),
          r && (this.request = r),
          i && (this.response = i);
      }
      B.inherits(N, Error, {
        toJSON: function () {
          return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: B.toJSONObject(this.config),
            code: this.code,
            status:
              this.response && this.response.status
                ? this.response.status
                : null,
          };
        },
      });
      const j = N.prototype,
        U = {};
      [
        "ERR_BAD_OPTION_VALUE",
        "ERR_BAD_OPTION",
        "ECONNABORTED",
        "ETIMEDOUT",
        "ERR_NETWORK",
        "ERR_FR_TOO_MANY_REDIRECTS",
        "ERR_DEPRECATED",
        "ERR_BAD_RESPONSE",
        "ERR_BAD_REQUEST",
        "ERR_CANCELED",
        "ERR_NOT_SUPPORT",
        "ERR_INVALID_URL",
      ].forEach((t) => {
        U[t] = { value: t };
      }),
        Object.defineProperties(N, U),
        Object.defineProperty(j, "isAxiosError", { value: !0 }),
        (N.from = (t, e, n, r, i, o) => {
          const s = Object.create(j);
          return (
            B.toFlatObject(
              t,
              s,
              function (t) {
                return t !== Error.prototype;
              },
              (t) => "isAxiosError" !== t
            ),
            N.call(s, t.message, e, n, r, i),
            (s.cause = t),
            (s.name = t.name),
            o && Object.assign(s, o),
            s
          );
        });
      var Z = N,
        V = n(21876).Buffer;
      function q(t) {
        return B.isPlainObject(t) || B.isArray(t);
      }
      function $(t) {
        return B.endsWith(t, "[]") ? t.slice(0, -2) : t;
      }
      function G(t, e, n) {
        return t
          ? t
              .concat(e)
              .map(function (t, e) {
                return (t = $(t)), !n && e ? "[" + t + "]" : t;
              })
              .join(n ? "." : "")
          : e;
      }
      const W = B.toFlatObject(B, {}, null, function (t) {
        return /^is[A-Z]/.test(t);
      });
      var H = function (t, e, n) {
        if (!B.isObject(t)) throw new TypeError("target must be an object");
        e = e || new FormData();
        const r = (n = B.toFlatObject(
            n,
            { metaTokens: !0, dots: !1, indexes: !1 },
            !1,
            function (t, e) {
              return !B.isUndefined(e[t]);
            }
          )).metaTokens,
          i = n.visitor || c,
          o = n.dots,
          s = n.indexes,
          a =
            (n.Blob || ("undefined" !== typeof Blob && Blob)) &&
            B.isSpecCompliantForm(e);
        if (!B.isFunction(i)) throw new TypeError("visitor must be a function");
        function l(t) {
          if (null === t) return "";
          if (B.isDate(t)) return t.toISOString();
          if (!a && B.isBlob(t))
            throw new Z("Blob is not supported. Use a Buffer instead.");
          return B.isArrayBuffer(t) || B.isTypedArray(t)
            ? a && "function" === typeof Blob
              ? new Blob([t])
              : V.from(t)
            : t;
        }
        function c(t, n, i) {
          let a = t;
          if (t && !i && "object" === typeof t)
            if (B.endsWith(n, "{}"))
              (n = r ? n : n.slice(0, -2)), (t = JSON.stringify(t));
            else if (
              (B.isArray(t) &&
                (function (t) {
                  return B.isArray(t) && !t.some(q);
                })(t)) ||
              ((B.isFileList(t) || B.endsWith(n, "[]")) && (a = B.toArray(t)))
            )
              return (
                (n = $(n)),
                a.forEach(function (t, r) {
                  !B.isUndefined(t) &&
                    null !== t &&
                    e.append(
                      !0 === s ? G([n], r, o) : null === s ? n : n + "[]",
                      l(t)
                    );
                }),
                !1
              );
          return !!q(t) || (e.append(G(i, n, o), l(t)), !1);
        }
        const u = [],
          h = Object.assign(W, {
            defaultVisitor: c,
            convertValue: l,
            isVisitable: q,
          });
        if (!B.isObject(t)) throw new TypeError("data must be an object");
        return (
          (function t(n, r) {
            if (!B.isUndefined(n)) {
              if (-1 !== u.indexOf(n))
                throw Error("Circular reference detected in " + r.join("."));
              u.push(n),
                B.forEach(n, function (n, o) {
                  !0 ===
                    (!(B.isUndefined(n) || null === n) &&
                      i.call(e, n, B.isString(o) ? o.trim() : o, r, h)) &&
                    t(n, r ? r.concat(o) : [o]);
                }),
                u.pop();
            }
          })(t),
          e
        );
      };
      function X(t) {
        const e = {
          "!": "%21",
          "'": "%27",
          "(": "%28",
          ")": "%29",
          "~": "%7E",
          "%20": "+",
          "%00": "\0",
        };
        return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function (t) {
          return e[t];
        });
      }
      function K(t, e) {
        (this._pairs = []), t && H(t, this, e);
      }
      const Y = K.prototype;
      (Y.append = function (t, e) {
        this._pairs.push([t, e]);
      }),
        (Y.toString = function (t) {
          const e = t
            ? function (e) {
                return t.call(this, e, X);
              }
            : X;
          return this._pairs
            .map(function (t) {
              return e(t[0]) + "=" + e(t[1]);
            }, "")
            .join("&");
        });
      var Q = K;
      function J(t) {
        return encodeURIComponent(t)
          .replace(/%3A/gi, ":")
          .replace(/%24/g, "$")
          .replace(/%2C/gi, ",")
          .replace(/%20/g, "+")
          .replace(/%5B/gi, "[")
          .replace(/%5D/gi, "]");
      }
      function tt(t, e, n) {
        if (!e) return t;
        const r = (n && n.encode) || J,
          i = n && n.serialize;
        let o;
        if (
          ((o = i
            ? i(e, n)
            : B.isURLSearchParams(e)
            ? e.toString()
            : new Q(e, n).toString(r)),
          o)
        ) {
          const e = t.indexOf("#");
          -1 !== e && (t = t.slice(0, e)),
            (t += (-1 === t.indexOf("?") ? "?" : "&") + o);
        }
        return t;
      }
      var et = class {
          constructor() {
            this.handlers = [];
          }
          use(t, e, n) {
            return (
              this.handlers.push({
                fulfilled: t,
                rejected: e,
                synchronous: !!n && n.synchronous,
                runWhen: n ? n.runWhen : null,
              }),
              this.handlers.length - 1
            );
          }
          eject(t) {
            this.handlers[t] && (this.handlers[t] = null);
          }
          clear() {
            this.handlers && (this.handlers = []);
          }
          forEach(t) {
            B.forEach(this.handlers, function (e) {
              null !== e && t(e);
            });
          }
        },
        nt = {
          silentJSONParsing: !0,
          forcedJSONParsing: !0,
          clarifyTimeoutError: !1,
        };
      var rt = {
        isBrowser: !0,
        classes: {
          URLSearchParams:
            "undefined" !== typeof URLSearchParams ? URLSearchParams : Q,
          FormData: "undefined" !== typeof FormData ? FormData : null,
          Blob: "undefined" !== typeof Blob ? Blob : null,
        },
        isStandardBrowserEnv: (() => {
          let t;
          return (
            ("undefined" === typeof navigator ||
              ("ReactNative" !== (t = navigator.product) &&
                "NativeScript" !== t &&
                "NS" !== t)) &&
            "undefined" !== typeof window &&
            "undefined" !== typeof document
          );
        })(),
        isStandardBrowserWebWorkerEnv:
          "undefined" !== typeof WorkerGlobalScope &&
          self instanceof WorkerGlobalScope &&
          "function" === typeof self.importScripts,
        protocols: ["http", "https", "file", "blob", "url", "data"],
      };
      var it = function (t) {
        function e(t, n, r, i) {
          let o = t[i++];
          const s = Number.isFinite(+o),
            a = i >= t.length;
          if (((o = !o && B.isArray(r) ? r.length : o), a))
            return B.hasOwnProp(r, o) ? (r[o] = [r[o], n]) : (r[o] = n), !s;
          (r[o] && B.isObject(r[o])) || (r[o] = []);
          return (
            e(t, n, r[o], i) &&
              B.isArray(r[o]) &&
              (r[o] = (function (t) {
                const e = {},
                  n = Object.keys(t);
                let r;
                const i = n.length;
                let o;
                for (r = 0; r < i; r++) (o = n[r]), (e[o] = t[o]);
                return e;
              })(r[o])),
            !s
          );
        }
        if (B.isFormData(t) && B.isFunction(t.entries)) {
          const n = {};
          return (
            B.forEachEntry(t, (t, r) => {
              e(
                (function (t) {
                  return B.matchAll(/\w+|\[(\w*)]/g, t).map((t) =>
                    "[]" === t[0] ? "" : t[1] || t[0]
                  );
                })(t),
                r,
                n,
                0
              );
            }),
            n
          );
        }
        return null;
      };
      const ot = { "Content-Type": void 0 };
      const st = {
        transitional: nt,
        adapter: ["xhr", "http"],
        transformRequest: [
          function (t, e) {
            const n = e.getContentType() || "",
              r = n.indexOf("application/json") > -1,
              i = B.isObject(t);
            i && B.isHTMLForm(t) && (t = new FormData(t));
            if (B.isFormData(t)) return r && r ? JSON.stringify(it(t)) : t;
            if (
              B.isArrayBuffer(t) ||
              B.isBuffer(t) ||
              B.isStream(t) ||
              B.isFile(t) ||
              B.isBlob(t)
            )
              return t;
            if (B.isArrayBufferView(t)) return t.buffer;
            if (B.isURLSearchParams(t))
              return (
                e.setContentType(
                  "application/x-www-form-urlencoded;charset=utf-8",
                  !1
                ),
                t.toString()
              );
            let o;
            if (i) {
              if (n.indexOf("application/x-www-form-urlencoded") > -1)
                return (function (t, e) {
                  return H(
                    t,
                    new rt.classes.URLSearchParams(),
                    Object.assign(
                      {
                        visitor: function (t, e, n, r) {
                          return rt.isNode && B.isBuffer(t)
                            ? (this.append(e, t.toString("base64")), !1)
                            : r.defaultVisitor.apply(this, arguments);
                        },
                      },
                      e
                    )
                  );
                })(t, this.formSerializer).toString();
              if (
                (o = B.isFileList(t)) ||
                n.indexOf("multipart/form-data") > -1
              ) {
                const e = this.env && this.env.FormData;
                return H(
                  o ? { "files[]": t } : t,
                  e && new e(),
                  this.formSerializer
                );
              }
            }
            return i || r
              ? (e.setContentType("application/json", !1),
                (function (t, e, n) {
                  if (B.isString(t))
                    try {
                      return (e || JSON.parse)(t), B.trim(t);
                    } catch (r) {
                      if ("SyntaxError" !== r.name) throw r;
                    }
                  return (n || JSON.stringify)(t);
                })(t))
              : t;
          },
        ],
        transformResponse: [
          function (t) {
            const e = this.transitional || st.transitional,
              n = e && e.forcedJSONParsing,
              r = "json" === this.responseType;
            if (t && B.isString(t) && ((n && !this.responseType) || r)) {
              const n = !(e && e.silentJSONParsing) && r;
              try {
                return JSON.parse(t);
              } catch (i) {
                if (n) {
                  if ("SyntaxError" === i.name)
                    throw Z.from(
                      i,
                      Z.ERR_BAD_RESPONSE,
                      this,
                      null,
                      this.response
                    );
                  throw i;
                }
              }
            }
            return t;
          },
        ],
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        env: { FormData: rt.classes.FormData, Blob: rt.classes.Blob },
        validateStatus: function (t) {
          return t >= 200 && t < 300;
        },
        headers: { common: { Accept: "application/json, text/plain, */*" } },
      };
      B.forEach(["delete", "get", "head"], function (t) {
        st.headers[t] = {};
      }),
        B.forEach(["post", "put", "patch"], function (t) {
          st.headers[t] = B.merge(ot);
        });
      var at = st;
      const lt = B.toObjectSet([
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent",
      ]);
      const ct = Symbol("internals");
      function ut(t) {
        return t && String(t).trim().toLowerCase();
      }
      function ht(t) {
        return !1 === t || null == t ? t : B.isArray(t) ? t.map(ht) : String(t);
      }
      function pt(t, e, n, r, i) {
        return B.isFunction(r)
          ? r.call(this, e, n)
          : (i && (e = n),
            B.isString(e)
              ? B.isString(r)
                ? -1 !== e.indexOf(r)
                : B.isRegExp(r)
                ? r.test(e)
                : void 0
              : void 0);
      }
      class dt {
        constructor(t) {
          t && this.set(t);
        }
        set(t, e, n) {
          const r = this;
          function i(t, e, n) {
            const i = ut(e);
            if (!i) throw new Error("header name must be a non-empty string");
            const o = B.findKey(r, i);
            (!o ||
              void 0 === r[o] ||
              !0 === n ||
              (void 0 === n && !1 !== r[o])) &&
              (r[o || e] = ht(t));
          }
          const o = (t, e) => B.forEach(t, (t, n) => i(t, n, e));
          return (
            B.isPlainObject(t) || t instanceof this.constructor
              ? o(t, e)
              : B.isString(t) &&
                (t = t.trim()) &&
                !/^[-_a-zA-Z]+$/.test(t.trim())
              ? o(
                  ((t) => {
                    const e = {};
                    let n, r, i;
                    return (
                      t &&
                        t.split("\n").forEach(function (t) {
                          (i = t.indexOf(":")),
                            (n = t.substring(0, i).trim().toLowerCase()),
                            (r = t.substring(i + 1).trim()),
                            !n ||
                              (e[n] && lt[n]) ||
                              ("set-cookie" === n
                                ? e[n]
                                  ? e[n].push(r)
                                  : (e[n] = [r])
                                : (e[n] = e[n] ? e[n] + ", " + r : r));
                        }),
                      e
                    );
                  })(t),
                  e
                )
              : null != t && i(e, t, n),
            this
          );
        }
        get(t, e) {
          if ((t = ut(t))) {
            const n = B.findKey(this, t);
            if (n) {
              const t = this[n];
              if (!e) return t;
              if (!0 === e)
                return (function (t) {
                  const e = Object.create(null),
                    n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                  let r;
                  for (; (r = n.exec(t)); ) e[r[1]] = r[2];
                  return e;
                })(t);
              if (B.isFunction(e)) return e.call(this, t, n);
              if (B.isRegExp(e)) return e.exec(t);
              throw new TypeError("parser must be boolean|regexp|function");
            }
          }
        }
        has(t, e) {
          if ((t = ut(t))) {
            const n = B.findKey(this, t);
            return !(!n || void 0 === this[n] || (e && !pt(0, this[n], n, e)));
          }
          return !1;
        }
        delete(t, e) {
          const n = this;
          let r = !1;
          function i(t) {
            if ((t = ut(t))) {
              const i = B.findKey(n, t);
              !i || (e && !pt(0, n[i], i, e)) || (delete n[i], (r = !0));
            }
          }
          return B.isArray(t) ? t.forEach(i) : i(t), r;
        }
        clear(t) {
          const e = Object.keys(this);
          let n = e.length,
            r = !1;
          for (; n--; ) {
            const i = e[n];
            (t && !pt(0, this[i], i, t, !0)) || (delete this[i], (r = !0));
          }
          return r;
        }
        normalize(t) {
          const e = this,
            n = {};
          return (
            B.forEach(this, (r, i) => {
              const o = B.findKey(n, i);
              if (o) return (e[o] = ht(r)), void delete e[i];
              const s = t
                ? (function (t) {
                    return t
                      .trim()
                      .toLowerCase()
                      .replace(
                        /([a-z\d])(\w*)/g,
                        (t, e, n) => e.toUpperCase() + n
                      );
                  })(i)
                : String(i).trim();
              s !== i && delete e[i], (e[s] = ht(r)), (n[s] = !0);
            }),
            this
          );
        }
        concat(...t) {
          return this.constructor.concat(this, ...t);
        }
        toJSON(t) {
          const e = Object.create(null);
          return (
            B.forEach(this, (n, r) => {
              null != n &&
                !1 !== n &&
                (e[r] = t && B.isArray(n) ? n.join(", ") : n);
            }),
            e
          );
        }
        [Symbol.iterator]() {
          return Object.entries(this.toJSON())[Symbol.iterator]();
        }
        toString() {
          return Object.entries(this.toJSON())
            .map(([t, e]) => t + ": " + e)
            .join("\n");
        }
        get [Symbol.toStringTag]() {
          return "AxiosHeaders";
        }
        static from(t) {
          return t instanceof this ? t : new this(t);
        }
        static concat(t, ...e) {
          const n = new this(t);
          return e.forEach((t) => n.set(t)), n;
        }
        static accessor(t) {
          const e = (this[ct] = this[ct] = { accessors: {} }).accessors,
            n = this.prototype;
          function r(t) {
            const r = ut(t);
            e[r] ||
              (!(function (t, e) {
                const n = B.toCamelCase(" " + e);
                ["get", "set", "has"].forEach((r) => {
                  Object.defineProperty(t, r + n, {
                    value: function (t, n, i) {
                      return this[r].call(this, e, t, n, i);
                    },
                    configurable: !0,
                  });
                });
              })(n, t),
              (e[r] = !0));
          }
          return B.isArray(t) ? t.forEach(r) : r(t), this;
        }
      }
      dt.accessor([
        "Content-Type",
        "Content-Length",
        "Accept",
        "Accept-Encoding",
        "User-Agent",
        "Authorization",
      ]),
        B.freezeMethods(dt.prototype),
        B.freezeMethods(dt);
      var ft = dt;
      function mt(t, e) {
        const n = this || at,
          r = e || n,
          i = ft.from(r.headers);
        let o = r.data;
        return (
          B.forEach(t, function (t) {
            o = t.call(n, o, i.normalize(), e ? e.status : void 0);
          }),
          i.normalize(),
          o
        );
      }
      function gt(t) {
        return !(!t || !t.__CANCEL__);
      }
      function yt(t, e, n) {
        Z.call(this, null == t ? "canceled" : t, Z.ERR_CANCELED, e, n),
          (this.name = "CanceledError");
      }
      B.inherits(yt, Z, { __CANCEL__: !0 });
      var _t = yt;
      var vt = rt.isStandardBrowserEnv
        ? {
            write: function (t, e, n, r, i, o) {
              const s = [];
              s.push(t + "=" + encodeURIComponent(e)),
                B.isNumber(n) && s.push("expires=" + new Date(n).toGMTString()),
                B.isString(r) && s.push("path=" + r),
                B.isString(i) && s.push("domain=" + i),
                !0 === o && s.push("secure"),
                (document.cookie = s.join("; "));
            },
            read: function (t) {
              const e = document.cookie.match(
                new RegExp("(^|;\\s*)(" + t + ")=([^;]*)")
              );
              return e ? decodeURIComponent(e[3]) : null;
            },
            remove: function (t) {
              this.write(t, "", Date.now() - 864e5);
            },
          }
        : {
            write: function () {},
            read: function () {
              return null;
            },
            remove: function () {},
          };
      function bt(t, e) {
        return t && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)
          ? (function (t, e) {
              return e
                ? t.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "")
                : t;
            })(t, e)
          : e;
      }
      var xt = rt.isStandardBrowserEnv
        ? (function () {
            const t = /(msie|trident)/i.test(navigator.userAgent),
              e = document.createElement("a");
            let n;
            function r(n) {
              let r = n;
              return (
                t && (e.setAttribute("href", r), (r = e.href)),
                e.setAttribute("href", r),
                {
                  href: e.href,
                  protocol: e.protocol ? e.protocol.replace(/:$/, "") : "",
                  host: e.host,
                  search: e.search ? e.search.replace(/^\?/, "") : "",
                  hash: e.hash ? e.hash.replace(/^#/, "") : "",
                  hostname: e.hostname,
                  port: e.port,
                  pathname:
                    "/" === e.pathname.charAt(0)
                      ? e.pathname
                      : "/" + e.pathname,
                }
              );
            }
            return (
              (n = r(window.location.href)),
              function (t) {
                const e = B.isString(t) ? r(t) : t;
                return e.protocol === n.protocol && e.host === n.host;
              }
            );
          })()
        : function () {
            return !0;
          };
      var wt = function (t, e) {
        t = t || 10;
        const n = new Array(t),
          r = new Array(t);
        let i,
          o = 0,
          s = 0;
        return (
          (e = void 0 !== e ? e : 1e3),
          function (a) {
            const l = Date.now(),
              c = r[s];
            i || (i = l), (n[o] = a), (r[o] = l);
            let u = s,
              h = 0;
            for (; u !== o; ) (h += n[u++]), (u %= t);
            if (((o = (o + 1) % t), o === s && (s = (s + 1) % t), l - i < e))
              return;
            const p = c && l - c;
            return p ? Math.round((1e3 * h) / p) : void 0;
          }
        );
      };
      function St(t, e) {
        let n = 0;
        const r = wt(50, 250);
        return (i) => {
          const o = i.loaded,
            s = i.lengthComputable ? i.total : void 0,
            a = o - n,
            l = r(a);
          n = o;
          const c = {
            loaded: o,
            total: s,
            progress: s ? o / s : void 0,
            bytes: a,
            rate: l || void 0,
            estimated: l && s && o <= s ? (s - o) / l : void 0,
            event: i,
          };
          (c[e ? "download" : "upload"] = !0), t(c);
        };
      }
      const Et = {
        http: null,
        xhr:
          "undefined" !== typeof XMLHttpRequest &&
          function (t) {
            return new Promise(function (e, n) {
              let r = t.data;
              const i = ft.from(t.headers).normalize(),
                o = t.responseType;
              let s;
              function a() {
                t.cancelToken && t.cancelToken.unsubscribe(s),
                  t.signal && t.signal.removeEventListener("abort", s);
              }
              B.isFormData(r) &&
                (rt.isStandardBrowserEnv || rt.isStandardBrowserWebWorkerEnv) &&
                i.setContentType(!1);
              let l = new XMLHttpRequest();
              if (t.auth) {
                const e = t.auth.username || "",
                  n = t.auth.password
                    ? unescape(encodeURIComponent(t.auth.password))
                    : "";
                i.set("Authorization", "Basic " + btoa(e + ":" + n));
              }
              const c = bt(t.baseURL, t.url);
              function u() {
                if (!l) return;
                const r = ft.from(
                  "getAllResponseHeaders" in l && l.getAllResponseHeaders()
                );
                !(function (t, e, n) {
                  const r = n.config.validateStatus;
                  n.status && r && !r(n.status)
                    ? e(
                        new Z(
                          "Request failed with status code " + n.status,
                          [Z.ERR_BAD_REQUEST, Z.ERR_BAD_RESPONSE][
                            Math.floor(n.status / 100) - 4
                          ],
                          n.config,
                          n.request,
                          n
                        )
                      )
                    : t(n);
                })(
                  function (t) {
                    e(t), a();
                  },
                  function (t) {
                    n(t), a();
                  },
                  {
                    data:
                      o && "text" !== o && "json" !== o
                        ? l.response
                        : l.responseText,
                    status: l.status,
                    statusText: l.statusText,
                    headers: r,
                    config: t,
                    request: l,
                  }
                ),
                  (l = null);
              }
              if (
                (l.open(
                  t.method.toUpperCase(),
                  tt(c, t.params, t.paramsSerializer),
                  !0
                ),
                (l.timeout = t.timeout),
                "onloadend" in l
                  ? (l.onloadend = u)
                  : (l.onreadystatechange = function () {
                      l &&
                        4 === l.readyState &&
                        (0 !== l.status ||
                          (l.responseURL &&
                            0 === l.responseURL.indexOf("file:"))) &&
                        setTimeout(u);
                    }),
                (l.onabort = function () {
                  l &&
                    (n(new Z("Request aborted", Z.ECONNABORTED, t, l)),
                    (l = null));
                }),
                (l.onerror = function () {
                  n(new Z("Network Error", Z.ERR_NETWORK, t, l)), (l = null);
                }),
                (l.ontimeout = function () {
                  let e = t.timeout
                    ? "timeout of " + t.timeout + "ms exceeded"
                    : "timeout exceeded";
                  const r = t.transitional || nt;
                  t.timeoutErrorMessage && (e = t.timeoutErrorMessage),
                    n(
                      new Z(
                        e,
                        r.clarifyTimeoutError ? Z.ETIMEDOUT : Z.ECONNABORTED,
                        t,
                        l
                      )
                    ),
                    (l = null);
                }),
                rt.isStandardBrowserEnv)
              ) {
                const e =
                  (t.withCredentials || xt(c)) &&
                  t.xsrfCookieName &&
                  vt.read(t.xsrfCookieName);
                e && i.set(t.xsrfHeaderName, e);
              }
              void 0 === r && i.setContentType(null),
                "setRequestHeader" in l &&
                  B.forEach(i.toJSON(), function (t, e) {
                    l.setRequestHeader(e, t);
                  }),
                B.isUndefined(t.withCredentials) ||
                  (l.withCredentials = !!t.withCredentials),
                o && "json" !== o && (l.responseType = t.responseType),
                "function" === typeof t.onDownloadProgress &&
                  l.addEventListener("progress", St(t.onDownloadProgress, !0)),
                "function" === typeof t.onUploadProgress &&
                  l.upload &&
                  l.upload.addEventListener("progress", St(t.onUploadProgress)),
                (t.cancelToken || t.signal) &&
                  ((s = (e) => {
                    l &&
                      (n(!e || e.type ? new _t(null, t, l) : e),
                      l.abort(),
                      (l = null));
                  }),
                  t.cancelToken && t.cancelToken.subscribe(s),
                  t.signal &&
                    (t.signal.aborted
                      ? s()
                      : t.signal.addEventListener("abort", s)));
              const h = (function (t) {
                const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
                return (e && e[1]) || "";
              })(c);
              h && -1 === rt.protocols.indexOf(h)
                ? n(
                    new Z(
                      "Unsupported protocol " + h + ":",
                      Z.ERR_BAD_REQUEST,
                      t
                    )
                  )
                : l.send(r || null);
            });
          },
      };
      B.forEach(Et, (t, e) => {
        if (t) {
          try {
            Object.defineProperty(t, "name", { value: e });
          } catch (n) {}
          Object.defineProperty(t, "adapterName", { value: e });
        }
      });
      var Tt = (t) => {
        t = B.isArray(t) ? t : [t];
        const { length: e } = t;
        let n, r;
        for (
          let i = 0;
          i < e && ((n = t[i]), !(r = B.isString(n) ? Et[n.toLowerCase()] : n));
          i++
        );
        if (!r) {
          if (!1 === r)
            throw new Z(
              `Adapter ${n} is not supported by the environment`,
              "ERR_NOT_SUPPORT"
            );
          throw new Error(
            B.hasOwnProp(Et, n)
              ? `Adapter '${n}' is not available in the build`
              : `Unknown adapter '${n}'`
          );
        }
        if (!B.isFunction(r)) throw new TypeError("adapter is not a function");
        return r;
      };
      function At(t) {
        if (
          (t.cancelToken && t.cancelToken.throwIfRequested(),
          t.signal && t.signal.aborted)
        )
          throw new _t(null, t);
      }
      function Ct(t) {
        At(t),
          (t.headers = ft.from(t.headers)),
          (t.data = mt.call(t, t.transformRequest)),
          -1 !== ["post", "put", "patch"].indexOf(t.method) &&
            t.headers.setContentType("application/x-www-form-urlencoded", !1);
        return Tt(t.adapter || at.adapter)(t).then(
          function (e) {
            return (
              At(t),
              (e.data = mt.call(t, t.transformResponse, e)),
              (e.headers = ft.from(e.headers)),
              e
            );
          },
          function (e) {
            return (
              gt(e) ||
                (At(t),
                e &&
                  e.response &&
                  ((e.response.data = mt.call(
                    t,
                    t.transformResponse,
                    e.response
                  )),
                  (e.response.headers = ft.from(e.response.headers)))),
              Promise.reject(e)
            );
          }
        );
      }
      const Pt = (t) => (t instanceof ft ? t.toJSON() : t);
      function Mt(t, e) {
        e = e || {};
        const n = {};
        function r(t, e, n) {
          return B.isPlainObject(t) && B.isPlainObject(e)
            ? B.merge.call({ caseless: n }, t, e)
            : B.isPlainObject(e)
            ? B.merge({}, e)
            : B.isArray(e)
            ? e.slice()
            : e;
        }
        function i(t, e, n) {
          return B.isUndefined(e)
            ? B.isUndefined(t)
              ? void 0
              : r(void 0, t, n)
            : r(t, e, n);
        }
        function o(t, e) {
          if (!B.isUndefined(e)) return r(void 0, e);
        }
        function s(t, e) {
          return B.isUndefined(e)
            ? B.isUndefined(t)
              ? void 0
              : r(void 0, t)
            : r(void 0, e);
        }
        function a(n, i, o) {
          return o in e ? r(n, i) : o in t ? r(void 0, n) : void 0;
        }
        const l = {
          url: o,
          method: o,
          data: o,
          baseURL: s,
          transformRequest: s,
          transformResponse: s,
          paramsSerializer: s,
          timeout: s,
          timeoutMessage: s,
          withCredentials: s,
          adapter: s,
          responseType: s,
          xsrfCookieName: s,
          xsrfHeaderName: s,
          onUploadProgress: s,
          onDownloadProgress: s,
          decompress: s,
          maxContentLength: s,
          maxBodyLength: s,
          beforeRedirect: s,
          transport: s,
          httpAgent: s,
          httpsAgent: s,
          cancelToken: s,
          socketPath: s,
          responseEncoding: s,
          validateStatus: a,
          headers: (t, e) => i(Pt(t), Pt(e), !0),
        };
        return (
          B.forEach(Object.keys(t).concat(Object.keys(e)), function (r) {
            const o = l[r] || i,
              s = o(t[r], e[r], r);
            (B.isUndefined(s) && o !== a) || (n[r] = s);
          }),
          n
        );
      }
      const Ot = "1.3.4",
        kt = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach(
        (t, e) => {
          kt[t] = function (n) {
            return typeof n === t || "a" + (e < 1 ? "n " : " ") + t;
          };
        }
      );
      const It = {};
      kt.transitional = function (t, e, n) {
        function r(t, e) {
          return (
            "[Axios v1.3.4] Transitional option '" +
            t +
            "'" +
            e +
            (n ? ". " + n : "")
          );
        }
        return (n, i, o) => {
          if (!1 === t)
            throw new Z(
              r(i, " has been removed" + (e ? " in " + e : "")),
              Z.ERR_DEPRECATED
            );
          return (
            e &&
              !It[i] &&
              ((It[i] = !0),
              console.warn(
                r(
                  i,
                  " has been deprecated since v" +
                    e +
                    " and will be removed in the near future"
                )
              )),
            !t || t(n, i, o)
          );
        };
      };
      var Dt = {
        assertOptions: function (t, e, n) {
          if ("object" !== typeof t)
            throw new Z("options must be an object", Z.ERR_BAD_OPTION_VALUE);
          const r = Object.keys(t);
          let i = r.length;
          for (; i-- > 0; ) {
            const o = r[i],
              s = e[o];
            if (s) {
              const e = t[o],
                n = void 0 === e || s(e, o, t);
              if (!0 !== n)
                throw new Z(
                  "option " + o + " must be " + n,
                  Z.ERR_BAD_OPTION_VALUE
                );
            } else if (!0 !== n)
              throw new Z("Unknown option " + o, Z.ERR_BAD_OPTION);
          }
        },
        validators: kt,
      };
      const zt = Dt.validators;
      class Rt {
        constructor(t) {
          (this.defaults = t),
            (this.interceptors = { request: new et(), response: new et() });
        }
        request(t, e) {
          "string" === typeof t ? ((e = e || {}).url = t) : (e = t || {}),
            (e = Mt(this.defaults, e));
          const { transitional: n, paramsSerializer: r, headers: i } = e;
          let o;
          void 0 !== n &&
            Dt.assertOptions(
              n,
              {
                silentJSONParsing: zt.transitional(zt.boolean),
                forcedJSONParsing: zt.transitional(zt.boolean),
                clarifyTimeoutError: zt.transitional(zt.boolean),
              },
              !1
            ),
            void 0 !== r &&
              Dt.assertOptions(
                r,
                { encode: zt.function, serialize: zt.function },
                !0
              ),
            (e.method = (
              e.method ||
              this.defaults.method ||
              "get"
            ).toLowerCase()),
            (o = i && B.merge(i.common, i[e.method])),
            o &&
              B.forEach(
                ["delete", "get", "head", "post", "put", "patch", "common"],
                (t) => {
                  delete i[t];
                }
              ),
            (e.headers = ft.concat(o, i));
          const s = [];
          let a = !0;
          this.interceptors.request.forEach(function (t) {
            ("function" === typeof t.runWhen && !1 === t.runWhen(e)) ||
              ((a = a && t.synchronous), s.unshift(t.fulfilled, t.rejected));
          });
          const l = [];
          let c;
          this.interceptors.response.forEach(function (t) {
            l.push(t.fulfilled, t.rejected);
          });
          let u,
            h = 0;
          if (!a) {
            const t = [Ct.bind(this), void 0];
            for (
              t.unshift.apply(t, s),
                t.push.apply(t, l),
                u = t.length,
                c = Promise.resolve(e);
              h < u;

            )
              c = c.then(t[h++], t[h++]);
            return c;
          }
          u = s.length;
          let p = e;
          for (h = 0; h < u; ) {
            const t = s[h++],
              e = s[h++];
            try {
              p = t(p);
            } catch (d) {
              e.call(this, d);
              break;
            }
          }
          try {
            c = Ct.call(this, p);
          } catch (d) {
            return Promise.reject(d);
          }
          for (h = 0, u = l.length; h < u; ) c = c.then(l[h++], l[h++]);
          return c;
        }
        getUri(t) {
          return tt(
            bt((t = Mt(this.defaults, t)).baseURL, t.url),
            t.params,
            t.paramsSerializer
          );
        }
      }
      B.forEach(["delete", "get", "head", "options"], function (t) {
        Rt.prototype[t] = function (e, n) {
          return this.request(
            Mt(n || {}, { method: t, url: e, data: (n || {}).data })
          );
        };
      }),
        B.forEach(["post", "put", "patch"], function (t) {
          function e(e) {
            return function (n, r, i) {
              return this.request(
                Mt(i || {}, {
                  method: t,
                  headers: e ? { "Content-Type": "multipart/form-data" } : {},
                  url: n,
                  data: r,
                })
              );
            };
          }
          (Rt.prototype[t] = e()), (Rt.prototype[t + "Form"] = e(!0));
        });
      var Lt = Rt;
      class Ft {
        constructor(t) {
          if ("function" !== typeof t)
            throw new TypeError("executor must be a function.");
          let e;
          this.promise = new Promise(function (t) {
            e = t;
          });
          const n = this;
          this.promise.then((t) => {
            if (!n._listeners) return;
            let e = n._listeners.length;
            for (; e-- > 0; ) n._listeners[e](t);
            n._listeners = null;
          }),
            (this.promise.then = (t) => {
              let e;
              const r = new Promise((t) => {
                n.subscribe(t), (e = t);
              }).then(t);
              return (
                (r.cancel = function () {
                  n.unsubscribe(e);
                }),
                r
              );
            }),
            t(function (t, r, i) {
              n.reason || ((n.reason = new _t(t, r, i)), e(n.reason));
            });
        }
        throwIfRequested() {
          if (this.reason) throw this.reason;
        }
        subscribe(t) {
          this.reason
            ? t(this.reason)
            : this._listeners
            ? this._listeners.push(t)
            : (this._listeners = [t]);
        }
        unsubscribe(t) {
          if (!this._listeners) return;
          const e = this._listeners.indexOf(t);
          -1 !== e && this._listeners.splice(e, 1);
        }
        static source() {
          let t;
          return {
            token: new Ft(function (e) {
              t = e;
            }),
            cancel: t,
          };
        }
      }
      var Bt = Ft;
      const Nt = {
        Continue: 100,
        SwitchingProtocols: 101,
        Processing: 102,
        EarlyHints: 103,
        Ok: 200,
        Created: 201,
        Accepted: 202,
        NonAuthoritativeInformation: 203,
        NoContent: 204,
        ResetContent: 205,
        PartialContent: 206,
        MultiStatus: 207,
        AlreadyReported: 208,
        ImUsed: 226,
        MultipleChoices: 300,
        MovedPermanently: 301,
        Found: 302,
        SeeOther: 303,
        NotModified: 304,
        UseProxy: 305,
        Unused: 306,
        TemporaryRedirect: 307,
        PermanentRedirect: 308,
        BadRequest: 400,
        Unauthorized: 401,
        PaymentRequired: 402,
        Forbidden: 403,
        NotFound: 404,
        MethodNotAllowed: 405,
        NotAcceptable: 406,
        ProxyAuthenticationRequired: 407,
        RequestTimeout: 408,
        Conflict: 409,
        Gone: 410,
        LengthRequired: 411,
        PreconditionFailed: 412,
        PayloadTooLarge: 413,
        UriTooLong: 414,
        UnsupportedMediaType: 415,
        RangeNotSatisfiable: 416,
        ExpectationFailed: 417,
        ImATeapot: 418,
        MisdirectedRequest: 421,
        UnprocessableEntity: 422,
        Locked: 423,
        FailedDependency: 424,
        TooEarly: 425,
        UpgradeRequired: 426,
        PreconditionRequired: 428,
        TooManyRequests: 429,
        RequestHeaderFieldsTooLarge: 431,
        UnavailableForLegalReasons: 451,
        InternalServerError: 500,
        NotImplemented: 501,
        BadGateway: 502,
        ServiceUnavailable: 503,
        GatewayTimeout: 504,
        HttpVersionNotSupported: 505,
        VariantAlsoNegotiates: 506,
        InsufficientStorage: 507,
        LoopDetected: 508,
        NotExtended: 510,
        NetworkAuthenticationRequired: 511,
      };
      Object.entries(Nt).forEach(([t, e]) => {
        Nt[e] = t;
      });
      var jt = Nt;
      const Ut = (function t(e) {
        const n = new Lt(e),
          r = o(Lt.prototype.request, n);
        return (
          B.extend(r, Lt.prototype, n, { allOwnKeys: !0 }),
          B.extend(r, n, null, { allOwnKeys: !0 }),
          (r.create = function (n) {
            return t(Mt(e, n));
          }),
          r
        );
      })(at);
      (Ut.Axios = Lt),
        (Ut.CanceledError = _t),
        (Ut.CancelToken = Bt),
        (Ut.isCancel = gt),
        (Ut.VERSION = Ot),
        (Ut.toFormData = H),
        (Ut.AxiosError = Z),
        (Ut.Cancel = Ut.CanceledError),
        (Ut.all = function (t) {
          return Promise.all(t);
        }),
        (Ut.spread = function (t) {
          return function (e) {
            return t.apply(null, e);
          };
        }),
        (Ut.isAxiosError = function (t) {
          return B.isObject(t) && !0 === t.isAxiosError;
        }),
        (Ut.mergeConfig = Mt),
        (Ut.AxiosHeaders = ft),
        (Ut.formToJSON = (t) => it(B.isHTMLForm(t) ? new FormData(t) : t)),
        (Ut.HttpStatusCode = jt),
        (Ut.default = Ut);
      var Zt = Ut,
        Vt = n(27484),
        qt = (n(6329), n(41004));
      function $t(t, e, n, r, i, o) {
        let s = "";
        if (t.length) {
          s += e.spacingOuter;
          const a = n + e.indent;
          for (let n = 0; n < t.length; n++)
            (s += a + o(t[n], e, a, r, i)),
              n < t.length - 1
                ? (s += "," + e.spacingInner)
                : e.min || (s += ",");
          s += e.spacingOuter + n;
        }
        return s;
      }
      function Gt(t, e, n, r, i, o) {
        let s = "";
        const a = ((t) => {
          const e = Object.keys(t).sort();
          return (
            Object.getOwnPropertySymbols &&
              Object.getOwnPropertySymbols(t).forEach((n) => {
                Object.getOwnPropertyDescriptor(t, n).enumerable && e.push(n);
              }),
            e
          );
        })(t);
        if (a.length) {
          s += e.spacingOuter;
          const l = n + e.indent;
          for (let n = 0; n < a.length; n++) {
            const c = a[n];
            (s += l + o(c, e, l, r, i) + ": " + o(t[c], e, l, r, i)),
              n < a.length - 1
                ? (s += "," + e.spacingInner)
                : e.min || (s += ",");
          }
          s += e.spacingOuter + n;
        }
        return s;
      }
      const Wt = Object.prototype.toString,
        Ht = Date.prototype.toISOString,
        Xt = Error.prototype.toString,
        Kt = RegExp.prototype.toString,
        Yt = (t) =>
          ("function" === typeof t.constructor && t.constructor.name) ||
          "Object",
        Qt = /^Symbol\((.*)\)(.*)$/,
        Jt = /\n/gi;
      class te extends Error {
        constructor(t, e) {
          super(t), (this.stack = e), (this.name = this.constructor.name);
        }
      }
      function ee(t, e) {
        return e ? "[Function " + (t.name || "anonymous") + "]" : "[Function]";
      }
      function ne(t) {
        return String(t).replace(Qt, "Symbol($1)");
      }
      function re(t) {
        return "[" + Xt.call(t) + "]";
      }
      function ie(t, e, n, r) {
        if (!0 === t || !1 === t) return "" + t;
        if (void 0 === t) return "undefined";
        if (null === t) return "null";
        const i = typeof t;
        if ("number" === i)
          return (function (t) {
            return Object.is(t, -0) ? "-0" : String(t);
          })(t);
        if ("bigint" === i)
          return (function (t) {
            return String(`${t}n`);
          })(t);
        if ("string" === i)
          return r ? '"' + t.replace(/"|\\/g, "\\$&") + '"' : '"' + t + '"';
        if ("function" === i) return ee(t, e);
        if ("symbol" === i) return ne(t);
        const o = Wt.call(t);
        return "[object WeakMap]" === o
          ? "WeakMap {}"
          : "[object WeakSet]" === o
          ? "WeakSet {}"
          : "[object Function]" === o || "[object GeneratorFunction]" === o
          ? ee(t, e)
          : "[object Symbol]" === o
          ? ne(t)
          : "[object Date]" === o
          ? isNaN(+t)
            ? "Date { NaN }"
            : Ht.call(t)
          : "[object Error]" === o
          ? re(t)
          : "[object RegExp]" === o
          ? n
            ? Kt.call(t).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&")
            : Kt.call(t)
          : t instanceof Error
          ? re(t)
          : null;
      }
      function oe(t, e, n, r, i, o) {
        if (-1 !== i.indexOf(t)) return "[Circular]";
        (i = i.slice()).push(t);
        const s = ++r > e.maxDepth,
          a = e.min;
        if (
          e.callToJSON &&
          !s &&
          t.toJSON &&
          "function" === typeof t.toJSON &&
          !o
        )
          return le(t.toJSON(), e, n, r, i, !0);
        const l = Wt.call(t);
        return "[object Arguments]" === l
          ? s
            ? "[Arguments]"
            : (a ? "" : "Arguments ") + "[" + $t(t, e, n, r, i, le) + "]"
          : (function (t) {
              return (
                "[object Array]" === t ||
                "[object ArrayBuffer]" === t ||
                "[object DataView]" === t ||
                "[object Float32Array]" === t ||
                "[object Float64Array]" === t ||
                "[object Int8Array]" === t ||
                "[object Int16Array]" === t ||
                "[object Int32Array]" === t ||
                "[object Uint8Array]" === t ||
                "[object Uint8ClampedArray]" === t ||
                "[object Uint16Array]" === t ||
                "[object Uint32Array]" === t
              );
            })(l)
          ? s
            ? "[" + t.constructor.name + "]"
            : (a ? "" : t.constructor.name + " ") +
              "[" +
              $t(t, e, n, r, i, le) +
              "]"
          : "[object Map]" === l
          ? s
            ? "[Map]"
            : "Map {" +
              (function (t, e, n, r, i, o, s = ": ") {
                let a = "",
                  l = t.next();
                if (!l.done) {
                  a += e.spacingOuter;
                  const c = n + e.indent;
                  for (; !l.done; )
                    (a +=
                      c +
                      o(l.value[0], e, c, r, i) +
                      s +
                      o(l.value[1], e, c, r, i)),
                      (l = t.next()),
                      l.done
                        ? e.min || (a += ",")
                        : (a += "," + e.spacingInner);
                  a += e.spacingOuter + n;
                }
                return a;
              })(t.entries(), e, n, r, i, le, " => ") +
              "}"
          : "[object Set]" === l
          ? s
            ? "[Set]"
            : "Set {" +
              (function (t, e, n, r, i, o) {
                let s = "",
                  a = t.next();
                if (!a.done) {
                  s += e.spacingOuter;
                  const l = n + e.indent;
                  for (; !a.done; )
                    (s += l + o(a.value, e, l, r, i)),
                      (a = t.next()),
                      a.done
                        ? e.min || (s += ",")
                        : (s += "," + e.spacingInner);
                  s += e.spacingOuter + n;
                }
                return s;
              })(t.values(), e, n, r, i, le) +
              "}"
          : s || ((t) => "undefined" !== typeof window && t === window)(t)
          ? "[" + Yt(t) + "]"
          : (a ? "" : Yt(t) + " ") + "{" + Gt(t, e, n, r, i, le) + "}";
      }
      function se(t, e, n, r, i, o) {
        let s;
        try {
          s = (function (t) {
            return null != t.serialize;
          })(t)
            ? t.serialize(e, n, r, i, o, le)
            : t.print(
                e,
                (t) => le(t, n, r, i, o),
                (t) => {
                  const e = r + n.indent;
                  return e + t.replace(Jt, "\n" + e);
                },
                {
                  edgeSpacing: n.spacingOuter,
                  min: n.min,
                  spacing: n.spacingInner,
                },
                n.colors
              );
        } catch (a) {
          throw new te(a.message, a.stack);
        }
        if ("string" !== typeof s)
          throw new Error(
            `pretty-format: Plugin must return type "string" but instead returned "${typeof s}".`
          );
        return s;
      }
      function ae(t, e) {
        for (let r = 0; r < t.length; r++)
          try {
            if (t[r].test(e)) return t[r];
          } catch (n) {
            throw new te(n.message, n.stack);
          }
        return null;
      }
      function le(t, e, n, r, i, o) {
        const s = ae(e.plugins, t);
        if (null !== s) return se(s, t, e, n, r, i);
        const a = ie(t, e.printFunctionName, e.escapeRegex, e.escapeString);
        return null !== a ? a : oe(t, e, n, r, i, o);
      }
      const ce = {
          comment: "gray",
          content: "reset",
          prop: "yellow",
          tag: "cyan",
          value: "green",
        },
        ue = Object.keys(ce),
        he = {
          callToJSON: !0,
          escapeRegex: !1,
          escapeString: !0,
          highlight: !1,
          indent: 2,
          maxDepth: 1 / 0,
          min: !1,
          plugins: [],
          printFunctionName: !0,
          theme: ce,
        };
      const pe = (t) =>
          ue.reduce((e, n) => {
            const r = t.theme && void 0 !== t.theme[n] ? t.theme[n] : ce[n],
              i = r && qt[r];
            if (!i || "string" !== typeof i.close || "string" !== typeof i.open)
              throw new Error(
                `pretty-format: Option "theme" has a key "${n}" whose value "${r}" is undefined in ansi-styles.`
              );
            return (e[n] = i), e;
          }, Object.create(null)),
        de = (t) =>
          t && void 0 !== t.printFunctionName
            ? t.printFunctionName
            : he.printFunctionName,
        fe = (t) =>
          t && void 0 !== t.escapeRegex ? t.escapeRegex : he.escapeRegex,
        me = (t) =>
          t && void 0 !== t.escapeString ? t.escapeString : he.escapeString,
        ge = (t) => {
          return {
            callToJSON:
              t && void 0 !== t.callToJSON ? t.callToJSON : he.callToJSON,
            colors:
              t && t.highlight
                ? pe(t)
                : ue.reduce(
                    (t, e) => ((t[e] = { close: "", open: "" }), t),
                    Object.create(null)
                  ),
            escapeRegex: fe(t),
            escapeString: me(t),
            indent:
              t && t.min
                ? ""
                : ((e = t && void 0 !== t.indent ? t.indent : he.indent),
                  new Array(e + 1).join(" ")),
            maxDepth: t && void 0 !== t.maxDepth ? t.maxDepth : he.maxDepth,
            min: t && void 0 !== t.min ? t.min : he.min,
            plugins: t && void 0 !== t.plugins ? t.plugins : he.plugins,
            printFunctionName: de(t),
            spacingInner: t && t.min ? " " : "\n",
            spacingOuter: t && t.min ? "" : "\n",
          };
          var e;
        };
      function ye(t, e) {
        if (
          e &&
          ((function (t) {
            if (
              (Object.keys(t).forEach((t) => {
                if (!he.hasOwnProperty(t))
                  throw new Error(`pretty-format: Unknown option "${t}".`);
              }),
              t.min && void 0 !== t.indent && 0 !== t.indent)
            )
              throw new Error(
                'pretty-format: Options "min" and "indent" cannot be used together.'
              );
            if (void 0 !== t.theme) {
              if (null === t.theme)
                throw new Error(
                  'pretty-format: Option "theme" must not be null.'
                );
              if ("object" !== typeof t.theme)
                throw new Error(
                  `pretty-format: Option "theme" must be of type "object" but instead received "${typeof t.theme}".`
                );
            }
          })(e),
          e.plugins)
        ) {
          const n = ae(e.plugins, t);
          if (null !== n) return se(n, t, ge(e), "", 0, []);
        }
        const n = ie(t, de(e), fe(e), me(e));
        return null !== n ? n : oe(t, ge(e), "", 0, []);
      }
      var _e = {
        randomUUID:
          "undefined" !== typeof crypto &&
          crypto.randomUUID &&
          crypto.randomUUID.bind(crypto),
      };
      let ve;
      const be = new Uint8Array(16);
      function xe() {
        if (
          !ve &&
          ((ve =
            "undefined" !== typeof crypto &&
            crypto.getRandomValues &&
            crypto.getRandomValues.bind(crypto)),
          !ve)
        )
          throw new Error(
            "crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"
          );
        return ve(be);
      }
      const we = [];
      for (let Kn = 0; Kn < 256; ++Kn)
        we.push((Kn + 256).toString(16).slice(1));
      function Se(t, e = 0) {
        return (
          we[t[e + 0]] +
          we[t[e + 1]] +
          we[t[e + 2]] +
          we[t[e + 3]] +
          "-" +
          we[t[e + 4]] +
          we[t[e + 5]] +
          "-" +
          we[t[e + 6]] +
          we[t[e + 7]] +
          "-" +
          we[t[e + 8]] +
          we[t[e + 9]] +
          "-" +
          we[t[e + 10]] +
          we[t[e + 11]] +
          we[t[e + 12]] +
          we[t[e + 13]] +
          we[t[e + 14]] +
          we[t[e + 15]]
        ).toLowerCase();
      }
      var Ee = function (t, e, n) {
          if (_e.randomUUID && !e && !t) return _e.randomUUID();
          const r = (t = t || {}).random || (t.rng || xe)();
          if (((r[6] = (15 & r[6]) | 64), (r[8] = (63 & r[8]) | 128), e)) {
            n = n || 0;
            for (let t = 0; t < 16; ++t) e[n + t] = r[t];
            return e;
          }
          return Se(r);
        },
        Te = n(86874),
        Ae = n(41465),
        Ce = function (t, e) {
          return (
            (Ce =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (t, e) {
                  t.__proto__ = e;
                }) ||
              function (t, e) {
                for (var n in e)
                  Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
              }),
            Ce(t, e)
          );
        };
      function Pe(t, e) {
        if ("function" !== typeof e && null !== e)
          throw new TypeError(
            "Class extends value " + String(e) + " is not a constructor or null"
          );
        function n() {
          this.constructor = t;
        }
        Ce(t, e),
          (t.prototype =
            null === e
              ? Object.create(e)
              : ((n.prototype = e.prototype), new n()));
      }
      function Me(t, e, n, r) {
        return new (n || (n = Promise))(function (i, o) {
          function s(t) {
            try {
              l(r.next(t));
            } catch (e) {
              o(e);
            }
          }
          function a(t) {
            try {
              l(r.throw(t));
            } catch (e) {
              o(e);
            }
          }
          function l(t) {
            var e;
            t.done
              ? i(t.value)
              : ((e = t.value),
                e instanceof n
                  ? e
                  : new n(function (t) {
                      t(e);
                    })).then(s, a);
          }
          l((r = r.apply(t, e || [])).next());
        });
      }
      function Oe(t, e) {
        var n,
          r,
          i,
          o,
          s = {
            label: 0,
            sent: function () {
              if (1 & i[0]) throw i[1];
              return i[1];
            },
            trys: [],
            ops: [],
          };
        return (
          (o = { next: a(0), throw: a(1), return: a(2) }),
          "function" === typeof Symbol &&
            (o[Symbol.iterator] = function () {
              return this;
            }),
          o
        );
        function a(a) {
          return function (l) {
            return (function (a) {
              if (n) throw new TypeError("Generator is already executing.");
              for (; o && ((o = 0), a[0] && (s = 0)), s; )
                try {
                  if (
                    ((n = 1),
                    r &&
                      (i =
                        2 & a[0]
                          ? r.return
                          : a[0]
                          ? r.throw || ((i = r.return) && i.call(r), 0)
                          : r.next) &&
                      !(i = i.call(r, a[1])).done)
                  )
                    return i;
                  switch (((r = 0), i && (a = [2 & a[0], i.value]), a[0])) {
                    case 0:
                    case 1:
                      i = a;
                      break;
                    case 4:
                      return s.label++, { value: a[1], done: !1 };
                    case 5:
                      s.label++, (r = a[1]), (a = [0]);
                      continue;
                    case 7:
                      (a = s.ops.pop()), s.trys.pop();
                      continue;
                    default:
                      if (
                        !(i = (i = s.trys).length > 0 && i[i.length - 1]) &&
                        (6 === a[0] || 2 === a[0])
                      ) {
                        s = 0;
                        continue;
                      }
                      if (3 === a[0] && (!i || (a[1] > i[0] && a[1] < i[3]))) {
                        s.label = a[1];
                        break;
                      }
                      if (6 === a[0] && s.label < i[1]) {
                        (s.label = i[1]), (i = a);
                        break;
                      }
                      if (i && s.label < i[2]) {
                        (s.label = i[2]), s.ops.push(a);
                        break;
                      }
                      i[2] && s.ops.pop(), s.trys.pop();
                      continue;
                  }
                  a = e.call(t, s);
                } catch (l) {
                  (a = [6, l]), (r = 0);
                } finally {
                  n = i = 0;
                }
              if (5 & a[0]) throw a[1];
              return { value: a[0] ? a[1] : void 0, done: !0 };
            })([a, l]);
          };
        }
      }
      var ke = (function () {
          function t() {
            (this.remotePath = null),
              (this.localPath = null),
              (this.initialized = !1),
              (this.data = {
                type: "",
                content: "",
                origin: {
                  function_name: "",
                  file: "",
                  line_number: 0,
                  hostname: "remote",
                },
              });
          }
          return (
            (t.prototype.replaceRemotePathWithLocalPath = function (t) {
              if (null === this.remotePath || null === this.localPath) return t;
              var e = new RegExp("^" + this.remotePath);
              return t.replace(e, this.localPath);
            }),
            (t.prototype.getContent = function () {
              return {};
            }),
            (t.prototype.toArray = function () {
              return (
                this.initialized ||
                  ((this.initialized = !0),
                  (this.data.type = this.getType()),
                  (this.data.content = this.getContent()),
                  (this.data.origin.file = this.replaceRemotePathWithLocalPath(
                    this.data.origin.file
                  ))),
                this.data
              );
            }),
            (t.prototype.toJson = function () {
              return JSON.stringify(this.toArray());
            }),
            t
          );
        })(),
        Ie = (function (t) {
          function e() {
            return (null !== t && t.apply(this, arguments)) || this;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "clear_all";
            }),
            e
          );
        })(ke),
        De = (function () {
          function t(t, e, n) {
            void 0 === t && (t = 23517),
              void 0 === e && (e = "localhost"),
              void 0 === n && (n = "http"),
              (this.scheme = "http"),
              (this.portNumber = t),
              (this.host = e),
              (this.scheme = n);
          }
          return (
            (t.prototype.init = function () {
              return Me(this, void 0, void 0, function () {
                return Oe(this, function (t) {
                  switch (t.label) {
                    case 0:
                      return [4, this.updateRayAvailabilty()];
                    case 1:
                      return t.sent(), [2];
                  }
                });
              });
            }),
            (t.prototype.isRayAvailable = function () {
              return (
                this.attemptAvailableReset(),
                null === t.rayState && this.updateRayAvailabilty(),
                null === t.rayState || t.rayState
              );
            }),
            (t.prototype.attemptAvailableReset = function () {
              null !== t.lastRayStateCheck &&
                new Date().getTime() - t.lastRayStateCheck >= 3e4 &&
                (t.rayState = null);
            }),
            (t.prototype.updateRayAvailabilty = function () {
              return Me(this, void 0, void 0, function () {
                var e, n;
                return Oe(this, function (r) {
                  switch (r.label) {
                    case 0:
                      if (
                        ((e = !0),
                        null !== t.lastRayStateCheck &&
                          new Date().getTime() - t.lastRayStateCheck < 3e4)
                      )
                        return [2, !0];
                      (t.lastRayStateCheck = new Date().getTime()),
                        (r.label = 1);
                    case 1:
                      return (
                        r.trys.push([1, 3, 4, 5]),
                        [
                          4,
                          Zt.get(
                            this.getUrlForPath("/locks/__availabilty_check"),
                            {}
                          ),
                        ]
                      );
                    case 2:
                      return r.sent(), [3, 5];
                    case 3:
                      return (
                        (n = r.sent()),
                        (e = !!n.response || (n.request, !1)),
                        [3, 5]
                      );
                    case 4:
                      return (t.rayState = e), [7];
                    case 5:
                      return [2];
                  }
                });
              });
            }),
            (t.prototype.getUrlForPath = function (t) {
              var e;
              return (
                (t = t.replace(/^\//, "")),
                ""
                  .concat(
                    null !== (e = this.scheme) && void 0 !== e ? e : "http",
                    "://"
                  )
                  .concat(this.host, ":")
                  .concat(this.portNumber, "/")
                  .concat(t)
              );
            }),
            (t.prototype.send = function (e) {
              return Me(this, void 0, void 0, function () {
                return Oe(this, function (n) {
                  switch (n.label) {
                    case 0:
                      (null !== t.rayState && null !== t.lastRayStateCheck) ||
                        this.updateRayAvailabilty(),
                        (n.label = 1);
                    case 1:
                      return (
                        n.trys.push([1, 3, , 4]),
                        (e.payloads = this.ensureAllPayloadsHaveAnOrigin(
                          e.payloads
                        )),
                        [
                          4,
                          Zt.post(this.getUrlForPath("/"), e.toArray(), {
                            withCredentials: !1,
                          }),
                        ]
                      );
                    case 2:
                    case 3:
                      return n.sent(), [3, 4];
                    case 4:
                      return [2];
                  }
                });
              });
            }),
            (t.prototype.ensureAllPayloadsHaveAnOrigin = function (t) {
              return (
                t.forEach(function (t) {
                  (null !== t.data.origin.file &&
                    "" !== t.data.origin.file &&
                    "undefined" !== typeof t.data.origin.file) ||
                    ((t.data.origin.file = "/unknown-file.js"),
                    (t.data.origin.line_number = 1),
                    (t.data.origin.function_name = "unknown"));
                }),
                t
              );
            }),
            (t.prototype.lockExists = function (t) {
              return Me(this, void 0, void 0, function () {
                var e = this;
                return Oe(this, function (n) {
                  return [
                    2,
                    new Promise(function (n, r) {
                      return Me(e, void 0, void 0, function () {
                        var e;
                        return Oe(this, function (i) {
                          switch (i.label) {
                            case 0:
                              return (
                                i.trys.push([0, 2, , 3]),
                                [
                                  4,
                                  Zt.get(
                                    this.getUrlForPath("/locks/".concat(t))
                                  ),
                                ]
                              );
                            case 1:
                              return (e = i.sent()), [3, 3];
                            case 2:
                              return i.sent(), [2, !1];
                            case 3:
                              return e.data.stop_execution
                                ? (r(new Error("stopping execution")), [2])
                                : (e.data.active, n(e.data), [2]);
                          }
                        });
                      });
                    }),
                  ];
                });
              });
            }),
            (t.rayState = !0),
            (t.lastRayStateCheck = null),
            t
          );
        })(),
        ze = (function () {
          function t() {}
          return (
            (t.removeRayFrames = function (e) {
              return e.filter(function (e) {
                return !t.isRayFrame(e) && !t.isNodeFrame(e);
              });
            }),
            (t.isRayFrame = function (t) {
              for (var e, n = 0, r = this.rayNamespaces(); n < r.length; n++) {
                var i = r[n];
                if (
                  null === (e = t.fileName) || void 0 === e
                    ? void 0
                    : e.includes(i)
                )
                  return !0;
              }
              return !1;
            }),
            (t.isNodeFrame = function (t) {
              var e;
              return (
                0 ===
                (null === (e = t.fileName) || void 0 === e
                  ? void 0
                  : e.indexOf("node:"))
              );
            }),
            (t.rayNamespaces = function () {
              return ["ray-node/dist", "node-ray/dist", "vue-ray/dist"];
            }),
            t
          );
        })(),
        Re = (function (t) {
          function e(e) {
            var n = t.call(this) || this;
            return (n.frames = ze.removeRayFrames(e)), n;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "caller";
            }),
            (e.prototype.getContent = function () {
              var t = this.frames.slice(0)[0],
                e = t
                  .getFunctionName()
                  .replace("Proxy.", "")
                  .split(".")
                  .slice(0),
                n = e.length ? e.shift() : "",
                r = e.join(".");
              return {
                frame: {
                  file_name: this.replaceRemotePathWithLocalPath(
                    t.getFileName()
                  ),
                  line_number: t.getLineNumber(),
                  class: n,
                  method: r,
                  vendor_frame: t.getFileName().includes("node_modules"),
                },
              };
            }),
            e
          );
        })(ke),
        Le = (function (t) {
          function e(e) {
            var n = t.call(this) || this;
            return (n.color = e), n;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "color";
            }),
            (e.prototype.getContent = function () {
              return { color: this.color };
            }),
            e
          );
        })(ke),
        Fe = (function (t) {
          function e() {
            return (null !== t && t.apply(this, arguments)) || this;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "confetti";
            }),
            e
          );
        })(ke),
        Be = console.log.bind({}),
        Ne = function () {
          for (var t, e = [], n = 0; n < arguments.length; n++)
            e[n] = arguments[n];
          "undefined" !== typeof Hn.client &&
            Hn.client.isRayAvailable() &&
            (t = Hn.create()).send.apply(t, e),
            Be.apply(void 0, e);
        },
        je = (function () {
          function t() {}
          return (
            (t.prototype.enable = function () {
              (t.active = !0), (console.log = Ne);
            }),
            (t.prototype.disable = function () {
              (t.active = !1), (console.log = Be);
            }),
            (t.prototype.active = function () {
              return t.active;
            }),
            (t.active = !1),
            t
          );
        })(),
        Ue = (function () {
          function t() {
            this.counters = {};
          }
          return (
            (t.prototype.increment = function (t) {
              "undefined" === typeof this.counters[t] &&
                (this.counters[t] = [Xn(), 0]);
              var e = this.counters[t],
                n = e[0],
                r = e[1] + 1;
              return (this.counters[t] = [n, r]), [n, r];
            }),
            (t.prototype.get = function (t) {
              return "undefined" === typeof this.counters[t]
                ? 0
                : this.counters[t][1];
            }),
            (t.prototype.clear = function () {
              this.counters = [];
            }),
            (t.prototype.setRay = function (t, e) {
              this.counters[t][0] = e;
            }),
            (t.prototype.getCounters = function () {
              return this.counters;
            }),
            t
          );
        })(),
        Ze = (function (t) {
          function e(e) {
            var n = t.call(this) || this;
            return (n.name = e), n;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "create_lock";
            }),
            (e.prototype.getContent = function () {
              return { name: this.name };
            }),
            e
          );
        })(ke),
        Ve = (function (t) {
          function e(e, n) {
            void 0 === n && (n = "");
            var r = t.call(this) || this;
            return (r.content = e), (r.label = n), r;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "custom";
            }),
            (e.prototype.getContent = function () {
              return { content: this.content, label: this.label };
            }),
            e
          );
        })(ke),
        qe = (function (t) {
          function e(e, n) {
            void 0 === n && (n = "YYYY-MM-DD hh:mm:ss");
            var r = t.call(this) || this;
            return (r.date = e), (r.format = n), r;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "carbon";
            }),
            (e.prototype.getContent = function () {
              return {
                formatted: this.date ? this.getFormatted() : null,
                timestamp: this.date ? this.getTimestamp() : null,
                timezone: this.date ? this.getTimezoneName() : null,
              };
            }),
            (e.prototype.getTimestamp = function () {
              var t;
              return Vt(
                null === (t = this.date) || void 0 === t
                  ? void 0
                  : t.toISOString()
              ).unix();
            }),
            (e.prototype.getFormatted = function () {
              var t;
              return Vt(
                null === (t = this.date) || void 0 === t
                  ? void 0
                  : t.toISOString()
              ).format(this.format);
            }),
            (e.prototype.getTimezoneName = function () {
              if (null === this.date) return "--";
              var t = this.date ? this.date : new Date(),
                e = /\((.*)\)/.exec(t.toString());
              return e ? e[1] : "--";
            }),
            e
          );
        })(ke),
        $e = (function (t) {
          function e(e) {
            var n = t.call(this) || this;
            return (n.value = e), n;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "custom";
            }),
            (e.prototype.getContent = function () {
              return { content: JSON.parse(this.value), label: "JSON" };
            }),
            e
          );
        })(ke),
        Ge = (function (t) {
          function e(e, n) {
            void 0 === n && (n = "Error");
            var r = t.call(this) || this;
            return (r.err = e), (r.label = n), r;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "custom";
            }),
            (e.prototype.getContent = function () {
              return { content: this.formatError(), label: this.label };
            }),
            (e.prototype.formatError = function () {
              return (
                '<span class="text-red-400 bold">'.concat(
                  this.err.name,
                  "</span>: <br>"
                ) +
                '<span class="pl-5 text-gray-500">'.concat(
                  this.err.message,
                  "</span>"
                )
              );
            }),
            e
          );
        })(ke),
        We = (function () {
          function t() {}
          return (
            (t.convertToPrimitive = function (e) {
              return null === e
                ? { value: null, isHtml: !1 }
                : "string" === typeof e ||
                  "number" === typeof e ||
                  "boolean" === typeof e
                ? { value: e, isHtml: !1 }
                : { value: t.prettyFormatForHtml(e), isHtml: !0 };
            }),
            (t.prettyFormatForHtml = function (t) {
              var e = ye(t, { indent: 4 })
                .replace(/ /g, "&nbsp;")
                .replace(/\r\n|\r|\n/g, "<br>")
                .replace(
                  /("[^"]+")/g,
                  '<code style="font-size: 0.8rem!important;" class="bold text-green-600 p-0">$1</code>'
                )
                .replace(
                  /Array(&nbsp;|\s)+(\[[^\]]+\])/g,
                  '<code style="font-size: 0.8rem!important;" class="text-gray-500 p-0">Array$1$2</code>'
                )
                .replace(
                  /^(\[[^\]]+\])$/g,
                  '<code style="font-size: 0.8rem!important;"class="text-gray-500 p-0">$1</code>'
                )
                .replace(
                  /(\{.+\})/g,
                  '<code style="font-size: 0.8rem!important;" class="text-gray-600 ">$1</code>'
                )
                .replace(
                  /(Array|Object|Function|Circular|Symbol|WeakMap|Map)/g,
                  '<span style="font-size: 0.8rem!important;" class="text-yellow-600 bold">$1</span>'
                )
                .replace(
                  /(true|false|null)/g,
                  '<span style="font-size: 0.8rem!important;" class="text-indigo-600 bold">$1</span>'
                )
                .replace(
                  /(:&nbsp;|[,[\]{}])/g,
                  '<span style="font-size: 0.8rem!important;" class="text-orange-400 bold">$1</span>'
                );
              return '<code style="font-size: 0.8rem!important;">'.concat(
                e,
                "</code>"
              );
            }),
            t
          );
        })(),
        He = (function (t) {
          function e(e, n) {
            var r = t.call(this) || this;
            return (r.eventName = e), (r.payload = n), r;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "event";
            }),
            (e.prototype.getContent = function () {
              return {
                name: this.eventName,
                event: this.payload[0],
                payload: We.convertToPrimitive(this.payload).value,
                class_based_event: !0,
              };
            }),
            e
          );
        })(ke),
        Xe = (function (t) {
          function e(e, n) {
            void 0 === n && (n = {});
            var r = t.call(this) || this;
            return (
              (r.meta = {}),
              (r.stack = i.getSync()),
              (r.exception = e),
              (r.meta = n),
              r
            );
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "exception";
            }),
            (e.prototype.getContent = function () {
              return {
                class: this.exception.name,
                message: this.exception.message,
                frames: this.getFrames(),
                meta: this.meta,
              };
            }),
            (e.prototype.getFrames = function () {
              var t = this;
              return this.stack
                .slice(1)
                .map(function (e) {
                  var n,
                    r,
                    i =
                      null !==
                        (r =
                          null === (n = e.functionName) || void 0 === n
                            ? void 0
                            : n.split(".")) && void 0 !== r
                        ? r
                        : ["unknown", "unknown"],
                    o = i.pop(),
                    s = i.pop();
                  return (
                    "undefined" === typeof s && (s = "unknown"),
                    {
                      file_name: t.replaceRemotePathWithLocalPath(
                        e.getFileName()
                      ),
                      line_number: e.getLineNumber(),
                      class: s,
                      method: o,
                      vendor_frame: e.getFileName().includes("node_modules"),
                      snippet: [],
                    }
                  );
                })
                .filter(function (t) {
                  return !t.file_name.startsWith("node:");
                })
                .filter(function (t) {
                  return !t.file_name.includes("jest-circus");
                })
                .filter(function (t) {
                  return "Ray" !== t.class && "exception" !== t.method;
                });
            }),
            e
          );
        })(ke),
        Ke = (function (t) {
          function e() {
            return (null !== t && t.apply(this, arguments)) || this;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "hide_app";
            }),
            e
          );
        })(ke),
        Ye = (function (t) {
          function e() {
            return (null !== t && t.apply(this, arguments)) || this;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "hide";
            }),
            e
          );
        })(ke),
        Qe = (function () {
          function t() {}
          return (
            (t.get = function () {
              var e;
              return null !== (e = t.hostname) && void 0 !== e ? e : "remote";
            }),
            (t.set = function (e) {
              t.hostname = e;
            }),
            (t.hostname = null),
            t
          );
        })(),
        Je = (function (t) {
          function e(e) {
            void 0 === e && (e = "");
            var n = t.call(this) || this;
            return (n.html = e), n;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "custom";
            }),
            (e.prototype.getContent = function () {
              return { content: this.html, label: "HTML" };
            }),
            e
          );
        })(ke),
        tn = (function (t) {
          function e(e) {
            var n = t.call(this) || this;
            return (n.location = e), n;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "custom";
            }),
            (e.prototype.getContent = function () {
              var t = this.location.replace('"', '\\\\"');
              return {
                content: '<img src="'.concat(t, '" alt="" />'),
                label: "Image",
              };
            }),
            e
          );
        })(ke),
        en = (function (t) {
          function e(e) {
            var n = t.call(this) || this;
            return (n.value = e), n;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "json_string";
            }),
            (e.prototype.getContent = function () {
              return { value: JSON.stringify(this.value) };
            }),
            e
          );
        })(ke),
        nn = (function (t) {
          function e(e) {
            var n = t.call(this) || this;
            return Array.isArray(e) || (e = [e]), (n.values = e), n;
          }
          return (
            Pe(e, t),
            (e.createForArguments = function (t) {
              return new this(
                t.map(function (t) {
                  return We.convertToPrimitive(t).value;
                })
              );
            }),
            (e.prototype.getType = function () {
              return "log";
            }),
            (e.prototype.getContent = function () {
              return { values: this.values };
            }),
            e
          );
        })(ke);
      function rn(t, e) {
        if (
          (void 0 === e && ((e = t), (t = 0)),
          "number" !== typeof t || "number" !== typeof e)
        )
          throw new TypeError("Expected all arguments to be numbers");
        return Math.floor(Math.random() * (e - t + 1) + t);
      }
      var on = function (t) {
          for (var e = new Date().getTime(); new Date().getTime() < e + t; );
        },
        sn = function (t, e) {
          return (
            void 0 === e && (e = { encodeEntities: !0 }),
            e.encodeEntities &&
              (t = (function (t) {
                var e = {
                    "\xa2": "cent",
                    "\xa3": "pound",
                    "\xa5": "yen",
                    "\u20ac": "euro",
                    "\xa9": "copy",
                    "\xae": "reg",
                    "<": "lt",
                    ">": "gt",
                    '"': "quot",
                    "&": "amp",
                    "'": "#39",
                  },
                  n = Object.keys(e),
                  r = new RegExp("[".concat(n.join(""), "]"), "g");
                return t.replace(r, function (t) {
                  return "&".concat(e[t], ";");
                });
              })(t)),
            t
              .replace(/^(\s+)/gm, function (t) {
                return "".concat("&nbsp;".repeat(t.length));
              })
              .replace(/(\r\n|\r|\n)/g, "<br>")
          );
        },
        an = function (t) {
          return !!t.length && t[t.length - 1];
        },
        ln = (function (t) {
          function e(e, n) {
            var r = t.call(this) || this;
            (r.isNewTimer = !1),
              (r.totalTime = 0),
              (r.maxMemoryUsageDuringTotalTime = 0),
              (r.timeSinceLastCall = 0),
              (r.maxMemoryUsageSinceLastCall = 0),
              (r.name = e),
              (r.totalTime = n.getDuration()),
              (r.maxMemoryUsageDuringTotalTime = n.getMemory());
            var i = n.getPeriods();
            return (
              i.length > 1 &&
                ((r.timeSinceLastCall = an(i)),
                (r.maxMemoryUsageSinceLastCall = 0)),
              r
            );
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "measure";
            }),
            (e.prototype.concernsNewTimer = function () {
              return (
                (this.isNewTimer = !0),
                (this.totalTime = 0),
                (this.maxMemoryUsageDuringTotalTime = 0),
                (this.timeSinceLastCall = 0),
                (this.maxMemoryUsageSinceLastCall = 0),
                this
              );
            }),
            (e.prototype.getContent = function () {
              return {
                name: this.name,
                is_new_timer: this.isNewTimer,
                total_time: this.totalTime,
                max_memory_usage_during_total_time:
                  this.maxMemoryUsageDuringTotalTime,
                time_since_last_call: this.timeSinceLastCall,
                max_memory_usage_since_last_call:
                  this.maxMemoryUsageSinceLastCall,
              };
            }),
            e
          );
        })(ke);
      const cn = (t, e, n = []) => {
          const r = Object.getOwnPropertyDescriptors(e);
          for (let i of n) delete r[i];
          Object.defineProperties(t, r);
        },
        un = (t, e = [t]) => {
          const n = Object.getPrototypeOf(t);
          return null === n ? e : un(n, [...e, n]);
        },
        hn = (t, e, n = []) => {
          var r;
          const i =
              null !==
                (r = ((...t) => {
                  if (0 === t.length) return;
                  let e;
                  const n = t.map((t) => un(t));
                  for (; n.every((t) => t.length > 0); ) {
                    const t = n.map((t) => t.pop()),
                      r = t[0];
                    if (!t.every((t) => t === r)) break;
                    e = r;
                  }
                  return e;
                })(...t)) && void 0 !== r
                ? r
                : Object.prototype,
            o = Object.create(i),
            s = un(i);
          for (let a of t) {
            let t = un(a);
            for (let e = t.length - 1; e >= 0; e--) {
              let r = t[e];
              -1 === s.indexOf(r) &&
                (cn(o, r, ["constructor", ...n]), s.push(r));
            }
          }
          return (o.constructor = e), o;
        },
        pn = (t) => t.filter((e, n) => t.indexOf(e) == n),
        dn = new Map(),
        fn = (t) => dn.get(t),
        mn = (t, e) => {
          var n, r;
          const i = pn([
              ...Object.getOwnPropertyNames(t),
              ...Object.getOwnPropertyNames(e),
            ]),
            o = {};
          for (let s of i)
            o[s] = pn([
              ...(null !== (n = null === t || void 0 === t ? void 0 : t[s]) &&
              void 0 !== n
                ? n
                : []),
              ...(null !== (r = null === e || void 0 === e ? void 0 : e[s]) &&
              void 0 !== r
                ? r
                : []),
            ]);
          return o;
        },
        gn = (t, e) => {
          var n, r, i, o;
          return {
            property: mn(
              null !== (n = null === t || void 0 === t ? void 0 : t.property) &&
                void 0 !== n
                ? n
                : {},
              null !== (r = null === e || void 0 === e ? void 0 : e.property) &&
                void 0 !== r
                ? r
                : {}
            ),
            method: mn(
              null !== (i = null === t || void 0 === t ? void 0 : t.method) &&
                void 0 !== i
                ? i
                : {},
              null !== (o = null === e || void 0 === e ? void 0 : e.method) &&
                void 0 !== o
                ? o
                : {}
            ),
          };
        },
        yn = new Map(),
        _n = (...t) => {
          const e = ((...t) => {
            var e;
            const n = new Set(),
              r = new Set([...t]);
            for (; r.size > 0; )
              for (let t of r) {
                const i = [
                  ...un(t.prototype).map((t) => t.constructor),
                  ...(null !== (e = fn(t)) && void 0 !== e ? e : []),
                ].filter((t) => !n.has(t));
                for (let t of i) r.add(t);
                n.add(t), r.delete(t);
              }
            return [...n];
          })(...t)
            .map((t) => yn.get(t))
            .filter((t) => !!t);
          return 0 == e.length
            ? {}
            : 1 == e.length
            ? e[0]
            : e.reduce((t, e) =>
                ((t, e) => {
                  var n, r, i, o, s, a;
                  return {
                    class: pn([
                      ...(null !==
                        (n = null === t || void 0 === t ? void 0 : t.class) &&
                      void 0 !== n
                        ? n
                        : []),
                      ...(null !==
                        (r = null === e || void 0 === e ? void 0 : e.class) &&
                      void 0 !== r
                        ? r
                        : []),
                    ]),
                    static: gn(
                      null !==
                        (i = null === t || void 0 === t ? void 0 : t.static) &&
                        void 0 !== i
                        ? i
                        : {},
                      null !==
                        (o = null === e || void 0 === e ? void 0 : e.static) &&
                        void 0 !== o
                        ? o
                        : {}
                    ),
                    instance: gn(
                      null !==
                        (s =
                          null === t || void 0 === t ? void 0 : t.instance) &&
                        void 0 !== s
                        ? s
                        : {},
                      null !==
                        (a =
                          null === e || void 0 === e ? void 0 : e.instance) &&
                        void 0 !== a
                        ? a
                        : {}
                    ),
                  };
                })(t, e)
              );
        };
      const vn = (t, e) => {
        const n = t.property,
          r = t.method;
        if (n) for (let i in n) for (let t of n[i]) t(e, i);
        if (r)
          for (let i in r)
            for (let t of r[i]) t(e, i, Object.getOwnPropertyDescriptor(e, i));
      };
      var bn = (function (t) {
          function e(e) {
            var n = t.call(this) || this;
            return (n.name = e), n;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "new_screen";
            }),
            (e.prototype.getContent = function () {
              return { name: this.name };
            }),
            e
          );
        })(ke),
        xn = (function (t) {
          function e(e) {
            var n = t.call(this) || this;
            return (n.text = e), n;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "notify";
            }),
            (e.prototype.getContent = function () {
              return { value: this.text };
            }),
            e
          );
        })(ke),
        wn = (function (t) {
          function e(e) {
            var n = t.call(this) || this;
            return (n.value = e), n;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "custom";
            }),
            (e.prototype.getContent = function () {
              return { content: this.value, label: "Boolean" };
            }),
            e
          );
        })(ke),
        Sn = (function (t) {
          function e() {
            return (null !== t && t.apply(this, arguments)) || this;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "custom";
            }),
            (e.prototype.getContent = function () {
              return { content: null, label: "Null" };
            }),
            e
          );
        })(ke),
        En = (function () {
          function t(t) {
            this.values = t;
          }
          return (
            (t.createForValues = function (t) {
              return new this(t).getPayloads();
            }),
            (t.registerPayloadFinder = function (t) {
              this.payloadFinder = t;
            }),
            (t.prototype.getPayloads = function () {
              var t = this;
              return this.values.map(function (e) {
                return t.getPayload(e);
              });
            }),
            (t.prototype.getPayload = function (t) {
              if ("boolean" === typeof t) return new wn(t);
              if (null === t) return new Sn();
              var e = We.convertToPrimitive(t);
              return e.isHtml ? new Je(e.value) : new nn(e.value);
            }),
            (t.payloadFinder = null),
            t
          );
        })(),
        Tn = (function () {
          function t() {}
          return (
            (t.prototype.color = function (t) {
              return this;
            }),
            (t.prototype.green = function () {
              return this.color("green");
            }),
            (t.prototype.orange = function () {
              return this.color("orange");
            }),
            (t.prototype.red = function () {
              return this.color("red");
            }),
            (t.prototype.purple = function () {
              return this.color("purple");
            }),
            (t.prototype.blue = function () {
              return this.color("blue");
            }),
            (t.prototype.gray = function () {
              return this.color("gray");
            }),
            t
          );
        })(),
        An = (function () {
          function t(t) {
            for (var e in ((this.enable = !0),
            (this._host = "localhost"),
            (this._port = 23517),
            (this._scheme = "http"),
            (this.remote_path = null),
            (this.local_path = null),
            (this.always_send_raw_values = !1),
            (this.intercept_console_log = !1),
            (this.enabled_callback = null),
            (this.sent_payload_callback = null),
            (this.sending_payload_callback = null),
            (this.originalSettings = Object.assign({}, t)),
            t))
              this[e] = t[e];
          }
          return (
            Object.defineProperty(t.prototype, "host", {
              get: function () {
                return this._host;
              },
              set: function (t) {
                (this._host = t),
                  Hn.useClient(new De(this.port, this.host, this.scheme));
              },
              enumerable: !1,
              configurable: !0,
            }),
            Object.defineProperty(t.prototype, "port", {
              get: function () {
                return this._port;
              },
              set: function (t) {
                (this._port = t),
                  Hn.useClient(new De(this.port, this.host, this.scheme));
              },
              enumerable: !1,
              configurable: !0,
            }),
            Object.defineProperty(t.prototype, "scheme", {
              get: function () {
                return this._scheme;
              },
              set: function (t) {
                (this._scheme = t),
                  Hn.useClient(new De(this.port, this.host, this.scheme));
              },
              enumerable: !1,
              configurable: !0,
            }),
            (t.prototype.toObject = function () {
              return this.originalSettings;
            }),
            t
          );
        })(),
        Cn = (function () {
          function t() {}
          return (
            (t.prototype.size = function (t) {
              return this;
            }),
            (t.prototype.small = function () {
              return this.size("sm");
            }),
            (t.prototype.large = function () {
              return this.size("lg");
            }),
            t
          );
        })(),
        Pn = (function (t) {
          function e() {
            return (null !== t && t.apply(this, arguments)) || this;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "remove";
            }),
            e
          );
        })(ke),
        Mn = (function () {
          function t(t, e, n) {
            void 0 === n && (n = []),
              (this.uuid = t),
              (this.payloads = e),
              (this.meta = n);
          }
          return (
            (t.prototype.toArray = function () {
              return {
                uuid: this.uuid,
                payloads: this.payloads.map(function (t) {
                  return t.toArray();
                }),
                meta: this.meta,
              };
            }),
            (t.prototype.toJson = function () {
              return JSON.stringify(this.toArray());
            }),
            t
          );
        })(),
        On = (function (t) {
          function e() {
            return (null !== t && t.apply(this, arguments)) || this;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "show_app";
            }),
            e
          );
        })(ke),
        kn = (function (t) {
          function e(e) {
            var n = t.call(this) || this;
            return (n.size = e), n;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "size";
            }),
            (e.prototype.getContent = function () {
              return { size: this.size };
            }),
            e
          );
        })(ke),
        In = (function () {
          function t(t, e) {
            var n;
            void 0 === e && (e = null),
              (this.laps = []),
              (this.name =
                null === (n = t.name) || void 0 === n ? void 0 : n.slice(0)),
              (this.laps = t.laps.slice(0)),
              (this.startedAt = t.startedAt),
              (this.endedAt = t.endedAt),
              (this.lapTime =
                null !== e && void 0 !== e ? e : new Date().getTime());
          }
          return (
            (t.prototype.getDuration = function () {
              return this.laps.reduce(function (t, e) {
                return e + t;
              }, 0);
            }),
            (t.prototype.getMemory = function () {
              return 0;
            }),
            (t.prototype.getPeriods = function () {
              return this.laps.slice();
            }),
            (t.prototype.getPreviousDuration = function () {
              return an(this.laps) - (new Date().getTime() - this.lapTime);
            }),
            t
          );
        })(),
        Dn = (function () {
          function t(t) {
            void 0 === t && (t = void 0),
              (this.laps = []),
              (this.startedAt = 0),
              (this.endedAt = 0),
              (this.name = t),
              (this.sw = new Te.G(t)),
              (this.laps = []),
              (this.startedAt = 0),
              (this.endedAt = 0);
          }
          return (
            (t.prototype.initialize = function (t) {
              (this.name = t),
                (this.sw = new Te.G(t)),
                (this.laps = []),
                (this.startedAt = 0),
                (this.endedAt = 0);
            }),
            (t.prototype.start = function (t) {
              return (
                (this.startedAt = new Date().getTime()),
                this.sw.start(t),
                new In(this)
              );
            }),
            (t.prototype.lap = function () {
              var t = new Date().getTime(),
                e = t - this.startedAt;
              return this.laps.push(e - this.totalDuration()), new In(this, t);
            }),
            (t.prototype.stop = function () {
              this.sw.stop(), (this.endedAt = new Date().getTime());
              var t = this.endedAt - this.startedAt;
              return this.laps.push(t - this.totalDuration()), new In(this);
            }),
            (t.prototype.totalDuration = function () {
              return this.laps.reduce(function (t, e) {
                return e + t;
              }, 0);
            }),
            (t.prototype.reset = function () {
              return this.initialize(this.name), this;
            }),
            (t.prototype.getLaps = function () {
              return this.laps;
            }),
            t
          );
        })(),
        zn = (function (t) {
          function e(e, n) {
            void 0 === n && (n = "Table");
            var r = t.call(this) || this;
            return (r.values = e), (r.label = n), r;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "table";
            }),
            (e.prototype.getContent = function () {
              return { values: this.getValues(), label: this.label };
            }),
            (e.prototype.getValues = function () {
              if (Array.isArray(this.values))
                return this.values.map(function (t) {
                  return We.convertToPrimitive(t).value;
                });
              var t = {};
              for (var e in this.values)
                t[e] = We.convertToPrimitive(this.values[e]).value;
              return t;
            }),
            e
          );
        })(ke),
        Rn = (function (t) {
          function e(e) {
            var n = t.call(this) || this;
            return (
              (n.startFromIndexNum = null),
              (n.limitNum = null),
              (n.frames = ze.removeRayFrames(e)),
              n
            );
          }
          return (
            Pe(e, t),
            (e.prototype.startFromIndex = function (t) {
              return (this.startFromIndexNum = t), this;
            }),
            (e.prototype.limit = function (t) {
              return (this.limitNum = t), this;
            }),
            (e.prototype.getType = function () {
              return "trace";
            }),
            (e.prototype.getContent = function () {
              var t,
                e = this,
                n = this.frames.map(function (t) {
                  var n = t
                      .getFunctionName()
                      .replace("Proxy.", "")
                      .split(".")
                      .slice(0),
                    r = n.length ? n.shift() : "",
                    i = n.join(".");
                  return {
                    file_name: e.replaceRemotePathWithLocalPath(
                      t.getFileName()
                    ),
                    line_number: t.getLineNumber(),
                    class: r,
                    method: i,
                    vendor_frame: t.getFileName().includes("node_modules"),
                  };
                });
              return (
                null !== this.limitNum &&
                  (n = n.slice(
                    null !== (t = this.startFromIndexNum) && void 0 !== t
                      ? t
                      : 0,
                    this.limitNum
                  )),
                { frames: n }
              );
            }),
            e
          );
        })(ke),
        Ln = (function (t) {
          function e(e) {
            var n = t.call(this) || this;
            return (n.value = e), n;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "custom";
            }),
            (e.prototype.getContent = function () {
              return {
                content: this.formatXmlForDisplay(this.value),
                label: "XML",
              };
            }),
            (e.prototype.formatXmlForDisplay = function (t) {
              var e = this.formatAndIndentXml(t);
              return this.encodeXml(e);
            }),
            (e.prototype.encodeXml = function (t) {
              return sn(t, { encodeEntities: !0 });
            }),
            (e.prototype.formatAndIndentXml = function (t) {
              return Ae(t.toString(), {
                indentation: "    ",
                collapseContent: !0,
                lineSeparator: "\n",
              });
            }),
            e
          );
        })(ke),
        Fn = (function (t) {
          function e(e, n) {
            void 0 === n && (n = { highlight: "none" });
            var r = t.call(this) || this;
            return (r.value = e), (r.options = n), r;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "custom";
            }),
            (e.prototype.getContent = function () {
              return {
                content: this.formatMarkupForDisplay(this.value),
                label: "Markup",
              };
            }),
            (e.prototype.formatMarkupForDisplay = function (t) {
              var e = this.formatAndIndentMarkup(t);
              return this.highlightHtmlMarkup(sn(e, { encodeEntities: !0 }));
            }),
            (e.prototype.formatAndIndentMarkup = function (t) {
              return Ae(t.toString(), {
                indentation: "    ",
                collapseContent: !0,
                lineSeparator: "\n",
              });
            }),
            (e.prototype.highlightHtmlMarkup = function (t) {
              return t
                .replace(/&quot;/g, '"')
                .replace(
                  /="([^"]+)"/g,
                  "=<span style='color:#16A34A;'>&quot;$1&quot;</span>"
                )
                .replace(
                  /(&lt;[A-Za-z\d-]+)(\s|&nbsp;|&gt;)/g,
                  '<span style="color:#1D4ED8;">$1</span>$2'
                )
                .replace(
                  /(&lt;\/[A-Za-z\d-]+)(&gt;)/g,
                  '<span style="color:#1D4ED8;">$1$2</span>'
                );
            }),
            e
          );
        })(ke),
        Bn = (function (t) {
          function e(e) {
            var n = t.call(this) || this;
            return (n.text = e), n;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "custom";
            }),
            (e.prototype.getContent = function () {
              return { content: this.formatContent(), label: "Text" };
            }),
            (e.prototype.formatContent = function () {
              return sn(this.text, { encodeEntities: !0 });
            }),
            e
          );
        })(ke),
        Nn = (function () {
          function t(t) {
            (this.store = []), (this.clock = t);
          }
          return (
            (t.prototype.hit = function () {
              return this.store.push(this.clock.now()), this;
            }),
            (t.prototype.clear = function () {
              return (this.store = []), this;
            }),
            (t.prototype.count = function () {
              return this.store.length;
            }),
            (t.prototype.countLastSecond = function () {
              var t = this,
                e = this.clock.now().modify("-1 second"),
                n = 0;
              return (
                this.store.forEach(function (r) {
                  t.isBetween(r, e, t.clock.now()) && n++;
                }),
                n
              );
            }),
            (t.prototype.isBetween = function (t, e, n) {
              return (
                t.getTimestamp() >= e.getTimestamp() &&
                t.getTimestamp() <= n.getTimestamp()
              );
            }),
            t
          );
        })(),
        jn = function () {},
        Un = (function () {
          function t(t) {
            void 0 === t && (t = null),
              (this.date = null !== t && void 0 !== t ? t : new Date()),
              (this.dateStr = this.date.toISOString()),
              (this.dateTs = this.date.getTime());
          }
          return (
            Object.defineProperty(t.prototype, "date", {
              get: function () {
                return Vt(this.dateStr).toDate();
              },
              set: function (t) {
                (this.dateTs = t.getTime()), (this.dateStr = t.toISOString());
              },
              enumerable: !1,
              configurable: !0,
            }),
            (t.createFrom = function (e) {
              return new t(e);
            }),
            (t.prototype.getTimestamp = function () {
              return Math.floor(this.dateTs / 1e3);
            }),
            (t.prototype.modify = function (e) {
              for (var n = e.split(" "), r = [], i = 0; i < n.length; i++)
                r.push({ value: Number(n[i]), unit: n[i + 1] }), i++;
              var o = Vt(1e3 * this.getTimestamp());
              return (
                r.forEach(function (t) {
                  o = o.add(1e3 * t.value);
                }),
                t.createFrom(o.toDate())
              );
            }),
            t
          );
        })(),
        Zn = (function (t) {
          function e() {
            return (null !== t && t.apply(this, arguments)) || this;
          }
          return (
            Pe(e, t),
            (e.prototype.now = function () {
              return new Un();
            }),
            e
          );
        })(jn),
        Vn = (function () {
          function t(t, e) {
            void 0 === t && (t = null),
              void 0 === e && (e = null),
              (this.notified = !1),
              (this.maxCalls = t),
              (this.maxPerSecond = e),
              (this.cache = new Nn(new Zn()));
          }
          return (
            (t.disabled = function () {
              return new t(null, null);
            }),
            (t.prototype.hit = function () {
              return this.cache.hit(), this;
            }),
            (t.prototype.max = function (t) {
              return void 0 === t && (t = null), (this.maxCalls = t), this;
            }),
            (t.prototype.perSecond = function (t) {
              return void 0 === t && (t = null), (this.maxPerSecond = t), this;
            }),
            (t.prototype.isMaxReached = function () {
              if (null === this.maxCalls) return !1;
              var t = this.cache.count() >= this.maxCalls;
              return t || (this.notified = !1), t;
            }),
            (t.prototype.isMaxPerSecondReached = function () {
              if (null === this.maxPerSecond) return !1;
              var t = this.cache.countLastSecond() >= this.maxPerSecond;
              return !1 === t && (this.notified = !1), t;
            }),
            (t.prototype.clear = function () {
              return (
                (this.maxCalls = null),
                (this.maxPerSecond = null),
                this.cache.clear(),
                this
              );
            }),
            (t.prototype.isNotified = function () {
              return this.notified;
            }),
            (t.prototype.notify = function () {
              this.notified = !0;
            }),
            (t.prototype.getCache = function () {
              return this.cache;
            }),
            t
          );
        })(),
        qn = (function () {
          function t() {
            this.counters = {};
          }
          return (
            (t.prototype.initialize = function (t, e) {
              var n = "".concat(t.file, ":").concat(t.line_number);
              return (
                "undefined" === typeof this.counters[n] &&
                  (this.counters[n] = { counter: 0, limit: e, valid: !0 }),
                this.counters[n]
              );
            }),
            (t.prototype.increment = function (t) {
              var e = "".concat(t.file, ":").concat(t.line_number);
              if ("undefined" === typeof this.counters[e])
                return { counter: 0, limit: 0, valid: !1 };
              var n = this.counters[e],
                r = n.counter,
                i = n.limit,
                o = n.valid;
              return (
                (this.counters[e] = { counter: r + 1, limit: i, valid: o }),
                this.counters[e]
              );
            }),
            (t.prototype.canSendPayload = function (t) {
              var e = "".concat(t.file, ":").concat(t.line_number);
              if ("undefined" === typeof this.counters[e]) return !0;
              var n = this.counters[e],
                r = n.counter,
                i = n.limit;
              return n.valid && (r < i || i <= 0);
            }),
            t
          );
        })(),
        $n = (function (t) {
          function e(e) {
            var n = t.call(this) || this;
            return (n.label = e), n;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "label";
            }),
            (e.prototype.getContent = function () {
              return { label: this.label };
            }),
            e
          );
        })(ke),
        Gn = (function (t) {
          function e() {
            return (null !== t && t.apply(this, arguments)) || this;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "separator";
            }),
            e
          );
        })(ke),
        Wn = (function (t) {
          function e(e) {
            var n = t.call(this) || this;
            return (n.color = e), n;
          }
          return (
            Pe(e, t),
            (e.prototype.getType = function () {
              return "screen_color";
            }),
            (e.prototype.getContent = function () {
              return { color: this.color };
            }),
            e
          );
        })(ke),
        Hn = (function (t) {
          function e(n, r, i, o) {
            void 0 === r && (r = null),
              void 0 === i && (i = null),
              void 0 === o && (o = !1);
            var s,
              a,
              l,
              c = this;
            return (
              ((c = t.call(this) || this).inCallback = !1),
              (c.limitOrigin = null),
              (c.canSendPayload = !0),
              !0 === e.defaultSettings.not_defined &&
                (e.defaultSettings = {
                  enable: !0,
                  host: "localhost",
                  port: 23517,
                  scheme: "http",
                  local_path: null,
                  remote_path: null,
                  always_send_raw_values: !1,
                  enabled_callback: null,
                  sending_payload_callback: null,
                  sent_payload_callback: null,
                  not_defined: !1,
                }),
              (c.inCallback = o),
              (c.settings = new An(e.defaultSettings)),
              null === e.enabled && (e.enabled = !1 !== c.settings.enable),
              (e.client =
                null !== (s = null !== r && void 0 !== r ? r : e.client) &&
                void 0 !== s
                  ? s
                  : new De(c.settings.port, c.settings.host)),
              (e._rateLimiter =
                null !== (a = e._rateLimiter) && void 0 !== a
                  ? a
                  : Vn.disabled()),
              (c.uuid =
                null !== (l = null !== i && void 0 !== i ? i : e.fakeUuid) &&
                void 0 !== l
                  ? l
                  : (function () {
                      var t = {
                        random: [
                          rn(1, 255),
                          rn(1, 255),
                          rn(1, 255),
                          rn(1, 255),
                          rn(1, 255),
                          rn(1, 255),
                          rn(1, 255),
                          rn(1, 255),
                          rn(1, 255),
                          rn(1, 255),
                          rn(1, 255),
                          rn(1, 255),
                          rn(1, 255),
                          rn(1, 255),
                          rn(1, 255),
                          rn(1, 255),
                        ],
                      };
                      return Ee(t).toString();
                    })()),
              c.settings.intercept_console_log &&
                !c.interceptor().active() &&
                c.interceptor().enable(),
              c.loadMacros(),
              c
            );
          }
          return (
            Pe(e, t),
            (e.create = function (t, n) {
              return (
                void 0 === t && (t = null),
                void 0 === n && (n = null),
                !0 === e.defaultSettings.not_defined &&
                  (e.defaultSettings = {
                    enable: !0,
                    host: "localhost",
                    port: 23517,
                    scheme: "http",
                    local_path: null,
                    remote_path: null,
                    always_send_raw_values: !1,
                    not_defined: !1,
                    intercept_console_log: !1,
                    enabled_callback: null,
                    sending_payload_callback: null,
                    sent_payload_callback: null,
                  }),
                new this(new An(e.defaultSettings), t, n)
              );
            }),
            (e.useDefaultSettings = function (t) {
              return (
                !0 === e.defaultSettings.not_defined &&
                  (e.defaultSettings = {
                    enable: !0,
                    host: "localhost",
                    port: 23517,
                    scheme: "http",
                    local_path: null,
                    remote_path: null,
                    always_send_raw_values: !1,
                    enabled_callback: null,
                    sending_payload_callback: null,
                    sent_payload_callback: null,
                    not_defined: !1,
                  }),
                (e.defaultSettings = Object.assign({}, e.defaultSettings, t)),
                (e.defaultSettings.not_defined = !1),
                (e.client = new De(
                  this.defaultSettings.port,
                  this.defaultSettings.host
                )),
                this
              );
            }),
            (e.prototype.loadMacros = function () {
              for (var t in e.macros) {
                var n = e.macros[t];
                this[t] = n.bind(this);
              }
              return this;
            }),
            (e.prototype.interceptor = function () {
              return e.interceptor;
            }),
            (e.prototype.client = function () {
              return e.client;
            }),
            (e.prototype.enable = function () {
              return (e.enabled = !0), this;
            }),
            (e.prototype.disable = function () {
              return (e.enabled = !1), this;
            }),
            (e.prototype.enabled = function () {
              return "function" === typeof this.settings.enabled_callback
                ? e.enabled && this.settings.enabled_callback()
                : e.enabled;
            }),
            (e.prototype.disabled = function () {
              return !this.enabled();
            }),
            (e.useClient = function (t) {
              this.client = t;
            }),
            (e.prototype.project = function (t) {
              return (e.projectName = t), this;
            }),
            (e.prototype.newScreen = function (t) {
              void 0 === t && (t = "");
              var e = new bn(t);
              return this.sendRequest(e);
            }),
            (e.prototype.clearAll = function () {
              var t = new Ie();
              return this.sendRequest(t);
            }),
            (e.prototype.clearScreen = function () {
              return this.newScreen();
            }),
            (e.prototype.color = function (t) {
              var e = new Le(t);
              return this.sendRequest(e);
            }),
            (e.prototype.confetti = function () {
              var t = new Fe();
              return this.sendRequest(t);
            }),
            (e.prototype.screenColor = function (t) {
              var e = new Wn(t);
              return this.sendRequest(e);
            }),
            (e.prototype.label = function (t) {
              var e = new $n(t);
              return this.sendRequest(e);
            }),
            (e.prototype.size = function (t) {
              var e = new kn(t);
              return this.sendRequest(e);
            }),
            (e.prototype.remove = function () {
              var t = new Pn();
              return this.sendRequest(t);
            }),
            (e.prototype.hide = function () {
              var t = new Ye();
              return this.sendRequest(t);
            }),
            (e.prototype.notify = function (t) {
              var e = new xn(t);
              return this.sendRequest(e);
            }),
            (e.prototype.toJson = function () {
              for (var t = [], e = 0; e < arguments.length; e++)
                t[e] = arguments[e];
              var n = t.map(function (t) {
                return new en(t);
              });
              return this.sendRequest(n);
            }),
            (e.prototype.json = function () {
              for (var t = [], e = 0; e < arguments.length; e++)
                t[e] = arguments[e];
              var n = t.map(function (t) {
                return new $e(t);
              });
              return this.sendRequest(n);
            }),
            (e.prototype.file = function (t) {
              return (
                console.error("file() unsupport on web (".concat(t, ")")), this
              );
            }),
            (e.prototype.image = function (t) {
              var e = new tn(t);
              return this.sendRequest(e);
            }),
            (e.prototype.die = function (t) {
              throw (
                (void 0 === t && (t = ""),
                new Error("Ray.die() called: ".concat(t || "no message")))
              );
            }),
            (e.prototype.className = function (t) {
              return this.send(t.constructor.name);
            }),
            (e.prototype.error = function (t) {
              var e = new Ge(t, "Error");
              return this.sendRequest(e), this.red(), this;
            }),
            (e.prototype.event = function (t, e) {
              void 0 === e && (e = []);
              var n = new He(t, e);
              return this.sendRequest(n);
            }),
            (e.prototype.exception = function (t, e) {
              void 0 === e && (e = {});
              var n = new Xe(t, e);
              return this.sendRequest(n), this.red(), this;
            }),
            (e.prototype.showWhen = function (t) {
              return (
                "function" === typeof t && (t = t()), t || this.remove(), this
              );
            }),
            (e.prototype.showIf = function (t) {
              return this.showWhen(t);
            }),
            (e.prototype.removeWhen = function (t) {
              return (
                "function" === typeof t && (t = t()), t && this.remove(), this
              );
            }),
            (e.prototype.removeIf = function (t) {
              return this.removeWhen(t);
            }),
            (e.prototype.ban = function () {
              return this.send("\ud83d\udd76");
            }),
            (e.prototype.charles = function () {
              return this.send(
                "\ud83c\udfb6 \ud83c\udfb9 \ud83c\udfb7 \ud83d\udd7a"
              );
            }),
            (e.prototype.table = function (t, e) {
              void 0 === e && (e = "Table");
              var n = new zn(t, e);
              return this.sendRequest(n);
            }),
            (e.prototype.count = function (t) {
              var n, i, o;
              void 0 === t && (t = null);
              var s = r(
                  ""
                    .concat(
                      null === (n = this.getCaller()) || void 0 === n
                        ? void 0
                        : n.getFileName()
                    )
                    .concat(
                      null === (i = this.getCaller()) || void 0 === i
                        ? void 0
                        : i.getLineNumber()
                    )
                ),
                a = e.counters.increment(
                  null !== (o = null !== t && void 0 !== t ? t : s) &&
                    void 0 !== o
                    ? o
                    : "none"
                ),
                l = a[0],
                c = a[1],
                u = "Called ";
              return (
                t && (u += "'".concat(t, "' ")),
                (u += ""
                  .concat(c, " ")
                  .concat(1 === c ? "time" : "times", ".")),
                l.sendCustom(u, "Count"),
                l
              );
            }),
            (e.prototype.clearCounters = function () {
              return e.counters.clear(), this;
            }),
            (e.prototype.pause = function () {
              return Me(this, void 0, void 0, function () {
                var t,
                  n,
                  i = this;
                return Oe(this, function (o) {
                  return (
                    e.lockCounter++,
                    (t = r(
                      "".concat(new Date().getTime(), "-").concat(e.lockCounter)
                    )),
                    (n = new Ze(t)),
                    this.sendRequest(n),
                    [
                      2,
                      new Promise(function (n, r) {
                        return Me(i, void 0, void 0, function () {
                          var i, o;
                          return Oe(this, function (s) {
                            switch (s.label) {
                              case 0:
                                on(1e3 * 1), (s.label = 1);
                              case 1:
                                return (
                                  s.trys.push([1, 3, , 4]),
                                  [4, e.client.lockExists(t)]
                                );
                              case 2:
                                return (i = s.sent()), [3, 4];
                              case 3:
                                return (o = s.sent()), r(o), [2, !1];
                              case 4:
                                if (!0 !== i && i && i.stop_execution)
                                  return r(!1), [2, !1];
                                s.label = 5;
                              case 5:
                                if (i.active) return [3, 0];
                                s.label = 6;
                              case 6:
                                return n(this), [2];
                            }
                          });
                        });
                      }),
                    ]
                  );
                });
              });
            }),
            (e.prototype.stopTime = function (t) {
              return (
                void 0 === t && (t = ""),
                "" === t
                  ? ((e.stopWatches = {}), this)
                  : ("undefined" !== typeof e.stopWatches[t] &&
                      delete e.stopWatches[t],
                    this)
              );
            }),
            (e.prototype.caller = function () {
              var t = i.getSync(),
                e = new Re(t);
              return this.sendRequest(e);
            }),
            (e.prototype.trace = function () {
              var t = i.getSync(),
                e = new Rn(t);
              return this.sendRequest(e);
            }),
            (e.prototype.measure = function (t) {
              if ((void 0 === t && (t = "default"), t instanceof Function))
                return this.measureClosure(t);
              if ("undefined" === typeof e.stopWatches[t]) {
                var n = this.getStopwatch(t);
                e.stopWatches[t] = n;
                var r = n.start(t),
                  i = this.getMeasurePayload(t, r);
                return i.concernsNewTimer(), this.sendRequest(i);
              }
              var o = e.stopWatches[t].lap(),
                s = this.getMeasurePayload(t, o);
              return this.sendRequest(s);
            }),
            (e.prototype.measureClosure = function (t) {
              var e = this.getStopwatch("closure");
              e.start("closure"), t();
              var n = e.stop(),
                r = this.getMeasurePayload("closure", n);
              return this.sendRequest(r);
            }),
            (e.prototype.getStopwatch = function (t) {
              return new Dn(t);
            }),
            (e.prototype.getMeasurePayload = function (t, e) {
              return new ln(t, e);
            }),
            (e.prototype.separator = function () {
              var t = new Gn();
              return this.sendRequest(t);
            }),
            (e.prototype.xml = function (t) {
              var e = new Ln(t);
              return this.sendRequest(e);
            }),
            (e.prototype.html = function (t) {
              void 0 === t && (t = "");
              var e = new Je(t);
              return this.sendRequest(e);
            }),
            (e.prototype.text = function (t) {
              void 0 === t && (t = "");
              var e = new Bn(t);
              return this.sendRequest(e);
            }),
            (e.prototype.date = function (t) {
              var e = new qe(t);
              return this.sendRequest(e);
            }),
            (e.prototype.raw = function () {
              for (var t = [], e = 0; e < arguments.length; e++)
                t[e] = arguments[e];
              if (!t.length) return this;
              var n = t.map(function (t) {
                return nn.createForArguments([t]);
              });
              return this.sendRequest(n);
            }),
            (e.prototype.send = function () {
              for (var t = [], e = 0; e < arguments.length; e++)
                t[e] = arguments[e];
              if (!t.length) return this;
              if (this.settings.always_send_raw_values)
                return this.raw.apply(this, t);
              var n = En.createForValues(t);
              return this.sendRequest(n);
            }),
            (e.prototype.pass = function (t) {
              return this.send(t), t;
            }),
            (e.prototype.showApp = function () {
              var t = new On();
              return this.sendRequest(t);
            }),
            (e.prototype.hideApp = function () {
              var t = new Ke();
              return this.sendRequest(t);
            }),
            (e.prototype.macro = function (t, n) {
              return (e.macros[t] = n), (this[t] = n.bind(this)), this;
            }),
            (e.prototype.htmlMarkup = function (t, e) {
              void 0 === e && (e = {});
              var n = new Fn(t, e);
              return this.sendRequest(n);
            }),
            (e.prototype.if = function (t, e) {
              return (
                void 0 === e && (e = null),
                "function" === typeof t && (t = t()),
                t && null !== e && e(this),
                null === e && (this.canSendPayload = t),
                this
              );
            }),
            (e.prototype.limit = function (t) {
              var n = this.getOriginFrame();
              return (
                (this.limitOrigin = {
                  function_name:
                    null === n || void 0 === n ? void 0 : n.getFunctionName(),
                  file: null === n || void 0 === n ? void 0 : n.getFileName(),
                  line_number:
                    null === n || void 0 === n ? void 0 : n.getLineNumber(),
                  hostname: Qe.get(),
                }),
                e.limiters.initialize(this.limitOrigin, t),
                this
              );
            }),
            (e.prototype.once = function () {
              for (var t = [], n = 0; n < arguments.length; n++)
                t[n] = arguments[n];
              var r = this.getOriginFrame();
              return (
                (this.limitOrigin = {
                  function_name:
                    null === r || void 0 === r ? void 0 : r.getFunctionName(),
                  file: null === r || void 0 === r ? void 0 : r.getFileName(),
                  line_number:
                    null === r || void 0 === r ? void 0 : r.getLineNumber(),
                  hostname: Qe.get(),
                }),
                e.limiters.initialize(this.limitOrigin, 1),
                t.length > 0 ? this.send.apply(this, t) : this
              );
            }),
            (e.prototype.sendCustom = function (t, e) {
              void 0 === e && (e = "");
              var n = new Ve(t, e);
              return this.sendRequest(n);
            }),
            (e.prototype.getOriginFrame = function () {
              var t = i.getSync(),
                e = t.findIndex(function (t) {
                  var e;
                  return null === (e = t.functionName) || void 0 === e
                    ? void 0
                    : e.includes("Ray.sendRequest");
                });
              return (
                -1 === e && (e = 0),
                ze
                  .removeRayFrames(
                    t.slice(e).filter(function (t) {
                      var e;
                      return !(null === (e = t.functionName) || void 0 === e
                        ? void 0
                        : e.includes("Ray."));
                    })
                  )
                  .slice(0)
                  .shift()
              );
            }),
            (e.prototype.getCaller = function () {
              var t = i.getSync(),
                e = t.findIndex(function (t) {
                  var e;
                  return null === (e = t.functionName) || void 0 === e
                    ? void 0
                    : e.includes("Ray.getCaller");
                });
              -1 === e && (e = 0);
              var n = t.slice(e);
              return 1 === n.length ? n.shift() : n.slice(2).shift();
            }),
            (e.prototype.getOriginData = function () {
              var t = this.getOriginFrame();
              return {
                function_name:
                  null === t || void 0 === t ? void 0 : t.getFunctionName(),
                file: null === t || void 0 === t ? void 0 : t.getFileName(),
                line_number:
                  null === t || void 0 === t ? void 0 : t.getLineNumber(),
                hostname: Qe.get(),
              };
            }),
            (e.prototype.sendRequest = function (t, n) {
              var r,
                i = this;
              if ((void 0 === n && (n = []), !this.enabled())) return this;
              if (!this.canSendPayload) return this;
              if (null !== this.limitOrigin) {
                if (!e.limiters.canSendPayload(this.limitOrigin)) return this;
                e.limiters.increment(this.limitOrigin);
              }
              if (
                (Array.isArray(t) || (t = [t]),
                this.rateLimiter().isMaxReached() ||
                  this.rateLimiter().isMaxPerSecondReached())
              )
                return this.notifyWhenRateLimitReached(), this;
              var o = Object.assign(
                {},
                {
                  node_ray_package_version: "1.19.4",
                  project_name: e.projectName,
                },
                n
              );
              t.forEach(function (t) {
                (t.data.origin = i.getOriginData()),
                  (t.remotePath = i.settings.remote_path),
                  (t.localPath = i.settings.local_path);
              }),
                null === this.settings.sending_payload_callback ||
                  this.inCallback ||
                  ((this.inCallback = !0),
                  this.settings.sending_payload_callback(
                    new e(this.settings, this.client(), this.uuid, !0),
                    t
                  ),
                  (this.inCallback = !1));
              var s = new Mn(this.uuid, t, o);
              return (
                null === (r = e.client) || void 0 === r || r.send(s),
                this.rateLimiter().hit(),
                null === this.settings.sent_payload_callback ||
                  this.inCallback ||
                  ((this.inCallback = !0),
                  this.settings.sent_payload_callback(this),
                  (this.inCallback = !1)),
                this
              );
            }),
            (e.prototype.rateLimiter = function () {
              return e._rateLimiter;
            }),
            (e.prototype.notifyWhenRateLimitReached = function () {
              if (!this.rateLimiter().isNotified()) {
                var t = new Ve("Rate limit has been reached...", "Rate limit"),
                  n = new Mn(this.uuid, [t], []);
                e.client.send(n), this.rateLimiter().notify();
              }
            }),
            (e.lockCounter = 0),
            (e.defaultSettings = { not_defined: !0 }),
            (e.projectName = ""),
            (e.counters = new Ue()),
            (e.limiters = new qn()),
            (e.interceptor = new je()),
            (e.stopWatches = {}),
            (e.enabled = null),
            (e.macros = {}),
            (e._rateLimiter = Vn.disabled()),
            e
          );
        })(
          (function (...t) {
            var e, n, r;
            const i = t.map((t) => t.prototype);
            function o(...e) {
              for (const n of t) cn(this, new n(...e));
            }
            (o.prototype = hn(i, o)),
              Object.setPrototypeOf(o, hn(t, null, ["prototype"]));
            let s = o;
            {
              const i = _n(...t);
              for (let t of null !==
                (e = null === i || void 0 === i ? void 0 : i.class) &&
              void 0 !== e
                ? e
                : []) {
                const e = t(s);
                e && (s = e);
              }
              vn(
                null !== (n = null === i || void 0 === i ? void 0 : i.static) &&
                  void 0 !== n
                  ? n
                  : {},
                s
              ),
                vn(
                  null !==
                    (r = null === i || void 0 === i ? void 0 : i.instance) &&
                    void 0 !== r
                    ? r
                    : {},
                  s.prototype
                );
            }
            var a, l;
            return (a = s), (l = t), dn.set(a, l), s;
          })(Tn, Cn)
        ),
        Xn = function () {
          for (var t, e = [], n = 0; n < arguments.length; n++)
            e[n] = arguments[n];
          return (t = Hn.create()).send.apply(t, e);
        };
    },
    88593: function (t) {
      "use strict";
      t.exports = JSON.parse(
        '{"name":"axios","version":"0.21.4","description":"Promise based HTTP client for the browser and node.js","main":"index.js","scripts":{"test":"grunt test","start":"node ./sandbox/server.js","build":"NODE_ENV=production grunt build","preversion":"npm test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json","postversion":"git push && git push --tags","examples":"node ./examples/server.js","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","fix":"eslint --fix lib/**/*.js"},"repository":{"type":"git","url":"https://github.com/axios/axios.git"},"keywords":["xhr","http","ajax","promise","node"],"author":"Matt Zabriskie","license":"MIT","bugs":{"url":"https://github.com/axios/axios/issues"},"homepage":"https://axios-http.com","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"jsdelivr":"dist/axios.min.js","unpkg":"dist/axios.min.js","typings":"./index.d.ts","dependencies":{"follow-redirects":"^1.14.0"},"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}]}'
      );
    },
  },
  function (t) {
    var e = function (e) {
      return t((t.s = e));
    };
    t.O(0, [9774, 179], function () {
      return e(23837), e(90387);
    });
    var n = t.O();
    _N_E = n;
  },
]);
